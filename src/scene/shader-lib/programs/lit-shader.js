import {
    SEMANTIC_ATTR8, SEMANTIC_ATTR9, SEMANTIC_ATTR10, SEMANTIC_ATTR11, SEMANTIC_ATTR12, SEMANTIC_ATTR13, SEMANTIC_ATTR14, SEMANTIC_ATTR15,
    SEMANTIC_BLENDINDICES, SEMANTIC_BLENDWEIGHT, SEMANTIC_COLOR, SEMANTIC_NORMAL, SEMANTIC_POSITION, SEMANTIC_TANGENT,
    SEMANTIC_TEXCOORD0, SEMANTIC_TEXCOORD1,
    SHADERTAG_MATERIAL,
    PIXELFORMAT_RGBA8
} from '../../../platform/graphics/constants.js';
import { shaderChunks } from '../chunks/chunks.js';
import { ChunkUtils } from '../chunk-utils.js';

import {
    BLEND_ADDITIVEALPHA, BLEND_NORMAL, BLEND_PREMULTIPLIED,
    FRESNEL_SCHLICK,
    LIGHTFALLOFF_LINEAR,
    LIGHTSHAPE_PUNCTUAL, LIGHTSHAPE_RECT, LIGHTSHAPE_DISK, LIGHTSHAPE_SPHERE,
    LIGHTTYPE_DIRECTIONAL, LIGHTTYPE_OMNI, LIGHTTYPE_SPOT,
    SHADER_DEPTH, SHADER_PICK,
    SHADOW_PCF3, SHADOW_PCF5, SHADOW_VSM8, SHADOW_VSM16, SHADOW_VSM32,
    SPECOCC_AO, SPECOCC_GLOSSDEPENDENT,
    SPECULAR_PHONG,
    SPRITE_RENDERMODE_SLICED, SPRITE_RENDERMODE_TILED, shadowTypeToString
} from '../../constants.js';
import { LightsBuffer } from '../../lighting/lights-buffer.js';
import { ShaderPass } from '../../shader-pass.js';

import { begin, end, fogCode, gammaCode, skinCode, tonemapCode } from './common.js';
import { validateUserChunks } from '../chunks/chunk-validation.js';
import { ShaderUtils } from '../../../platform/graphics/shader-utils.js';
import { ChunkBuilder } from '../chunk-builder.js';

const builtinAttributes = {
    vertex_normal: SEMANTIC_NORMAL,
    vertex_tangent: SEMANTIC_TANGENT,
    vertex_texCoord0: SEMANTIC_TEXCOORD0,
    vertex_texCoord1: SEMANTIC_TEXCOORD1,
    vertex_color: SEMANTIC_COLOR,
    vertex_boneWeights: SEMANTIC_BLENDWEIGHT,
    vertex_boneIndices: SEMANTIC_BLENDINDICES
};

const builtinVaryings = {
    vVertexColor: "vec4",
    vPositionW: "vec3",
    vNormalV: "vec3",
    vNormalW: "vec3",
    vTangentW: "vec3",
    vBinormalW: "vec3",
    vObjectSpaceUpW: "vec3",
    vUv0: "vec2",
    vUv1: "vec2"
};

class LitShader {
    constructor(device, options) {
        /**
         * @param {import('../../../platform/graphics/graphics-device.js').GraphicsDevice} device - The
         * graphics device.
         * @param {import('../../../scene/materials/lit-options.js').LitOptions} options - The
         * lit options.
         * @ignore
         */
        this.device = device;
        this.options = options;

        // resolve custom chunk attributes
        this.attributes = {
            vertex_position: SEMANTIC_POSITION
        };

        if (options.chunks) {
            this.chunks = {};

            const userChunks = options.chunks;

            // #if _DEBUG
            validateUserChunks(options.chunks);
            // #endif

            for (const chunkName in shaderChunks) {
                if (userChunks.hasOwnProperty(chunkName)) {
                    const chunk = userChunks[chunkName];
                    for (const a in builtinAttributes) {
                        if (builtinAttributes.hasOwnProperty(a) && chunk.indexOf(a) >= 0) {
                            this.attributes[a] = builtinAttributes[a];
                        }
                    }
                    this.chunks[chunkName] = chunk;
                } else {
                    this.chunks[chunkName] = shaderChunks[chunkName];
                }
            }
        } else {
            this.chunks = shaderChunks;
        }

        this.lighting = (options.lights.length > 0) || options.dirLightMapEnabled || options.clusteredLightingEnabled;
        this.reflections = !!options.reflectionSource;
        this.shadowPass = ShaderPass.isShadow(options.pass);
        this.needsNormal = this.lighting || this.reflections || options.useSpecular || options.ambientSH || options.heightMapEnabled || options.enableGGXSpecular ||
            (options.clusteredLightingEnabled && !this.shadowPass) || options.clearCoatNormalMapEnabled;
        this.needsNormal = this.needsNormal && !this.shadowPass;
        this.needsSceneColor = options.useDynamicRefraction;
        this.needsScreenSize = options.useDynamicRefraction;
        this.needsTransforms = options.useDynamicRefraction;

        // generated by vshader
        this.varyings = "";
        this.vshader = null;

        // supplied by caller
        this.frontendDecl = null;
        this.frontendCode = null;
        this.frontendFunc = null;
        this.lightingUv = null;

        // defines set by the shader generation
        this.defines = [];

        // generated by fshader
        this.fshader = null;
    }

    _vsAddBaseCode(code, chunks, options) {
        code += chunks.baseVS;
        if (options.nineSlicedMode === SPRITE_RENDERMODE_SLICED ||
            options.nineSlicedMode === SPRITE_RENDERMODE_TILED) {
            code += chunks.baseNineSlicedVS;
        }
        return code;
    }

    _vsAddTransformCode(code, device, chunks, options) {
        code += this.chunks.transformVS;
        return code;
    }

    _setMapTransform(codes, name, id, uv) {
        const checkId = id + uv * 100;
        if (!codes[3][checkId]) {
            // upload a 3x2 matrix and manually perform the multiplication
            const varName = `texture_${name}MapTransform`;
            codes[0] += `uniform vec3 ${varName}0;\n`;
            codes[0] += `uniform vec3 ${varName}1;\n`;
            codes[1] += `varying vec2 vUV${uv}_${id};\n`;
            codes[2] += `   vUV${uv}_${id} = vec2(dot(vec3(uv${uv}, 1), ${varName}0), dot(vec3(uv${uv}, 1), ${varName}1));\n`;
            codes[3][checkId] = true;
        }
        return codes;
    }

    // Add "Base" Code section to fragment shader.
    _fsGetBaseCode() {
        const options = this.options;
        const chunks = this.chunks;
        let result = this.chunks.basePS;
        if (options.nineSlicedMode === SPRITE_RENDERMODE_SLICED) {
            result += chunks.baseNineSlicedPS;
        } else if (options.nineSlicedMode === SPRITE_RENDERMODE_TILED) {
            result += chunks.baseNineSlicedTiledPS;
        }
        return result;
    }

    // Add "Start" Code section to fragment shader.
    _fsGetStartCode(code, device, chunks, options) {
        let result = chunks.startPS;
        if (options.nineSlicedMode === SPRITE_RENDERMODE_SLICED) {
            result += chunks.startNineSlicedPS;
        } else if (options.nineSlicedMode === SPRITE_RENDERMODE_TILED) {
            result += chunks.startNineSlicedTiledPS;
        }
        return result;
    }

    // handles directional map shadow coordinate generation, including cascaded shadows
    _directionalShadowMapProjection(light, shadowMatArg, shadowParamArg, lightArgs, lightIndex, coordsFunctionName) {

        // for shadow cascades
        let code = "";
        const lightParams = lightArgs ? ", " + lightArgs : "";
        let shadowCoordArgs = `(${shadowMatArg}, ${shadowParamArg}${lightParams});`;
        if (light.numCascades > 1) {
            // compute which cascade matrix needs to be used
            code += `getShadowCascadeMatrix(light${lightIndex}_shadowMatrixPalette, light${lightIndex}_shadowCascadeDistances, light${lightIndex}_shadowCascadeCount);\n`;
            shadowCoordArgs = `(cascadeShadowMat, ${shadowParamArg}${lightParams});\n`;
        }

        // shadow coordinate generation
        code += coordsFunctionName + shadowCoordArgs;

        // stop shadow at the far distance
        code += `fadeShadow(light${lightIndex}_shadowCascadeDistances);\n`;

        return code;
    }

    _nonPointShadowMapProjection(device, light, shadowMatArg, shadowParamArg, lightIndex) {
        const lightDirArgs = `dLightDirW`;
        const lightDirNormArgs = `dLightPosW, dLightDirW, dLightDirNormW, dVertexNormalW`;
        const shadowCoordArgs = `(${shadowMatArg}, ${shadowParamArg});\n`;
        const shadowCoordNormArgs = `(${shadowMatArg}, ${shadowParamArg}, dVertexNormalW);\n`;
        const shadowCoordDirArgs = `(${shadowMatArg}, ${shadowParamArg}, ${lightDirArgs});\n`;
        const shadowCoordLightNormArgs = `(${shadowMatArg}, ${shadowParamArg}, ${lightDirNormArgs});\n`;
        if (!light._normalOffsetBias || light._isVsm) {
            if (light._type === LIGHTTYPE_SPOT) {
                if (light._isPcf && (device.webgl2 || device.extStandardDerivatives || device.isWebGPU)) {
                    return "       getShadowCoordPerspZbuffer" + shadowCoordArgs;
                }
                return "       getShadowCoordPersp" + shadowCoordDirArgs;
            }
            return this._directionalShadowMapProjection(light, shadowMatArg, shadowParamArg, null, lightIndex, "getShadowCoordOrtho");
        }
        if (light._type === LIGHTTYPE_SPOT) {
            if (light._isPcf && (device.webgl2 || device.extStandardDerivatives || device.isWebGPU)) {
                return "       getShadowCoordPerspZbufferNormalOffset" + shadowCoordNormArgs;
            }
            return "       getShadowCoordPerspNormalOffset" + shadowCoordLightNormArgs;
        }
        return this._directionalShadowMapProjection(light, shadowMatArg, shadowParamArg, lightDirNormArgs, lightIndex, "getShadowCoordOrthoNormalOffset");
    }

    _getLightSourceShapeString(shape) {
        switch (shape) {
            case LIGHTSHAPE_RECT:
                return 'Rect';
            case LIGHTSHAPE_DISK:
                return 'Disk';
            case LIGHTSHAPE_SPHERE:
                return 'Sphere';
            default:
                return '';
        }
    }

    generateVertexShader(useUv, useUnmodifiedUv, mapTransforms) {
        const device = this.device;
        const options = this.options;
        const chunks = this.chunks;

        let code = '';
        let codeBody = '';

        // code += chunks.baseVS;
        code = this._vsAddBaseCode(code, chunks, options);

        codeBody += "   vPositionW    = getWorldPosition();\n";

        if (this.options.pass === SHADER_DEPTH) {
            code += 'varying float vDepth;\n';
            code += '#ifndef VIEWMATRIX\n';
            code += '#define VIEWMATRIX\n';
            code += 'uniform mat4 matrix_view;\n';
            code += '#endif\n';
            code += '#ifndef CAMERAPLANES\n';
            code += '#define CAMERAPLANES\n';
            code += 'uniform vec4 camera_params;\n\n';
            code += '#endif\n';
            codeBody += "    vDepth = -(matrix_view * vec4(vPositionW,1.0)).z * camera_params.x;\n";
        }

        if (this.options.useInstancing) {
            this.attributes.instance_line1 = SEMANTIC_ATTR12;
            this.attributes.instance_line2 = SEMANTIC_ATTR13;
            this.attributes.instance_line3 = SEMANTIC_ATTR14;
            this.attributes.instance_line4 = SEMANTIC_ATTR15;
            code += chunks.instancingVS;
        }

        if (this.needsNormal) {
            this.attributes.vertex_normal = SEMANTIC_NORMAL;
            codeBody += "   vNormalW = getNormal();\n";

            if (options.reflectionSource === 'sphereMap' && device.fragmentUniformsCount <= 16) {
                code += chunks.viewNormalVS;
                codeBody += "   vNormalV    = getViewNormal();\n";
            }

            if (options.hasTangents && (options.heightMapEnabled || options.normalMapEnabled || options.enableGGXSpecular)) {
                this.attributes.vertex_tangent = SEMANTIC_TANGENT;
                code += chunks.tangentBinormalVS;
                codeBody += "   vTangentW   = getTangent();\n";
                codeBody += "   vBinormalW  = getBinormal();\n";
            } else if (options.enableGGXSpecular || !device.extStandardDerivatives) {
                codeBody += "   vObjectSpaceUpW = normalize(dNormalMatrix * vec3(0, 1, 0));\n";
            }
        }

        const maxUvSets = 2;

        for (let i = 0; i < maxUvSets; i++) {
            if (useUv[i]) {
                this.attributes["vertex_texCoord" + i] = "TEXCOORD" + i;
                code += chunks["uv" + i + "VS"];
                codeBody += "   vec2 uv" + i + " = getUv" + i + "();\n";
            }
            if (useUnmodifiedUv[i]) {
                codeBody += "   vUv" + i + " = uv" + i + ";\n";
            }
        }

        const codes = [code, this.varyings, codeBody, []];

        mapTransforms.forEach((mapTransform) => {
            this._setMapTransform(codes, mapTransform.name, mapTransform.id, mapTransform.uv);
        });

        code = codes[0];
        this.varyings = codes[1];
        codeBody = codes[2];

        if (options.vertexColors) {
            this.attributes.vertex_color = SEMANTIC_COLOR;
            codeBody += "   vVertexColor = vertex_color;\n";
        }

        if (options.useMsdf && options.msdfTextAttribute) {
            this.attributes.vertex_outlineParameters = SEMANTIC_ATTR8;
            this.attributes.vertex_shadowParameters = SEMANTIC_ATTR9;

            codeBody += "    unpackMsdfParams();\n";

            code += chunks.msdfVS;
        }

        // morphing
        if (options.useMorphPosition || options.useMorphNormal) {

            if (options.useMorphTextureBased) {

                code += "#define MORPHING_TEXTURE_BASED\n";

                if (options.useMorphPosition) {
                    code += "#define MORPHING_TEXTURE_BASED_POSITION\n";
                }

                if (options.useMorphNormal) {
                    code += "#define MORPHING_TEXTURE_BASED_NORMAL\n";
                }

                // vertex ids attributes
                this.attributes.morph_vertex_id = SEMANTIC_ATTR15;
                code += "attribute float morph_vertex_id;\n";

            } else {

                // set up 8 slots for morphing. these are supported combinations: PPPPPPPP, NNNNNNNN, PPPPNNNN
                code += "#define MORPHING\n";

                // first 4 slots are either position or normal
                if (options.useMorphPosition) {
                    this.attributes.morph_pos0 = SEMANTIC_ATTR8;
                    this.attributes.morph_pos1 = SEMANTIC_ATTR9;
                    this.attributes.morph_pos2 = SEMANTIC_ATTR10;
                    this.attributes.morph_pos3 = SEMANTIC_ATTR11;

                    code += "#define MORPHING_POS03\n";
                    code += "attribute vec3 morph_pos0;\n";
                    code += "attribute vec3 morph_pos1;\n";
                    code += "attribute vec3 morph_pos2;\n";
                    code += "attribute vec3 morph_pos3;\n";

                } else if (options.useMorphNormal) {
                    this.attributes.morph_nrm0 = SEMANTIC_ATTR8;
                    this.attributes.morph_nrm1 = SEMANTIC_ATTR9;
                    this.attributes.morph_nrm2 = SEMANTIC_ATTR10;
                    this.attributes.morph_nrm3 = SEMANTIC_ATTR11;

                    code += "#define MORPHING_NRM03\n";
                    code += "attribute vec3 morph_nrm0;\n";
                    code += "attribute vec3 morph_nrm1;\n";
                    code += "attribute vec3 morph_nrm2;\n";
                    code += "attribute vec3 morph_nrm3;\n";
                }

                // next 4 slots are either position or normal
                if (!options.useMorphNormal) {
                    this.attributes.morph_pos4 = SEMANTIC_ATTR12;
                    this.attributes.morph_pos5 = SEMANTIC_ATTR13;
                    this.attributes.morph_pos6 = SEMANTIC_ATTR14;
                    this.attributes.morph_pos7 = SEMANTIC_ATTR15;

                    code += "#define MORPHING_POS47\n";
                    code += "attribute vec3 morph_pos4;\n";
                    code += "attribute vec3 morph_pos5;\n";
                    code += "attribute vec3 morph_pos6;\n";
                    code += "attribute vec3 morph_pos7;\n";
                } else {
                    this.attributes.morph_nrm4 = SEMANTIC_ATTR12;
                    this.attributes.morph_nrm5 = SEMANTIC_ATTR13;
                    this.attributes.morph_nrm6 = SEMANTIC_ATTR14;
                    this.attributes.morph_nrm7 = SEMANTIC_ATTR15;

                    code += "#define MORPHING_NRM47\n";
                    code += "attribute vec3 morph_nrm4;\n";
                    code += "attribute vec3 morph_nrm5;\n";
                    code += "attribute vec3 morph_nrm6;\n";
                    code += "attribute vec3 morph_nrm7;\n";
                }
            }
        }

        if (options.skin) {
            this.attributes.vertex_boneWeights = SEMANTIC_BLENDWEIGHT;
            this.attributes.vertex_boneIndices = SEMANTIC_BLENDINDICES;
            code += skinCode(device, chunks);
            code += "#define SKIN\n";
        } else if (options.useInstancing) {
            code += "#define INSTANCING\n";
        }
        if (options.screenSpace) {
            code += "#define SCREENSPACE\n";
        }
        if (options.pixelSnap) {
            code += "#define PIXELSNAP\n";
        }

        code = this._vsAddTransformCode(code, device, chunks, options);

        if (this.needsNormal) {
            code += chunks.normalVS;
        }

        code += "\n";
        code += chunks.startVS;
        code += codeBody;
        code += chunks.endVS;
        code += "}";

        // build varyings
        Object.keys(builtinVaryings).forEach((v) => {
            if (code.indexOf(v) >= 0) {
                this.varyings += `varying ${builtinVaryings[v]} ${v};\n`;
            }
        });

        const shaderPassDefine = ShaderPass.getPassShaderDefine(this.options.pass);
        this.vshader = shaderPassDefine + this.varyings + code;
    }

    _fsGetBeginCode() {

        let code = ShaderPass.getPassShaderDefine(this.options.pass);

        for (let i = 0; i < this.defines.length; i++) {
            code += `#define ${this.defines[i]}\n`;
        }

        return code;
    }

    _fsGetPickPassCode() {
        let code = this._fsGetBeginCode();
        code += "uniform vec4 uColor;\n";
        code += this.varyings;
        code += this.frontendDecl;
        code += this.frontendCode;
        code += begin();
        code += this.frontendFunc;
        code += "    gl_FragColor = uColor;\n";
        code += end();
        return code;
    }

    _fsGetDepthPassCode() {
        const chunks = this.chunks;

        let code = this._fsGetBeginCode();

        code += 'varying float vDepth;\n';
        code += this.varyings;
        code += chunks.packDepthPS;
        code += this.frontendDecl;
        code += this.frontendCode;
        code += begin();
        code += this.frontendFunc;
        code += "    gl_FragColor = packFloat(vDepth);\n";
        code += end();

        return code;
    }

    _fsGetShadowPassCode() {
        const device = this.device;
        const options = this.options;
        const chunks = this.chunks;
        const varyings = this.varyings;

        const lightType = ShaderPass.toLightType(options.pass);
        const shadowType = ShaderPass.toShadowType(options.pass);

        let code = this._fsGetBeginCode();

        if (device.extStandardDerivatives && !device.webgl2 && !device.isWebGPU) {
            code += 'uniform vec2 polygonOffset;\n';
        }

        if (shadowType === SHADOW_VSM32) {
            if (device.textureFloatHighPrecision) {
                code += '#define VSM_EXPONENT 15.0\n\n';
            } else {
                code += '#define VSM_EXPONENT 5.54\n\n';
            }
        } else if (shadowType === SHADOW_VSM16) {
            code += '#define VSM_EXPONENT 5.54\n\n';
        }

        if (lightType !== LIGHTTYPE_DIRECTIONAL) {
            code += 'uniform vec3 view_position;\n';
            code += 'uniform float light_radius;\n';
        }

        code += varyings;
        code += this.frontendDecl;
        code += this.frontendCode;

        if (shadowType === SHADOW_PCF3 && (!device.webgl2 || !device.isWebGPU || lightType === LIGHTTYPE_OMNI)) {
            code += chunks.packDepthPS;
        } else if (shadowType === SHADOW_VSM8) {
            code += "vec2 encodeFloatRG( float v ) {\n";
            code += "    vec2 enc = vec2(1.0, 255.0) * v;\n";
            code += "    enc = fract(enc);\n";
            code += "    enc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);\n";
            code += "    return enc;\n";
            code += "}\n\n";
        }

        code += begin();

        code += this.frontendFunc;

        const isVsm = shadowType === SHADOW_VSM8 || shadowType === SHADOW_VSM16 || shadowType === SHADOW_VSM32;
        const applySlopeScaleBias = !device.webgl2 && device.extStandardDerivatives && !device.isWebGPU;

        if (lightType === LIGHTTYPE_OMNI || (isVsm && lightType !== LIGHTTYPE_DIRECTIONAL)) {
            code += "    float depth = min(distance(view_position, vPositionW) / light_radius, 0.99999);\n";
        } else {
            code += "    float depth = gl_FragCoord.z;\n";
        }

        if (applySlopeScaleBias) {
            code += "    float minValue = 2.3374370500153186e-10; //(1.0 / 255.0) / (256.0 * 256.0 * 256.0);\n";
            code += "    depth += polygonOffset.x * max(abs(dFdx(depth)), abs(dFdy(depth))) + minValue * polygonOffset.y;\n";
        }

        if (shadowType === SHADOW_PCF3 && (!device.webgl2 || (lightType === LIGHTTYPE_OMNI && !options.clusteredLightingEnabled))) {
            code += "    gl_FragColor = packFloat(depth);\n";
        } else if (shadowType === SHADOW_PCF3 || shadowType === SHADOW_PCF5) {
            code += "    gl_FragColor = vec4(1.0);\n"; // just the simplest code, color is not written anyway

            // clustered omni light is using shadow sampler and needs to write custom depth
            if (options.clusteredLightingEnabled && lightType === LIGHTTYPE_OMNI && device.webgl2) {
                code += "    gl_FragDepth = depth;\n";
            }
        } else if (shadowType === SHADOW_VSM8) {
            code += "    gl_FragColor = vec4(encodeFloatRG(depth), encodeFloatRG(depth*depth));\n";
        } else {
            code += chunks.storeEVSMPS;
        }

        code += end();

        return code;
    }

    // the big one
    _fsGetLitPassCode() {
        const device = this.device;
        const options = this.options;
        const chunks = this.chunks;

        const decl = new ChunkBuilder();
        const func = new ChunkBuilder();
        const backend = new ChunkBuilder();
        const code = new ChunkBuilder();

        if (options.opacityFadesSpecular === false) {
            decl.append('uniform float material_alphaFade;');
        }

        if (options.useSpecular) {
            this.defines.push("LIT_SPECULAR");

            if (this.reflections) {
                this.defines.push("LIT_REFLECTIONS");
            }

            if (options.useClearCoat) {
                this.defines.push("LIT_CLEARCOAT");
            }

            if (options.fresnelModel > 0) {
                this.defines.push("LIT_SPECULAR_FRESNEL");
            }

            // enable conserve energy path in clustered chunk
            if (options.conserveEnergy) {
                this.defines.push("LIT_CONSERVE_ENERGY");
            }

            if (options.useSheen) {
                this.defines.push("LIT_SHEEN");
            }

            if (options.useIridescence) {
                this.defines.push("LIT_IRIDESCENCE");
            }
        }

        // FRAGMENT SHADER INPUTS: UNIFORMS
        const shadowTypeUsed = [];
        let numShadowLights = 0;
        let shadowedDirectionalLightUsed = false;
        let useVsm = false;
        let usePerspZbufferShadow = false;

        let hasAreaLights = options.lights.some(function (light) {
            return light._shape && light._shape !== LIGHTSHAPE_PUNCTUAL;
        });

        // if clustered lighting has area lights enabled, it always runs in 'area lights mode'
        // TODO: maybe we should always use it and remove the other way?
        if (options.clusteredLightingEnabled && options.clusteredLightingAreaLightsEnabled) {
            hasAreaLights = true;
        }

        let areaLutsPrecision = 'highp';
        if (device.areaLightLutFormat === PIXELFORMAT_RGBA8) {
            // use offset and scale for rgb8 format luts
            decl.append("#define AREA_R8_G8_B8_A8_LUTS");
            areaLutsPrecision = 'lowp';
        }

        if (hasAreaLights || options.clusteredLightingEnabled) {
            decl.append("#define AREA_LIGHTS");
            decl.append(`uniform ${areaLutsPrecision} sampler2D areaLightsLutTex1;`);
            decl.append(`uniform ${areaLutsPrecision} sampler2D areaLightsLutTex2;`);
        }

        for (let i = 0; i < options.lights.length; i++) {
            const light = options.lights[i];
            const lightType = light._type;

            // skip uniform generation for local lights if clustered lighting is enabled
            if (options.clusteredLightingEnabled && lightType !== LIGHTTYPE_DIRECTIONAL)
                continue;

            const lightShape = (hasAreaLights && light._shape) ? light._shape : LIGHTSHAPE_PUNCTUAL;

            decl.append("uniform vec3 light" + i + "_color;");
            if (lightType === LIGHTTYPE_DIRECTIONAL) {
                decl.append("uniform vec3 light" + i + "_direction;");
            } else {
                decl.append("uniform vec3 light" + i + "_position;");
                decl.append("uniform float light" + i + "_radius;");
                if (lightType === LIGHTTYPE_SPOT) {
                    decl.append("uniform vec3 light" + i + "_direction;");
                    decl.append("uniform float light" + i + "_innerConeAngle;");
                    decl.append("uniform float light" + i + "_outerConeAngle;");
                }
            }
            if (lightShape !== LIGHTSHAPE_PUNCTUAL) {
                if (lightType === LIGHTTYPE_DIRECTIONAL) {
                    decl.append("uniform vec3 light" + i + "_position;");
                }
                decl.append("uniform vec3 light" + i + "_halfWidth;");
                decl.append("uniform vec3 light" + i + "_halfHeight;");
            }
            if (light.castShadows && !options.noShadow) {
                decl.append("uniform mat4 light" + i + "_shadowMatrix;");
                decl.append("uniform float light" + i + "_shadowIntensity;");

                // directional (cascaded) shadows
                if (lightType === LIGHTTYPE_DIRECTIONAL) {
                    decl.append("uniform mat4 light" + i + "_shadowMatrixPalette[4];");
                    decl.append("uniform float light" + i + "_shadowCascadeDistances[4];");
                    decl.append("uniform float light" + i + "_shadowCascadeCount;");
                }

                if (lightType !== LIGHTTYPE_DIRECTIONAL) {
                    decl.append("uniform vec4 light" + i + "_shadowParams;"); // Width, height, bias, radius
                } else {
                    shadowedDirectionalLightUsed = true;
                    decl.append("uniform vec3 light" + i + "_shadowParams;"); // Width, height, bias
                }
                if (lightType === LIGHTTYPE_OMNI) {
                    decl.append("uniform samplerCube light" + i + "_shadowMap;");
                } else {
                    if (light._isPcf && device.supportsDepthShadow) {
                        decl.append("uniform sampler2DShadow light" + i + "_shadowMap;");
                    } else {
                        decl.append("uniform sampler2D light" + i + "_shadowMap;");
                    }
                }
                numShadowLights++;
                shadowTypeUsed[light._shadowType] = true;
                if (light._isVsm) useVsm = true;
                if (light._isPcf && (device.supportsDepthShadow || device.extStandardDerivatives) && lightType === LIGHTTYPE_SPOT) usePerspZbufferShadow = true;
            }
            if (light._cookie) {
                if (light._cookie._cubemap) {
                    if (lightType === LIGHTTYPE_OMNI) {
                        decl.append("uniform samplerCube light" + i + "_cookie;");
                        decl.append("uniform float light" + i + "_cookieIntensity;");
                        if (!light.castShadows || options.noShadow) {
                            decl.append("uniform mat4 light" + i + "_shadowMatrix;");
                        }
                    }
                } else {
                    if (lightType === LIGHTTYPE_SPOT) {
                        decl.append("uniform sampler2D light" + i + "_cookie;");
                        decl.append("uniform float light" + i + "_cookieIntensity;");
                        if (!light.castShadows || options.noShadow) {
                            decl.append("uniform mat4 light" + i + "_shadowMatrix;");
                        }
                        if (light._cookieTransform) {
                            decl.append("uniform vec4 light" + i + "_cookieMatrix;");
                            decl.append("uniform vec2 light" + i + "_cookieOffset;");
                        }
                    }
                }
            }
        }

        // TBN
        const hasTBN = this.needsNormal && (options.normalMapEnabled || options.clearCoatNormalMapEnabled || (options.enableGGXSpecular && !options.heightMapEnabled));

        if (hasTBN) {
            if (options.hasTangents) {
                func.append(options.fastTbn ? chunks.TBNfastPS : chunks.TBNPS);
            } else {
                if (device.extStandardDerivatives && (options.normalMapEnabled || options.clearCoatNormalMapEnabled)) {
                    func.append(chunks.TBNderivativePS.replace(/\$UV/g, this.lightingUv));
                } else {
                    func.append(chunks.TBNObjectSpacePS);
                }
            }
        }

        // FIXME: only add these when needed
        func.append(chunks.sphericalPS);
        func.append(chunks.decodePS);
        func.append(gammaCode(options.gamma, chunks));
        func.append(tonemapCode(options.toneMap, chunks));
        func.append(fogCode(options.fog, chunks));

        // frontend
        func.append(this.frontendCode);

        if (options.useCubeMapRotation) {
            decl.append("#define CUBEMAP_ROTATION");
        }

        if (this.needsNormal) {
            func.append(chunks.cubeMapRotatePS);
            func.append(options.cubeMapProjection > 0 ? chunks.cubeMapProjectBoxPS : chunks.cubeMapProjectNonePS);
            func.append(options.skyboxIntensity ? chunks.envMultiplyPS : chunks.envConstPS);
        }

        if ((this.lighting && options.useSpecular) || this.reflections) {
            if (options.useMetalness) {
                func.append(chunks.metalnessModulatePS);
            }

            if (options.fresnelModel === FRESNEL_SCHLICK) {
                func.append(chunks.fresnelSchlickPS);
            }

            if (options.useIridescence) {
                func.append(chunks.iridescenceDiffractionPS);
            }
        }

        const useAo = options.aoMapEnabled || options.useAoVertexColors;

        if (useAo) {
            func.append(chunks.aoDiffuseOccPS);
            switch (options.occludeSpecular) {
                case SPECOCC_AO:
                    func.append(options.occludeSpecularFloat ? chunks.aoSpecOccSimplePS : chunks.aoSpecOccConstSimplePS);
                    break;
                case SPECOCC_GLOSSDEPENDENT:
                    func.append(options.occludeSpecularFloat ? chunks.aoSpecOccPS : chunks.aoSpecOccConstPS);
                    break;
                default:
                    break;
            }
        }

        if (options.reflectionSource === 'envAtlasHQ') {
            func.append(options.fixSeams ? chunks.fixCubemapSeamsStretchPS : chunks.fixCubemapSeamsNonePS);
            func.append(chunks.envAtlasPS);
            func.append(chunks.reflectionEnvHQPS.replace(/\$DECODE/g, ChunkUtils.decodeFunc(options.reflectionEncoding)));
        } else if (options.reflectionSource === 'envAtlas') {
            func.append(chunks.envAtlasPS);
            func.append(chunks.reflectionEnvPS.replace(/\$DECODE/g, ChunkUtils.decodeFunc(options.reflectionEncoding)));
        } else if (options.reflectionSource === 'cubeMap') {
            func.append(options.fixSeams ? chunks.fixCubemapSeamsStretchPS : chunks.fixCubemapSeamsNonePS);
            func.append(chunks.reflectionCubePS.replace(/\$DECODE/g, ChunkUtils.decodeFunc(options.reflectionEncoding)));
        } else if (options.reflectionSource === 'sphereMap') {
            const scode = device.fragmentUniformsCount > 16 ? chunks.reflectionSpherePS : chunks.reflectionSphereLowPS;
            func.append(scode.replace(/\$DECODE/g, ChunkUtils.decodeFunc(options.reflectionEncoding)));
        }

        if (this.reflections) {
            if (options.useClearCoat) {
                func.append(chunks.reflectionCCPS);
            }
            if (options.useSheen) {
                func.append(chunks.reflectionSheenPS);
            }
        }

        if (options.useRefraction) {
            if (options.useDynamicRefraction) {
                func.append(chunks.refractionDynamicPS);
            } else if (this.reflections) {
                func.append(chunks.refractionCubePS);
            }
        }

        if (options.useSheen) {
            func.append(chunks.lightSheenPS);
        }

        // clustered lighting
        if (options.clusteredLightingEnabled) {

            // include this before shadow / cookie code
            func.append(chunks.clusteredLightUtilsPS);
            if (options.clusteredLightingCookiesEnabled)
                func.append(chunks.clusteredLightCookiesPS);

            // include shadow chunks clustered lights support
            if (options.clusteredLightingShadowsEnabled && !options.noShadow) {
                shadowTypeUsed[SHADOW_PCF3] = true;
                shadowTypeUsed[SHADOW_PCF5] = true;
            }
            usePerspZbufferShadow = true;
        }

        if (numShadowLights > 0 || options.clusteredLightingEnabled) {
            if (shadowedDirectionalLightUsed) {
                func.append(chunks.shadowCascadesPS);
            }
            if (shadowTypeUsed[SHADOW_PCF3]) {
                func.append(chunks.shadowStandardPS);
            }
            if (shadowTypeUsed[SHADOW_PCF5] && (device.webgl2 || device.isWebGPU)) {
                func.append(chunks.shadowStandardGL2PS);
            }
            if (useVsm) {
                func.append(chunks.shadowVSM_commonPS);
                if (shadowTypeUsed[SHADOW_VSM8]) {
                    func.append(chunks.shadowVSM8PS);
                }
                if (shadowTypeUsed[SHADOW_VSM16]) {
                    func.append(device.extTextureHalfFloatLinear ? chunks.shadowEVSMPS.replace(/\$/g, "16") : chunks.shadowEVSMnPS.replace(/\$/g, "16"));
                }
                if (shadowTypeUsed[SHADOW_VSM32]) {
                    func.append(device.extTextureFloatLinear ? chunks.shadowEVSMPS.replace(/\$/g, "32") : chunks.shadowEVSMnPS.replace(/\$/g, "32"));
                }
            }

            if (!(device.webgl2 || device.extStandardDerivatives || device.isWebGPU)) {
                func.append(chunks.biasConstPS);
            }

            // otherwise bias is applied on render
            func.append(chunks.shadowCoordPS + chunks.shadowCommonPS);
            if (usePerspZbufferShadow) {
                func.append(chunks.shadowCoordPerspZbufferPS);
            }
        }

        if (options.enableGGXSpecular) func.append("uniform float material_anisotropy;");

        if (this.lighting) {
            func.append(chunks.lightDiffuseLambertPS);
            if (hasAreaLights || options.clusteredLightingAreaLightsEnabled) {
                func.append(chunks.ltcPS);
            }
        }

        let useOldAmbient = false;
        if (options.useSpecular) {

            if (this.lighting) {
                func.append(options.shadingModel === SPECULAR_PHONG ? chunks.lightSpecularPhongPS : (options.enableGGXSpecular ? chunks.lightSpecularAnisoGGXPS : chunks.lightSpecularBlinnPS));
            }

            if (!options.fresnelModel && !this.reflections && !options.diffuseMapEnabled) {
                decl.append("uniform vec3 material_ambient;");
                decl.append("#define LIT_OLD_AMBIENT");
                useOldAmbient = true;
            }
        }

        func.append(chunks.combinePS);

        // lightmap support
        if (options.lightMapEnabled || options.useLightMapVertexColors) {
            func.append((options.useSpecular && options.dirLightMapEnabled) ? chunks.lightmapDirAddPS : chunks.lightmapAddPS);
        }

        const addAmbient = (!options.lightMapEnabled && !options.useLightMapVertexColors) || options.lightMapWithoutAmbient;

        if (addAmbient) {
            if (options.ambientSource === 'ambientSH') {
                func.append(chunks.ambientSHPS);
            } else if (options.ambientSource === 'envAtlas') {
                if (options.reflectionSource !== 'envAtlas' && options.reflectionSource !== 'envAtlasHQ') {
                    func.append(chunks.envAtlasPS);
                }
                func.append(chunks.ambientEnvPS.replace(/\$DECODE/g, ChunkUtils.decodeFunc(options.ambientEncoding)));
            } else {
                func.append(chunks.ambientConstantPS);
            }
        }

        if (options.useAmbientTint && !useOldAmbient) {
            decl.append("uniform vec3 material_ambient;");
        }

        if (options.useMsdf) {
            if (!options.msdfTextAttribute) {
                decl.append("#define UNIFORM_TEXT_PARAMETERS");
            }
            func.append(chunks.msdfPS);
        }

        if (this.needsNormal) {
            func.append(chunks.viewDirPS);
            if (options.useSpecular) {
                func.append((options.enableGGXSpecular) ? chunks.reflDirAnisoPS : chunks.reflDirPS);
            }
        }

        let hasPointLights = false;
        let usesLinearFalloff = false;
        let usesInvSquaredFalloff = false;
        let usesSpot = false;
        let usesCookie = false;
        let usesCookieNow;

        // clustered lighting
        if (options.clusteredLightingEnabled && this.lighting) {

            usesSpot = true;
            hasPointLights = true;
            usesLinearFalloff = true;
            usesCookie = true;

            func.append(chunks.floatUnpackingPS);

            if (options.lightMaskDynamic)
                decl.append("#define CLUSTER_MESH_DYNAMIC_LIGHTS");

            if (options.clusteredLightingCookiesEnabled)
                decl.append("#define CLUSTER_COOKIES");
            if (options.clusteredLightingShadowsEnabled && !options.noShadow) {
                decl.append("#define CLUSTER_SHADOWS");
                decl.append("#define CLUSTER_SHADOW_TYPE_" + shadowTypeToString[options.clusteredLightingShadowType]);
            }

            if (options.clusteredLightingAreaLightsEnabled)
                decl.append("#define CLUSTER_AREALIGHTS");

            decl.append(LightsBuffer.shaderDefines);

            if (options.clusteredLightingShadowsEnabled && !options.noShadow) {
                func.append(chunks.clusteredLightShadowsPS);
            }

            func.append(chunks.clusteredLightPS);
        }

        if (options.twoSidedLighting) {
            decl.append("uniform float twoSidedLightingNegScaleFactor;");
        }

        // FRAGMENT SHADER BODY

        code.append(this._fsGetStartCode(code, device, chunks, options));

        if (this.needsNormal) {
            if (options.twoSidedLighting) {
                code.append("    dVertexNormalW = normalize(gl_FrontFacing ? vNormalW * twoSidedLightingNegScaleFactor : -vNormalW * twoSidedLightingNegScaleFactor);");
            } else {
                code.append("    dVertexNormalW = normalize(vNormalW);");
            }

            if ((options.heightMapEnabled || options.normalMapEnabled) && options.hasTangents) {
                if (options.twoSidedLighting) {
                    code.append("    dTangentW = gl_FrontFacing ? vTangentW * twoSidedLightingNegScaleFactor : -vTangentW * twoSidedLightingNegScaleFactor;");
                    code.append("    dBinormalW = gl_FrontFacing ? vBinormalW * twoSidedLightingNegScaleFactor : -vBinormalW * twoSidedLightingNegScaleFactor;");
                } else {
                    code.append("    dTangentW = vTangentW;");
                    code.append("    dBinormalW = vBinormalW;");
                }
            }

            code.append("    getViewDir();");
            if (hasTBN) {
                code.append("    getTBN(dTangentW, dBinormalW, dVertexNormalW);");
            }
        }

        // invoke frontend functions
        code.append(this.frontendFunc);

        // transform tangent space normals to world space
        if (this.needsNormal) {
            if (options.useSpecular) {
                backend.append("    getReflDir(litShaderArgs.worldNormal, dViewDirW, litShaderArgs.gloss, dTBN);");
            }

            if (options.useClearCoat) {
                backend.append("    ccReflDirW = normalize(-reflect(dViewDirW, litShaderArgs.clearcoat.worldNormal));");
            }
        }

        if ((this.lighting && options.useSpecular) || this.reflections) {
            if (options.useMetalness) {
                backend.append("    getMetalnessModulate(litShaderArgs);");
            }

            if (options.useIridescence) {
                backend.append("    vec3 iridescenceFresnel = getIridescence(saturate(dot(dViewDirW, litShaderArgs.worldNormal)), litShaderArgs.specularity, litShaderArgs.iridescence);");
            }
        }

        if (addAmbient) {
            backend.append("    addAmbient(litShaderArgs.worldNormal);");
            if (options.conserveEnergy && options.useSpecular) {
                backend.append(`   dDiffuseLight = dDiffuseLight * (1.0 - litShaderArgs.specularity);`);
            }

            // move ambient color out of diffuse (used by Lightmapper, to multiply ambient color by accumulated AO)
            if (options.separateAmbient) {
                backend.append(`
                    vec3 dAmbientLight = dDiffuseLight;
                    dDiffuseLight = vec3(0);
                `);
            }
        }

        if (options.useAmbientTint && !useOldAmbient) {
            backend.append("    dDiffuseLight *= material_ambient;");
        }

        if (useAo && !options.occludeDirect) {
            backend.append("    occludeDiffuse(litShaderArgs.ao);");
        }

        if (options.lightMapEnabled || options.useLightMapVertexColors) {
            backend.append(`    addLightMap(
                litShaderArgs.lightmap, 
                litShaderArgs.lightmapDir, 
                litShaderArgs.worldNormal, 
                dViewDirW, 
                dReflDirW, 
                litShaderArgs.gloss, 
                litShaderArgs.specularity, 
                dVertexNormalW,
                dTBN
            #if defined(LIT_IRIDESCENCE)
                , iridescenceFresnel,
                litShaderArgs.iridescence
            #endif
                );`);
        }

        if (this.lighting || this.reflections) {
            if (this.reflections) {
                if (options.useClearCoat) {
                    backend.append("    addReflectionCC(ccReflDirW, litShaderArgs.clearcoat.gloss);");
                    if (options.fresnelModel > 0) {
                        backend.append("    ccFresnel = getFresnelCC(dot(dViewDirW, litShaderArgs.clearcoat.worldNormal));");
                        backend.append("    ccReflection.rgb *= ccFresnel;");
                    } else {
                        backend.append("    ccFresnel = 0.0;");
                    }
                }
                if (options.useSpecularityFactor) {
                    backend.append("    ccReflection.rgb *= litShaderArgs.specularityFactor;");
                }

                if (options.useSheen) {
                    backend.append("    addReflectionSheen(litShaderArgs.worldNormal, dViewDirW, litShaderArgs.sheen.gloss);");
                }

                // Fresnel has to be applied to reflections
                backend.append("    addReflection(dReflDirW, litShaderArgs.gloss);");

                if (options.fresnelModel > 0) {
                    backend.append(`    dReflection.rgb *= 
                        getFresnel(
                            dot(dViewDirW, litShaderArgs.worldNormal), 
                            litShaderArgs.gloss, 
                            litShaderArgs.specularity
                        #if defined(LIT_IRIDESCENCE)
                            , iridescenceFresnel,
                            litShaderArgs.iridescence
                        #endif
                            );`);
                } else {
                    backend.append("    dReflection.rgb *= litShaderArgs.specularity;");
                }
                if (options.useSpecularityFactor) {
                    backend.append("    dReflection.rgb *= litShaderArgs.specularityFactor;");
                }
            }

            if (hasAreaLights) {
                // specular has to be accumulated differently if we want area lights to look correct
                backend.append("    dSpecularLight *= litShaderArgs.specularity;");
                // code += "    float roughness = max((1.0 - dGlossiness) * (1.0 - dGlossiness), 0.001);\n";

                // evaluate material based area lights data, shared by all area lights
                if (options.useSpecular) {
                    backend.append("    calcLTCLightValues(litShaderArgs.gloss, litShaderArgs.worldNormal, dViewDirW, litShaderArgs.specularity, litShaderArgs.clearcoat.gloss, litShaderArgs.clearcoat.worldNormal, litShaderArgs.clearcoat.specularity);");
                }
            }

            for (let i = 0; i < options.lights.length; i++) {
                const light = options.lights[i];
                const lightType = light._type;

                // if clustered lights are used, skip normal lights other than directional
                if (options.clusteredLightingEnabled && lightType !== LIGHTTYPE_DIRECTIONAL) {
                    continue;
                }

                // The following code is not decoupled to separate shader files, because most of it can be actually changed to achieve different behaviors like:
                // - different falloffs
                // - different shadow coords (omni shadows will use drastically different genShadowCoord)
                // - different shadow filter modes
                // - different light source shapes

                // getLightDiffuse and getLightSpecular is BRDF itself.

                usesCookieNow = false;

                const lightShape = (hasAreaLights && light._shape) ? light.shape : LIGHTSHAPE_PUNCTUAL;
                const shapeString = (hasAreaLights && light._shape) ? this._getLightSourceShapeString(lightShape) : '';

                if (lightShape !== LIGHTSHAPE_PUNCTUAL) {
                    backend.append("    calc" + shapeString + "LightValues(light" + i + "_position, light" + i + "_halfWidth, light" + i + "_halfHeight);");
                }

                if (lightType === LIGHTTYPE_DIRECTIONAL) {
                    // directional
                    backend.append("    dLightDirNormW = light" + i + "_direction;");
                    backend.append("    dAtten = 1.0;");
                } else {

                    if (light._cookie) {
                        if (lightType === LIGHTTYPE_SPOT && !light._cookie._cubemap) {
                            usesCookie = true;
                            usesCookieNow = true;
                        } else if (lightType === LIGHTTYPE_OMNI && light._cookie._cubemap) {
                            usesCookie = true;
                            usesCookieNow = true;
                        }
                    }

                    backend.append("    getLightDirPoint(light" + i + "_position);");
                    hasPointLights = true;

                    if (usesCookieNow) {
                        if (lightType === LIGHTTYPE_SPOT) {
                            backend.append("    dAtten3 = getCookie2D" + (light._cookieFalloff ? "" : "Clip") + (light._cookieTransform ? "Xform" : "") + "(light" + i + "_cookie, light" + i + "_shadowMatrix, light" + i + "_cookieIntensity" + (light._cookieTransform ? ", light" + i + "_cookieMatrix, light" + i + "_cookieOffset" : "") + ")." + light._cookieChannel + ";");
                        } else {
                            backend.append("    dAtten3 = getCookieCube(light" + i + "_cookie, light" + i + "_shadowMatrix, light" + i + "_cookieIntensity)." + light._cookieChannel + ";");
                        }
                    }

                    if (lightShape === LIGHTSHAPE_PUNCTUAL) {
                        if (light._falloffMode === LIGHTFALLOFF_LINEAR) {
                            backend.append("    dAtten = getFalloffLinear(light" + i + "_radius, dLightDirW);");
                            usesLinearFalloff = true;
                        } else {
                            backend.append("    dAtten = getFalloffInvSquared(light" + i + "_radius, dLightDirW);");
                            usesInvSquaredFalloff = true;
                        }
                    } else {
                        // non punctual lights only gets the range window here
                        backend.append("    dAtten = getFalloffWindow(light" + i + "_radius, dLightDirW);");
                        usesInvSquaredFalloff = true;
                    }

                    backend.append("    if (dAtten > 0.00001) {"); // BRANCH START

                    if (lightType === LIGHTTYPE_SPOT) {
                        if (!(usesCookieNow && !light._cookieFalloff)) {
                            backend.append("    dAtten *= getSpotEffect(light" + i + "_direction, light" + i + "_innerConeAngle, light" + i + "_outerConeAngle, dLightDirNormW);");
                            usesSpot = true;
                        }
                    }
                }

                // diffuse lighting - LTC lights do not mix diffuse lighting into attenuation that affects specular
                if (lightShape !== LIGHTSHAPE_PUNCTUAL) {
                    if (lightType === LIGHTTYPE_DIRECTIONAL) {
                        // NB: A better aproximation perhaps using wrap lighting could be implemented here
                        backend.append("    dAttenD = getLightDiffuse(litShaderArgs.worldNormal, dViewDirW, dLightDirW, dLightDirNormW);");
                    } else {
                        // 16.0 is a constant that is in getFalloffInvSquared()
                        backend.append("    dAttenD = get" + shapeString + "LightDiffuse(litShaderArgs.worldNormal, dViewDirW, dLightDirW, dLightDirNormW) * 16.0;");
                    }
                } else {
                    backend.append("    dAtten *= getLightDiffuse(litShaderArgs.worldNormal, dViewDirW, dLightDirW, dLightDirNormW);");
                }

                if (light.castShadows && !options.noShadow) {
                    let shadowReadMode = null;
                    let evsmExp;
                    if (light._shadowType === SHADOW_VSM8) {
                        shadowReadMode = "VSM8";
                        evsmExp = "0.0";
                    } else if (light._shadowType === SHADOW_VSM16) {
                        shadowReadMode = "VSM16";
                        evsmExp = "5.54";
                    } else if (light._shadowType === SHADOW_VSM32) {
                        shadowReadMode = "VSM32";
                        if (device.textureFloatHighPrecision) {
                            evsmExp = "15.0";
                        } else {
                            evsmExp = "5.54";
                        }
                    } else if (light._shadowType === SHADOW_PCF5) {
                        shadowReadMode = "PCF5x5";
                    } else {
                        shadowReadMode = "PCF3x3";
                    }

                    if (shadowReadMode !== null) {
                        if (lightType === LIGHTTYPE_OMNI) {
                            const shadowCoordArgs = "(light" + i + "_shadowMap, dShadowCoord, light" + i + "_shadowParams, dLightDirW);";
                            if (light._normalOffsetBias) {
                                backend.append("    normalOffsetPointShadow(light" + i + "_shadowParams, dLightPosW, dLightDirW, dLightDirNormW, dVertexNormalW);");
                            }
                            backend.append(`    float shadow${i} = getShadowPoint${shadowReadMode}${shadowCoordArgs}`);
                            backend.append(`    dAtten *= mix(1.0, shadow${i}, light${i}_shadowIntensity);`);
                        } else {
                            const shadowMatArg = `light${i}_shadowMatrix`;
                            const shadowParamArg = `light${i}_shadowParams`;
                            backend.append(this._nonPointShadowMapProjection(device, options.lights[i], shadowMatArg, shadowParamArg, i));

                            if (lightType === LIGHTTYPE_SPOT) shadowReadMode = "Spot" + shadowReadMode;
                            backend.append(`    float shadow${i} = getShadow${shadowReadMode}(SHADOWMAP_PASS(light${i}_shadowMap), dShadowCoord, light${i}_shadowParams${(light._isVsm ? ", " + evsmExp + ", dLightDirW" : "")});`);
                            backend.append(`    dAtten *= mix(1.0, shadow${i}, light${i}_shadowIntensity);`);
                        }
                    }
                }

                if (lightShape !== LIGHTSHAPE_PUNCTUAL) {

                    // area light - they do not mix diffuse lighting into specular attenuation
                    if (options.conserveEnergy && options.useSpecular) {
                        backend.append("    dDiffuseLight += ((dAttenD * dAtten) * light" + i + "_color" + (usesCookieNow ? " * dAtten3" : "") + ") * (1.0 - dLTCSpecFres);");
                    } else {
                        backend.append("    dDiffuseLight += (dAttenD * dAtten) * light" + i + "_color" + (usesCookieNow ? " * dAtten3" : "") + ";");
                    }
                } else {

                    // punctual light
                    if (hasAreaLights && options.conserveEnergy && options.useSpecular) {
                        backend.append("    dDiffuseLight += (dAtten * light" + i + "_color" + (usesCookieNow ? " * dAtten3" : "") + ") * (1.0 - litShaderArgs.specularity);");
                    } else {
                        backend.append("    dDiffuseLight += dAtten * light" + i + "_color" + (usesCookieNow ? " * dAtten3" : "") + ";");
                    }
                }

                if (options.useSpecular) {
                    backend.append("    dHalfDirW = normalize(-dLightDirNormW + dViewDirW);");
                }

                // specular / clear coat
                if (lightShape !== LIGHTSHAPE_PUNCTUAL) {

                    // area light
                    if (options.useClearCoat) {
                        backend.append(`    ccSpecularLight += ccLTCSpecFres * get${shapeString}LightSpecular(litShaderArgs.clearcoat.worldNormal, dViewDirW) * dAtten * light${i}_color` + (usesCookieNow ? " * dAtten3" : "") + ";");
                    }
                    if (options.useSpecular) {
                        backend.append(`    dSpecularLight += dLTCSpecFres * get${shapeString}LightSpecular(litShaderArgs.worldNormal, dViewDirW) * dAtten * light${i}_color` + (usesCookieNow ? " * dAtten3" : "") + ";");
                    }

                } else {
                    var calcFresnel = false;
                    if (lightType === LIGHTTYPE_DIRECTIONAL && options.fresnelModel > 0) {
                        calcFresnel = true;
                    }

                    // if LTC lights are present, specular must be accumulated with specularity (specularity is pre multiplied by punctual light fresnel)
                    if (options.useClearCoat) {
                        backend.append(`    ccSpecularLight += getLightSpecular(dHalfDirW, ccReflDirW, litShaderArgs.clearcoat.worldNormal, dViewDirW, dLightDirNormW, litShaderArgs.clearcoat.gloss, dTBN) * dAtten * light${i}_color` +
                            (usesCookieNow ? " * dAtten3" : "") +
                            (calcFresnel ? " * getFresnelCC(dot(dViewDirW, dHalfDirW));" : ";"));
                    }
                    if (options.useSheen) {
                        backend.append(`    sSpecularLight += getLightSpecularSheen(dHalfDirW, litShaderArgs.worldNormal, dViewDirW, dLightDirNormW, litShaderArgs.sheen.gloss) * dAtten * light${i}_color` +
                            (usesCookieNow ? " * dAtten3;" : ";"));
                    }
                    if (options.useSpecular) {
                        backend.append(`    dSpecularLight += getLightSpecular(dHalfDirW, dReflDirW, litShaderArgs.worldNormal, dViewDirW, dLightDirNormW, litShaderArgs.gloss, dTBN) * dAtten * light${i}_color` +
                            (usesCookieNow ? " * dAtten3" : "") +
                            (calcFresnel ? ` 
                                * getFresnel(
                                    dot(dViewDirW, dHalfDirW), 
                                    litShaderArgs.gloss, 
                                    litShaderArgs.specularity
                                #if defined(LIT_IRIDESCENCE)
                                    , iridescenceFresnel, 
                                    litShaderArgs.iridescence
                                #endif
                                );` : `* litShaderArgs.specularity;`));
                    }
                }

                if (lightType !== LIGHTTYPE_DIRECTIONAL) {
                    backend.append("    }"); // BRANCH END
                }
            }

            // clustered lighting
            if (options.clusteredLightingEnabled && this.lighting) {
                usesLinearFalloff = true;
                usesInvSquaredFalloff = true;
                hasPointLights = true;
                backend.append(`    addClusteredLights(
                                        litShaderArgs.worldNormal, 
                                        dViewDirW, 
                                        dReflDirW,
                                #if defined(LIT_CLEARCOAT)
                                        ccReflDirW,
                                #endif
                                        litShaderArgs.gloss, 
                                        litShaderArgs.specularity, 
                                        dVertexNormalW, 
                                        dTBN, 
                                #if defined(LIT_IRIDESCENCE)
                                        iridescenceFresnel,
                                #endif
                                        litShaderArgs.clearcoat, 
                                        litShaderArgs.sheen, 
                                        litShaderArgs.iridescence
                                    );`);
            }

            if (hasAreaLights) {
                // specular has to be accumulated differently if we want area lights to look correct
                if (options.useClearCoat) {
                    backend.append("    litShaderArgs.clearcoat.specularity = 1.0;");
                }
                if (options.useSpecular) {
                    backend.append("    litShaderArgs.specularity = vec3(1);");
                }
            }

            if (options.useRefraction) {
                backend.append(`    addRefraction(
                        litShaderArgs.worldNormal, 
                        dViewDirW, 
                        litShaderArgs.thickness, 
                        litShaderArgs.gloss, 
                        litShaderArgs.specularity, 
                        litShaderArgs.albedo, 
                        litShaderArgs.transmission
                    #if defined(LIT_IRIDESCENCE)
                        , iridescenceFresnel, 
                        litShaderArgs.iridescence
                    #endif
                    );`);
            }
        }

        if (useAo) {
            if (options.occludeDirect) {
                backend.append("    occludeDiffuse(litShaderArgs.ao);");
            }
            if (options.occludeSpecular === SPECOCC_AO || options.occludeSpecular === SPECOCC_GLOSSDEPENDENT) {
                backend.append("    occludeSpecular(litShaderArgs.gloss, litShaderArgs.ao, litShaderArgs.worldNormal, dViewDirW);");
            }
        }

        if (options.useSpecularityFactor) {
            backend.append("    dSpecularLight *= litShaderArgs.specularityFactor;");
        }

        if (options.opacityFadesSpecular === false) {
            if (options.blendType === BLEND_NORMAL || options.blendType === BLEND_PREMULTIPLIED) {
                backend.append("float specLum = dot((dSpecularLight + dReflection.rgb * dReflection.a), vec3( 0.2126, 0.7152, 0.0722 ));");
                backend.append("#ifdef LIT_CLEARCOAT\n specLum += dot(ccSpecularLight * litShaderArgs.clearcoat.specularity + ccReflection.rgb * litShaderArgs.clearcoat.specularity, vec3( 0.2126, 0.7152, 0.0722 ));\n#endif");
                backend.append("litShaderArgs.opacity = clamp(litShaderArgs.opacity + gammaCorrectInput(specLum), 0.0, 1.0);");
            }
            backend.append("litShaderArgs.opacity *= material_alphaFade;");
        }

        backend.append(chunks.endPS);
        if (options.blendType === BLEND_NORMAL || options.blendType === BLEND_ADDITIVEALPHA || options.alphaToCoverage) {
            backend.append(chunks.outputAlphaPS);
        } else if (options.blendType === BLEND_PREMULTIPLIED) {
            backend.append(chunks.outputAlphaPremulPS);
        } else {
            backend.append(chunks.outputAlphaOpaquePS);
        }

        if (options.useMsdf) {
            backend.append("    gl_FragColor = applyMsdf(gl_FragColor);");
        }


        if (hasPointLights) {
            func.prepend(chunks.lightDirPointPS);
        }
        if (usesLinearFalloff) {
            func.prepend(chunks.falloffLinearPS);
        }
        if (usesInvSquaredFalloff) {
            func.prepend(chunks.falloffInvSquaredPS);
        }
        if (usesSpot) {
            func.prepend(chunks.spotPS);
        }
        if (usesCookie && !options.clusteredLightingEnabled) {
            // non-clustered lights cookie code
            func.prepend(chunks.cookiePS);
        }
        let structCode = "";

        const backendCode = `void evaluateBackend(LitShaderArguments litShaderArgs) {\n${backend.code}\n}`;
        func.append(backendCode);
        code.append("    evaluateBackend(litShaderArgs);");

        code.append(end());

        const mergedCode = decl.code + func.code + code.code;

        // Light inputs
        if (mergedCode.includes("dTBN")) structCode += "mat3 dTBN;\n";
        if (mergedCode.includes("dVertexNormalW")) structCode += "vec3 dVertexNormalW;\n";
        if (mergedCode.includes("dTangentW")) structCode += "vec3 dTangentW;\n";
        if (mergedCode.includes("dBinormalW")) structCode += "vec3 dBinormalW;\n";
        if (mergedCode.includes("dViewDirW")) structCode += "vec3 dViewDirW;\n";
        if (mergedCode.includes("dReflDirW")) structCode += "vec3 dReflDirW;\n";
        if (mergedCode.includes("dHalfDirW")) structCode += "vec3 dHalfDirW;\n";
        if (mergedCode.includes("ccReflDirW")) structCode += "vec3 ccReflDirW;\n";

        // Per-light temporaries
        if (mergedCode.includes("dLightDirNormW")) structCode += "vec3 dLightDirNormW;\n";
        if (mergedCode.includes("dLightDirW")) structCode += "vec3 dLightDirW;\n";
        if (mergedCode.includes("dLightPosW")) structCode += "vec3 dLightPosW;\n";
        if (mergedCode.includes("dShadowCoord")) structCode += "vec3 dShadowCoord;\n";

        // Outputs
        if (mergedCode.includes("dReflection")) structCode += "vec4 dReflection;\n";
        if (mergedCode.includes("dDiffuseLight")) structCode += "vec3 dDiffuseLight;\n";
        if (mergedCode.includes("dSpecularLight")) structCode += "vec3 dSpecularLight;\n";
        if (mergedCode.includes("dAtten")) structCode += "float dAtten;\n";
        if (mergedCode.includes("dAttenD")) structCode += "float dAttenD;\n"; // separate diffuse attenuation for non-punctual light sources
        if (mergedCode.includes("dAtten3")) structCode += "vec3 dAtten3;\n";
        if (mergedCode.includes("dMsdf")) structCode += "vec4 dMsdf;\n";
        if (mergedCode.includes("ccFresnel")) structCode += "float ccFresnel;\n";
        if (mergedCode.includes("ccReflection")) structCode += "vec3 ccReflection;\n";
        if (mergedCode.includes("ccSpecularLight")) structCode += "vec3 ccSpecularLight;\n";
        if (mergedCode.includes("ccSpecularityNoFres")) structCode += "float ccSpecularityNoFres;\n";
        if (mergedCode.includes("sSpecularLight")) structCode += "vec3 sSpecularLight;\n";
        if (mergedCode.includes("sReflection")) structCode += "vec3 sReflection;\n";

        const result = this._fsGetBeginCode() +
            this.varyings +
            this._fsGetBaseCode() +
            (options.detailModes ? chunks.detailModesPS : "") +
            structCode +
            this.frontendDecl +
            mergedCode;

        return result;
    }

    generateFragmentShader(frontendDecl, frontendCode, frontendFunc, lightingUv) {
        const options = this.options;

        this.frontendDecl = frontendDecl;
        this.frontendCode = frontendCode;
        this.frontendFunc = frontendFunc;
        this.lightingUv = lightingUv;

        if (options.pass === SHADER_PICK) {
            this.fshader = this._fsGetPickPassCode();
        } else if (options.pass === SHADER_DEPTH) {
            this.fshader = this._fsGetDepthPassCode();
        } else if (this.shadowPass) {
            this.fshader = this._fsGetShadowPassCode();
        } else if (options.customFragmentShader) {
            this.fshader = this._fsGetBeginCode() + options.customFragmentShader;
        } else {
            this.fshader = this._fsGetLitPassCode();
        }
    }

    getDefinition() {

        const definition = ShaderUtils.createDefinition(this.device, {
            name: 'LitShader',
            attributes: this.attributes,
            vertexCode: this.vshader,
            fragmentCode: this.fshader
        });

        if (ShaderPass.isForward(this.options.pass)) {
            definition.tag = SHADERTAG_MATERIAL;
        }

        return definition;
    }
}

export { LitShader };
