import {
    SEMANTIC_ATTR8, SEMANTIC_ATTR9, SEMANTIC_ATTR12, SEMANTIC_ATTR13, SEMANTIC_ATTR14, SEMANTIC_ATTR15,
    SEMANTIC_BLENDINDICES, SEMANTIC_BLENDWEIGHT, SEMANTIC_COLOR, SEMANTIC_NORMAL, SEMANTIC_POSITION, SEMANTIC_TANGENT,
    SEMANTIC_TEXCOORD0, SEMANTIC_TEXCOORD1
} from '../../../platform/graphics/constants.js';
import {
    LIGHTFALLOFF_LINEAR,
    LIGHTSHAPE_PUNCTUAL, LIGHTSHAPE_RECT, LIGHTSHAPE_DISK, LIGHTSHAPE_SPHERE,
    LIGHTTYPE_DIRECTIONAL, LIGHTTYPE_OMNI, LIGHTTYPE_SPOT,
    SHADER_DEPTH, SHADER_PICK,
    SHADOW_PCF1_32F, SHADOW_PCF3_32F, SHADOW_PCF5_32F, SHADOW_VSM_16F, SHADOW_VSM_32F, SHADOW_PCSS_32F,
    SPECOCC_AO, SPECOCC_GLOSSDEPENDENT,
    SPRITE_RENDERMODE_SLICED, SPRITE_RENDERMODE_TILED, shadowTypeInfo, SHADER_PREPASS,
    SHADOW_PCF1_16F, SHADOW_PCF5_16F, SHADOW_PCF3_16F,
    lightTypeNames, lightShapeNames, spriteRenderModeNames, fresnelNames, blendNames,
    cubemaProjectionNames
} from '../../constants.js';
import { shaderChunks } from '../chunks/chunks.js';
import { ChunkUtils } from '../chunk-utils.js';
import { ShaderPass } from '../../shader-pass.js';
import { validateUserChunks } from '../chunks/chunk-validation.js';
import { ChunkBuilder } from '../chunk-builder.js';
import { Debug } from '../../../core/debug.js';

/**
 * @import { GraphicsDevice } from '../../../platform/graphics/graphics-device.js'
 * @import { LitShaderOptions } from './lit-shader-options.js'
 */

const builtinAttributes = {
    vertex_normal: SEMANTIC_NORMAL,
    vertex_tangent: SEMANTIC_TANGENT,
    vertex_texCoord0: SEMANTIC_TEXCOORD0,
    vertex_texCoord1: SEMANTIC_TEXCOORD1,
    vertex_color: SEMANTIC_COLOR,
    vertex_boneWeights: SEMANTIC_BLENDWEIGHT,
    vertex_boneIndices: SEMANTIC_BLENDINDICES
};

export const varyingsWGSLTypes = new Map([
    ['vec4', 'vec4f'],
    ['vec3', 'vec3f'],
    ['vec2', 'vec2f'],
    ['float', 'f32']
]);

class LitShader {
    /**
     * Shader code representing varyings.
     *
     * @type {string}
     */
    varyingsCode = '';

    /**
     * @param {GraphicsDevice} device - The graphics device.
     * @param {LitShaderOptions} options - The lit options.
     */
    constructor(device, options) {
        this.device = device;
        this.options = options;

        // resolve custom chunk attributes
        this.attributes = {
            vertex_position: SEMANTIC_POSITION
        };

        if (options.userAttributes) {
            for (const [semantic, name] of Object.entries(options.userAttributes)) {
                this.attributes[name] = semantic;
            }
        }

        if (options.chunks) {
            const userChunks = options.chunks;

            // #if _DEBUG
            validateUserChunks(userChunks);
            // #endif

            this.chunks = Object.create(shaderChunks);
            for (const chunkName in shaderChunks) {
                if (userChunks.hasOwnProperty(chunkName)) {
                    const chunk = userChunks[chunkName];
                    for (const a in builtinAttributes) {
                        if (builtinAttributes.hasOwnProperty(a) && chunk.indexOf(a) >= 0) {
                            this.attributes[a] = builtinAttributes[a];
                        }
                    }
                    this.chunks[chunkName] = chunk;
                }
            }
        } else {
            this.chunks = shaderChunks;
        }

        this.shaderPassInfo = ShaderPass.get(this.device).getByIndex(options.pass);
        this.shadowPass = this.shaderPassInfo.isShadow;

        this.lighting = (options.lights.length > 0) || options.dirLightMapEnabled || options.clusteredLightingEnabled;
        this.reflections = !!options.reflectionSource;
        this.needsNormal =
            this.lighting ||
            this.reflections ||
            options.useSpecular ||
            options.ambientSH ||
            options.useHeights ||
            options.enableGGXSpecular ||
            (options.clusteredLightingEnabled && !this.shadowPass) ||
            options.useClearCoatNormals;
        this.needsNormal = this.needsNormal && !this.shadowPass;
        this.needsSceneColor = options.useDynamicRefraction;
        this.needsScreenSize = options.useDynamicRefraction;
        this.needsTransforms = options.useDynamicRefraction;

        // generated by vshader
        this.vshader = null;

        // supplied by caller
        this.frontendDecl = null;
        this.frontendCode = null;
        this.lightingUv = null;

        // defines set by the shader generation
        this.defines = [];

        this.vDefines = new Map();
        this.fDefines = new Map();

        // generated by fshader
        this.fshader = null;
    }

    // Add "Base" Code section to fragment shader.
    _fsGetBaseCode() {
        const options = this.options;
        const chunks = this.chunks;
        let result = this.chunks.basePS;
        if (options.nineSlicedMode === SPRITE_RENDERMODE_SLICED) {
            result += chunks.baseNineSlicedPS;
        } else if (options.nineSlicedMode === SPRITE_RENDERMODE_TILED) {
            result += chunks.baseNineSlicedTiledPS;
        }
        return result;
    }

    _getLightSourceShapeString(shape) {
        switch (shape) {
            case LIGHTSHAPE_RECT:
                return 'Rect';
            case LIGHTSHAPE_DISK:
                return 'Disk';
            case LIGHTSHAPE_SPHERE:
                return 'Sphere';
            default:
                return '';
        }
    }

    /**
     * The function generates defines for the lit vertex shader, and handles required attributes and
     * varyings. The source code of the shader is supplied by litMainVS chunk.
     *
     * @param {any} useUv - Info about used UVs.
     * @param {any} useUnmodifiedUv - Info about used unmodified UVs.
     * @param {any} mapTransforms - Info about used texture transforms.
     */
    generateVertexShader(useUv, useUnmodifiedUv, mapTransforms) {

        const { options, vDefines, attributes, chunks } = this;

        // varyings
        const varyings = new Map();
        varyings.set('vPositionW', 'vec3');

        if (options.nineSlicedMode === SPRITE_RENDERMODE_SLICED || options.nineSlicedMode === SPRITE_RENDERMODE_TILED) {
            vDefines.set('NINESLICED', true);
        }

        if (this.options.linearDepth) {
            vDefines.set('LINEAR_DEPTH', true);
            varyings.set('vLinearDepth', 'float');
        }

        if (this.needsNormal) vDefines.set('NORMALS', true);

        if (this.options.useInstancing) {

            // only attach these if the default instancing chunk is used, otherwise it is expected
            // for the user to provide required attributes using material.setAttribute
            if (this.chunks.transformInstancingVS === shaderChunks.transformInstancingVS) {
                attributes.instance_line1 = SEMANTIC_ATTR12;
                attributes.instance_line2 = SEMANTIC_ATTR13;
                attributes.instance_line3 = SEMANTIC_ATTR14;
                attributes.instance_line4 = SEMANTIC_ATTR15;
            }
        }

        if (this.needsNormal) {
            attributes.vertex_normal = SEMANTIC_NORMAL;
            varyings.set('vNormalW', 'vec3');

            if (options.hasTangents && (options.useHeights || options.useNormals || options.enableGGXSpecular)) {

                vDefines.set('TANGENTS', true);
                attributes.vertex_tangent = SEMANTIC_TANGENT;
                varyings.set('vTangentW', 'vec3');
                varyings.set('vBinormalW', 'vec3');

            } else if (options.enableGGXSpecular) {

                vDefines.set('GGX_SPECULAR', true);
                varyings.set('vObjectSpaceUpW', 'vec3');
            }
        }

        const maxUvSets = 2;
        for (let i = 0; i < maxUvSets; i++) {
            if (useUv[i]) {
                vDefines.set(`UV${i}`, true);
                attributes[`vertex_texCoord${i}`] = `TEXCOORD${i}`;
            }
            if (useUnmodifiedUv[i]) {
                vDefines.set(`UV${i}_UNMODIFIED`, true);
                varyings.set(`vUv${i}`, 'vec2');
            }
        }

        // prepare defines for texture transforms
        let numTransforms = 0;
        const transformDone = new Set();
        mapTransforms.forEach((mapTransform) => {

            const { id, uv, name } = mapTransform;
            const checkId = id + uv * 100; // make sure each UV set is transformed by each unique transform only once

            if (!transformDone.has(checkId)) {
                transformDone.add(checkId);

                // register the varying
                varyings.set(`vUV${uv}_${id}`, 'vec2');

                // defines used by the included chunks
                const varName = `texture_${name}MapTransform`;
                vDefines.set(`{TRANSFORM_NAME_${numTransforms}}`, varName);
                vDefines.set(`{TRANSFORM_UV_${numTransforms}}`, uv);
                vDefines.set(`{TRANSFORM_ID_${numTransforms}}`, id);

                numTransforms++;
            }
        });

        // number of transforms, this drives the looped includes
        vDefines.set('UV_TRANSFORMS_COUNT', numTransforms);

        if (options.vertexColors) {
            attributes.vertex_color = SEMANTIC_COLOR;
            vDefines.set('VERTEX_COLOR', true);
            varyings.set('vVertexColor', 'vec4');
        }

        if (options.useMsdf && options.msdfTextAttribute) {
            attributes.vertex_outlineParameters = SEMANTIC_ATTR8;
            attributes.vertex_shadowParameters = SEMANTIC_ATTR9;
            vDefines.set('MSDF', true);
        }

        // morphing
        if (options.useMorphPosition || options.useMorphNormal) {

            vDefines.set('MORPHING', true);
            if (options.useMorphTextureBasedInt) vDefines.set('MORPHING_INT', true);
            if (options.useMorphPosition) vDefines.set('MORPHING_POSITION', true);
            if (options.useMorphNormal) vDefines.set('MORPHING_NORMAL', true);

            // vertex ids attributes
            attributes.morph_vertex_id = SEMANTIC_ATTR15;
        }

        if (options.skin) {

            attributes.vertex_boneIndices = SEMANTIC_BLENDINDICES;

            if (options.batch) {
                vDefines.set('BATCH', true);
            } else {
                attributes.vertex_boneWeights = SEMANTIC_BLENDWEIGHT;
                vDefines.set('SKIN', true);
            }
        }

        if (options.useInstancing) vDefines.set('INSTANCING', true);
        if (options.screenSpace) vDefines.set('SCREENSPACE', true);
        if (options.pixelSnap) vDefines.set('PIXELSNAP', true);

        // generate varyings code
        varyings.forEach((type, name) => {
            vDefines.set(`VARYING_${name.toUpperCase()}`, true);
            const generateWgsl = false; // when we switch generation to WGSL on WebGPU
            this.varyingsCode += generateWgsl ?
                `varying ${name}: ${varyingsWGSLTypes.get(type)};\n` :
                `varying ${type} ${name};\n`;
        });

        this.vshader = this.varyingsCode + chunks.litMainVS;
    }

    _fsGetBeginCode() {

        let code = '';
        for (let i = 0; i < this.defines.length; i++) {
            code += `#define ${this.defines[i]}\n`;
        }

        return code;
    }

    _fsGetShadowPassCode() {
        const options = this.options;

        const lightType = this.shaderPassInfo.lightType;
        let shadowType = this.shaderPassInfo.shadowType;

        const shadowInfo = shadowTypeInfo.get(shadowType);
        Debug.assert(shadowInfo);
        const { vsm, pcss, pcf } = shadowInfo;

        // If not a directional light and using clustered, fall back to using PCF3x3 if shadow type isn't supported
        if (lightType !== LIGHTTYPE_DIRECTIONAL && options.clusteredLightingEnabled) {
            if (!pcf) {
                shadowType = SHADOW_PCF3_32F;
            }
        }

        // Use perspective depth for:
        // Directional: Always since light has no position
        // Spot: If not using VSM
        // Point: Never
        const usePerspectiveDepth = (lightType === LIGHTTYPE_DIRECTIONAL || (!vsm && lightType === LIGHTTYPE_SPOT));

        const code = `

            ${this._fsGetBeginCode()}
            ${this.varyingsCode}
            ${this.frontendDecl}
            ${this.frontendCode}

            // Flag if we are using non-standard depth, i.e gl_FragCoord.z
            ${usePerspectiveDepth ? '#define PERSPECTIVE_DEPTH' : ''}
            ${pcss ? '#define PCSS' : ''}
            ${vsm ? '#define VSM' : ''}
            ${shadowType === SHADOW_VSM_32F ? '#define VSM_32F' : ''}
            ${lightType === LIGHTTYPE_DIRECTIONAL ? '#define DIRECTIONAL_LIGHT' : ''}

            #ifndef DIRECTIONAL_LIGHT
                uniform vec3 view_position;
                uniform float light_radius;
            #endif

            #ifdef PCSS
                #include "linearizeDepthPS"
            #endif

            void main(void) {
                evaluateFrontend();

                #ifdef PERSPECTIVE_DEPTH
                    float depth = gl_FragCoord.z;

                    #ifdef PCSS
                        // spot/omni shadows currently use linear depth.
                        // TODO: use perspective depth for spot/omni the same way as directional
                        #ifndef DIRECTIONAL_LIGHT
                            depth = linearizeDepth(depth, camera_params);
                        #endif
                    #endif

                #else
                    float depth = min(distance(view_position, vPositionW) / light_radius, 0.99999);
                    #define MODIFIED_DEPTH
                #endif

                #ifdef VSM
                    #ifdef VSM_32F
                        float exponent = 15.0;
                    #else
                        float exponent = 5.54;
                    #endif
                    depth = 2.0 * depth - 1.0;
                    depth =  exp(exponent * depth);
                    gl_FragColor = vec4(depth, depth*depth, 1.0, 1.0);
                #else
                    #ifdef PCSS
                        // store depth into R32
                        gl_FragColor.r = depth;
                    #else
                        #ifdef MODIFIED_DEPTH
                            // If we end up using modified depth, it needs to be explicitly written to gl_FragDepth
                            gl_FragDepth = depth;
                        #endif

                        // just the simplest code, color is not written anyway
                        gl_FragColor = vec4(1.0);
                    #endif
                #endif
            }
        `;

        return code;
    }

    /**
     * Generate defines for lighting environment as well as individual lights.
     *
     * @param {boolean} hasAreaLights - Whether any of the lights are area lights.
     * @param {boolean} clusteredLightingEnabled - Whether clustered lighting is enabled.
     */
    _setupLightingDefines(hasAreaLights, clusteredLightingEnabled) {

        const fDefines = this.fDefines;
        const options = this.options;

        this.fDefines.set('LIGHT_COUNT', options.lights.length);
        if (hasAreaLights) fDefines.set('AREA_LIGHTS', true);

        // clustered lights defines
        if (clusteredLightingEnabled && this.lighting) {
            fDefines.set('CLUSTERED_LIGHTS', true);
            if (options.clusteredLightingCookiesEnabled) fDefines.set('CLUSTER_COOKIES', true);
            if (options.clusteredLightingAreaLightsEnabled) fDefines.set('CLUSTER_AREALIGHTS', true);
            if (options.lightMaskDynamic) fDefines.set('CLUSTER_MESH_DYNAMIC_LIGHTS', true);

            // shadows
            if (options.clusteredLightingShadowsEnabled && !options.noShadow) {
                const clusteredShadowInfo = shadowTypeInfo.get(options.clusteredLightingShadowType);
                fDefines.set('CLUSTER_SHADOWS', true);
                fDefines.set(`SHADOW_KIND_${clusteredShadowInfo.kind}`, true);
                fDefines.set(`CLUSTER_SHADOW_TYPE_${clusteredShadowInfo.kind}`, true);
            }
        }

        // generate defines for all non-clustered lights
        for (let i = 0; i < options.lights.length; i++) {
            const light = options.lights[i];
            const lightType = light._type;

            // when clustered lighting is enabled, skip non-directional lights
            if (clusteredLightingEnabled && lightType !== LIGHTTYPE_DIRECTIONAL) {
                continue;
            }

            const lightShape = (hasAreaLights && light._shape) ? light._shape : LIGHTSHAPE_PUNCTUAL;
            const shadowType = light._shadowType;
            const castShadow = light.castShadows && !options.noShadow;
            const shadowInfo = shadowTypeInfo.get(shadowType);

            // per light defines
            fDefines.set(`LIGHT${i}`, true);
            fDefines.set(`LIGHT${i}TYPE`, `${lightTypeNames[lightType]}`);
            fDefines.set(`LIGHT${i}SHADOWTYPE`, `${shadowInfo.name}`);
            fDefines.set(`LIGHT${i}SHAPE`, `${lightShapeNames[lightShape]}`);
            if (light._cookie) fDefines.set(`LIGHT${i}COOKIE`, true);
            if (light._cookie?._cubemap) fDefines.set(`LIGHT${i}COOKIE_CUBEMAP`, true);
            if (light._cookieTransform) fDefines.set(`LIGHT${i}COOKIE_TRANSFORM`, true);

            if (castShadow) {
                fDefines.set(`LIGHT${i}CASTSHADOW`, true);
                if (shadowInfo.pcf) fDefines.set(`LIGHT${i}SHADOW_PCF`, true);
            }

            // global lighting defines
            if (castShadow) {
                fDefines.set(`SHADOW_KIND_${shadowInfo.kind}`, true);
                if (lightType === LIGHTTYPE_DIRECTIONAL) fDefines.set('SHADOW_DIRECTIONAL', true);
            }
        }
    }

    fDefineSet(condition, name, value = '') {
        if (condition) {
            this.fDefines.set(name, value);
        }
    }

    // the big one
    _fsGetLitPassCode() {
        const { device, options, chunks } = this;

        const decl = new ChunkBuilder();
        const func = new ChunkBuilder();
        const backend = new ChunkBuilder();
        const code = new ChunkBuilder();

        const hasTBN = this.needsNormal && (options.useNormals || options.useClearCoatNormals || (options.enableGGXSpecular && !options.useHeights));

        // area lights are used when clustered area lights are enabled or any lights have area shape
        const clusteredAreaLights = options.clusteredLightingEnabled && options.clusteredLightingAreaLightsEnabled;
        const hasAreaLights = clusteredAreaLights || options.lights.some((light) => {
            return light._shape && light._shape !== LIGHTSHAPE_PUNCTUAL;
        });

        if (options.useSpecular) {
            this.fDefineSet(true, 'LIT_SPECULAR');
            this.fDefineSet(this.reflections, 'LIT_REFLECTIONS');
            this.fDefineSet(options.useClearCoat, 'LIT_CLEARCOAT');
            this.fDefineSet(options.fresnelModel > 0, 'LIT_SPECULAR_FRESNEL');
            this.fDefineSet(options.useSheen, 'LIT_SHEEN');
            this.fDefineSet(options.useIridescence, 'LIT_IRIDESCENCE');
        }

        this.fDefineSet(true, 'LIT_FRESNEL_MODEL', fresnelNames[options.fresnelModel]);
        this.fDefineSet(options.useMetalness, 'LIT_METALNESS');
        this.fDefineSet(options.enableGGXSpecular, 'LIT_GGX_SPECULAR');
        this.fDefineSet(options.useSpecularityFactor, 'LIT_SPECULARITY_FACTOR');
        this.fDefineSet(options.useCubeMapRotation, 'CUBEMAP_ROTATION');
        this.fDefineSet(options.occludeSpecularFloat, 'LIT_OCCLUDE_SPECULAR_FLOAT');
        this.fDefineSet(options.separateAmbient, 'LIT_SEPARATE_AMBIENT');
        this.fDefineSet(options.twoSidedLighting, 'LIT_TWO_SIDED_LIGHTING');
        this.fDefineSet(options.lightMapEnabled, 'LIT_LIGHTMAP');
        this.fDefineSet(options.dirLightMapEnabled, 'LIT_DIR_LIGHTMAP');
        this.fDefineSet(hasTBN, 'LIT_TBN');
        this.fDefineSet(options.hasTangents, 'LIT_TANGENTS');
        this.fDefineSet(options.useNormals, 'LIT_USE_NORMALS');
        this.fDefineSet(this.needsNormal, 'LIT_NEEDS_NORMAL');
        this.fDefineSet(options.useClearCoatNormals, 'LIT_USE_CLEARCOAT_NORMALS');
        this.fDefineSet(options.useRefraction, 'LIT_REFRACTION');
        this.fDefineSet(options.dispersion, 'LIT_DISPERSION');
        this.fDefineSet(options.useHeights, 'LIT_HEIGHTS');
        this.fDefineSet(options.opacityFadesSpecular, 'LIT_OPACITY_FADES_SPECULAR');
        this.fDefineSet(options.alphaToCoverage, 'LIT_ALPHA_TO_COVERAGE');
        this.fDefineSet(true, 'LIT_NONE_SLICE_MODE', spriteRenderModeNames[options.nineSlicedMode]);
        this.fDefineSet(true, 'LIT_BLEND_TYPE', blendNames[options.blendType]);
        this.fDefineSet(true, 'LIT_CUBEMAP_PROJECTION', cubemaProjectionNames[options.cubeMapProjection]);

        // injection defines
        this.fDefineSet(true, '{lightingUv}', this.lightingUv ?? ''); // example: vUV0_1

        // lighting defines
        this._setupLightingDefines(hasAreaLights, options.clusteredLightingEnabled);

        decl.append(`
            // globals
            vec3 sReflection;
            vec3 dVertexNormalW;
            vec3 dTangentW;
            vec3 dBinormalW;
            vec3 dViewDirW;
            vec3 dReflDirW;
            vec3 dHalfDirW;
            vec3 ccReflDirW;

            // Per-light temporaries
            vec3 dLightDirNormW;
            vec3 dLightDirW;
            vec3 dLightPosW;
            vec3 dShadowCoord;

            // Outputs
            mat3 dTBN;
            vec4 dReflection;
            vec3 dDiffuseLight;
            vec3 dSpecularLight;
            float dAtten;
            float dAttenD; // separate diffuse attenuation for non-punctual light sources
            vec3 dAtten3;
            vec4 dMsdf;
            float ccFresnel;
            vec3 ccReflection;
            vec3 ccSpecularLight;
            float ccSpecularityNoFres;
            vec3 sSpecularLight;

            #ifdef LIT_DISPERSION
                uniform float material_dispersion;
            #endif
        `);

        // FRAGMENT SHADER INPUTS: UNIFORMS

        decl.append(`
            #ifndef LIT_OPACITY_FADES_SPECULAR
                uniform float material_alphaFade;
            #endif

            // lighting and shadowing code

            // LOOP - uniform declarations for all non-clustered lights
            #include "lightDeclarationPS, LIGHT_COUNT"

            #if defined(CLUSTERED_LIGHTS)
                #include "lightBufferDefinesPS"
            #endif

            // required lighting functionality
            #include "lightingPS"
        `);

        func.append(`

            // TBN
            #ifdef LIT_TBN
                #include "TBNPS"

                #ifdef LIT_TWO_SIDED_LIGHTING
                    #include "twoSidedLightingPS"
                #endif
            #endif

            #include "sphericalPS"
            #include "decodePS"
            #include "gammaPS"
            #include "tonemappingPS"
            #include "fogPS"

        `);

        // frontend
        func.append(this.frontendCode);

        if (this.needsNormal) {
            func.append(`
                #include "cubeMapRotatePS"
                #include "cubeMapProjectPS"
            `);

            func.append(options.skyboxIntensity ? chunks.envMultiplyPS : chunks.envConstPS);
        }

        if ((this.lighting && options.useSpecular) || this.reflections) {
            func.append(`
                #ifdef LIT_METALNESS
                    #include "metalnessModulatePS"
                #endif

                #if LIT_FRESNEL_MODEL == SCHLICK
                    #include "fresnelSchlickPS"
                #endif

                #ifdef LIT_IRIDESCENCE
                    #include "iridescenceDiffractionPS"
                #endif
            `);
        }

        if (options.useAo) {
            func.append(chunks.aoDiffuseOccPS);
            switch (options.occludeSpecular) {
                case SPECOCC_AO:
                    func.append(`
                        #ifdef LIT_OCCLUDE_SPECULAR_FLOAT
                            #include "aoSpecOccSimplePS"
                        #else
                            #include "aoSpecOccConstSimplePS"
                        #endif
                    `);
                    break;
                case SPECOCC_GLOSSDEPENDENT:
                    func.append(`
                        #ifdef LIT_OCCLUDE_SPECULAR_FLOAT
                            #include "aoSpecOccPS"
                        #else
                            #include "aoSpecOccConstPS"
                        #endif
                    `);
                    break;
                default:
                    break;
            }
        }

        if (options.reflectionSource === 'envAtlasHQ') {
            func.append(chunks.envAtlasPS);
            func.append(chunks.reflectionEnvHQPS
            .replace(/\$DECODE_CUBEMAP/g, ChunkUtils.decodeFunc(options.reflectionCubemapEncoding))
            .replace(/\$DECODE/g, ChunkUtils.decodeFunc(options.reflectionEncoding))
            );
        } else if (options.reflectionSource === 'envAtlas') {
            func.append(chunks.envAtlasPS);
            func.append(chunks.reflectionEnvPS.replace(/\$DECODE/g, ChunkUtils.decodeFunc(options.reflectionEncoding)));
        } else if (options.reflectionSource === 'cubeMap') {
            func.append(chunks.reflectionCubePS.replace(/\$DECODE/g, ChunkUtils.decodeFunc(options.reflectionEncoding)));
        } else if (options.reflectionSource === 'sphereMap') {
            func.append(chunks.reflectionSpherePS.replace(/\$DECODE/g, ChunkUtils.decodeFunc(options.reflectionEncoding)));
        }

        func.append(`
            #ifdef LIT_REFLECTIONS
                #ifdef LIT_CLEARCOAT
                    #include "reflectionCCPS"
                #endif

                #ifdef LIT_SHEEN
                    #include "reflectionSheenPS"
                #endif
            #endif
        `);

        if (options.useRefraction) {
            if (options.useDynamicRefraction) {
                func.append(chunks.refractionDynamicPS);
            } else if (this.reflections) {
                func.append(chunks.refractionCubePS);
            }
        }

        func.append(`
            #ifdef LIT_SHEEN
                #include "lightSheenPS"
            #endif

            #ifdef LIT_GGX_SPECULAR
                uniform float material_anisotropy;
            #endif
        `);

        if (this.lighting) {
            func.append(chunks.lightDiffuseLambertPS);
            if (hasAreaLights || options.clusteredLightingAreaLightsEnabled) {
                func.append(chunks.ltcPS);
            }
        }

        let useOldAmbient = false;
        if (options.useSpecular) {

            if (this.lighting) {
                func.append(`
                    #ifdef LIT_GGX_SPECULAR
                        #include "lightSpecularAnisoGGXPS"
                    #else
                        #include "lightSpecularBlinnPS"
                    #endif
                `);
            }

            if (!options.fresnelModel && !this.reflections && !options.diffuseMapEnabled) {
                decl.append('uniform vec3 material_ambient;');
                decl.append('#define LIT_OLD_AMBIENT');
                useOldAmbient = true;
            }
        }

        func.append(`

            #include "combinePS"

            #ifdef LIT_LIGHTMAP
                #include "lightmapAddPS"
            #endif
        `);

        const addAmbient = !options.lightMapEnabled || options.lightMapWithoutAmbient;

        if (addAmbient) {
            if (options.ambientSource === 'ambientSH') {
                func.append(chunks.ambientSHPS);
            } else if (options.ambientSource === 'envAtlas') {
                if (options.reflectionSource !== 'envAtlas' && options.reflectionSource !== 'envAtlasHQ') {
                    func.append(chunks.envAtlasPS);
                }
                func.append(chunks.ambientEnvPS.replace(/\$DECODE/g, ChunkUtils.decodeFunc(options.ambientEncoding)));
            } else {
                func.append(chunks.ambientConstantPS);
            }
        }

        if (!useOldAmbient) {
            decl.append('uniform vec3 material_ambient;');
        }

        if (options.useMsdf) {
            if (!options.msdfTextAttribute) {
                decl.append('#define UNIFORM_TEXT_PARAMETERS');
            }
            func.append(chunks.msdfPS);
        }

        func.append(`
            #ifdef LIT_NEEDS_NORMAL
                #include "viewDirPS"
                #ifdef LIT_SPECULAR
                    #ifdef LIT_GGX_SPECULAR
                        #include "reflDirAnisoPS"
                    #else
                        #include "reflDirPS"
                    #endif
                #endif
            #endif
        `);

        let hasPointLights = false;
        let usesLinearFalloff = false;
        let usesInvSquaredFalloff = false;
        let usesSpot = false;
        let usesCookie = false;
        let usesCookieNow;

        // clustered lighting
        if (options.clusteredLightingEnabled && this.lighting) {

            usesSpot = true;
            hasPointLights = true;
            usesLinearFalloff = true;
            usesCookie = true;
        }

        // TODO - move this section to lighting when possible, for now it has dependencies on the above code
        if (options.clusteredLightingEnabled && this.lighting) {

            if (options.clusteredLightingShadowsEnabled && !options.noShadow) {
                func.append(`
                    #include "clusteredLightShadowsPS"
                `);
            }

            func.append(`
                #include "floatUnpackingPS"
                #include "clusteredLightPS"
            `);
        }

        // FRAGMENT SHADER BODY

        code.append(`

            void main(void) {
                dReflection = vec4(0);

                #ifdef LIT_CLEARCOAT
                    ccSpecularLight = vec3(0);
                    ccReflection = vec3(0);
                #endif

                #if LIT_NONE_SLICE_MODE == SLICED
                    #include "startNineSlicedPS"
                #elif LIT_NONE_SLICE_MODE == TILED
                    #include "startNineSlicedTiledPS"
                #endif

                #ifdef LIT_NEEDS_NORMAL
                    dVertexNormalW = normalize(vNormalW);

                    #ifdef LIT_TANGENTS
                        #if defined(LIT_HEIGHTS) || defined(LIT_USE_NORMALS)
                            dTangentW = vTangentW;
                            dBinormalW = vBinormalW;
                        #endif
                    #endif

                    getViewDir();

                    #ifdef LIT_TBN
                        getTBN(dTangentW, dBinormalW, dVertexNormalW);

                        #ifdef LIT_TWO_SIDED_LIGHTING
                            handleTwoSidedLighting();
                        #endif
                    #endif
                #endif

                // invoke frontend functions
                evaluateFrontend();

                #include "debugProcessFrontendPS"

                evaluateBackend();
            }
        `);

        // apply SSAO
        if (options.ssao) {
            func.append(`
                    uniform sampler2D ssaoTexture;
                    uniform vec2 ssaoTextureSizeInv;
                `);
            backend.append('litArgs_ao *= texture2DLod(ssaoTexture, gl_FragCoord.xy * ssaoTextureSizeInv, 0.0).r;');
        }

        // transform tangent space normals to world space
        backend.append(`
            #ifdef LIT_NEEDS_NORMAL
                #ifdef LIT_SPECULAR
                    getReflDir(litArgs_worldNormal, dViewDirW, litArgs_gloss, dTBN);
                #endif

                #ifdef LIT_CLEARCOAT
                    ccReflDirW = normalize(-reflect(dViewDirW, litArgs_clearcoat_worldNormal));
                #endif
            #endif
        `);

        if ((this.lighting && options.useSpecular) || this.reflections) {
            backend.append(`
                #ifdef LIT_METALNESS
                    float f0 = 1.0 / litArgs_ior; f0 = (f0 - 1.0) / (f0 + 1.0); f0 *= f0;
                    litArgs_specularity = getSpecularModulate(litArgs_specularity, litArgs_albedo, litArgs_metalness, f0);
                    litArgs_albedo = getAlbedoModulate(litArgs_albedo, litArgs_metalness);
                #endif

                #ifdef LIT_IRIDESCENCE
                    vec3 iridescenceFresnel = getIridescence(saturate(dot(dViewDirW, litArgs_worldNormal)), litArgs_specularity, litArgs_iridescence_thickness);
                #endif
            `);
        }

        if (addAmbient) {
            backend.append(`
                addAmbient(litArgs_worldNormal);

                #ifdef LIT_SPECULAR
                    dDiffuseLight = dDiffuseLight * (1.0 - litArgs_specularity);
                #endif

                // move ambient color out of diffuse (used by Lightmapper, to multiply ambient color by accumulated AO)
                #ifdef LIT_SEPARATE_AMBIENT
                    vec3 dAmbientLight = dDiffuseLight;
                    dDiffuseLight = vec3(0);
                #endif
            `);
        }

        if (!useOldAmbient) {
            backend.append('    dDiffuseLight *= material_ambient;');
        }

        if (options.useAo && !options.occludeDirect) {
            backend.append('    occludeDiffuse(litArgs_ao);');
        }

        backend.append(`
            #ifdef LIT_LIGHTMAP
                addLightMap(
                    litArgs_lightmap, 
                    litArgs_lightmapDir, 
                    litArgs_worldNormal, 
                    dViewDirW, 
                    dReflDirW, 
                    litArgs_gloss, 
                    litArgs_specularity, 
                    dVertexNormalW,
                    dTBN
                #if defined(LIT_IRIDESCENCE)
                    , iridescenceFresnel,
                    litArgs_iridescence_intensity
                #endif
                );
            #endif
        `);

        if (this.lighting || this.reflections) {
            backend.append(`
                
                #ifdef LIT_REFLECTIONS

                    #ifdef LIT_CLEARCOAT
                        addReflectionCC(ccReflDirW, litArgs_clearcoat_gloss);
                    
                        #ifdef LIT_SPECULAR_FRESNEL
                            ccFresnel = getFresnelCC(dot(dViewDirW, litArgs_clearcoat_worldNormal));
                            ccReflection.rgb *= ccFresnel;
                        #else
                            ccFresnel = 0.0;
                        #endif
                    #endif

                    #ifdef LIT_SPECULARITY_FACTOR
                        ccReflection.rgb *= litArgs_specularityFactor;
                    #endif

                    #ifdef LIT_SHEEN
                        addReflectionSheen(litArgs_worldNormal, dViewDirW, litArgs_sheen_gloss);
                    #endif

                    // Fresnel has to be applied to reflections
                    addReflection(dReflDirW, litArgs_gloss);

                    #ifdef LIT_FRESNEL_MODEL

                        dReflection.rgb *= getFresnel(
                            dot(dViewDirW, litArgs_worldNormal), 
                            litArgs_gloss, 
                            litArgs_specularity
                        #if defined(LIT_IRIDESCENCE)
                            , iridescenceFresnel,
                            litArgs_iridescence_intensity
                        #endif
                            );

                    #else

                        dReflection.rgb *= litArgs_specularity;

                    #endif

                    #ifdef LIT_SPECULARITY_FACTOR
                        dReflection.rgb *= litArgs_specularityFactor;
                    #endif

                #endif

                #ifdef AREA_LIGHTS
                    // specular has to be accumulated differently if we want area lights to look correct
                    dSpecularLight *= litArgs_specularity;

                    #ifdef LIT_SPECULAR
                        // evaluate material based area lights data, shared by all area lights
                        calcLTCLightValues(litArgs_gloss, litArgs_worldNormal, dViewDirW, litArgs_specularity, litArgs_clearcoat_gloss, litArgs_clearcoat_worldNormal, litArgs_clearcoat_specularity);
                    #endif
                #endif
            `);

            for (let i = 0; i < options.lights.length; i++) {
                const light = options.lights[i];
                const lightType = light._type;

                // if clustered lights are used, skip normal lights other than directional
                if (options.clusteredLightingEnabled && lightType !== LIGHTTYPE_DIRECTIONAL) {
                    continue;
                }

                // The following code is not decoupled to separate shader files, because most of it can be actually changed to achieve different behaviors like:
                // - different falloffs
                // - different shadow coords (omni shadows will use drastically different genShadowCoord)
                // - different shadow filter modes
                // - different light source shapes

                // getLightDiffuse and getLightSpecular is BRDF itself.

                usesCookieNow = false;

                const lightShape = (hasAreaLights && light._shape) ? light.shape : LIGHTSHAPE_PUNCTUAL;
                const shapeString = (hasAreaLights && light._shape) ? this._getLightSourceShapeString(lightShape) : '';

                if (lightShape !== LIGHTSHAPE_PUNCTUAL) {
                    backend.append(`    calc${shapeString}LightValues(light${i}_position, light${i}_halfWidth, light${i}_halfHeight);`);
                }

                if (lightType === LIGHTTYPE_DIRECTIONAL) {
                    // directional
                    backend.append(`    dLightDirNormW = light${i}_direction;`);
                    backend.append('    dAtten = 1.0;');
                } else {

                    if (light._cookie) {
                        if (lightType === LIGHTTYPE_SPOT && !light._cookie._cubemap) {
                            usesCookie = true;
                            usesCookieNow = true;
                        } else if (lightType === LIGHTTYPE_OMNI && light._cookie._cubemap) {
                            usesCookie = true;
                            usesCookieNow = true;
                        }
                    }

                    backend.append(`    getLightDirPoint(light${i}_position);`);
                    hasPointLights = true;

                    if (usesCookieNow) {
                        if (lightType === LIGHTTYPE_SPOT) {
                            backend.append(`    dAtten3 = getCookie2D${light._cookieFalloff ? '' : 'Clip'}${light._cookieTransform ? 'Xform' : ''}(light${i}_cookie, light${i}_shadowMatrix, light${i}_cookieIntensity${light._cookieTransform ? `, light${i}_cookieMatrix, light${i}_cookieOffset` : ''}).${light._cookieChannel};`);
                        } else {
                            backend.append(`    dAtten3 = getCookieCube(light${i}_cookie, light${i}_shadowMatrix, light${i}_cookieIntensity).${light._cookieChannel};`);
                        }
                    }

                    if (lightShape === LIGHTSHAPE_PUNCTUAL) {
                        if (light._falloffMode === LIGHTFALLOFF_LINEAR) {
                            backend.append(`    dAtten = getFalloffLinear(light${i}_radius, dLightDirW);`);
                            usesLinearFalloff = true;
                        } else {
                            backend.append(`    dAtten = getFalloffInvSquared(light${i}_radius, dLightDirW);`);
                            usesInvSquaredFalloff = true;
                        }
                    } else {
                        // non punctual lights only gets the range window here
                        backend.append(`    dAtten = getFalloffWindow(light${i}_radius, dLightDirW);`);
                        usesInvSquaredFalloff = true;
                    }

                    backend.append('    if (dAtten > 0.00001) {'); // BRANCH START

                    if (lightType === LIGHTTYPE_SPOT) {
                        if (!(usesCookieNow && !light._cookieFalloff)) {
                            backend.append(`    dAtten *= getSpotEffect(light${i}_direction, light${i}_innerConeAngle, light${i}_outerConeAngle, dLightDirNormW);`);
                            usesSpot = true;
                        }
                    }
                }

                // diffuse lighting - LTC lights do not mix diffuse lighting into attenuation that affects specular
                if (lightShape !== LIGHTSHAPE_PUNCTUAL) {
                    if (lightType === LIGHTTYPE_DIRECTIONAL) {
                        // NB: A better aproximation perhaps using wrap lighting could be implemented here
                        backend.append('    dAttenD = getLightDiffuse(litArgs_worldNormal, dViewDirW, dLightDirW, dLightDirNormW);');
                    } else {
                        // 16.0 is a constant that is in getFalloffInvSquared()
                        backend.append(`    dAttenD = get${shapeString}LightDiffuse(litArgs_worldNormal, dViewDirW, dLightDirW, dLightDirNormW) * 16.0;`);
                    }
                } else {
                    backend.append('    dAtten *= getLightDiffuse(litArgs_worldNormal, dViewDirW, dLightDirW, dLightDirNormW);');
                }

                if (light.castShadows && !options.noShadow) {
                    const shadowInfo = shadowTypeInfo.get(light._shadowType);
                    Debug.assert(shadowInfo);

                    const pcssShadows = light._shadowType === SHADOW_PCSS_32F;
                    const vsmShadows = shadowInfo?.vsm;
                    const pcfShadows = shadowInfo?.pcf;
                    let shadowReadMode = null;
                    let evsmExp;
                    switch (light._shadowType) {
                        case SHADOW_VSM_16F:
                            shadowReadMode = 'VSM16';
                            evsmExp = '5.54';
                            break;
                        case SHADOW_VSM_32F:
                            shadowReadMode = 'VSM32';
                            evsmExp = '15.0';
                            break;
                        case SHADOW_PCF1_32F:
                        case SHADOW_PCF1_16F:
                            shadowReadMode = 'PCF1x1';
                            break;
                        case SHADOW_PCF5_32F:
                        case SHADOW_PCF5_16F:
                            shadowReadMode = 'PCF5x5';
                            break;
                        case SHADOW_PCSS_32F:
                            shadowReadMode = 'PCSS';
                            break;
                        case SHADOW_PCF3_32F:
                        case SHADOW_PCF3_16F:
                        default:
                            shadowReadMode = 'PCF3x3';
                            break;
                    }

                    if (shadowReadMode !== null) {
                        if (light._normalOffsetBias && !light._isVsm) {
                            func.append('#define SHADOW_SAMPLE_NORMAL_OFFSET');
                        }
                        if (lightType === LIGHTTYPE_DIRECTIONAL) {
                            func.append('#define SHADOW_SAMPLE_ORTHO');
                        }
                        if ((pcfShadows || pcssShadows) || device.isWebGPU) {
                            func.append('#define SHADOW_SAMPLE_SOURCE_ZBUFFER');
                        }
                        if (lightType === LIGHTTYPE_OMNI) {
                            func.append('#define SHADOW_SAMPLE_POINT');
                        }

                        // Create shadow coord sampler function for this light
                        const coordCode = chunks.shadowSampleCoordPS;
                        func.append(coordCode.replace('$LIGHT', i));

                        // Make sure to undefine the shadow sampler defines
                        func.append('#undef SHADOW_SAMPLE_NORMAL_OFFSET');
                        func.append('#undef SHADOW_SAMPLE_ORTHO');
                        func.append('#undef SHADOW_SAMPLE_SOURCE_ZBUFFER');
                        func.append('#undef SHADOW_SAMPLE_POINT');

                        let shadowMatrix = `light${i}_shadowMatrix`;
                        if (lightType === LIGHTTYPE_DIRECTIONAL && light.numCascades > 1) {
                            // select shadow cascade matrix
                            backend.append(`int cascadeIndex${i} = getShadowCascadeIndex(light${i}_shadowCascadeDistances, light${i}_shadowCascadeCount);`);

                            if (light.cascadeBlend > 0) {
                                backend.append(`cascadeIndex${i} = ditherShadowCascadeIndex(cascadeIndex${i}, light${i}_shadowCascadeDistances, light${i}_shadowCascadeCount, light${i}_shadowCascadeBlend);`);
                            }

                            backend.append(`mat4 cascadeShadowMat${i} = light${i}_shadowMatrixPalette[cascadeIndex${i}];`);
                            shadowMatrix = `cascadeShadowMat${i}`;
                        }

                        backend.append(`    dShadowCoord = getShadowSampleCoord${i}(${shadowMatrix}, light${i}_shadowParams, vPositionW, dLightPosW, dLightDirW, dLightDirNormW, dVertexNormalW);`);

                        // Fade shadow at edges
                        if (lightType === LIGHTTYPE_DIRECTIONAL) {
                            backend.append(`    fadeShadow(light${i}_shadowCascadeDistances);`);
                        }

                        let shadowCoordArgs = `SHADOWMAP_PASS(light${i}_shadowMap), dShadowCoord, light${i}_shadowParams`;

                        if (vsmShadows) {
                            // VSM
                            shadowCoordArgs = `${shadowCoordArgs}, ${evsmExp}, dLightDirW`;
                        } else if (pcssShadows) {
                            let penumbraSizeArg =  lightType === LIGHTTYPE_DIRECTIONAL ? `light${i}_softShadowParams` : `vec2(light${i}_shadowSearchArea)`;
                            if (lightShape !== LIGHTSHAPE_PUNCTUAL) {
                                penumbraSizeArg = `vec2(length(light${i}_halfWidth), length(light${i}_halfHeight)) * light${i}_shadowSearchArea`;
                            }
                            shadowCoordArgs = `${shadowCoordArgs}, light${i}_cameraParams, ${penumbraSizeArg}, dLightDirW`;
                        }

                        if (lightType === LIGHTTYPE_OMNI) {
                            shadowReadMode = `Point${shadowReadMode}`;
                            if (!pcssShadows) {
                                shadowCoordArgs = `${shadowCoordArgs}, dLightDirW`;
                            }
                        } else if (lightType === LIGHTTYPE_SPOT) {
                            shadowReadMode = `Spot${shadowReadMode}`;
                        }

                        backend.append(`    float shadow${i} = getShadow${shadowReadMode}(${shadowCoordArgs});`);
                        backend.append(`    dAtten *= mix(1.0, shadow${i}, light${i}_shadowIntensity);`);
                    }
                }

                if (lightShape !== LIGHTSHAPE_PUNCTUAL) {

                    backend.append(`

                        // area light - they do not mix diffuse lighting into specular attenuation
                        #ifdef LIT_SPECULAR
                            dDiffuseLight += ((dAttenD * dAtten) * light${i}_color${usesCookieNow ? ' * dAtten3' : ''}) * (1.0 - dLTCSpecFres);
                        #else
                            dDiffuseLight += (dAttenD * dAtten) * light${i}_color${usesCookieNow ? ' * dAtten3' : ''};
                        #endif                        
                    `);

                } else {

                    backend.append(`

                        // punctual light
                        #if defined(AREA_LIGHTS) && defined(LIT_SPECULAR)
                            dDiffuseLight += (dAtten * light${i}_color${usesCookieNow ? ' * dAtten3' : ''}) * (1.0 - litArgs_specularity);
                        #else
                            dDiffuseLight += dAtten * light${i}_color${usesCookieNow ? ' * dAtten3' : ''};
                        #endif
                    `);
                }

                backend.append(`
                    #ifdef LIT_SPECULAR
                        dHalfDirW = normalize(-dLightDirNormW + dViewDirW);
                    #endif
                `);

                // specular / clear coat
                if (light.affectSpecularity) {
                    if (lightShape !== LIGHTSHAPE_PUNCTUAL) {

                        // area light
                        if (options.useClearCoat) {
                            backend.append(`    ccSpecularLight += ccLTCSpecFres * get${shapeString}LightSpecular(litArgs_clearcoat_worldNormal, dViewDirW) * dAtten * light${i}_color${usesCookieNow ? ' * dAtten3' : ''};`);
                        }
                        if (options.useSpecular) {
                            backend.append(`    dSpecularLight += dLTCSpecFres * get${shapeString}LightSpecular(litArgs_worldNormal, dViewDirW) * dAtten * light${i}_color${usesCookieNow ? ' * dAtten3' : ''};`);
                        }

                    } else {
                        let calcFresnel = false;
                        if (lightType === LIGHTTYPE_DIRECTIONAL && options.fresnelModel > 0) {
                            calcFresnel = true;
                        }

                        // if LTC lights are present, specular must be accumulated with specularity (specularity is pre multiplied by punctual light fresnel)
                        if (options.useClearCoat) {
                            backend.append(`    ccSpecularLight += getLightSpecular(dHalfDirW, ccReflDirW, litArgs_clearcoat_worldNormal, dViewDirW, dLightDirNormW, litArgs_clearcoat_gloss, dTBN) * dAtten * light${i}_color${
                                usesCookieNow ? ' * dAtten3' : ''
                            }${calcFresnel ? ' * getFresnelCC(dot(dViewDirW, dHalfDirW));' : ';'}`);
                        }
                        if (options.useSheen) {
                            backend.append(`    sSpecularLight += getLightSpecularSheen(dHalfDirW, litArgs_worldNormal, dViewDirW, dLightDirNormW, litArgs_sheen_gloss) * dAtten * light${i}_color${
                                usesCookieNow ? ' * dAtten3;' : ';'}`);
                        }
                        if (options.useSpecular) {
                            backend.append(`    dSpecularLight += getLightSpecular(dHalfDirW, dReflDirW, litArgs_worldNormal, dViewDirW, dLightDirNormW, litArgs_gloss, dTBN) * dAtten * light${i}_color${
                                usesCookieNow ? ' * dAtten3' : ''
                            }${calcFresnel ? ` 
                                    * getFresnel(
                                        dot(dViewDirW, dHalfDirW), 
                                        litArgs_gloss, 
                                        litArgs_specularity
                                    #if defined(LIT_IRIDESCENCE)
                                        , iridescenceFresnel, 
                                        litArgs_iridescence_intensity
                                    #endif
                                    );` : '* litArgs_specularity;'}`);
                        }
                    }
                }

                if (lightType !== LIGHTTYPE_DIRECTIONAL) {
                    backend.append('    }'); // BRANCH END
                }
            }

            // clustered lighting
            if (options.clusteredLightingEnabled && this.lighting) {
                usesLinearFalloff = true;
                usesInvSquaredFalloff = true;
                hasPointLights = true;
                backend.append(`    addClusteredLights(
                                        litArgs_worldNormal, 
                                        dViewDirW, 
                                        dReflDirW,
                                #if defined(LIT_CLEARCOAT)
                                        ccReflDirW,
                                #endif
                                        litArgs_gloss, 
                                        litArgs_specularity, 
                                        dVertexNormalW, 
                                        dTBN, 
                                #if defined(LIT_IRIDESCENCE)
                                        iridescenceFresnel,
                                #endif
                                        litArgs_clearcoat_worldNormal, 
                                        litArgs_clearcoat_gloss,
                                        litArgs_sheen_gloss,
                                        litArgs_iridescence_intensity
                                    );`);
            }

            backend.append(`

                #ifdef AREA_LIGHTS

                    #ifdef LIT_CLEARCOAT
                        // specular has to be accumulated differently if we want area lights to look correct
                        litArgs_clearcoat_specularity = 1.0;
                    #endif

                    #ifdef LIT_SPECULAR
                        litArgs_specularity = vec3(1);
                    #endif

                #endif

                #ifdef LIT_REFRACTION
                    addRefraction(
                        litArgs_worldNormal, 
                        dViewDirW, 
                        litArgs_thickness, 
                        litArgs_gloss, 
                        litArgs_specularity, 
                        litArgs_albedo, 
                        litArgs_transmission,
                        litArgs_ior,
                        litArgs_dispersion
                        #if defined(LIT_IRIDESCENCE)
                            , iridescenceFresnel, 
                            litArgs_iridescence_intensity
                        #endif
                    );
                #endif
            `);
        }

        if (options.useAo) {
            if (options.occludeDirect) {
                backend.append('    occludeDiffuse(litArgs_ao);');
            }
            if (options.occludeSpecular === SPECOCC_AO || options.occludeSpecular === SPECOCC_GLOSSDEPENDENT) {
                backend.append('    occludeSpecular(litArgs_gloss, litArgs_ao, litArgs_worldNormal, dViewDirW);');
            }
        }

        backend.append(`
            #ifdef LIT_SPECULARITY_FACTOR
                dSpecularLight *= litArgs_specularityFactor;
            #endif

            #if !defined(LIT_OPACITY_FADES_SPECULAR)

                #if LIT_BLEND_TYPE == NORMAL || LIT_BLEND_TYPE == PREMULTIPLIED

                    float specLum = dot((dSpecularLight + dReflection.rgb * dReflection.a), vec3( 0.2126, 0.7152, 0.0722 ));
                    #ifdef LIT_CLEARCOAT
                        specLum += dot(ccSpecularLight * litArgs_clearcoat_specularity + ccReflection.rgb * litArgs_clearcoat_specularity, vec3( 0.2126, 0.7152, 0.0722 ));
                    #endif
                    litArgs_opacity = clamp(litArgs_opacity + gammaCorrectInput(specLum), 0.0, 1.0);

                #endif

                litArgs_opacity *= material_alphaFade;

            #endif

            #include "endPS"
            #include "outputAlphaPS"
        `);

        if (options.useMsdf) {
            backend.append('    gl_FragColor = applyMsdf(gl_FragColor);');
        }

        // TODO: moving this to include bellow makes MRT example to break, as we no longer find pc_fragColor1
        // in code during preprocessing with stripUnusedColorAttachments. We need some other soltuion for it,
        // perhaps do this preprocessing after the incldues are inlined?
        backend.append(chunks.outputPS);

        backend.append(`
            // #include "outputPS"
            #include "debugOutputPS"
        `);

        if (hasPointLights) {
            func.prepend(chunks.lightDirPointPS);
        }
        if (usesLinearFalloff) {
            func.prepend(chunks.falloffLinearPS);
        }
        if (usesInvSquaredFalloff) {
            func.prepend(chunks.falloffInvSquaredPS);
        }
        if (usesSpot) {
            func.prepend(chunks.spotPS);
        }
        if (usesCookie && !options.clusteredLightingEnabled) {
            // non-clustered lights cookie code
            func.prepend(chunks.cookiePS);
        }

        func.append(`
            void evaluateBackend() {
                ${backend.code}
            }
        `);

        const result = this._fsGetBeginCode() +
            this.varyingsCode +
            this._fsGetBaseCode() +
            this.frontendDecl +
            decl.code +
            func.code +
            code.code;

        return result;
    }

    /**
     * Generates a fragment shader.
     *
     * @param {string} frontendDecl - Frontend declarations like `float dAlpha;`
     * @param {string} frontendCode - Frontend code containing `getOpacity()` etc.
     * @param {string} lightingUv - E.g. `vUv0`
     */
    generateFragmentShader(frontendDecl, frontendCode, lightingUv) {
        const options = this.options;

        this.frontendDecl = frontendDecl;
        this.frontendCode = frontendCode;
        this.lightingUv = lightingUv;

        if (options.pass === SHADER_PICK || options.pass === SHADER_DEPTH || options.pass === SHADER_PREPASS) {

            this.fshader = `

                ${this.device.textureFloatRenderable ? '#define TEXTURE_FLOAT_RENDERABLE' : ''}

                ${this._fsGetBeginCode()}
                ${this.varyingsCode}
                ${this.frontendDecl}
                ${this.frontendCode}

                #ifdef PICK_PASS
                    #include "pickPS"
                #endif

                #ifdef PREPASS_PASS
                    #include "floatAsUintPS"
                #endif

                void main(void) {
                    evaluateFrontend();

                    #ifdef PICK_PASS
                        gl_FragColor = getPickOutput();
                    #endif

                    #ifdef DEPTH_PASS
                        gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
                    #endif

                    #ifdef PREPASS_PASS
                        #if defined(TEXTURE_FLOAT_RENDERABLE)
                            gl_FragColor = vec4(vLinearDepth, 1.0, 1.0, 1.0);
                        #else
                            gl_FragColor = float2uint(vLinearDepth);
                        #endif
                    #endif
                }
            `;
        } else if (this.shadowPass) {
            this.fshader = this._fsGetShadowPassCode();
        } else if (options.customFragmentShader) {
            this.fshader = this._fsGetBeginCode() + options.customFragmentShader;
        } else {
            this.fshader = this._fsGetLitPassCode();
        }

        Debug.assert(!this.fshader.includes('litShaderArgs'), 'Automatic compatibility with shaders using litShaderArgs has been removed. Please update the shader to use the new system.');
    }
}

export { LitShader };
