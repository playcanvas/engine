// Fragment shader template for GSplatProcessor - processes splat data from src to dst streams
export default /* wgsl */`

// Texture size and splat count uniforms
uniform splatTextureSize: u32;
uniform dstTextureSize: u32;
uniform srcNumSplats: u32;
uniform dstNumSplats: u32;

// Shared splat identification (index, uv) and setSplat() helper
#include "gsplatSplatVS"

// Input stream declarations (generated by GSplatFormat.getInputDeclarations)
#include "gsplatProcessInputVS"

// Module-scope output for write functions to access
var<private> processOutput: FragmentOutput;

// Output write functions (generated by GSplatFormat.getOutputDeclarations)
#include "gsplatProcessOutputVS"

// Format-specific read code (included when "default" stream is used)
#include "gsplatProcessReadVS"

// User's process code - defines process() function and any declarations
#include "gsplatProcessChunk"

@fragment
fn fragmentMain(input: FragmentInput) -> FragmentOutput {
    // Fragment coordinates give us the destination splat index
    let fragCoords = vec2i(input.position.xy);
    
    // Linear index of the destination splat
    let splatIndex = u32(fragCoords.y * i32(uniform.dstTextureSize) + fragCoords.x);
    
    // Skip padding pixels (texture may be larger than actual splat count)
    if (splatIndex >= uniform.dstNumSplats) {
        discard;
    }
    
    // Initialize global splat for sampling
    // Note: splat.uv assumes 1:1 mapping using splatTextureSize. When sizes differ,
    // call setSplat() with a different index in user code.
    setSplat(splatIndex);
    
    // Call user's process function
    process();
    
    return processOutput;
}
`;
