// Fragment shader template for GSplatProcessor - processes splat data from src to dst streams
export default /* wgsl */`

// SplatSource struct for reading splat data
struct SplatSource {
    id: u32,            // splat id
    uv: vec2i           // splat uv for texture sampling
}

// splatUV is set before calling load functions
var<private> splatUV: vec2i;

// Texture size uniform
uniform splatTextureSize: u32;

// User uniform declarations
#include "gsplatProcessDeclarationsVS"

// Input stream declarations (generated by GSplatFormat.getInputDeclarations)
#include "gsplatProcessInputVS"

// Module-scope output for write functions to access
var<private> processOutput: FragmentOutput;

// Output write functions (generated by GSplatFormat.getOutputDeclarations)
#include "gsplatProcessOutputVS"

// Format-specific read code (included when "default" stream is used)
#include "gsplatProcessReadVS"

@fragment
fn fragmentMain(input: FragmentInput) -> FragmentOutput {
    // Fragment coordinates give us the splat index
    let fragCoords = vec2i(input.position.xy);
    
    // Linear index of the splat
    let splatIndex = fragCoords.y * i32(uniform.splatTextureSize) + fragCoords.x;
    
    // Create SplatSource for sampling (uv matches fragCoords since textures use same size)
    var source: SplatSource;
    source.id = u32(splatIndex);
    source.uv = fragCoords;
    
    // Set splatUV for load functions
    splatUV = source.uv;
    
    // User's processing code
    #include "gsplatProcessChunk"
    
    return processOutput;
}
`;
