// fragment shader to copy splats in any supported format to MRT work-buffer
export default /* wgsl */`

#define GSPLAT_CENTER_NOPROJ

#include "gsplatHelpersVS"
#include "gsplatFormatVS"
#include "gsplatStructsVS"
#include "gsplatDeclarationsVS"
#include "gsplatCenterVS"
#include "gsplatEvalSHVS"
#include "gsplatQuatToMat3VS"
#include "gsplatReadVS"

// Module-scope output for write functions to access
var<private> processOutput: FragmentOutput;

// Work buffer output write functions (generated by GSplatFormat.getOutputDeclarations)
#include "gsplatWorkBufferOutputVS"

#include "gsplatModifyVS"

uniform uStartLine: i32;      // Start row in destination texture
uniform uViewportWidth: i32;  // Width of the destination viewport in pixels

#ifdef GSPLAT_LOD
    // Packed sub-draw params: (sourceBase, colStart, rowWidth, rowStart)
    varying @interpolate(flat) vSubDraw: vec4i;
#endif

uniform uColorMultiply: vec3f;

// number of splats
uniform uActiveSplats: i32;

// pre-computed model matrix decomposition
uniform model_scale: vec3f;
uniform model_rotation: vec4f;  // (x,y,z,w) format

#ifdef GSPLAT_ID
    uniform uId: u32;
#endif

#ifdef GSPLAT_NODE_INDEX
    uniform uBoundsBaseIndex: u32;
    #ifdef HAS_NODE_MAPPING
        var nodeMappingTexture: texture_2d<u32>;
        var nodeToLocalBoundsTexture: texture_2d<u32>;
        uniform nodeToLocalBoundsWidth: i32;
    #endif
#endif

@fragment
fn fragmentMain(input: FragmentInput) -> FragmentOutput {
    // local fragment coordinates (within the viewport)
    let localFragCoords = vec2i(i32(input.position.x), i32(input.position.y) - uniform.uStartLine);

    // linear index of the splat
    let targetIndex = localFragCoords.y * uniform.uViewportWidth + localFragCoords.x;
    
    if (targetIndex >= uniform.uActiveSplats) {

        // Out of bounds: write zeros using generated write functions
        writeDataColor(vec4f(0.0));
        #ifndef GSPLAT_COLOR_ONLY
            writeDataTransformA(vec4u(0u));
            writeDataTransformB(vec4u(0u));
        #endif

    } else {

        #ifdef GSPLAT_LOD
            // Compute source index from packed sub-draw varying: (sourceBase, colStart, rowWidth, rowStart)
            let localRow = i32(input.position.y) - uniform.uStartLine - input.vSubDraw.w;
            let localCol = i32(input.position.x) - input.vSubDraw.y;
            let originalIndex = u32(input.vSubDraw.x + localRow * input.vSubDraw.z + localCol);
        #else
            let originalIndex = targetIndex;
        #endif
        
        // Initialize global splat for format read functions
        setSplat(u32(originalIndex));

        // read center in local space
        var modelCenter = getCenter();

        // compute world-space center for storage
        var worldCenter = (uniform.matrix_model * vec4f(modelCenter, 1.0)).xyz;
        var center: SplatCenter;
        initCenter(modelCenter, &center);

        // Get source rotation and scale
        // getRotation() returns (w,x,y,z) format, convert to (x,y,z,w) for quatMul
        let srcRotation = getRotation().yzwx;
        let srcScale = getScale();

        // Combine: world = model * source (both in x,y,z,w format)
        var worldRotation = quatMul(uniform.model_rotation, srcRotation);
        // Ensure w is positive so sqrt() reconstruction works correctly
        // (quaternions q and -q represent the same rotation)
        if (worldRotation.w < 0.0) {
            worldRotation = -worldRotation;
        }
        var worldScale = uniform.model_scale * srcScale;

        // Apply custom center modification
        let originalCenter = worldCenter;
        modifySplatCenter(&worldCenter);

        // Apply custom rotation/scale modification
        modifySplatRotationScale(originalCenter, worldCenter, &worldRotation, &worldScale);

        // read color
        var color = getColor();

        // evaluate spherical harmonics
        #if SH_BANDS > 0
            // calculate the model-space view direction
            let dir = normalize(center.view * mat3x3f(center.modelView[0].xyz, center.modelView[1].xyz, center.modelView[2].xyz));

            // read sh coefficients
            var sh: array<half3, SH_COEFFS>;
            var scale: f32;
            readSHData(&sh, &scale);

            // evaluate
            color = vec4f(color.xyz + vec3f(evalSH(&sh, dir) * half(scale)), color.w);
        #endif

        // Apply custom color modification
        modifySplatColor(worldCenter, &color);

        color = vec4f(color.xyz * uniform.uColorMultiply, color.w);

        // write out results using generated write functions
        writeDataColor(color);
        #ifndef GSPLAT_COLOR_ONLY
            // Store rotation (xyz, w derived) and scale as 6 half-floats
            writeDataTransformA(vec4u(bitcast<u32>(worldCenter.x), bitcast<u32>(worldCenter.y), bitcast<u32>(worldCenter.z), pack2x16float(worldRotation.xy)));
            writeDataTransformB(vec4u(pack2x16float(vec2f(worldRotation.z, worldScale.x)), pack2x16float(worldScale.yz), 0u, 0u));
        #endif

        #ifdef GSPLAT_ID
            writePcId(vec4u(uniform.uId, 0u, 0u, 0u));
        #endif

        #ifdef GSPLAT_NODE_INDEX
            #ifdef HAS_NODE_MAPPING
                // Octree resource: look up node index from source splat, then local bounds index
                let srcTextureWidth = i32(textureDimensions(nodeMappingTexture, 0).x);
                let sourceCoord = vec2i(i32(originalIndex) % srcTextureWidth, i32(originalIndex) / srcTextureWidth);
                let nodeIndex = textureLoad(nodeMappingTexture, sourceCoord, 0).r;
                let ntlCoord = vec2i(i32(nodeIndex) % uniform.nodeToLocalBoundsWidth, i32(nodeIndex) / uniform.nodeToLocalBoundsWidth);
                let localBoundsIdx = textureLoad(nodeToLocalBoundsTexture, ntlCoord, 0).r;
                writePcNodeIndex(vec4u(uniform.uBoundsBaseIndex + localBoundsIdx, 0u, 0u, 0u));
            #else
                // Non-octree resource: single bounds entry
                writePcNodeIndex(vec4u(uniform.uBoundsBaseIndex, 0u, 0u, 0u));
            #endif
        #endif
    }
    
    return processOutput;
}
`;
