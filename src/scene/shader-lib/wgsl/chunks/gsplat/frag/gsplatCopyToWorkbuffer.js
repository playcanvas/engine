// fragment shader to copy splats in any supported format to MRT work-buffer
export default /* wgsl */`

#define GSPLAT_CENTER_NOPROJ

#include "gsplatHelpersVS"
#include "gsplatFormatVS"
#include "gsplatStructsVS"
#include "gsplatDeclarationsVS"
#include "gsplatCenterVS"
#include "gsplatEvalSHVS"
#include "gsplatQuatToMat3VS"
#include "gsplatReadVS"

// Module-scope output for write functions to access
var<private> processOutput: FragmentOutput;

// Work buffer output write functions (generated by GSplatFormat.getOutputDeclarations)
#include "gsplatWorkBufferOutputVS"

#include "gsplatWriteVS"
#include "gsplatModifyVS"

// Packed sub-draw params: (sourceBase, colStart, rowWidth, rowStart)
varying @interpolate(flat) vSubDraw: vec4i;

uniform uColorMultiply: vec3f;

// pre-computed model matrix decomposition
uniform model_scale: vec3f;
uniform model_rotation: vec4f;  // (x,y,z,w) format

#ifdef GSPLAT_ID
    uniform uId: u32;
#endif

#ifdef GSPLAT_NODE_INDEX
    uniform uBoundsBaseIndex: u32;
    #ifdef HAS_NODE_MAPPING
        var nodeMappingTexture: texture_2d<u32>;
        var nodeToLocalBoundsTexture: texture_2d<u32>;
        uniform nodeToLocalBoundsWidth: i32;
    #endif
#endif

@fragment
fn fragmentMain(input: FragmentInput) -> FragmentOutput {
    // Compute source index from packed sub-draw varying: (sourceBase, colStart, rowWidth, rowStart)
    let localRow = i32(input.position.y) - input.vSubDraw.w;
    let localCol = i32(input.position.x) - input.vSubDraw.y;
    let originalIndex = u32(input.vSubDraw.x + localRow * input.vSubDraw.z + localCol);

    // Initialize global splat for format read functions
    setSplat(originalIndex);

    // read center in local space
    var modelCenter = getCenter();

    // compute world-space center for storage
    var worldCenter = (uniform.matrix_model * vec4f(modelCenter, 1.0)).xyz;
    var center: SplatCenter;
    initCenter(modelCenter, &center);

    // Get source rotation and scale
    // getRotation() returns (w,x,y,z) format, convert to (x,y,z,w) for quatMul
    let srcRotation = getRotation().yzwx;
    let srcScale = getScale();

    // Combine: world = model * source (both in x,y,z,w format)
    var worldRotation = vec4f(quatMul(half4(uniform.model_rotation), half4(srcRotation)));
    // Ensure w is positive so sqrt() reconstruction works correctly
    // (quaternions q and -q represent the same rotation)
    if (worldRotation.w < 0.0) {
        worldRotation = -worldRotation;
    }
    var worldScale = uniform.model_scale * srcScale;

    // Apply custom center modification
    let originalCenter = worldCenter;
    modifySplatCenter(&worldCenter);

    // Apply custom rotation/scale modification
    modifySplatRotationScale(originalCenter, worldCenter, &worldRotation, &worldScale);

    // read color
    var color = getColor();

    // evaluate spherical harmonics
    #if SH_BANDS > 0
        // calculate the model-space view direction
        let dir = normalize(center.view * mat3x3f(center.modelView[0].xyz, center.modelView[1].xyz, center.modelView[2].xyz));

        // read sh coefficients
        var sh: array<half3, SH_COEFFS>;
        var scale: f32;
        readSHData(&sh, &scale);

        // evaluate
        color = vec4f(color.xyz + vec3f(evalSH(&sh, dir) * half(scale)), color.w);
    #endif

    // Apply custom color modification
    modifySplatColor(worldCenter, &color);

    color = vec4f(color.xyz * uniform.uColorMultiply, color.w);

    // write color + transform using format-specific encoding
    writeSplat(worldCenter, worldRotation, worldScale, color);

    #ifdef GSPLAT_ID
        writePcId(vec4u(uniform.uId, 0u, 0u, 0u));
    #endif

    #ifdef GSPLAT_NODE_INDEX
        #ifdef HAS_NODE_MAPPING
            // Octree resource: look up node index from source splat, then local bounds index
            let srcTextureWidth = i32(textureDimensions(nodeMappingTexture, 0).x);
            let sourceCoord = vec2i(i32(originalIndex) % srcTextureWidth, i32(originalIndex) / srcTextureWidth);
            let nodeIndex = textureLoad(nodeMappingTexture, sourceCoord, 0).r;
            let ntlCoord = vec2i(i32(nodeIndex) % uniform.nodeToLocalBoundsWidth, i32(nodeIndex) / uniform.nodeToLocalBoundsWidth);
            let localBoundsIdx = textureLoad(nodeToLocalBoundsTexture, ntlCoord, 0).r;
            writePcNodeIndex(vec4u(uniform.uBoundsBaseIndex + localBoundsIdx, 0u, 0u, 0u));
        #else
            // Non-octree resource: single bounds entry
            writePcNodeIndex(vec4u(uniform.uBoundsBaseIndex, 0u, 0u, 0u));
        #endif
    #endif

    return processOutput;
}
`;
