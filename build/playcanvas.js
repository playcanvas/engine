/**
 * @license
 * PlayCanvas Engine v1.34.0-dev revision 2680e004
 * Copyright 2011-2020 PlayCanvas Ltd. All rights reserved.
 */
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = global || self, factory(global.pc = {}));
}(this, (function (exports) { 'use strict';

	if (!Array.prototype.find) {
		Object.defineProperty(Array.prototype, 'find', {
			value: function(predicate) {
				if (this == null) {
					throw TypeError('"this" is null or not defined');
				}
				var o = Object(this);
				var len = o.length >>> 0;
				if (typeof predicate !== 'function') {
					throw TypeError('predicate must be a function');
				}
				var thisArg = arguments[1];
				var k = 0;
				while (k < len) {
					var kValue = o[k];
					if (predicate.call(thisArg, kValue, k, o)) {
						return kValue;
					}
					k++;
				}
				return undefined;
			},
			configurable: true,
			writable: true
		});
	}

	Math.log2 = Math.log2 || function(x) {
		return Math.log(x) * Math.LOG2E;
	};

	if (!Math.sign) {
		Math.sign = function(x) {
			return ((x > 0) - (x < 0)) || +x;
		};
	}

	if (typeof Object.assign != 'function') {
		Object.defineProperty(Object, "assign", {
			value: function assign(target, varArgs) {
				if (target == null) {
					throw new TypeError('Cannot convert undefined or null to object');
				}
				var to = Object(target);
				for (var index = 1; index < arguments.length; index++) {
					var nextSource = arguments[index];
					if (nextSource != null) {
						for (var nextKey in nextSource) {
							if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
								to[nextKey] = nextSource[nextKey];
							}
						}
					}
				}
				return to;
			},
			writable: true,
			configurable: true
		});
	}

	(function () {
		if (typeof navigator === 'undefined' || typeof document === 'undefined') {
			return;
		}
		navigator.pointer = navigator.pointer || navigator.webkitPointer || navigator.mozPointer;
		var pointerlockchange = function () {
			var e = document.createEvent('CustomEvent');
			e.initCustomEvent('pointerlockchange', true, false, null);
			document.dispatchEvent(e);
		};
		var pointerlockerror = function () {
			var e = document.createEvent('CustomEvent');
			e.initCustomEvent('pointerlockerror', true, false, null);
			document.dispatchEvent(e);
		};
		document.addEventListener('webkitpointerlockchange', pointerlockchange, false);
		document.addEventListener('webkitpointerlocklost', pointerlockchange, false);
		document.addEventListener('mozpointerlockchange', pointerlockchange, false);
		document.addEventListener('mozpointerlocklost', pointerlockchange, false);
		document.addEventListener('webkitpointerlockerror', pointerlockerror, false);
		document.addEventListener('mozpointerlockerror', pointerlockerror, false);
		if (Element.prototype.mozRequestPointerLock) {
			Element.prototype.requestPointerLock = function () {
				this.mozRequestPointerLock();
			};
		} else {
			Element.prototype.requestPointerLock = Element.prototype.requestPointerLock || Element.prototype.webkitRequestPointerLock || Element.prototype.mozRequestPointerLock;
		}
		if (!Element.prototype.requestPointerLock && navigator.pointer) {
			Element.prototype.requestPointerLock = function () {
				var el = this;
				document.pointerLockElement = el;
				navigator.pointer.lock(el, pointerlockchange, pointerlockerror);
			};
		}
		document.exitPointerLock = document.exitPointerLock || document.webkitExitPointerLock || document.mozExitPointerLock;
		if (!document.exitPointerLock) {
			document.exitPointerLock = function () {
				if (navigator.pointer) {
					document.pointerLockElement = null;
					navigator.pointer.unlock();
				}
			};
		}
	})();

	(function() {
		if (typeof window === 'undefined') return;
		var lastTime = 0;
		var vendors = ['ms', 'moz', 'webkit', 'o'];
		for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
			window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];
			window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame']
									   || window[vendors[x]+'CancelRequestAnimationFrame'];
		}
		if (!window.requestAnimationFrame)
			window.requestAnimationFrame = function(callback, element) {
				var currTime = new Date().getTime();
				var timeToCall = Math.max(0, 16 - (currTime - lastTime));
				var id = window.setTimeout(function() { callback(currTime + timeToCall); },
				  timeToCall);
				lastTime = currTime + timeToCall;
				return id;
			};
		if (!window.cancelAnimationFrame)
			window.cancelAnimationFrame = function(id) {
				clearTimeout(id);
			};
	}());

	if (!String.prototype.endsWith) {
		String.prototype.endsWith = function(search, this_len) {
			if (this_len === undefined || this_len > this.length) {
				this_len = this.length;
			}
			return this.substring(this_len - search.length, this_len) === search;
		};
	}
	if (!String.prototype.includes) {
		String.prototype.includes = function(search, start) {
			if (typeof start !== 'number') {
				start = 0;
			}
			if (start + search.length > this.length) {
				return false;
			} else {
				return this.indexOf(search, start) !== -1;
			}
		};
	}
	if (!String.prototype.startsWith) {
		String.prototype.startsWith = function(search, pos) {
			return this.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
		};
	}

	(function() {
	var glErrorShadow = { };
	function error(msg) {
		if (window.console && window.console.error) {
			window.console.error(msg);
		}
	}
	function log(msg) {
		if (window.console && window.console.log) {
			window.console.log(msg);
		}
	}
	function synthesizeGLError(err, opt_msg) {
		glErrorShadow[err] = true;
		if (opt_msg !== undefined) {
			error(opt_msg);
		}
	}
	function wrapGLError(gl) {
		var f = gl.getError;
		gl.getError = function() {
			var err;
			do {
				err = f.apply(gl);
				if (err != gl.NO_ERROR) {
					glErrorShadow[err] = true;
				}
			} while (err != gl.NO_ERROR);
			for (var err in glErrorShadow) {
				if (glErrorShadow[err]) {
					delete glErrorShadow[err];
					return parseInt(err);
				}
			}
			return gl.NO_ERROR;
		};
	}
	var WebGLVertexArrayObjectOES = function WebGLVertexArrayObjectOES(ext) {
		var gl = ext.gl;
		this.ext = ext;
		this.isAlive = true;
		this.hasBeenBound = false;
		this.elementArrayBuffer = null;
		this.attribs = new Array(ext.maxVertexAttribs);
		for (var n = 0; n < this.attribs.length; n++) {
			var attrib = new WebGLVertexArrayObjectOES.VertexAttrib(gl);
			this.attribs[n] = attrib;
		}
		this.maxAttrib = 0;
	};
	WebGLVertexArrayObjectOES.VertexAttrib = function VertexAttrib(gl) {
		this.enabled = false;
		this.buffer = null;
		this.size = 4;
		this.type = gl.FLOAT;
		this.normalized = false;
		this.stride = 16;
		this.offset = 0;
		this.cached = "";
		this.recache();
	};
	WebGLVertexArrayObjectOES.VertexAttrib.prototype.recache = function recache() {
		this.cached = [this.size, this.type, this.normalized, this.stride, this.offset].join(":");
	};
	var OESVertexArrayObject = function OESVertexArrayObject(gl) {
		var self = this;
		this.gl = gl;
		wrapGLError(gl);
		var original = this.original = {
			getParameter: gl.getParameter,
			enableVertexAttribArray: gl.enableVertexAttribArray,
			disableVertexAttribArray: gl.disableVertexAttribArray,
			bindBuffer: gl.bindBuffer,
			getVertexAttrib: gl.getVertexAttrib,
			vertexAttribPointer: gl.vertexAttribPointer
		};
		gl.getParameter = function getParameter(pname) {
			if (pname == self.VERTEX_ARRAY_BINDING_OES) {
				if (self.currentVertexArrayObject == self.defaultVertexArrayObject) {
					return null;
				} else {
					return self.currentVertexArrayObject;
				}
			}
			return original.getParameter.apply(this, arguments);
		};
		gl.enableVertexAttribArray = function enableVertexAttribArray(index) {
			var vao = self.currentVertexArrayObject;
			vao.maxAttrib = Math.max(vao.maxAttrib, index);
			var attrib = vao.attribs[index];
			attrib.enabled = true;
			return original.enableVertexAttribArray.apply(this, arguments);
		};
		gl.disableVertexAttribArray = function disableVertexAttribArray(index) {
			var vao = self.currentVertexArrayObject;
			vao.maxAttrib = Math.max(vao.maxAttrib, index);
			var attrib = vao.attribs[index];
			attrib.enabled = false;
			return original.disableVertexAttribArray.apply(this, arguments);
		};
		gl.bindBuffer = function bindBuffer(target, buffer) {
			switch (target) {
				case gl.ARRAY_BUFFER:
					self.currentArrayBuffer = buffer;
					break;
				case gl.ELEMENT_ARRAY_BUFFER:
					self.currentVertexArrayObject.elementArrayBuffer = buffer;
					break;
			}
			return original.bindBuffer.apply(this, arguments);
		};
		gl.getVertexAttrib = function getVertexAttrib(index, pname) {
			var vao = self.currentVertexArrayObject;
			var attrib = vao.attribs[index];
			switch (pname) {
				case gl.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING:
					return attrib.buffer;
				case gl.VERTEX_ATTRIB_ARRAY_ENABLED:
					return attrib.enabled;
				case gl.VERTEX_ATTRIB_ARRAY_SIZE:
					return attrib.size;
				case gl.VERTEX_ATTRIB_ARRAY_STRIDE:
					return attrib.stride;
				case gl.VERTEX_ATTRIB_ARRAY_TYPE:
					return attrib.type;
				case gl.VERTEX_ATTRIB_ARRAY_NORMALIZED:
					return attrib.normalized;
				default:
					return original.getVertexAttrib.apply(this, arguments);
			}
		};
		gl.vertexAttribPointer = function vertexAttribPointer(indx, size, type, normalized, stride, offset) {
			var vao = self.currentVertexArrayObject;
			vao.maxAttrib = Math.max(vao.maxAttrib, indx);
			var attrib = vao.attribs[indx];
			attrib.buffer = self.currentArrayBuffer;
			attrib.size = size;
			attrib.type = type;
			attrib.normalized = normalized;
			attrib.stride = stride;
			attrib.offset = offset;
			attrib.recache();
			return original.vertexAttribPointer.apply(this, arguments);
		};
		if (gl.instrumentExtension) {
			gl.instrumentExtension(this, "OES_vertex_array_object");
		}
		gl.canvas.addEventListener('webglcontextrestored', function() {
			log("OESVertexArrayObject emulation library context restored");
			self.reset_();
		}, true);
		this.reset_();
	};
	OESVertexArrayObject.prototype.VERTEX_ARRAY_BINDING_OES = 0x85B5;
	OESVertexArrayObject.prototype.reset_ = function reset_() {
		var contextWasLost = this.vertexArrayObjects !== undefined;
		if (contextWasLost) {
			for (var ii = 0; ii < this.vertexArrayObjects.length; ++ii) {
				this.vertexArrayObjects.isAlive = false;
			}
		}
		var gl = this.gl;
		this.maxVertexAttribs = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
		this.defaultVertexArrayObject = new WebGLVertexArrayObjectOES(this);
		this.currentVertexArrayObject = null;
		this.currentArrayBuffer = null;
		this.vertexArrayObjects = [this.defaultVertexArrayObject];
		this.bindVertexArrayOES(null);
	};
	OESVertexArrayObject.prototype.createVertexArrayOES = function createVertexArrayOES() {
		var arrayObject = new WebGLVertexArrayObjectOES(this);
		this.vertexArrayObjects.push(arrayObject);
		return arrayObject;
	};
	OESVertexArrayObject.prototype.deleteVertexArrayOES = function deleteVertexArrayOES(arrayObject) {
		arrayObject.isAlive = false;
		this.vertexArrayObjects.splice(this.vertexArrayObjects.indexOf(arrayObject), 1);
		if (this.currentVertexArrayObject == arrayObject) {
			this.bindVertexArrayOES(null);
		}
	};
	OESVertexArrayObject.prototype.isVertexArrayOES = function isVertexArrayOES(arrayObject) {
		if (arrayObject && arrayObject instanceof WebGLVertexArrayObjectOES) {
			if (arrayObject.hasBeenBound && arrayObject.ext == this) {
				return true;
			}
		}
		return false;
	};
	OESVertexArrayObject.prototype.bindVertexArrayOES = function bindVertexArrayOES(arrayObject) {
		var gl = this.gl;
		if (arrayObject && !arrayObject.isAlive) {
			synthesizeGLError(gl.INVALID_OPERATION, "bindVertexArrayOES: attempt to bind deleted arrayObject");
			return;
		}
		var original = this.original;
		var oldVAO = this.currentVertexArrayObject;
		this.currentVertexArrayObject = arrayObject || this.defaultVertexArrayObject;
		this.currentVertexArrayObject.hasBeenBound = true;
		var newVAO = this.currentVertexArrayObject;
		if (oldVAO == newVAO) {
			return;
		}
		if (!oldVAO || newVAO.elementArrayBuffer != oldVAO.elementArrayBuffer) {
			original.bindBuffer.call(gl, gl.ELEMENT_ARRAY_BUFFER, newVAO.elementArrayBuffer);
		}
		var currentBinding = this.currentArrayBuffer;
		var maxAttrib = Math.max(oldVAO ? oldVAO.maxAttrib : 0, newVAO.maxAttrib);
		for (var n = 0; n <= maxAttrib; n++) {
			var attrib = newVAO.attribs[n];
			var oldAttrib = oldVAO ? oldVAO.attribs[n] : null;
			if (!oldVAO || attrib.enabled != oldAttrib.enabled) {
				if (attrib.enabled) {
					original.enableVertexAttribArray.call(gl, n);
				} else {
					original.disableVertexAttribArray.call(gl, n);
				}
			}
			if (attrib.enabled) {
				var bufferChanged = false;
				if (!oldVAO || attrib.buffer != oldAttrib.buffer) {
					if (currentBinding != attrib.buffer) {
						original.bindBuffer.call(gl, gl.ARRAY_BUFFER, attrib.buffer);
						currentBinding = attrib.buffer;
					}
					bufferChanged = true;
				}
				if (bufferChanged || attrib.cached != oldAttrib.cached) {
					original.vertexAttribPointer.call(gl, n, attrib.size, attrib.type, attrib.normalized, attrib.stride, attrib.offset);
				}
			}
		}
		if (this.currentArrayBuffer != currentBinding) {
			original.bindBuffer.call(gl, gl.ARRAY_BUFFER, this.currentArrayBuffer);
		}
	};
	window.setupVertexArrayObject = function(gl) {
		if (gl.getSupportedExtensions) {
			var exts = gl.getSupportedExtensions();
			if (exts.indexOf("OES_vertex_array_object") != -1) {
				return;
			}
		} else if (gl.getExtension) {
			var vao = gl.getExtension("OES_vertex_array_object");
			if (vao) {
				return;
			}
		}
		if (gl.getSupportedExtensions) {
			var original_getSupportedExtensions = gl.getSupportedExtensions;
			gl.getSupportedExtensions = function getSupportedExtensions() {
				var list = original_getSupportedExtensions.call(this) || [];
				list.push("OES_vertex_array_object");
				return list;
			};
		}
		var original_getExtension = gl.getExtension;
		gl.getExtension = function getExtension(name) {
			if (name == "OES_vertex_array_object") {
				if (!gl.__OESVertexArrayObject) {
					gl.__OESVertexArrayObject = new OESVertexArrayObject(gl);
				}
				return gl.__OESVertexArrayObject;
			}
			if (original_getExtension) {
				return original_getExtension.call(this, name);
			} else {
				return null;
			}
		};
	};
	}());

	var _typeLookup = function () {
		var result = { };
		var names = ["Array", "Object", "Function", "Date", "RegExp", "Float32Array"];
		for (var i = 0; i < names.length; i++)
			result["[object " + names[i] + "]"] = names[i].toLowerCase();
		return result;
	}();
	var version = "1.34.0-dev";
	var revision = "2680e004";
	var config = { };
	var common = { };
	var apps = { };
	var data = { };
	function type(obj) {
		if (obj === null) {
			return "null";
		}
		var type = typeof obj;
		if (type === "undefined" || type === "number" || type === "string" || type === "boolean") {
			return type;
		}
		return _typeLookup[Object.prototype.toString.call(obj)];
	}
	function extend(target, ex) {
		var prop,
			copy;
		for (prop in ex) {
			copy = ex[prop];
			if (type(copy) == "object") {
				target[prop] = extend({}, copy);
			} else if (type(copy) == "array") {
				target[prop] = extend([], copy);
			} else {
				target[prop] = copy;
			}
		}
		return target;
	}
	function isDefined(o) {
		var a;
		return (o !== a);
	}

	var debug = (function () {
		var table = null;
		var row = null;
		var title = null;
		var field = null;
		return {
			display: function (data) {
				function init() {
					table = document.createElement('table');
					row = document.createElement('tr');
					title = document.createElement('td');
					field = document.createElement('td');
					table.style.cssText = 'position:absolute;font-family:sans-serif;font-size:12px;color:#cccccc';
					table.style.top = '0px';
					table.style.left = '0px';
					table.style.border = 'thin solid #cccccc';
					document.body.appendChild(table);
				}
				if (!table) {
					init();
				}
				table.innerHTML = '';
				for (var key in data) {
					var r = row.cloneNode();
					var t = title.cloneNode();
					var f = field.cloneNode();
					t.textContent = key;
					f.textContent = data[key];
					r.appendChild(t);
					r.appendChild(f);
					table.appendChild(r);
				}
			}
		};
	}());

	function EventHandler() {
		this._callbacks = { };
		this._callbackActive = { };
	}
	Object.assign(EventHandler.prototype, {
		_addCallback: function (name, callback, scope, once) {
			if (!name || typeof name !== 'string' || !callback)
				return;
			if (!this._callbacks[name])
				this._callbacks[name] = [];
			if (this._callbackActive[name] && this._callbackActive[name] === this._callbacks[name])
				this._callbackActive[name] = this._callbackActive[name].slice();
			this._callbacks[name].push({
				callback: callback,
				scope: scope || this,
				once: once || false
			});
		},
		on: function (name, callback, scope) {
			this._addCallback(name, callback, scope, false);
			return this;
		},
		off: function (name, callback, scope) {
			if (name) {
				if (this._callbackActive[name] && this._callbackActive[name] === this._callbacks[name])
					this._callbackActive[name] = this._callbackActive[name].slice();
			} else {
				for (var key in this._callbackActive) {
					if (!this._callbacks[key])
						continue;
					if (this._callbacks[key] !== this._callbackActive[key])
						continue;
					this._callbackActive[key] = this._callbackActive[key].slice();
				}
			}
			if (!name) {
				this._callbacks = { };
			} else if (!callback) {
				if (this._callbacks[name])
					this._callbacks[name] = [];
			} else {
				var events = this._callbacks[name];
				if (!events)
					return this;
				var count = events.length;
				for (var i = 0; i < count; i++) {
					if (events[i].callback !== callback)
						continue;
					if (scope && events[i].scope !== scope)
						continue;
					events[i--] = events[--count];
				}
				events.length = count;
			}
			return this;
		},
		fire: function (name, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) {
			if (!name || !this._callbacks[name])
				return this;
			var callbacks;
			if (!this._callbackActive[name]) {
				this._callbackActive[name] = this._callbacks[name];
			} else {
				if (this._callbackActive[name] === this._callbacks[name])
					this._callbackActive[name] = this._callbackActive[name].slice();
				callbacks = this._callbacks[name].slice();
			}
			for (var i = 0; (callbacks || this._callbackActive[name]) && (i < (callbacks || this._callbackActive[name]).length); i++) {
				var evt = (callbacks || this._callbackActive[name])[i];
				evt.callback.call(evt.scope, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
				if (evt.once) {
					var ind = this._callbacks[name].indexOf(evt);
					if (ind !== -1) {
						if (this._callbackActive[name] === this._callbacks[name])
							this._callbackActive[name] = this._callbackActive[name].slice();
						this._callbacks[name].splice(ind, 1);
					}
				}
			}
			if (!callbacks)
				this._callbackActive[name] = null;
			return this;
		},
		once: function (name, callback, scope) {
			this._addCallback(name, callback, scope, true);
			return this;
		},
		hasEvent: function (name) {
			return (this._callbacks[name] && this._callbacks[name].length !== 0) || false;
		}
	});

	var events = {
		attach: function (target) {
			var ev = events;
			target._addCallback = ev._addCallback;
			target.on = ev.on;
			target.off = ev.off;
			target.fire = ev.fire;
			target.once = ev.once;
			target.hasEvent = ev.hasEvent;
			target._callbacks = { };
			target._callbackActive = { };
			return target;
		},
		_addCallback: EventHandler.prototype._addCallback,
		on: EventHandler.prototype.on,
		off: EventHandler.prototype.off,
		fire: EventHandler.prototype.fire,
		once: EventHandler.prototype.once,
		hasEvent: EventHandler.prototype.hasEvent
	};

	var guid = {
		create: function () {
			return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
				var r = Math.random() * 16 | 0,
					v = (c == 'x') ? r : (r & 0x3 | 0x8);
				return v.toString(16);
			});
		}
	};

	var path = {
		delimiter: "/",
		join: function () {
			var index;
			var num = arguments.length;
			var result = arguments[0];
			for (index = 0; index < num - 1; ++index) {
				var one = arguments[index];
				var two = arguments[index + 1];
				if (!isDefined(one) || !isDefined(two)) {
					throw new Error("undefined argument to pc.path.join");
				}
				if (two[0] === path.delimiter) {
					result = two;
					continue;
				}
				if (one && two && one[one.length - 1] !== path.delimiter && two[0] !== path.delimiter) {
					result += (path.delimiter + two);
				} else {
					result += (two);
				}
			}
			return result;
		},
		normalize: function (pathname) {
			var lead = pathname.startsWith(path.delimiter);
			var trail = pathname.endsWith(path.delimiter);
			var parts = pathname.split('/');
			var result = '';
			var cleaned = [];
			for (var i = 0; i < parts.length; i++) {
				if (parts[i] === '') continue;
				if (parts[i] === '.') continue;
				if (parts[i] === '..' && cleaned.length > 0) {
					cleaned = cleaned.slice(0, cleaned.length - 2);
					continue;
				}
				if (i > 0) cleaned.push(path.delimiter);
				cleaned.push(parts[i]);
			}
			result = cleaned.join('');
			if (!lead && result[0] === path.delimiter) {
				result = result.slice(1);
			}
			if (trail && result[result.length - 1] !== path.delimiter) {
				result += path.delimiter;
			}
			return result;
		},
		split: function (pathname) {
			var parts = pathname.split(path.delimiter);
			var tail = parts.slice(parts.length - 1)[0];
			var head = parts.slice(0, parts.length - 1).join(path.delimiter);
			return [head, tail];
		},
		getBasename: function (pathname) {
			return path.split(pathname)[1];
		},
		getDirectory: function (pathname) {
			var parts = pathname.split(path.delimiter);
			return parts.slice(0, parts.length - 1).join(path.delimiter);
		},
		getExtension: function (pathname) {
			var ext = pathname.split('?')[0].split('.').pop();
			if (ext !== pathname) {
				return "." + ext;
			}
			return "";
		},
		isRelativePath: function (pathname) {
			return pathname.charAt(0) !== "/" && pathname.match(/:\/\//) === null;
		},
		extractPath: function (pathname) {
			var result = "";
			var parts = pathname.split("/");
			var i = 0;
			if (parts.length > 1) {
				if (path.isRelativePath(pathname)) {
					if (parts[0] === ".") {
						for (i = 0; i < parts.length - 1; ++i) {
							result += (i === 0) ? parts[i] : "/" + parts[i];
						}
					} else if (parts[0] === "..") {
						for (i = 0; i < parts.length - 1; ++i) {
							result += (i === 0) ? parts[i] : "/" + parts[i];
						}
					} else {
						result = ".";
						for (i = 0; i < parts.length - 1; ++i) {
							result += "/" + parts[i];
						}
					}
				} else {
					for (i = 0; i < parts.length - 1; ++i) {
						result += (i === 0) ? parts[i] : "/" + parts[i];
					}
				}
			}
			return result;
		}
	};

	var platform = {
		desktop: false,
		mobile: false,
		ios: false,
		android: false,
		windows: false,
		xbox: false,
		gamepads: false,
		touch: false,
		workers: false,
		passiveEvents: false
	};
	if (typeof navigator !== 'undefined') {
		var ua = navigator.userAgent;
		if (/(windows|mac os|linux|cros)/i.test(ua))
			platform.desktop = true;
		if (/xbox/i.test(ua))
			platform.xbox = true;
		if (/(windows phone|iemobile|wpdesktop)/i.test(ua)) {
			platform.desktop = false;
			platform.mobile = true;
			platform.windows = true;
		} else if (/android/i.test(ua)) {
			platform.desktop = false;
			platform.mobile = true;
			platform.android = true;
		} else if (/ip([ao]d|hone)/i.test(ua)) {
			platform.desktop = false;
			platform.mobile = true;
			platform.ios = true;
		}
		if (typeof window !== 'undefined') {
			platform.touch = 'ontouchstart' in window || ('maxTouchPoints' in navigator && navigator.maxTouchPoints > 0);
		}
		platform.gamepads = 'getGamepads' in navigator;
		platform.workers = (typeof(Worker) !== 'undefined');
		try {
			var opts = Object.defineProperty({}, 'passive', {
				get: function () {
					platform.passiveEvents = true;
					return false;
				}
			});
			window.addEventListener("testpassive", null, opts);
			window.removeEventListener("testpassive", null, opts);
		} catch (e) {}
	}

	var ASCII_LOWERCASE = "abcdefghijklmnopqrstuvwxyz";
	var ASCII_UPPERCASE = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	var ASCII_LETTERS = ASCII_LOWERCASE + ASCII_UPPERCASE;
	var HIGH_SURROGATE_BEGIN = 0xD800;
	var HIGH_SURROGATE_END = 0xDBFF;
	var LOW_SURROGATE_BEGIN = 0xDC00;
	var LOW_SURROGATE_END = 0xDFFF;
	var ZERO_WIDTH_JOINER = 0x200D;
	var REGIONAL_INDICATOR_BEGIN = 0x1F1E6;
	var REGIONAL_INDICATOR_END = 0x1F1FF;
	var FITZPATRICK_MODIFIER_BEGIN = 0x1F3FB;
	var FITZPATRICK_MODIFIER_END = 0x1F3FF;
	var DIACRITICAL_MARKS_BEGIN = 0x20D0;
	var DIACRITICAL_MARKS_END = 0x20FF;
	var VARIATION_MODIFIER_BEGIN = 0xFE00;
	var VARIATION_MODIFIER_END = 0xFE0F;
	function getCodePointData(string, i) {
		var size = string.length;
		i = i || 0;
		if (i < 0 || i >= size) {
			return null;
		}
		var first = string.charCodeAt(i);
		var second;
		if (size > 1 && first >= HIGH_SURROGATE_BEGIN && first <= HIGH_SURROGATE_END) {
			second = string.charCodeAt(i + 1);
			if (second >= LOW_SURROGATE_BEGIN && second <= LOW_SURROGATE_END) {
				return { code: (first - HIGH_SURROGATE_BEGIN) * 0x400 + second - LOW_SURROGATE_BEGIN + 0x10000, long: true };
			}
		}
		return { code: first, long: false };
	}
	function isCodeBetween(string, begin, end) {
		if (!string)
			return false;
		var codeData = getCodePointData(string);
		if (codeData) {
			var code = codeData.code;
			return code >= begin && code <= end;
		}
		return false;
	}
	function numCharsToTakeForNextSymbol(string, index) {
		if (index === string.length - 1) {
			return 1;
		}
		if (isCodeBetween(string[index], HIGH_SURROGATE_BEGIN, HIGH_SURROGATE_END)) {
			var first = string.substring(index, index + 2);
			var second = string.substring(index + 2, index + 4);
			if (isCodeBetween(second, FITZPATRICK_MODIFIER_BEGIN, FITZPATRICK_MODIFIER_END) ||
				(isCodeBetween(first, REGIONAL_INDICATOR_BEGIN, REGIONAL_INDICATOR_END) &&
				isCodeBetween(second, REGIONAL_INDICATOR_BEGIN, REGIONAL_INDICATOR_END))
			) {
				return 4;
			}
			if (isCodeBetween(second, VARIATION_MODIFIER_BEGIN, VARIATION_MODIFIER_END)) {
				return 3;
			}
			return 2;
		}
		if (isCodeBetween(string[index + 1], VARIATION_MODIFIER_BEGIN, VARIATION_MODIFIER_END)) {
			return 2;
		}
		return 1;
	}
	var string = {
		ASCII_LOWERCASE: ASCII_LOWERCASE,
		ASCII_UPPERCASE: ASCII_UPPERCASE,
		ASCII_LETTERS: ASCII_LETTERS,
		format: function (s) {
			for (var i = 1; i < arguments.length; i++) {
				s = s.replace('{' + (i - 1) + '}', arguments[i]);
			}
			return s;
		},
		toBool: function (s, strict) {
			if (s === 'true') {
				return true;
			}
			if (strict) {
				if (s === 'false') {
					return false;
				}
				throw new TypeError('Not a boolean string');
			}
			return false;
		},
		getCodePoint: function (string, i) {
			var codePointData = getCodePointData(string, i);
			return codePointData && codePointData.code;
		},
		getCodePoints: function (string) {
			if (typeof string !== 'string') {
				throw new TypeError('Not a string');
			}
			var i = 0;
			var arr = [];
			var codePoint;
			while (!!(codePoint = getCodePointData(string, i))) {
				arr.push(codePoint.code);
				i += codePoint.long ? 2 : 1;
			}
			return arr;
		},
		getSymbols: function (string) {
			if (typeof string !== 'string') {
				throw new TypeError('Not a string');
			}
			var index = 0;
			var length = string.length;
			var output = [];
			var take = 0;
			var ch;
			while (index < length) {
				take += numCharsToTakeForNextSymbol(string, index + take);
				ch = string[index + take];
				if (isCodeBetween(ch, DIACRITICAL_MARKS_BEGIN, DIACRITICAL_MARKS_END)) {
					ch = string[index + (take++)];
				}
				if (isCodeBetween(ch, VARIATION_MODIFIER_BEGIN, VARIATION_MODIFIER_END)) {
					ch = string[index + (take++)];
				}
				if (ch && ch.charCodeAt(0) === ZERO_WIDTH_JOINER) {
					ch = string[index + (take++)];
					continue;
				}
				var char = string.substring(index, index + take);
				output.push(char);
				index += take;
				take = 0;
			}
			return output;
		},
		fromCodePoint: function () {
			var chars = [];
			var current;
			var codePoint;
			var units;
			for (var i = 0; i < arguments.length; ++i) {
				current = Number(arguments[i]);
				codePoint = current - 0x10000;
				units = current > 0xFFFF ? [(codePoint >> 10) + 0xD800, (codePoint % 0x400) + 0xDC00] : [current];
				chars.push(String.fromCharCode.apply(null, units));
			}
			return chars.join('');
		}
	};

	var math = {
		DEG_TO_RAD: Math.PI / 180,
		RAD_TO_DEG: 180 / Math.PI,
		clamp: function (value, min, max) {
			if (value >= max) return max;
			if (value <= min) return min;
			return value;
		},
		intToBytes24: function (i) {
			var r, g, b;
			r = (i >> 16) & 0xff;
			g = (i >> 8) & 0xff;
			b = (i) & 0xff;
			return [r, g, b];
		},
		intToBytes32: function (i) {
			var r, g, b, a;
			r = (i >> 24) & 0xff;
			g = (i >> 16) & 0xff;
			b = (i >> 8) & 0xff;
			a = (i) & 0xff;
			return [r, g, b, a];
		},
		bytesToInt24: function (r, g, b) {
			if (r.length) {
				b = r[2];
				g = r[1];
				r = r[0];
			}
			return ((r << 16) | (g << 8) | b);
		},
		bytesToInt32: function (r, g, b, a) {
			if (r.length) {
				a = r[3];
				b = r[2];
				g = r[1];
				r = r[0];
			}
			return ((r << 24) | (g << 16) | (b << 8) | a) >>> 32;
		},
		lerp: function (a, b, alpha) {
			return a + (b - a) * math.clamp(alpha, 0, 1);
		},
		lerpAngle: function (a, b, alpha) {
			if (b - a > 180 ) {
				b -= 360;
			}
			if (b - a < -180 ) {
				b += 360;
			}
			return math.lerp(a, b, math.clamp(alpha, 0, 1));
		},
		powerOfTwo: function (x) {
			return ((x !== 0) && !(x & (x - 1)));
		},
		nextPowerOfTwo: function (val) {
			val--;
			val |= (val >> 1);
			val |= (val >> 2);
			val |= (val >> 4);
			val |= (val >> 8);
			val |= (val >> 16);
			val++;
			return val;
		},
		random: function (min, max) {
			var diff = max - min;
			return Math.random() * diff + min;
		},
		smoothstep: function (min, max, x) {
			if (x <= min) return 0;
			if (x >= max) return 1;
			x = (x - min) / (max - min);
			return x * x * (3 - 2 * x);
		},
		smootherstep: function (min, max, x) {
			if (x <= min) return 0;
			if (x >= max) return 1;
			x = (x - min) / (max - min);
			return x * x * x * (x * (x * 6 - 15) + 10);
		},
		roundUp: function (numToRound, multiple) {
			if (multiple === 0)
				return numToRound;
			return Math.ceil(numToRound / multiple) * multiple;
		},
		float2Half: (function () {
			var floatView = new Float32Array(1);
			var int32View = new Int32Array(floatView.buffer);
			return function (val) {
				floatView[0] = val;
				var x = int32View[0];
				var bits = (x >> 16) & 0x8000;
				var m = (x >> 12) & 0x07ff;
				var e = (x >> 23) & 0xff;
				if (e < 103) {
					return bits;
				}
				if (e > 142) {
					bits |= 0x7c00;
					bits |= ((e == 255) ? 0 : 1) && (x & 0x007fffff);
					return bits;
				}
				if (e < 113) {
					m |= 0x0800;
					bits |= (m >> (114 - e)) + ((m >> (113 - e)) & 1);
					return bits;
				}
				bits |= ((e - 112) << 10) | (m >> 1);
				bits += m & 1;
				return bits;
			};
		}())
	};

	function Color(r, g, b, a) {
		var length = r && r.length;
		if (length === 3 || length === 4) {
			this.r = r[0];
			this.g = r[1];
			this.b = r[2];
			this.a = r[3] !== undefined ? r[3] : 1;
		} else {
			this.r = r || 0;
			this.g = g || 0;
			this.b = b || 0;
			this.a = a !== undefined ? a : 1;
		}
	}
	Object.assign(Color.prototype, {
		clone: function () {
			return new Color(this.r, this.g, this.b, this.a);
		},
		copy: function (rhs) {
			this.r = rhs.r;
			this.g = rhs.g;
			this.b = rhs.b;
			this.a = rhs.a;
			return this;
		},
		equals: function (rhs) {
			return this.r === rhs.r && this.g === rhs.g && this.b === rhs.b && this.a === rhs.a;
		},
		set: function (r, g, b, a) {
			this.r = r;
			this.g = g;
			this.b = b;
			this.a = (a === undefined) ? 1 : a;
			return this;
		},
		lerp: function (lhs, rhs, alpha) {
			this.r = lhs.r + alpha * (rhs.r - lhs.r);
			this.g = lhs.g + alpha * (rhs.g - lhs.g);
			this.b = lhs.b + alpha * (rhs.b - lhs.b);
			this.a = lhs.a + alpha * (rhs.a - lhs.a);
			return this;
		},
		fromString: function (hex) {
			var i = parseInt(hex.replace('#', '0x'), 16);
			var bytes;
			if (hex.length > 7) {
				bytes = math.intToBytes32(i);
			} else {
				bytes = math.intToBytes24(i);
				bytes[3] = 255;
			}
			this.set(bytes[0] / 255, bytes[1] / 255, bytes[2] / 255, bytes[3] / 255);
			return this;
		},
		toString: function (alpha) {
			var s = "#" + ((1 << 24) + (Math.round(this.r * 255) << 16) + (Math.round(this.g * 255) << 8) + Math.round(this.b * 255)).toString(16).slice(1);
			if (alpha === true) {
				var a = Math.round(this.a * 255).toString(16);
				if (this.a < 16 / 255) {
					s += '0' + a;
				} else {
					s += a;
				}
			}
			return s;
		}
	});
	Object.defineProperties(Color, {
		BLACK: { value: new Color(0, 0, 0, 1) },
		WHITE: { value: new Color(1, 1, 1, 1) },
		YELLOW: { value: new Color(1, 1, 0, 1) },
		RED: { value: new Color(1, 0, 0, 1) },
		MAGENTA: { value: new Color(1, 0, 1, 1) },
		GREEN: { value: new Color(0, 1, 0, 1) },
		GRAY: { value: new Color(0.5, 0.5, 0.5, 1) },
		CYAN: { value: new Color(0, 1, 1, 1) },
		BLUE: { value: new Color(0, 0, 1, 1) }
	});
	Object.freeze(Color.BLACK);
	Object.freeze(Color.WHITE);
	Object.freeze(Color.YELLOW);
	Object.freeze(Color.RED);
	Object.freeze(Color.MAGENTA);
	Object.freeze(Color.GREEN);
	Object.freeze(Color.GRAY);
	Object.freeze(Color.CYAN);
	Object.freeze(Color.BLUE);

	function IndexedList() {
		this._list = [];
		this._index = {};
	}
	Object.assign(IndexedList.prototype, {
		push: function (key, item) {
			if (this._index[key]) {
				throw Error("Key already in index " + key);
			}
			var location = this._list.push(item) - 1;
			this._index[key] = location;
		},
		has: function (key) {
			return this._index[key] !== undefined;
		},
		get: function (key) {
			var location = this._index[key];
			if (location !== undefined) {
				return this._list[location];
			}
			return null;
		},
		remove: function (key) {
			var location = this._index[key];
			if (location !== undefined) {
				this._list.splice(location, 1);
				delete this._index[key];
				for (key in this._index) {
					var idx = this._index[key];
					if (idx > location) {
						this._index[key] = idx - 1;
					}
				}
				return true;
			}
			return false;
		},
		list: function () {
			return this._list;
		},
		clear: function () {
			this._list.length = 0;
			for (var prop in this._index) {
				delete this._index[prop];
			}
		}
	});

	function TagsCache(key) {
		this._index = { };
		this._key = key || null;
	}
	Object.assign(TagsCache.prototype, {
		addItem: function (item) {
			var tags = item.tags._list;
			for (var i = 0; i < tags.length; i++)
				this.add(tags[i], item);
		},
		removeItem: function (item) {
			var tags = item.tags._list;
			for (var i = 0; i < tags.length; i++)
				this.remove(tags[i], item);
		},
		add: function (tag, item) {
			if (this._index[tag] && this._index[tag].list.indexOf(item) !== -1)
				return;
			if (!this._index[tag]) {
				this._index[tag] = {
					list: []
				};
				if (this._key)
					this._index[tag].keys = { };
			}
			this._index[tag].list.push(item);
			if (this._key)
				this._index[tag].keys[item[this._key]] = item;
		},
		remove: function (tag, item) {
			if (!this._index[tag])
				return;
			if (this._key) {
				if (!this._index[tag].keys[item[this._key]])
					return;
			}
			var ind = this._index[tag].indexOf(item);
			if (ind === -1)
				return;
			this._index[tag].list.splice(ind, 1);
			if (this._key)
				delete this._index[tag].keys[item[this._key]];
			if (this._index[tag].list.length === 0)
				delete this._index[tag];
		},
		find: function (args) {
			var self = this;
			var index = { };
			var items = [];
			var i, n, t;
			var item, tag, tags, tagsRest, missingIndex;
			var sort = function (a, b) {
				return self._index[a].list.length - self._index[b].list.length;
			};
			for (i = 0; i < args.length; i++) {
				tag = args[i];
				if (tag instanceof Array) {
					if (tag.length === 0)
						continue;
					if (tag.length === 1) {
						tag = tag[0];
					} else {
						missingIndex = false;
						for (t = 0; t < tag.length; t++) {
							if (!this._index[tag[t]]) {
								missingIndex = true;
								break;
							}
						}
						if (missingIndex)
							continue;
						tags = tag.slice(0).sort(sort);
						tagsRest = tags.slice(1);
						if (tagsRest.length === 1)
							tagsRest = tagsRest[0];
						for (n = 0; n < this._index[tags[0]].list.length; n++) {
							item = this._index[tags[0]].list[n];
							if ((this._key ? !index[item[this._key]] : (items.indexOf(item) === -1)) && item.tags.has(tagsRest)) {
								if (this._key)
									index[item[this._key]] = true;
								items.push(item);
							}
						}
						continue;
					}
				}
				if (tag && typeof tag === 'string' && this._index[tag]) {
					for (n = 0; n < this._index[tag].list.length; n++) {
						item = this._index[tag].list[n];
						if (this._key) {
							if (!index[item[this._key]]) {
								index[item[this._key]] = true;
								items.push(item);
							}
						} else if (items.indexOf(item) === -1) {
							items.push(item);
						}
					}
				}
			}
			return items;
		}
	});
	function Tags(parent) {
		EventHandler.call(this);
		this._index = { };
		this._list = [];
		this._parent = parent;
	}
	Tags.prototype = Object.create(EventHandler.prototype);
	Tags.prototype.constructor = Tags;
	Object.assign(Tags.prototype, {
		add: function () {
			var changed = false;
			var tags = this._processArguments(arguments, true);
			if (!tags.length)
				return changed;
			for (var i = 0; i < tags.length; i++) {
				if (this._index[tags[i]])
					continue;
				changed = true;
				this._index[tags[i]] = true;
				this._list.push(tags[i]);
				this.fire('add', tags[i], this._parent);
			}
			if (changed)
				this.fire('change', this._parent);
			return changed;
		},
		remove: function () {
			var changed = false;
			if (!this._list.length)
				return changed;
			var tags = this._processArguments(arguments, true);
			if (!tags.length)
				return changed;
			for (var i = 0; i < tags.length; i++) {
				if (!this._index[tags[i]])
					continue;
				changed = true;
				delete this._index[tags[i]];
				this._list.splice(this._list.indexOf(tags[i]), 1);
				this.fire('remove', tags[i], this._parent);
			}
			if (changed)
				this.fire('change', this._parent);
			return changed;
		},
		clear: function () {
			if (!this._list.length)
				return;
			var tags = this._list.slice(0);
			this._list = [];
			this._index = { };
			for (var i = 0; i < tags.length; i++)
				this.fire('remove', tags[i], this._parent);
			this.fire('change', this._parent);
		},
		has: function () {
			if (!this._list.length)
				return false;
			return this._has(this._processArguments(arguments));
		},
		_has: function (tags) {
			if (!this._list.length || !tags.length)
				return false;
			for (var i = 0; i < tags.length; i++) {
				if (tags[i].length === 1) {
					if (this._index[tags[i][0]])
						return true;
				} else {
					var multiple = true;
					for (var t = 0; t < tags[i].length; t++) {
						if (this._index[tags[i][t]])
							continue;
						multiple = false;
						break;
					}
					if (multiple)
						return true;
				}
			}
			return false;
		},
		list: function () {
			return this._list.slice(0);
		},
		_processArguments: function (args, flat) {
			var tags = [];
			var tmp = [];
			if (!args || !args.length)
				return tags;
			for (var i = 0; i < args.length; i++) {
				if (args[i] instanceof Array) {
					if (!flat)
						tmp = [];
					for (var t = 0; t < args[i].length; t++) {
						if (typeof args[i][t] !== 'string')
							continue;
						if (flat) {
							tags.push(args[i][t]);
						} else {
							tmp.push(args[i][t]);
						}
					}
					if (!flat && tmp.length)
						tags.push(tmp);
				} else if (typeof args[i] === 'string') {
					if (flat) {
						tags.push(args[i]);
					} else {
						tags.push([args[i]]);
					}
				}
			}
			return tags;
		}
	});
	Object.defineProperty(Tags.prototype, 'size', {
		get: function () {
			return this._list.length;
		}
	});

	var now = (typeof window !== 'undefined') && window.performance && window.performance.now && window.performance.timing ? function () {
		return window.performance.now();
	} : Date.now;
	function Timer() {
		this._isRunning = false;
		this._a = 0;
		this._b = 0;
	}
	Object.assign(Timer.prototype, {
		start: function () {
			this._isRunning = true;
			this._a = now();
		},
		stop: function () {
			this._isRunning = false;
			this._b = now();
		},
		getMilliseconds: function () {
			return this._b - this._a;
		}
	});

	function createURI(options) {
		var s = "";
		if ((options.authority || options.scheme) && (options.host || options.hostpath)) {
			throw new Error("Can't have 'scheme' or 'authority' and 'host' or 'hostpath' option");
		}
		if (options.host && options.hostpath) {
			throw new Error("Can't have 'host' and 'hostpath' option");
		}
		if (options.path && options.hostpath) {
			throw new Error("Can't have 'path' and 'hostpath' option");
		}
		if (options.scheme) {
			s += options.scheme + ":";
		}
		if (options.authority) {
			s += "//" + options.authority;
		}
		if (options.host) {
			s += options.host;
		}
		if (options.path) {
			s += options.path;
		}
		if (options.hostpath) {
			s += options.hostpath;
		}
		if (options.query) {
			s += "?" + options.query;
		}
		if (options.fragment) {
			s += "#" + options.fragment;
		}
		return s;
	}
	function URI(uri) {
		var re = /^(([^:\/?#]+):)?(\/\/([^\/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/,
			result = uri.match(re);
		this.scheme = result[2];
		this.authority = result[4];
		this.path = result[5];
		this.query = result[7];
		this.fragment = result[9];
		this.toString = function () {
			var s = "";
			if (this.scheme) {
				s += this.scheme + ":";
			}
			if (this.authority) {
				s += "//" + this.authority;
			}
			s += this.path;
			if (this.query) {
				s += "?" + this.query;
			}
			if (this.fragment) {
				s += "#" + this.fragment;
			}
			return s;
		};
		this.getQuery = function () {
			var vars;
			var pair;
			var result = {};
			if (this.query) {
				vars = decodeURIComponent(this.query).split("&");
				vars.forEach(function (item, index, arr) {
					pair = item.split("=");
					result[pair[0]] = pair[1];
				}, this);
			}
			return result;
		};
		this.setQuery = function (params) {
			var q = "";
			for (var key in params) {
				if (params.hasOwnProperty(key)) {
					if (q !== "") {
						q += "&";
					}
					q += encodeURIComponent(key) + "=" + encodeURIComponent(params[key]);
				}
			}
			this.query = q;
		};
	}

	function Http() {}
	Http.ContentType = {
		FORM_URLENCODED: "application/x-www-form-urlencoded",
		GIF: "image/gif",
		JPEG: "image/jpeg",
		DDS: "image/dds",
		JSON: "application/json",
		PNG: "image/png",
		TEXT: "text/plain",
		XML: "application/xml",
		WAV: "audio/x-wav",
		OGG: "audio/ogg",
		MP3: "audio/mpeg",
		MP4: "audio/mp4",
		AAC: "audio/aac",
		BIN: "application/octet-stream",
		BASIS: "image/basis",
		GLB: "model/gltf-binary"
	};
	Http.ResponseType = {
		TEXT: 'text',
		ARRAY_BUFFER: 'arraybuffer',
		BLOB: 'blob',
		DOCUMENT: 'document',
		JSON: 'json'
	};
	Http.binaryExtensions = [
		'.model',
		'.wav',
		'.ogg',
		'.mp3',
		'.mp4',
		'.m4a',
		'.aac',
		'.dds',
		'.basis',
		'.glb'
	];
	Http.retryDelay = 100;
	Object.assign(Http.prototype, {
		ContentType: Http.ContentType,
		ResponseType: Http.ResponseType,
		binaryExtensions: Http.binaryExtensions,
		get: function (url, options, callback) {
			if (typeof options === "function") {
				callback = options;
				options = {};
			}
			return this.request("GET", url, options, callback);
		},
		post: function (url, data, options, callback) {
			if (typeof options === "function") {
				callback = options;
				options = {};
			}
			options.postdata = data;
			return this.request("POST", url, options, callback);
		},
		put: function (url, data, options, callback) {
			if (typeof options === "function") {
				callback = options;
				options = {};
			}
			options.postdata = data;
			return this.request("PUT", url, options, callback);
		},
		del: function (url, options, callback) {
			if (typeof options === "function") {
				callback = options;
				options = {};
			}
			return this.request("DELETE", url, options, callback);
		},
		request: function (method, url, options, callback) {
			var uri, query, timestamp, postdata, xhr;
			var errored = false;
			if (typeof options === "function") {
				callback = options;
				options = {};
			}
			if (options.retry) {
				options = Object.assign({
					retries: 0,
					maxRetries: 5
				}, options);
			}
			options.callback = callback;
			if (options.async == null) {
				options.async = true;
			}
			if (options.headers == null) {
				options.headers = {};
			}
			if (options.postdata != null) {
				if (options.postdata instanceof Document) {
					postdata = options.postdata;
				} else if (options.postdata instanceof FormData) {
					postdata = options.postdata;
				} else if (options.postdata instanceof Object) {
					var contentType = options.headers["Content-Type"];
					if (contentType === undefined) {
						options.headers["Content-Type"] = Http.ContentType.FORM_URLENCODED;
						contentType = options.headers["Content-Type"];
					}
					switch (contentType) {
						case Http.ContentType.FORM_URLENCODED:
							postdata = "";
							var bFirstItem = true;
							for (var key in options.postdata) {
								if (options.postdata.hasOwnProperty(key)) {
									if (bFirstItem) {
										bFirstItem = false;
									} else {
										postdata += "&";
									}
									postdata += escape(key) + "=" + escape(options.postdata[key]);
								}
							}
							break;
						default:
						case Http.ContentType.JSON:
							if (contentType == null) {
								options.headers["Content-Type"] = Http.ContentType.JSON;
							}
							postdata = JSON.stringify(options.postdata);
							break;
					}
				} else {
					postdata = options.postdata;
				}
			}
			if (options.cache === false) {
				timestamp = now();
				uri = new URI(url);
				if (!uri.query) {
					uri.query = "ts=" + timestamp;
				} else {
					uri.query = uri.query + "&ts=" + timestamp;
				}
				url = uri.toString();
			}
			if (options.query) {
				uri = new URI(url);
				query = extend(uri.getQuery(), options.query);
				uri.setQuery(query);
				url = uri.toString();
			}
			xhr = new XMLHttpRequest();
			xhr.open(method, url, options.async);
			xhr.withCredentials = options.withCredentials !== undefined ? options.withCredentials : false;
			xhr.responseType = options.responseType || this._guessResponseType(url);
			for (var header in options.headers) {
				if (options.headers.hasOwnProperty(header)) {
					xhr.setRequestHeader(header, options.headers[header]);
				}
			}
			xhr.onreadystatechange = function () {
				this._onReadyStateChange(method, url, options, xhr);
			}.bind(this);
			xhr.onerror = function () {
				this._onError(method, url, options, xhr);
				errored = true;
			}.bind(this);
			try {
				xhr.send(postdata);
			} catch (e) {
				if (!errored) {
					options.error(xhr.status, xhr, e);
				}
			}
			return xhr;
		},
		_guessResponseType: function (url) {
			var uri = new URI(url);
			var ext = path.getExtension(uri.path);
			if (Http.binaryExtensions.indexOf(ext) >= 0) {
				return Http.ResponseType.ARRAY_BUFFER;
			}
			if (ext === ".xml") {
				return Http.ResponseType.DOCUMENT;
			}
			return Http.ResponseType.TEXT;
		},
		_isBinaryContentType: function (contentType) {
			var binTypes = [
				Http.ContentType.MP4,
				Http.ContentType.WAV,
				Http.ContentType.OGG,
				Http.ContentType.MP3,
				Http.ContentType.BIN,
				Http.ContentType.DDS,
				Http.ContentType.BASIS,
				Http.ContentType.GLB
			];
			if (binTypes.indexOf(contentType) >= 0) {
				return true;
			}
			return false;
		},
		_onReadyStateChange: function (method, url, options, xhr) {
			if (xhr.readyState === 4) {
				switch (xhr.status) {
					case 0: {
						if (url[0] != '/') {
							this._onSuccess(method, url, options, xhr);
						} else {
							this._onError(method, url, options, xhr);
						}
						break;
					}
					case 200:
					case 201:
					case 206:
					case 304: {
						this._onSuccess(method, url, options, xhr);
						break;
					}
					default: {
						this._onError(method, url, options, xhr);
						break;
					}
				}
			}
		},
		_onSuccess: function (method, url, options, xhr) {
			var response;
			var header;
			var contentType;
			var parts;
			header = xhr.getResponseHeader("Content-Type");
			if (header) {
				parts = header.split(";");
				contentType = parts[0].trim();
			}
			try {
				if (contentType === this.ContentType.JSON || url.split('?')[0].endsWith(".json")) {
					response = JSON.parse(xhr.responseText);
				} else if (this._isBinaryContentType(contentType)) {
					response = xhr.response;
				} else {
					if (contentType) {
						console.warn("responseType: " + xhr.responseType + " being served with Content-Type: " + contentType);
					}
					if (xhr.responseType === Http.ResponseType.ARRAY_BUFFER) {
						response = xhr.response;
					} else if (xhr.responseType === Http.ResponseType.BLOB || xhr.responseType === Http.ResponseType.JSON) {
						response = xhr.response;
					} else {
						if (xhr.responseType === Http.ResponseType.DOCUMENT || contentType === this.ContentType.XML) {
							response = xhr.responseXML;
						} else {
							response = xhr.responseText;
						}
					}
				}
				options.callback(null, response);
			} catch (err) {
				options.callback(err);
			}
		},
		_onError: function (method, url, options, xhr) {
			if (options.retrying) {
				return;
			}
			if (options.retry && options.retries < options.maxRetries) {
				options.retries++;
				options.retrying = true;
				var retryDelay = math.clamp(Math.pow(2, options.retries) * Http.retryDelay, 0, options.maxRetryDelay || 5000);
				console.log(method + ': ' + url + ' - Error ' + xhr.status + '. Retrying in ' + retryDelay + ' ms');
				setTimeout(function () {
					options.retrying = false;
					this.request(method, url, options, options.callback);
				}.bind(this), retryDelay);
			} else {
				options.callback(xhr.status === 0 ? 'Network error' : xhr.status, null);
			}
		}
	});
	var http = new Http();

	var CURVE_LINEAR = 0;
	var CURVE_SMOOTHSTEP = 1;
	var CURVE_CATMULL = 2;
	var CURVE_CARDINAL = 3;
	var CURVE_SPLINE = 4;
	var CURVE_STEP = 5;

	function CurveEvaluator(curve, time) {
		this._curve = curve;
		this._left = -Infinity;
		this._right = Infinity;
		this._recip = 0;
		this._p0 = 0;
		this._p1 = 0;
		this._m0 = 0;
		this._m1 = 0;
		this._reset(time || 0);
	}
	Object.assign(CurveEvaluator.prototype, {
		evaluate: function (time, forceReset) {
			if (forceReset || time < this._left || time >= this._right) {
				this._reset(time);
			}
			var result;
			var type = this._curve.type;
			if (type === CURVE_STEP) {
				result = this._p0;
			} else {
				var t = (this._recip === 0) ? 0 : (time - this._left) * this._recip;
				if (type === CURVE_LINEAR) {
					result = math.lerp(this._p0, this._p1, t);
				} else if (type === CURVE_SMOOTHSTEP) {
					result = math.lerp(this._p0, this._p1, t * t * (3 - 2 * t));
				} else {
					result = this._evaluateHermite(this._p0, this._p1, this._m0, this._m1, t);
				}
			}
			return result;
		},
		_reset: function (time) {
			var keys = this._curve.keys;
			var len = keys.length;
			if (!len) {
				this._left = -Infinity;
				this._right = Infinity;
				this._recip = 0;
				this._p0 = this._p1 = this._m0 = this._m1 = 0;
			} else {
				if (time < keys[0][0]) {
					this._left = -Infinity;
					this._right = keys[0][0];
					this._recip = 0;
					this._p0 = this._p1 = keys[0][1];
					this._m0 = this._m1 = 0;
				} else if (time >= keys[len - 1][0]) {
					this._left = keys[len - 1][0];
					this._right = Infinity;
					this._recip = 0;
					this._p0 = this._p1 = keys[len - 1][1];
					this._m0 = this._m1 = 0;
				} else {
					var index = 0;
					while (time >= keys[index + 1][0]) {
						index++;
					}
					this._left = keys[index][0];
					this._right = keys[index + 1][0];
					var diff = 1.0 / (this._right - this._left);
					this._recip = (isFinite(diff) ? diff : 0);
					this._p0 = keys[index][1];
					this._p1 = keys[index + 1][1];
					if (this._isHermite()) {
						this._calcTangents(keys, index);
					}
				}
			}
		},
		_isHermite: function () {
			return this._curve.type === CURVE_CATMULL ||
				   this._curve.type === CURVE_CARDINAL ||
				   this._curve.type === CURVE_SPLINE;
		},
		_calcTangents: function (keys, index) {
			var a;
			var b = keys[index];
			var c = keys[index + 1];
			var d;
			if (index === 0) {
				a = [keys[0][0] + (keys[0][0] - keys[1][0]),
					keys[0][1] + (keys[0][1] - keys[1][1])];
			} else {
				a = keys[index - 1];
			}
			if (index == keys.length - 2) {
				d = [keys[index + 1][0] + (keys[index + 1][0] - keys[index][0]),
					keys[index + 1][1] + (keys[index + 1][1] - keys[index][1])];
			} else {
				d = keys[index + 2];
			}
			if (this._curve.type === CURVE_SPLINE) {
				var s1_ = 2 * (c[0] - b[0]) / (c[0] - a[0]);
				var s2_ = 2 * (c[0] - b[0]) / (d[0] - b[0]);
				this._m0 = this._curve.tension * (isFinite(s1_) ? s1_ : 0) * (c[1] - a[1]);
				this._m1 = this._curve.tension * (isFinite(s2_) ? s2_ : 0) * (d[1] - b[1]);
			} else {
				var s1 = (c[0] - b[0]) / (b[0] - a[0]);
				var s2 = (c[0] - b[0]) / (d[0] - c[0]);
				var a_ = b[1] + (a[1] - b[1]) * (isFinite(s1) ? s1 : 0);
				var d_ = c[1] + (d[1] - c[1]) * (isFinite(s2) ? s2 : 0);
				var tension = (this._curve.type === CURVE_CATMULL) ? 0.5 : this._curve.tension;
				this._m0 = tension * (c[1] - a_);
				this._m1 = tension * (d_ - b[1]);
			}
		},
		_evaluateHermite: function (p0, p1, m0, m1, t) {
			var t2 = t * t;
			var twot = t + t;
			var omt = 1 - t;
			var omt2 = omt * omt;
			return p0 * ((1 + twot) * omt2) +
				   m0 * (t * omt2) +
				   p1 * (t2 * (3 - twot)) +
				   m1 * (t2 * (t - 1));
		}
	});

	function Curve(data) {
		this.keys = [];
		this.type = CURVE_SMOOTHSTEP;
		this.tension = 0.5;
		this._eval = new CurveEvaluator(this);
		if (data) {
			for (var i = 0; i < data.length - 1; i += 2) {
				this.keys.push([data[i], data[i + 1]]);
			}
		}
		this.sort();
	}
	Object.assign(Curve.prototype, {
		add: function (time, value) {
			var keys = this.keys;
			var len = keys.length;
			var i = 0;
			for (; i < len; i++) {
				if (keys[i][0] > time) {
					break;
				}
			}
			var key = [time, value];
			this.keys.splice(i, 0, key);
			return key;
		},
		get: function (index) {
			return this.keys[index];
		},
		sort: function () {
			this.keys.sort(function (a, b) {
				return a[0] - b[0];
			});
		},
		value: function (time) {
			return this._eval.evaluate(time, true);
		},
		closest: function (time) {
			var keys = this.keys;
			var length = keys.length;
			var min = 2;
			var result = null;
			for (var i = 0; i < length; i++) {
				var diff = Math.abs(time - keys[i][0]);
				if (min >= diff) {
					min = diff;
					result = keys[i];
				} else {
					break;
				}
			}
			return result;
		},
		clone: function () {
			var result = new Curve();
			result.keys = extend(result.keys, this.keys);
			result.type = this.type;
			result.tension = this.tension;
			return result;
		},
		quantize: function (precision) {
			precision = Math.max(precision, 2);
			var values = new Float32Array(precision);
			var step = 1.0 / (precision - 1);
			values[0] = this._eval.evaluate(0, true);
			for (var i = 1; i < precision; i++) {
				values[i] = this._eval.evaluate(step * i);
			}
			return values;
		},
		quantizeClamped: function (precision, min, max) {
			var result = this.quantize(precision);
			for (var i = 0; i < result.length; ++i) {
				result[i] = Math.min(max, Math.max(min, result[i]));
			}
			return result;
		}
	});
	Object.defineProperty(Curve.prototype, 'length', {
		get: function () {
			return this.keys.length;
		}
	});

	function CurveSet() {
		var i;
		this.curves = [];
		this._type = CURVE_SMOOTHSTEP;
		if (arguments.length > 1) {
			for (i = 0; i < arguments.length; i++) {
				this.curves.push(new Curve(arguments[i]));
			}
		} else {
			if (arguments.length === 0) {
				this.curves.push(new Curve());
			} else {
				var arg = arguments[0];
				if (typeof arg === 'number') {
					for (i = 0; i < arg; i++) {
						this.curves.push(new Curve());
					}
				} else {
					for (i = 0; i < arg.length; i++) {
						this.curves.push(new Curve(arg[i]));
					}
				}
			}
		}
	}
	Object.assign(CurveSet.prototype, {
		get: function (index) {
			return this.curves[index];
		},
		value: function (time, result) {
			var length = this.curves.length;
			result = result || [];
			result.length = length;
			for (var i = 0; i < length; i++) {
				result[i] = this.curves[i].value(time);
			}
			return result;
		},
		clone: function () {
			var result = new CurveSet();
			result.curves = [];
			for (var i = 0; i < this.curves.length; i++) {
				result.curves.push(this.curves[i].clone());
			}
			result._type = this._type;
			return result;
		},
		quantize: function (precision) {
			precision = Math.max(precision, 2);
			var numCurves = this.curves.length;
			var values = new Float32Array(precision * numCurves);
			var step = 1.0 / (precision - 1);
			for (var c = 0; c < numCurves; c++) {
				var ev = new CurveEvaluator(this.curves[c]);
				for (var i = 0; i < precision; i++) {
					values[i * numCurves + c] = ev.evaluate(step * i);
				}
			}
			return values;
		},
		quantizeClamped: function (precision, min, max) {
			var result = this.quantize(precision);
			for (var i = 0; i < result.length; ++i) {
				result[i] = Math.min(max, Math.max(min, result[i]));
			}
			return result;
		}
	});
	Object.defineProperty(CurveSet.prototype, 'length', {
		get: function () {
			return this.curves.length;
		}
	});
	Object.defineProperty(CurveSet.prototype, 'type', {
		get: function () {
			return this._type;
		},
		set: function (value) {
			this._type = value;
			for (var i = 0; i < this.curves.length; i++) {
				this.curves[i].type = value;
			}
		}
	});

	function Mat3() {
		var data;
		data = new Float32Array(9);
		data[0] = data[4] = data[8] = 1;
		this.data = data;
	}
	Object.assign(Mat3.prototype, {
		clone: function () {
			return new Mat3().copy(this);
		},
		copy: function (rhs) {
			var src = rhs.data;
			var dst = this.data;
			dst[0] = src[0];
			dst[1] = src[1];
			dst[2] = src[2];
			dst[3] = src[3];
			dst[4] = src[4];
			dst[5] = src[5];
			dst[6] = src[6];
			dst[7] = src[7];
			dst[8] = src[8];
			return this;
		},
		set: function (src) {
			var dst = this.data;
			dst[0] = src[0];
			dst[1] = src[1];
			dst[2] = src[2];
			dst[3] = src[3];
			dst[4] = src[4];
			dst[5] = src[5];
			dst[6] = src[6];
			dst[7] = src[7];
			dst[8] = src[8];
			return this;
		},
		equals: function (rhs) {
			var l = this.data;
			var r = rhs.data;
			return ((l[0] === r[0]) &&
					(l[1] === r[1]) &&
					(l[2] === r[2]) &&
					(l[3] === r[3]) &&
					(l[4] === r[4]) &&
					(l[5] === r[5]) &&
					(l[6] === r[6]) &&
					(l[7] === r[7]) &&
					(l[8] === r[8]));
		},
		isIdentity: function () {
			var m = this.data;
			return ((m[0] === 1) &&
					(m[1] === 0) &&
					(m[2] === 0) &&
					(m[3] === 0) &&
					(m[4] === 1) &&
					(m[5] === 0) &&
					(m[6] === 0) &&
					(m[7] === 0) &&
					(m[8] === 1));
		},
		setIdentity: function () {
			var m = this.data;
			m[0] = 1;
			m[1] = 0;
			m[2] = 0;
			m[3] = 0;
			m[4] = 1;
			m[5] = 0;
			m[6] = 0;
			m[7] = 0;
			m[8] = 1;
			return this;
		},
		toString: function () {
			var t = '[';
			for (var i = 0; i < 9; i++) {
				t += this.data[i];
				t += (i !== 8) ? ', ' : '';
			}
			t += ']';
			return t;
		},
		transpose: function () {
			var m = this.data;
			var tmp;
			tmp = m[1]; m[1] = m[3]; m[3] = tmp;
			tmp = m[2]; m[2] = m[6]; m[6] = tmp;
			tmp = m[5]; m[5] = m[7]; m[7] = tmp;
			return this;
		}
	});
	Object.defineProperties(Mat3, {
		ZERO: { value: new Mat3().set([0, 0, 0, 0, 0, 0, 0, 0, 0]) },
		IDENTITY: { value: new Mat3() }
	});
	Object.freeze(Mat3.ZERO);
	Object.freeze(Mat3.IDENTITY);

	function Vec3(x, y, z) {
		if (x && x.length === 3) {
			this.x = x[0];
			this.y = x[1];
			this.z = x[2];
		} else {
			this.x = x || 0;
			this.y = y || 0;
			this.z = z || 0;
		}
	}
	Object.assign(Vec3.prototype, {
		add: function (rhs) {
			this.x += rhs.x;
			this.y += rhs.y;
			this.z += rhs.z;
			return this;
		},
		add2: function (lhs, rhs) {
			this.x = lhs.x + rhs.x;
			this.y = lhs.y + rhs.y;
			this.z = lhs.z + rhs.z;
			return this;
		},
		clone: function () {
			return new Vec3().copy(this);
		},
		copy: function (rhs) {
			this.x = rhs.x;
			this.y = rhs.y;
			this.z = rhs.z;
			return this;
		},
		cross: function (lhs, rhs) {
			var lx = lhs.x;
			var ly = lhs.y;
			var lz = lhs.z;
			var rx = rhs.x;
			var ry = rhs.y;
			var rz = rhs.z;
			this.x = ly * rz - ry * lz;
			this.y = lz * rx - rz * lx;
			this.z = lx * ry - rx * ly;
			return this;
		},
		distance: function (rhs) {
			var x = this.x - rhs.x;
			var y = this.y - rhs.y;
			var z = this.z - rhs.z;
			return Math.sqrt(x * x + y * y + z * z);
		},
		dot: function (rhs) {
			return this.x * rhs.x + this.y * rhs.y + this.z * rhs.z;
		},
		equals: function (rhs) {
			return this.x === rhs.x && this.y === rhs.y && this.z === rhs.z;
		},
		length: function () {
			return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
		},
		lengthSq: function () {
			return this.x * this.x + this.y * this.y + this.z * this.z;
		},
		lerp: function (lhs, rhs, alpha) {
			this.x = lhs.x + alpha * (rhs.x - lhs.x);
			this.y = lhs.y + alpha * (rhs.y - lhs.y);
			this.z = lhs.z + alpha * (rhs.z - lhs.z);
			return this;
		},
		mul: function (rhs) {
			this.x *= rhs.x;
			this.y *= rhs.y;
			this.z *= rhs.z;
			return this;
		},
		mul2: function (lhs, rhs) {
			this.x = lhs.x * rhs.x;
			this.y = lhs.y * rhs.y;
			this.z = lhs.z * rhs.z;
			return this;
		},
		normalize: function () {
			var lengthSq = this.x * this.x + this.y * this.y + this.z * this.z;
			if (lengthSq > 0) {
				var invLength = 1 / Math.sqrt(lengthSq);
				this.x *= invLength;
				this.y *= invLength;
				this.z *= invLength;
			}
			return this;
		},
		project: function (rhs) {
			var a_dot_b = this.x * rhs.x + this.y * rhs.y + this.z * rhs.z;
			var b_dot_b = rhs.x * rhs.x + rhs.y * rhs.y + rhs.z * rhs.z;
			var s = a_dot_b / b_dot_b;
			this.x = rhs.x * s;
			this.y = rhs.y * s;
			this.z = rhs.z * s;
			return this;
		},
		scale: function (scalar) {
			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;
			return this;
		},
		set: function (x, y, z) {
			this.x = x;
			this.y = y;
			this.z = z;
			return this;
		},
		sub: function (rhs) {
			this.x -= rhs.x;
			this.y -= rhs.y;
			this.z -= rhs.z;
			return this;
		},
		sub2: function (lhs, rhs) {
			this.x = lhs.x - rhs.x;
			this.y = lhs.y - rhs.y;
			this.z = lhs.z - rhs.z;
			return this;
		},
		toString: function () {
			return '[' + this.x + ', ' + this.y + ', ' + this.z + ']';
		}
	});
	Object.defineProperties(Vec3, {
		ZERO: { value: new Vec3(0, 0, 0) },
		ONE: { value: new Vec3(1, 1, 1) },
		UP: { value: new Vec3(0, 1, 0) },
		DOWN: { value: new Vec3(0, -1, 0) },
		RIGHT: { value: new Vec3(1, 0, 0) },
		LEFT: { value: new Vec3(-1, 0, 0) },
		FORWARD: { value: new Vec3(0, 0, -1) },
		BACK: { value: new Vec3(0, 0, 1) }
	});
	Object.freeze(Vec3.ZERO);
	Object.freeze(Vec3.ONE);
	Object.freeze(Vec3.UP);
	Object.freeze(Vec3.DOWN);
	Object.freeze(Vec3.RIGHT);
	Object.freeze(Vec3.LEFT);
	Object.freeze(Vec3.FORWARD);
	Object.freeze(Vec3.BACK);

	function Vec4(x, y, z, w) {
		if (x && x.length === 4) {
			this.x = x[0];
			this.y = x[1];
			this.z = x[2];
			this.w = x[3];
		} else {
			this.x = x || 0;
			this.y = y || 0;
			this.z = z || 0;
			this.w = w || 0;
		}
	}
	Object.assign(Vec4.prototype, {
		add: function (rhs) {
			this.x += rhs.x;
			this.y += rhs.y;
			this.z += rhs.z;
			this.w += rhs.w;
			return this;
		},
		add2: function (lhs, rhs) {
			this.x = lhs.x + rhs.x;
			this.y = lhs.y + rhs.y;
			this.z = lhs.z + rhs.z;
			this.w = lhs.w + rhs.w;
			return this;
		},
		clone: function () {
			return new Vec4().copy(this);
		},
		copy: function (rhs) {
			this.x = rhs.x;
			this.y = rhs.y;
			this.z = rhs.z;
			this.w = rhs.w;
			return this;
		},
		dot: function (rhs) {
			return this.x * rhs.x + this.y * rhs.y + this.z * rhs.z + this.w * rhs.w;
		},
		equals: function (rhs) {
			return this.x === rhs.x && this.y === rhs.y && this.z === rhs.z && this.w === rhs.w;
		},
		length: function () {
			return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
		},
		lengthSq: function () {
			return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
		},
		lerp: function (lhs, rhs, alpha) {
			this.x = lhs.x + alpha * (rhs.x - lhs.x);
			this.y = lhs.y + alpha * (rhs.y - lhs.y);
			this.z = lhs.z + alpha * (rhs.z - lhs.z);
			this.w = lhs.w + alpha * (rhs.w - lhs.w);
			return this;
		},
		mul: function (rhs) {
			this.x *= rhs.x;
			this.y *= rhs.y;
			this.z *= rhs.z;
			this.w *= rhs.w;
			return this;
		},
		mul2: function (lhs, rhs) {
			this.x = lhs.x * rhs.x;
			this.y = lhs.y * rhs.y;
			this.z = lhs.z * rhs.z;
			this.w = lhs.w * rhs.w;
			return this;
		},
		normalize: function () {
			var lengthSq = this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
			if (lengthSq > 0) {
				var invLength = 1 / Math.sqrt(lengthSq);
				this.x *= invLength;
				this.y *= invLength;
				this.z *= invLength;
				this.w *= invLength;
			}
			return this;
		},
		scale: function (scalar) {
			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;
			this.w *= scalar;
			return this;
		},
		set: function (x, y, z, w) {
			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;
			return this;
		},
		sub: function (rhs) {
			this.x -= rhs.x;
			this.y -= rhs.y;
			this.z -= rhs.z;
			this.w -= rhs.w;
			return this;
		},
		sub2: function (lhs, rhs) {
			this.x = lhs.x - rhs.x;
			this.y = lhs.y - rhs.y;
			this.z = lhs.z - rhs.z;
			this.w = lhs.w - rhs.w;
			return this;
		},
		toString: function () {
			return '[' + this.x + ', ' + this.y + ', ' + this.z + ', ' + this.w + ']';
		}
	});
	Object.defineProperties(Vec4, {
		ZERO: { value: new Vec4(0, 0, 0, 0) },
		ONE: { value: new Vec4(1, 1, 1, 1) }
	});
	Object.freeze(Vec4.ZERO);
	Object.freeze(Vec4.ONE);

	function Mat4() {
		var data = new Float32Array(16);
		data[0] = data[5] = data[10] = data[15] = 1;
		this.data = data;
	}
	Object.assign(Mat4.prototype, {
		add2: function (lhs, rhs) {
			var a = lhs.data,
				b = rhs.data,
				r = this.data;
			r[0] = a[0] + b[0];
			r[1] = a[1] + b[1];
			r[2] = a[2] + b[2];
			r[3] = a[3] + b[3];
			r[4] = a[4] + b[4];
			r[5] = a[5] + b[5];
			r[6] = a[6] + b[6];
			r[7] = a[7] + b[7];
			r[8] = a[8] + b[8];
			r[9] = a[9] + b[9];
			r[10] = a[10] + b[10];
			r[11] = a[11] + b[11];
			r[12] = a[12] + b[12];
			r[13] = a[13] + b[13];
			r[14] = a[14] + b[14];
			r[15] = a[15] + b[15];
			return this;
		},
		add: function (rhs) {
			return this.add2(this, rhs);
		},
		clone: function () {
			return new Mat4().copy(this);
		},
		copy: function (rhs) {
			var src = rhs.data,
				dst = this.data;
			dst[0] = src[0];
			dst[1] = src[1];
			dst[2] = src[2];
			dst[3] = src[3];
			dst[4] = src[4];
			dst[5] = src[5];
			dst[6] = src[6];
			dst[7] = src[7];
			dst[8] = src[8];
			dst[9] = src[9];
			dst[10] = src[10];
			dst[11] = src[11];
			dst[12] = src[12];
			dst[13] = src[13];
			dst[14] = src[14];
			dst[15] = src[15];
			return this;
		},
		equals: function (rhs) {
			var l = this.data,
				r = rhs.data;
			return ((l[0] === r[0]) &&
					(l[1] === r[1]) &&
					(l[2] === r[2]) &&
					(l[3] === r[3]) &&
					(l[4] === r[4]) &&
					(l[5] === r[5]) &&
					(l[6] === r[6]) &&
					(l[7] === r[7]) &&
					(l[8] === r[8]) &&
					(l[9] === r[9]) &&
					(l[10] === r[10]) &&
					(l[11] === r[11]) &&
					(l[12] === r[12]) &&
					(l[13] === r[13]) &&
					(l[14] === r[14]) &&
					(l[15] === r[15]));
		},
		isIdentity: function () {
			var m = this.data;
			return ((m[0] === 1) &&
					(m[1] === 0) &&
					(m[2] === 0) &&
					(m[3] === 0) &&
					(m[4] === 0) &&
					(m[5] === 1) &&
					(m[6] === 0) &&
					(m[7] === 0) &&
					(m[8] === 0) &&
					(m[9] === 0) &&
					(m[10] === 1) &&
					(m[11] === 0) &&
					(m[12] === 0) &&
					(m[13] === 0) &&
					(m[14] === 0) &&
					(m[15] === 1));
		},
		mul2: function (lhs, rhs) {
			var a00, a01, a02, a03,
				a10, a11, a12, a13,
				a20, a21, a22, a23,
				a30, a31, a32, a33,
				b0, b1, b2, b3,
				a = lhs.data,
				b = rhs.data,
				r = this.data;
			a00 = a[0];
			a01 = a[1];
			a02 = a[2];
			a03 = a[3];
			a10 = a[4];
			a11 = a[5];
			a12 = a[6];
			a13 = a[7];
			a20 = a[8];
			a21 = a[9];
			a22 = a[10];
			a23 = a[11];
			a30 = a[12];
			a31 = a[13];
			a32 = a[14];
			a33 = a[15];
			b0 = b[0];
			b1 = b[1];
			b2 = b[2];
			b3 = b[3];
			r[0]  = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;
			r[1]  = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;
			r[2]  = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;
			r[3]  = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;
			b0 = b[4];
			b1 = b[5];
			b2 = b[6];
			b3 = b[7];
			r[4]  = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;
			r[5]  = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;
			r[6]  = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;
			r[7]  = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;
			b0 = b[8];
			b1 = b[9];
			b2 = b[10];
			b3 = b[11];
			r[8]  = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;
			r[9]  = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;
			r[10] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;
			r[11] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;
			b0 = b[12];
			b1 = b[13];
			b2 = b[14];
			b3 = b[15];
			r[12] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;
			r[13] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;
			r[14] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;
			r[15] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;
			return this;
		},
		mulAffine2: function (lhs, rhs) {
			var a00, a01, a02,
				a10, a11, a12,
				a20, a21, a22,
				a30, a31, a32,
				b0, b1, b2,
				a = lhs.data,
				b = rhs.data,
				r = this.data;
			a00 = a[0];
			a01 = a[1];
			a02 = a[2];
			a10 = a[4];
			a11 = a[5];
			a12 = a[6];
			a20 = a[8];
			a21 = a[9];
			a22 = a[10];
			a30 = a[12];
			a31 = a[13];
			a32 = a[14];
			b0 = b[0];
			b1 = b[1];
			b2 = b[2];
			r[0]  = a00 * b0 + a10 * b1 + a20 * b2;
			r[1]  = a01 * b0 + a11 * b1 + a21 * b2;
			r[2]  = a02 * b0 + a12 * b1 + a22 * b2;
			r[3] = 0;
			b0 = b[4];
			b1 = b[5];
			b2 = b[6];
			r[4]  = a00 * b0 + a10 * b1 + a20 * b2;
			r[5]  = a01 * b0 + a11 * b1 + a21 * b2;
			r[6]  = a02 * b0 + a12 * b1 + a22 * b2;
			r[7] = 0;
			b0 = b[8];
			b1 = b[9];
			b2 = b[10];
			r[8]  = a00 * b0 + a10 * b1 + a20 * b2;
			r[9]  = a01 * b0 + a11 * b1 + a21 * b2;
			r[10] = a02 * b0 + a12 * b1 + a22 * b2;
			r[11] = 0;
			b0 = b[12];
			b1 = b[13];
			b2 = b[14];
			r[12] = a00 * b0 + a10 * b1 + a20 * b2 + a30;
			r[13] = a01 * b0 + a11 * b1 + a21 * b2 + a31;
			r[14] = a02 * b0 + a12 * b1 + a22 * b2 + a32;
			r[15] = 1;
			return this;
		},
		mul: function (rhs) {
			return this.mul2(this, rhs);
		},
		transformPoint: function (vec, res) {
			var x, y, z, m;
			m = this.data;
			x = vec.x;
			y = vec.y;
			z = vec.z;
			res = (res === undefined) ? new Vec3() : res;
			res.x = x * m[0] + y * m[4] + z * m[8] + m[12];
			res.y = x * m[1] + y * m[5] + z * m[9] + m[13];
			res.z = x * m[2] + y * m[6] + z * m[10] + m[14];
			return res;
		},
		transformVector: function (vec, res) {
			var x, y, z, m;
			m = this.data;
			x = vec.x;
			y = vec.y;
			z = vec.z;
			res = (res === undefined) ? new Vec3() : res;
			res.x = x * m[0] + y * m[4] + z * m[8];
			res.y = x * m[1] + y * m[5] + z * m[9];
			res.z = x * m[2] + y * m[6] + z * m[10];
			return res;
		},
		transformVec4: function (vec, res) {
			var x, y, z, w, m;
			m = this.data;
			x = vec.x;
			y = vec.y;
			z = vec.z;
			w = vec.w;
			res = (res === undefined) ? new Vec4() : res;
			res.x = x * m[0] + y * m[4] + z * m[8] + w * m[12];
			res.y = x * m[1] + y * m[5] + z * m[9] + w * m[13];
			res.z = x * m[2] + y * m[6] + z * m[10] + w * m[14];
			res.w = x * m[3] + y * m[7] + z * m[11] + w * m[15];
			return res;
		},
		setLookAt: (function () {
			var x, y, z;
			x = new Vec3();
			y = new Vec3();
			z = new Vec3();
			return function (position, target, up) {
				z.sub2(position, target).normalize();
				y.copy(up).normalize();
				x.cross(y, z).normalize();
				y.cross(z, x);
				var r = this.data;
				r[0]  = x.x;
				r[1]  = x.y;
				r[2]  = x.z;
				r[3]  = 0;
				r[4]  = y.x;
				r[5]  = y.y;
				r[6]  = y.z;
				r[7]  = 0;
				r[8]  = z.x;
				r[9]  = z.y;
				r[10] = z.z;
				r[11] = 0;
				r[12] = position.x;
				r[13] = position.y;
				r[14] = position.z;
				r[15] = 1;
				return this;
			};
		}()),
		setFrustum: function (left, right, bottom, top, znear, zfar) {
			var temp1, temp2, temp3, temp4, r;
			temp1 = 2 * znear;
			temp2 = right - left;
			temp3 = top - bottom;
			temp4 = zfar - znear;
			r = this.data;
			r[0] = temp1 / temp2;
			r[1] = 0;
			r[2] = 0;
			r[3] = 0;
			r[4] = 0;
			r[5] = temp1 / temp3;
			r[6] = 0;
			r[7] = 0;
			r[8] = (right + left) / temp2;
			r[9] = (top + bottom) / temp3;
			r[10] = (-zfar - znear) / temp4;
			r[11] = -1;
			r[12] = 0;
			r[13] = 0;
			r[14] = (-temp1 * zfar) / temp4;
			r[15] = 0;
			return this;
		},
		setPerspective: function (fov, aspect, znear, zfar, fovIsHorizontal) {
			var xmax, ymax;
			if (!fovIsHorizontal) {
				ymax = znear * Math.tan(fov * Math.PI / 360);
				xmax = ymax * aspect;
			} else {
				xmax = znear * Math.tan(fov * Math.PI / 360);
				ymax = xmax / aspect;
			}
			return this.setFrustum(-xmax, xmax, -ymax, ymax, znear, zfar);
		},
		setOrtho: function (left, right, bottom, top, near, far) {
			var r = this.data;
			r[0] = 2 / (right - left);
			r[1] = 0;
			r[2] = 0;
			r[3] = 0;
			r[4] = 0;
			r[5] = 2 / (top - bottom);
			r[6] = 0;
			r[7] = 0;
			r[8] = 0;
			r[9] = 0;
			r[10] = -2 / (far - near);
			r[11] = 0;
			r[12] = -(right + left) / (right - left);
			r[13] = -(top + bottom) / (top - bottom);
			r[14] = -(far + near) / (far - near);
			r[15] = 1;
			return this;
		},
		setFromAxisAngle: function (axis, angle) {
			var x, y, z, c, s, t, tx, ty, m;
			angle *= math.DEG_TO_RAD;
			x = axis.x;
			y = axis.y;
			z = axis.z;
			c = Math.cos(angle);
			s = Math.sin(angle);
			t = 1 - c;
			tx = t * x;
			ty = t * y;
			m = this.data;
			m[0] = tx * x + c;
			m[1] = tx * y + s * z;
			m[2] = tx * z - s * y;
			m[3] = 0;
			m[4] = tx * y - s * z;
			m[5] = ty * y + c;
			m[6] = ty * z + s * x;
			m[7] = 0;
			m[8] = tx * z + s * y;
			m[9] = ty * z - x * s;
			m[10] = t * z * z + c;
			m[11] = 0;
			m[12] = 0;
			m[13] = 0;
			m[14] = 0;
			m[15] = 1;
			return this;
		},
		setTranslate: function (x, y, z) {
			var m = this.data;
			m[0] = 1;
			m[1] = 0;
			m[2] = 0;
			m[3] = 0;
			m[4] = 0;
			m[5] = 1;
			m[6] = 0;
			m[7] = 0;
			m[8] = 0;
			m[9] = 0;
			m[10] = 1;
			m[11] = 0;
			m[12] = x;
			m[13] = y;
			m[14] = z;
			m[15] = 1;
			return this;
		},
		setScale: function (x, y, z) {
			var m = this.data;
			m[0] = x;
			m[1] = 0;
			m[2] = 0;
			m[3] = 0;
			m[4] = 0;
			m[5] = y;
			m[6] = 0;
			m[7] = 0;
			m[8] = 0;
			m[9] = 0;
			m[10] = z;
			m[11] = 0;
			m[12] = 0;
			m[13] = 0;
			m[14] = 0;
			m[15] = 1;
			return this;
		},
		invert: function () {
			var a00, a01, a02, a03,
				a10, a11, a12, a13,
				a20, a21, a22, a23,
				a30, a31, a32, a33,
				b00, b01, b02, b03,
				b04, b05, b06, b07,
				b08, b09, b10, b11,
				det, invDet, m;
			m = this.data;
			a00 = m[0];
			a01 = m[1];
			a02 = m[2];
			a03 = m[3];
			a10 = m[4];
			a11 = m[5];
			a12 = m[6];
			a13 = m[7];
			a20 = m[8];
			a21 = m[9];
			a22 = m[10];
			a23 = m[11];
			a30 = m[12];
			a31 = m[13];
			a32 = m[14];
			a33 = m[15];
			b00 = a00 * a11 - a01 * a10;
			b01 = a00 * a12 - a02 * a10;
			b02 = a00 * a13 - a03 * a10;
			b03 = a01 * a12 - a02 * a11;
			b04 = a01 * a13 - a03 * a11;
			b05 = a02 * a13 - a03 * a12;
			b06 = a20 * a31 - a21 * a30;
			b07 = a20 * a32 - a22 * a30;
			b08 = a20 * a33 - a23 * a30;
			b09 = a21 * a32 - a22 * a31;
			b10 = a21 * a33 - a23 * a31;
			b11 = a22 * a33 - a23 * a32;
			det = (b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06);
			if (det === 0) {
				this.setIdentity();
			} else {
				invDet = 1 / det;
				m[0] = (a11 * b11 - a12 * b10 + a13 * b09) * invDet;
				m[1] = (-a01 * b11 + a02 * b10 - a03 * b09) * invDet;
				m[2] = (a31 * b05 - a32 * b04 + a33 * b03) * invDet;
				m[3] = (-a21 * b05 + a22 * b04 - a23 * b03) * invDet;
				m[4] = (-a10 * b11 + a12 * b08 - a13 * b07) * invDet;
				m[5] = (a00 * b11 - a02 * b08 + a03 * b07) * invDet;
				m[6] = (-a30 * b05 + a32 * b02 - a33 * b01) * invDet;
				m[7] = (a20 * b05 - a22 * b02 + a23 * b01) * invDet;
				m[8] = (a10 * b10 - a11 * b08 + a13 * b06) * invDet;
				m[9] = (-a00 * b10 + a01 * b08 - a03 * b06) * invDet;
				m[10] = (a30 * b04 - a31 * b02 + a33 * b00) * invDet;
				m[11] = (-a20 * b04 + a21 * b02 - a23 * b00) * invDet;
				m[12] = (-a10 * b09 + a11 * b07 - a12 * b06) * invDet;
				m[13] = (a00 * b09 - a01 * b07 + a02 * b06) * invDet;
				m[14] = (-a30 * b03 + a31 * b01 - a32 * b00) * invDet;
				m[15] = (a20 * b03 - a21 * b01 + a22 * b00) * invDet;
			}
			return this;
		},
		set: function (src) {
			var dst = this.data;
			dst[0] = src[0];
			dst[1] = src[1];
			dst[2] = src[2];
			dst[3] = src[3];
			dst[4] = src[4];
			dst[5] = src[5];
			dst[6] = src[6];
			dst[7] = src[7];
			dst[8] = src[8];
			dst[9] = src[9];
			dst[10] = src[10];
			dst[11] = src[11];
			dst[12] = src[12];
			dst[13] = src[13];
			dst[14] = src[14];
			dst[15] = src[15];
			return this;
		},
		setIdentity: function () {
			var m = this.data;
			m[0] = 1;
			m[1] = 0;
			m[2] = 0;
			m[3] = 0;
			m[4] = 0;
			m[5] = 1;
			m[6] = 0;
			m[7] = 0;
			m[8] = 0;
			m[9] = 0;
			m[10] = 1;
			m[11] = 0;
			m[12] = 0;
			m[13] = 0;
			m[14] = 0;
			m[15] = 1;
			return this;
		},
		setTRS: function (t, r, s) {
			var qx, qy, qz, qw, sx, sy, sz,
				x2, y2, z2, xx, xy, xz, yy, yz, zz, wx, wy, wz, m;
			qx = r.x;
			qy = r.y;
			qz = r.z;
			qw = r.w;
			sx = s.x;
			sy = s.y;
			sz = s.z;
			x2 = qx + qx;
			y2 = qy + qy;
			z2 = qz + qz;
			xx = qx * x2;
			xy = qx * y2;
			xz = qx * z2;
			yy = qy * y2;
			yz = qy * z2;
			zz = qz * z2;
			wx = qw * x2;
			wy = qw * y2;
			wz = qw * z2;
			m = this.data;
			m[0] = (1 - (yy + zz)) * sx;
			m[1] = (xy + wz) * sx;
			m[2] = (xz - wy) * sx;
			m[3] = 0;
			m[4] = (xy - wz) * sy;
			m[5] = (1 - (xx + zz)) * sy;
			m[6] = (yz + wx) * sy;
			m[7] = 0;
			m[8] = (xz + wy) * sz;
			m[9] = (yz - wx) * sz;
			m[10] = (1 - (xx + yy)) * sz;
			m[11] = 0;
			m[12] = t.x;
			m[13] = t.y;
			m[14] = t.z;
			m[15] = 1;
			return this;
		},
		transpose: function () {
			var tmp, m = this.data;
			tmp = m[1];
			m[1] = m[4];
			m[4] = tmp;
			tmp = m[2];
			m[2] = m[8];
			m[8] = tmp;
			tmp = m[3];
			m[3] = m[12];
			m[12] = tmp;
			tmp = m[6];
			m[6] = m[9];
			m[9] = tmp;
			tmp = m[7];
			m[7] = m[13];
			m[13] = tmp;
			tmp = m[11];
			m[11] = m[14];
			m[14] = tmp;
			return this;
		},
		invertTo3x3: function (res) {
			var a11, a21, a31, a12, a22, a32, a13, a23, a33,
				m, r, det, idet;
			m = this.data;
			r = res.data;
			var m0 = m[0];
			var m1 = m[1];
			var m2 = m[2];
			var m4 = m[4];
			var m5 = m[5];
			var m6 = m[6];
			var m8 = m[8];
			var m9 = m[9];
			var m10 = m[10];
			a11 =  m10 * m5 - m6 * m9;
			a21 = -m10 * m1 + m2 * m9;
			a31 =  m6  * m1 - m2 * m5;
			a12 = -m10 * m4 + m6 * m8;
			a22 =  m10 * m0 - m2 * m8;
			a32 = -m6  * m0 + m2 * m4;
			a13 =  m9  * m4 - m5 * m8;
			a23 = -m9  * m0 + m1 * m8;
			a33 =  m5  * m0 - m1 * m4;
			det =  m0 * a11 + m1 * a12 + m2 * a13;
			if (det === 0) {
				return this;
			}
			idet = 1 / det;
			r[0] = idet * a11;
			r[1] = idet * a21;
			r[2] = idet * a31;
			r[3] = idet * a12;
			r[4] = idet * a22;
			r[5] = idet * a32;
			r[6] = idet * a13;
			r[7] = idet * a23;
			r[8] = idet * a33;
			return this;
		},
		getTranslation: function (t) {
			t = (t === undefined) ? new Vec3() : t;
			return t.set(this.data[12], this.data[13], this.data[14]);
		},
		getX: function (x) {
			x = (x === undefined) ? new Vec3() : x;
			return x.set(this.data[0], this.data[1], this.data[2]);
		},
		getY: function (y) {
			y = (y === undefined) ? new Vec3() : y;
			return y.set(this.data[4], this.data[5], this.data[6]);
		},
		getZ: function (z) {
			z = (z === undefined) ? new Vec3() : z;
			return z.set(this.data[8], this.data[9], this.data[10]);
		},
		getScale: (function () {
			var x, y, z;
			x = new Vec3();
			y = new Vec3();
			z = new Vec3();
			return function (scale) {
				scale = (scale === undefined) ? new Vec3() : scale;
				this.getX(x);
				this.getY(y);
				this.getZ(z);
				scale.set(x.length(), y.length(), z.length());
				return scale;
			};
		}()),
		setFromEulerAngles: function (ex, ey, ez) {
			var s1, c1, s2, c2, s3, c3, m;
			ex *= math.DEG_TO_RAD;
			ey *= math.DEG_TO_RAD;
			ez *= math.DEG_TO_RAD;
			s1 = Math.sin(-ex);
			c1 = Math.cos(-ex);
			s2 = Math.sin(-ey);
			c2 = Math.cos(-ey);
			s3 = Math.sin(-ez);
			c3 = Math.cos(-ez);
			m = this.data;
			m[0] = c2 * c3;
			m[1] = -c2 * s3;
			m[2] = s2;
			m[3] = 0;
			m[4] = c1 * s3 + c3 * s1 * s2;
			m[5] = c1 * c3 - s1 * s2 * s3;
			m[6] = -c2 * s1;
			m[7] = 0;
			m[8] = s1 * s3 - c1 * c3 * s2;
			m[9] = c3 * s1 + c1 * s2 * s3;
			m[10] = c1 * c2;
			m[11] = 0;
			m[12] = 0;
			m[13] = 0;
			m[14] = 0;
			m[15] = 1;
			return this;
		},
		getEulerAngles: (function () {
			var scale = new Vec3();
			return function (eulers) {
				var x, y, z, sx, sy, sz, m, halfPi;
				eulers = (eulers === undefined) ? new Vec3() : eulers;
				this.getScale(scale);
				sx = scale.x;
				sy = scale.y;
				sz = scale.z;
				m = this.data;
				y = Math.asin(-m[2] / sx);
				halfPi = Math.PI * 0.5;
				if (y < halfPi) {
					if (y > -halfPi) {
						x = Math.atan2(m[6] / sy, m[10] / sz);
						z = Math.atan2(m[1] / sx, m[0] / sx);
					} else {
						z = 0;
						x = -Math.atan2(m[4] / sy, m[5] / sy);
					}
				} else {
					z = 0;
					x = Math.atan2(m[4] / sy, m[5] / sy);
				}
				return eulers.set(x, y, z).scale(math.RAD_TO_DEG);
			};
		}()),
		toString: function () {
			var i, t;
			t = '[';
			for (i = 0; i < 16; i += 1) {
				t += this.data[i];
				t += (i !== 15) ? ', ' : '';
			}
			t += ']';
			return t;
		}
	});
	Object.defineProperties(Mat4, {
		ZERO: { value: new Mat4().set([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) },
		IDENTITY: { value: new Mat4() }
	});
	Object.freeze(Mat4.ZERO);
	Object.freeze(Mat4.IDENTITY);

	function Quat(x, y, z, w) {
		if (x && x.length === 4) {
			this.x = x[0];
			this.y = x[1];
			this.z = x[2];
			this.w = x[3];
		} else {
			this.x = (x === undefined) ? 0 : x;
			this.y = (y === undefined) ? 0 : y;
			this.z = (z === undefined) ? 0 : z;
			this.w = (w === undefined) ? 1 : w;
		}
	}
	Object.assign(Quat.prototype, {
		clone: function () {
			return new Quat(this.x, this.y, this.z, this.w);
		},
		conjugate: function () {
			this.x *= -1;
			this.y *= -1;
			this.z *= -1;
			return this;
		},
		copy: function (rhs) {
			this.x = rhs.x;
			this.y = rhs.y;
			this.z = rhs.z;
			this.w = rhs.w;
			return this;
		},
		equals: function (rhs) {
			return ((this.x === rhs.x) && (this.y === rhs.y) && (this.z === rhs.z) && (this.w === rhs.w));
		},
		getAxisAngle: function (axis) {
			var rad = Math.acos(this.w) * 2;
			var s = Math.sin(rad / 2);
			if (s !== 0) {
				axis.x = this.x / s;
				axis.y = this.y / s;
				axis.z = this.z / s;
				if (axis.x < 0 || axis.y < 0 || axis.z < 0) {
					axis.x *= -1;
					axis.y *= -1;
					axis.z *= -1;
					rad *= -1;
				}
			} else {
				axis.x = 1;
				axis.y = 0;
				axis.z = 0;
			}
			return rad * math.RAD_TO_DEG;
		},
		getEulerAngles: function (eulers) {
			var x, y, z, qx, qy, qz, qw, a2;
			eulers = (eulers === undefined) ? new Vec3() : eulers;
			qx = this.x;
			qy = this.y;
			qz = this.z;
			qw = this.w;
			a2 = 2 * (qw * qy - qx * qz);
			if (a2 <= -0.99999) {
				x = 2 * Math.atan2(qx, qw);
				y = -Math.PI / 2;
				z = 0;
			} else if (a2 >= 0.99999) {
				x = 2 * Math.atan2(qx, qw);
				y = Math.PI / 2;
				z = 0;
			} else {
				x = Math.atan2(2 * (qw * qx + qy * qz), 1 - 2 * (qx * qx + qy * qy));
				y = Math.asin(a2);
				z = Math.atan2(2 * (qw * qz + qx * qy), 1 - 2 * (qy * qy + qz * qz));
			}
			return eulers.set(x, y, z).scale(math.RAD_TO_DEG);
		},
		invert: function () {
			return this.conjugate().normalize();
		},
		length: function () {
			return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
		},
		lengthSq: function () {
			return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
		},
		mul: function (rhs) {
			var q1x, q1y, q1z, q1w, q2x, q2y, q2z, q2w;
			q1x = this.x;
			q1y = this.y;
			q1z = this.z;
			q1w = this.w;
			q2x = rhs.x;
			q2y = rhs.y;
			q2z = rhs.z;
			q2w = rhs.w;
			this.x = q1w * q2x + q1x * q2w + q1y * q2z - q1z * q2y;
			this.y = q1w * q2y + q1y * q2w + q1z * q2x - q1x * q2z;
			this.z = q1w * q2z + q1z * q2w + q1x * q2y - q1y * q2x;
			this.w = q1w * q2w - q1x * q2x - q1y * q2y - q1z * q2z;
			return this;
		},
		mul2: function (lhs, rhs) {
			var q1x, q1y, q1z, q1w, q2x, q2y, q2z, q2w;
			q1x = lhs.x;
			q1y = lhs.y;
			q1z = lhs.z;
			q1w = lhs.w;
			q2x = rhs.x;
			q2y = rhs.y;
			q2z = rhs.z;
			q2w = rhs.w;
			this.x = q1w * q2x + q1x * q2w + q1y * q2z - q1z * q2y;
			this.y = q1w * q2y + q1y * q2w + q1z * q2x - q1x * q2z;
			this.z = q1w * q2z + q1z * q2w + q1x * q2y - q1y * q2x;
			this.w = q1w * q2w - q1x * q2x - q1y * q2y - q1z * q2z;
			return this;
		},
		normalize: function () {
			var len = this.length();
			if (len === 0) {
				this.x = this.y = this.z = 0;
				this.w = 1;
			} else {
				len = 1 / len;
				this.x *= len;
				this.y *= len;
				this.z *= len;
				this.w *= len;
			}
			return this;
		},
		set: function (x, y, z, w) {
			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;
			return this;
		},
		setFromAxisAngle: function (axis, angle) {
			var sa, ca;
			angle *= 0.5 * math.DEG_TO_RAD;
			sa = Math.sin(angle);
			ca = Math.cos(angle);
			this.x = sa * axis.x;
			this.y = sa * axis.y;
			this.z = sa * axis.z;
			this.w = ca;
			return this;
		},
		setFromEulerAngles: function (ex, ey, ez) {
			var sx, cx, sy, cy, sz, cz, halfToRad;
			halfToRad = 0.5 * math.DEG_TO_RAD;
			ex *= halfToRad;
			ey *= halfToRad;
			ez *= halfToRad;
			sx = Math.sin(ex);
			cx = Math.cos(ex);
			sy = Math.sin(ey);
			cy = Math.cos(ey);
			sz = Math.sin(ez);
			cz = Math.cos(ez);
			this.x = sx * cy * cz - cx * sy * sz;
			this.y = cx * sy * cz + sx * cy * sz;
			this.z = cx * cy * sz - sx * sy * cz;
			this.w = cx * cy * cz + sx * sy * sz;
			return this;
		},
		setFromMat4: function (m) {
			var m00, m01, m02, m10, m11, m12, m20, m21, m22,
				tr, s, rs, lx, ly, lz;
			m = m.data;
			m00 = m[0];
			m01 = m[1];
			m02 = m[2];
			m10 = m[4];
			m11 = m[5];
			m12 = m[6];
			m20 = m[8];
			m21 = m[9];
			m22 = m[10];
			lx = m00 * m00 + m01 * m01 + m02 * m02;
			if (lx === 0)
				return this;
			lx = 1 / Math.sqrt(lx);
			ly = m10 * m10 + m11 * m11 + m12 * m12;
			if (ly === 0)
				return this;
			ly = 1 / Math.sqrt(ly);
			lz = m20 * m20 + m21 * m21 + m22 * m22;
			if (lz === 0)
				return this;
			lz = 1 / Math.sqrt(lz);
			m00 *= lx;
			m01 *= lx;
			m02 *= lx;
			m10 *= ly;
			m11 *= ly;
			m12 *= ly;
			m20 *= lz;
			m21 *= lz;
			m22 *= lz;
			tr = m00 + m11 + m22;
			if (tr >= 0) {
				s = Math.sqrt(tr + 1);
				this.w = s * 0.5;
				s = 0.5 / s;
				this.x = (m12 - m21) * s;
				this.y = (m20 - m02) * s;
				this.z = (m01 - m10) * s;
			} else {
				if (m00 > m11) {
					if (m00 > m22) {
						rs = (m00 - (m11 + m22)) + 1;
						rs = Math.sqrt(rs);
						this.x = rs * 0.5;
						rs = 0.5 / rs;
						this.w = (m12 - m21) * rs;
						this.y = (m01 + m10) * rs;
						this.z = (m02 + m20) * rs;
					} else {
						rs = (m22 - (m00 + m11)) + 1;
						rs = Math.sqrt(rs);
						this.z = rs * 0.5;
						rs = 0.5 / rs;
						this.w = (m01 - m10) * rs;
						this.x = (m20 + m02) * rs;
						this.y = (m21 + m12) * rs;
					}
				} else if (m11 > m22) {
					rs = (m11 - (m22 + m00)) + 1;
					rs = Math.sqrt(rs);
					this.y = rs * 0.5;
					rs = 0.5 / rs;
					this.w = (m20 - m02) * rs;
					this.z = (m12 + m21) * rs;
					this.x = (m10 + m01) * rs;
				} else {
					rs = (m22 - (m00 + m11)) + 1;
					rs = Math.sqrt(rs);
					this.z = rs * 0.5;
					rs = 0.5 / rs;
					this.w = (m01 - m10) * rs;
					this.x = (m20 + m02) * rs;
					this.y = (m21 + m12) * rs;
				}
			}
			return this;
		},
		slerp: function (lhs, rhs, alpha) {
			var lx, ly, lz, lw, rx, ry, rz, rw;
			lx = lhs.x;
			ly = lhs.y;
			lz = lhs.z;
			lw = lhs.w;
			rx = rhs.x;
			ry = rhs.y;
			rz = rhs.z;
			rw = rhs.w;
			var cosHalfTheta = lw * rw + lx * rx + ly * ry + lz * rz;
			if (cosHalfTheta < 0) {
				rw = -rw;
				rx = -rx;
				ry = -ry;
				rz = -rz;
				cosHalfTheta = -cosHalfTheta;
			}
			if (Math.abs(cosHalfTheta) >= 1) {
				this.w = lw;
				this.x = lx;
				this.y = ly;
				this.z = lz;
				return this;
			}
			var halfTheta = Math.acos(cosHalfTheta);
			var sinHalfTheta = Math.sqrt(1 - cosHalfTheta * cosHalfTheta);
			if (Math.abs(sinHalfTheta) < 0.001) {
				this.w = (lw * 0.5 + rw * 0.5);
				this.x = (lx * 0.5 + rx * 0.5);
				this.y = (ly * 0.5 + ry * 0.5);
				this.z = (lz * 0.5 + rz * 0.5);
				return this;
			}
			var ratioA = Math.sin((1 - alpha) * halfTheta) / sinHalfTheta;
			var ratioB = Math.sin(alpha * halfTheta) / sinHalfTheta;
			this.w = (lw * ratioA + rw * ratioB);
			this.x = (lx * ratioA + rx * ratioB);
			this.y = (ly * ratioA + ry * ratioB);
			this.z = (lz * ratioA + rz * ratioB);
			return this;
		},
		transformVector: function (vec, res) {
			if (res === undefined) {
				res = new Vec3();
			}
			var x = vec.x, y = vec.y, z = vec.z;
			var qx = this.x, qy = this.y, qz = this.z, qw = this.w;
			var ix = qw * x + qy * z - qz * y;
			var iy = qw * y + qz * x - qx * z;
			var iz = qw * z + qx * y - qy * x;
			var iw = -qx * x - qy * y - qz * z;
			res.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
			res.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
			res.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
			return res;
		},
		toString: function () {
			return '[' + this.x + ', ' + this.y + ', ' + this.z + ', ' + this.w + ']';
		}
	});
	Object.defineProperties(Quat, {
		ZERO: { value: new Quat(0, 0, 0, 0) },
		IDENTITY: { value: new Quat(0, 0, 0, 1) }
	});
	Object.freeze(Quat.ZERO);
	Object.freeze(Quat.IDENTITY);

	function Vec2(x, y) {
		if (x && x.length === 2) {
			this.x = x[0];
			this.y = x[1];
		} else {
			this.x = x || 0;
			this.y = y || 0;
		}
	}
	Object.assign(Vec2.prototype, {
		add: function (rhs) {
			this.x += rhs.x;
			this.y += rhs.y;
			return this;
		},
		add2: function (lhs, rhs) {
			this.x = lhs.x + rhs.x;
			this.y = lhs.y + rhs.y;
			return this;
		},
		clone: function () {
			return new Vec2().copy(this);
		},
		copy: function (rhs) {
			this.x = rhs.x;
			this.y = rhs.y;
			return this;
		},
		distance: function (rhs) {
			var x = this.x - rhs.x;
			var y = this.y - rhs.y;
			return Math.sqrt(x * x + y * y);
		},
		dot: function (rhs) {
			return this.x * rhs.x + this.y * rhs.y;
		},
		equals: function (rhs) {
			return this.x === rhs.x && this.y === rhs.y;
		},
		length: function () {
			return Math.sqrt(this.x * this.x + this.y * this.y);
		},
		lengthSq: function () {
			return this.x * this.x + this.y * this.y;
		},
		lerp: function (lhs, rhs, alpha) {
			this.x = lhs.x + alpha * (rhs.x - lhs.x);
			this.y = lhs.y + alpha * (rhs.y - lhs.y);
			return this;
		},
		mul: function (rhs) {
			this.x *= rhs.x;
			this.y *= rhs.y;
			return this;
		},
		mul2: function (lhs, rhs) {
			this.x = lhs.x * rhs.x;
			this.y = lhs.y * rhs.y;
			return this;
		},
		normalize: function () {
			var lengthSq = this.x * this.x + this.y * this.y;
			if (lengthSq > 0) {
				var invLength = 1 / Math.sqrt(lengthSq);
				this.x *= invLength;
				this.y *= invLength;
			}
			return this;
		},
		scale: function (scalar) {
			this.x *= scalar;
			this.y *= scalar;
			return this;
		},
		set: function (x, y) {
			this.x = x;
			this.y = y;
			return this;
		},
		sub: function (rhs) {
			this.x -= rhs.x;
			this.y -= rhs.y;
			return this;
		},
		sub2: function (lhs, rhs) {
			this.x = lhs.x - rhs.x;
			this.y = lhs.y - rhs.y;
			return this;
		},
		toString: function () {
			return '[' + this.x + ', ' + this.y + ']';
		}
	});
	Object.defineProperties(Vec2, {
		ZERO: { value: new Vec2(0, 0) },
		ONE: { value: new Vec2(1, 1) },
		UP: { value: new Vec2(0, 1) },
		DOWN: { value: new Vec2(0, -1) },
		RIGHT: { value: new Vec2(1, 0) },
		LEFT: { value: new Vec2(-1, 0) }
	});
	Object.freeze(Vec2.ZERO);
	Object.freeze(Vec2.ONE);
	Object.freeze(Vec2.UP);
	Object.freeze(Vec2.DOWN);
	Object.freeze(Vec2.RIGHT);
	Object.freeze(Vec2.LEFT);

	var tmpVecA = new Vec3();
	var tmpVecB = new Vec3();
	var tmpVecC = new Vec3();
	var tmpVecD = new Vec3();
	var tmpVecE = new Vec3();
	function BoundingBox(center, halfExtents) {
		this.center = center || new Vec3(0, 0, 0);
		this.halfExtents = halfExtents || new Vec3(0.5, 0.5, 0.5);
		this._min = new Vec3();
		this._max = new Vec3();
	}
	Object.assign(BoundingBox.prototype, {
		add: function (other) {
			var tc = this.center;
			var tcx = tc.x;
			var tcy = tc.y;
			var tcz = tc.z;
			var th = this.halfExtents;
			var thx = th.x;
			var thy = th.y;
			var thz = th.z;
			var tminx = tcx - thx;
			var tmaxx = tcx + thx;
			var tminy = tcy - thy;
			var tmaxy = tcy + thy;
			var tminz = tcz - thz;
			var tmaxz = tcz + thz;
			var oc = other.center;
			var ocx = oc.x;
			var ocy = oc.y;
			var ocz = oc.z;
			var oh = other.halfExtents;
			var ohx = oh.x;
			var ohy = oh.y;
			var ohz = oh.z;
			var ominx = ocx - ohx;
			var omaxx = ocx + ohx;
			var ominy = ocy - ohy;
			var omaxy = ocy + ohy;
			var ominz = ocz - ohz;
			var omaxz = ocz + ohz;
			if (ominx < tminx) tminx = ominx;
			if (omaxx > tmaxx) tmaxx = omaxx;
			if (ominy < tminy) tminy = ominy;
			if (omaxy > tmaxy) tmaxy = omaxy;
			if (ominz < tminz) tminz = ominz;
			if (omaxz > tmaxz) tmaxz = omaxz;
			tc.x = (tminx + tmaxx) * 0.5;
			tc.y = (tminy + tmaxy) * 0.5;
			tc.z = (tminz + tmaxz) * 0.5;
			th.x = (tmaxx - tminx) * 0.5;
			th.y = (tmaxy - tminy) * 0.5;
			th.z = (tmaxz - tminz) * 0.5;
		},
		copy: function (src) {
			this.center.copy(src.center);
			this.halfExtents.copy(src.halfExtents);
			this.type = src.type;
		},
		clone: function () {
			return new BoundingBox(this.center.clone(), this.halfExtents.clone());
		},
		intersects: function (other) {
			var aMax = this.getMax();
			var aMin = this.getMin();
			var bMax = other.getMax();
			var bMin = other.getMin();
			return (aMin.x <= bMax.x) && (aMax.x >= bMin.x) &&
				   (aMin.y <= bMax.y) && (aMax.y >= bMin.y) &&
				   (aMin.z <= bMax.z) && (aMax.z >= bMin.z);
		},
		_intersectsRay: function (ray, point) {
			var tMin = tmpVecA.copy(this.getMin()).sub(ray.origin);
			var tMax = tmpVecB.copy(this.getMax()).sub(ray.origin);
			var dir = ray.direction;
			if (dir.x === 0) {
				tMin.x = tMin.x < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
				tMax.x = tMax.x < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
			} else {
				tMin.x /= dir.x;
				tMax.x /= dir.x;
			}
			if (dir.y === 0) {
				tMin.y = tMin.y < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
				tMax.y = tMax.y < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
			} else {
				tMin.y /= dir.y;
				tMax.y /= dir.y;
			}
			if (dir.z === 0) {
				tMin.z = tMin.z < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
				tMax.z = tMax.z < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
			} else {
				tMin.z /= dir.z;
				tMax.z /= dir.z;
			}
			var realMin = tmpVecC.set(Math.min(tMin.x, tMax.x), Math.min(tMin.y, tMax.y), Math.min(tMin.z, tMax.z));
			var realMax = tmpVecD.set(Math.max(tMin.x, tMax.x), Math.max(tMin.y, tMax.y), Math.max(tMin.z, tMax.z));
			var minMax = Math.min(Math.min(realMax.x, realMax.y), realMax.z);
			var maxMin = Math.max(Math.max(realMin.x, realMin.y), realMin.z);
			var intersects = minMax >= maxMin && maxMin >= 0;
			if (intersects)
				point.copy(ray.direction).scale(maxMin).add(ray.origin);
			return intersects;
		},
		_fastIntersectsRay: function (ray) {
			var diff = tmpVecA;
			var cross = tmpVecB;
			var prod = tmpVecC;
			var absDiff = tmpVecD;
			var absDir = tmpVecE;
			var rayDir = ray.direction;
			diff.sub2(ray.origin, this.center);
			absDiff.set(Math.abs(diff.x), Math.abs(diff.y), Math.abs(diff.z));
			prod.mul2(diff, rayDir);
			if (absDiff.x > this.halfExtents.x && prod.x >= 0)
				return false;
			if (absDiff.y > this.halfExtents.y && prod.y >= 0)
				return false;
			if (absDiff.z > this.halfExtents.z && prod.z >= 0)
				return false;
			absDir.set(Math.abs(rayDir.x), Math.abs(rayDir.y), Math.abs(rayDir.z));
			cross.cross(rayDir, diff);
			cross.set(Math.abs(cross.x), Math.abs(cross.y), Math.abs(cross.z));
			if (cross.x > this.halfExtents.y * absDir.z + this.halfExtents.z * absDir.y)
				return false;
			if (cross.y > this.halfExtents.x * absDir.z + this.halfExtents.z * absDir.x)
				return false;
			if (cross.z > this.halfExtents.x * absDir.y + this.halfExtents.y * absDir.x)
				return false;
			return true;
		},
		intersectsRay: function (ray, point) {
			if (point) {
				return this._intersectsRay(ray, point);
			}
			return this._fastIntersectsRay(ray);
		},
		setMinMax: function (min, max) {
			this.center.add2(max, min).scale(0.5);
			this.halfExtents.sub2(max, min).scale(0.5);
		},
		getMin: function () {
			return this._min.copy(this.center).sub(this.halfExtents);
		},
		getMax: function () {
			return this._max.copy(this.center).add(this.halfExtents);
		},
		containsPoint: function (point) {
			var min = this.getMin();
			var max = this.getMax();
			if (point.x < min.x || point.x > max.x ||
				point.y < min.y || point.y > max.y ||
				point.z < min.z || point.z > max.z) {
				return false;
			}
			return true;
		},
		setFromTransformedAabb: function (aabb, m) {
			var bc = this.center;
			var br = this.halfExtents;
			var ac = aabb.center;
			var ar = aabb.halfExtents;
			m = m.data;
			var mx0 = m[0];
			var mx1 = m[4];
			var mx2 = m[8];
			var my0 = m[1];
			var my1 = m[5];
			var my2 = m[9];
			var mz0 = m[2];
			var mz1 = m[6];
			var mz2 = m[10];
			var mx0a = Math.abs(mx0);
			var mx1a = Math.abs(mx1);
			var mx2a = Math.abs(mx2);
			var my0a = Math.abs(my0);
			var my1a = Math.abs(my1);
			var my2a = Math.abs(my2);
			var mz0a = Math.abs(mz0);
			var mz1a = Math.abs(mz1);
			var mz2a = Math.abs(mz2);
			bc.set(
				m[12] + mx0 * ac.x + mx1 * ac.y + mx2 * ac.z,
				m[13] + my0 * ac.x + my1 * ac.y + my2 * ac.z,
				m[14] + mz0 * ac.x + mz1 * ac.y + mz2 * ac.z
			);
			br.set(
				mx0a * ar.x + mx1a * ar.y + mx2a * ar.z,
				my0a * ar.x + my1a * ar.y + my2a * ar.z,
				mz0a * ar.x + mz1a * ar.y + mz2a * ar.z
			);
		},
		compute: function (vertices, numVerts) {
			numVerts = numVerts === undefined ? vertices.length / 3 : numVerts;
			if (numVerts > 0) {
				var min = tmpVecA.set(vertices[0], vertices[1], vertices[2]);
				var max = tmpVecB.set(vertices[0], vertices[1], vertices[2]);
				for (var i = 1; i < numVerts; i++) {
					var x = vertices[i * 3 + 0];
					var y = vertices[i * 3 + 1];
					var z = vertices[i * 3 + 2];
					if (x < min.x) min.x = x;
					if (y < min.y) min.y = y;
					if (z < min.z) min.z = z;
					if (x > max.x) max.x = x;
					if (y > max.y) max.y = y;
					if (z > max.z) max.z = z;
				}
				this.setMinMax(min, max);
			}
		},
		intersectsBoundingSphere: function (sphere) {
			var sq = this._distanceToBoundingSphereSq(sphere);
			if (sq <= sphere.radius * sphere.radius) {
				return true;
			}
			return false;
		},
		_distanceToBoundingSphereSq: function (sphere) {
			var boxMin = this.getMin();
			var boxMax = this.getMax();
			var sq = 0;
			var axis = ['x', 'y', 'z'];
			for (var i = 0; i < 3; ++i) {
				var out = 0;
				var pn = sphere.center[axis[i]];
				var bMin = boxMin[axis[i]];
				var bMax = boxMax[axis[i]];
				var val = 0;
				if (pn < bMin) {
					val = (bMin - pn);
					out += val * val;
				}
				if (pn > bMax) {
					val = (pn - bMax);
					out += val * val;
				}
				sq += out;
			}
			return sq;
		},
		_expand: function (expandMin, expandMax) {
			tmpVecA.add2(this.getMin(), expandMin);
			tmpVecB.add2(this.getMax(), expandMax);
			this.setMinMax(tmpVecA, tmpVecB);
		}
	});

	var tmpVecA$1 = new Vec3();
	var tmpVecB$1 = new Vec3();
	var tmpVecC$1 = new Vec3();
	var tmpVecD$1 = new Vec3();
	function BoundingSphere(center, radius) {
		this.center = center || new Vec3(0, 0, 0);
		this.radius = radius === undefined ? 0.5 : radius;
	}
	Object.assign(BoundingSphere.prototype, {
		containsPoint: function (point) {
			var lenSq = tmpVecA$1.sub2(point, this.center).lengthSq();
			var r = this.radius;
			return lenSq < r * r;
		},
		compute: function (vertices) {
			var i;
			var numVerts = vertices.length / 3;
			var vertex = tmpVecA$1;
			var avgVertex = tmpVecB$1;
			var sum = tmpVecC$1;
			for (i = 0; i < numVerts; i++) {
				vertex.set(vertices[i * 3], vertices[i * 3 + 1], vertices[i * 3 + 2]);
				sum.addSelf(vertex);
				if (i % 100 === 0) {
					sum.scale(1 / numVerts);
					avgVertex.add(sum);
					sum.set(0, 0, 0);
				}
			}
			sum.scale(1 / numVerts);
			avgVertex.add(sum);
			this.center.copy(avgVertex);
			var maxDistSq = 0;
			var centerToVert = tmpVecD$1;
			for (i = 0; i < numVerts; i++) {
				vertex.set(vertices[i * 3], vertices[i * 3 + 1], vertices[i * 3 + 2]);
				centerToVert.sub2(vertex, this.center);
				maxDistSq = Math.max(centerToVert.lengthSq(), maxDistSq);
			}
			this.radius = Math.sqrt(maxDistSq);
		},
		intersectsRay: function (ray, point) {
			var m = tmpVecA$1.copy(ray.origin).sub(this.center);
			var b = m.dot(tmpVecB$1.copy(ray.direction).normalize());
			var c = m.dot(m) - this.radius * this.radius;
			if (c > 0 && b > 0)
				return null;
			var discr = b * b - c;
			if (discr < 0)
				return false;
			var t = Math.abs(-b - Math.sqrt(discr));
			if (point)
				point.copy(ray.direction).scale(t).add(ray.origin);
			return true;
		},
		intersectsBoundingSphere: function (sphere) {
			tmpVecA$1.sub2(sphere.center, this.center);
			var totalRadius = sphere.radius + this.radius;
			if (tmpVecA$1.lengthSq() <= totalRadius * totalRadius) {
				return true;
			}
			return false;
		}
	});

	function Frustum() {
		this.planes = [];
		for (var i = 0; i < 6; i++)
			this.planes[i] = [];
	}
	Object.assign(Frustum.prototype, {
		setFromMat4: function (matrix) {
			var vpm = matrix.data;
			var plane;
			var planes = this.planes;
			plane = planes[0];
			plane[0] = vpm[3] - vpm[0];
			plane[1] = vpm[7] - vpm[4];
			plane[2] = vpm[11] - vpm[8];
			plane[3] = vpm[15] - vpm[12];
			var t = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);
			plane[0] /= t;
			plane[1] /= t;
			plane[2] /= t;
			plane[3] /= t;
			plane = planes[1];
			plane[0] = vpm[3] + vpm[0];
			plane[1] = vpm[7] + vpm[4];
			plane[2] = vpm[11] + vpm[8];
			plane[3] = vpm[15] + vpm[12];
			t = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);
			plane[0] /= t;
			plane[1] /= t;
			plane[2] /= t;
			plane[3] /= t;
			plane = planes[2];
			plane[0] = vpm[3] + vpm[1];
			plane[1] = vpm[7] + vpm[5];
			plane[2] = vpm[11] + vpm[9];
			plane[3] = vpm[15] + vpm[13];
			t = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);
			plane[0] /= t;
			plane[1] /= t;
			plane[2] /= t;
			plane[3] /= t;
			plane = planes[3];
			plane[0] = vpm[3] - vpm[1];
			plane[1] = vpm[7] - vpm[5];
			plane[2] = vpm[11] - vpm[9];
			plane[3] = vpm[15] - vpm[13];
			t = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);
			plane[0] /= t;
			plane[1] /= t;
			plane[2] /= t;
			plane[3] /= t;
			plane = planes[4];
			plane[0] = vpm[3] - vpm[2];
			plane[1] = vpm[7] - vpm[6];
			plane[2] = vpm[11] - vpm[10];
			plane[3] = vpm[15] - vpm[14];
			t = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);
			plane[0] /= t;
			plane[1] /= t;
			plane[2] /= t;
			plane[3] /= t;
			plane = planes[5];
			plane[0] = vpm[3] + vpm[2];
			plane[1] = vpm[7] + vpm[6];
			plane[2] = vpm[11] + vpm[10];
			plane[3] = vpm[15] + vpm[14];
			t = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);
			plane[0] /= t;
			plane[1] /= t;
			plane[2] /= t;
			plane[3] /= t;
		},
		containsPoint: function (point) {
			var p, plane;
			for (p = 0; p < 6; p++) {
				plane = this.planes[p];
				if (plane[0] * point.x + plane[1] * point.y + plane[2] * point.z + plane[3] <= 0) {
					return false;
				}
			}
			return true;
		},
		containsSphere: function (sphere) {
			var c = 0;
			var d;
			var p;
			var sr = sphere.radius;
			var sc = sphere.center;
			var scx = sc.x;
			var scy = sc.y;
			var scz = sc.z;
			var planes = this.planes;
			var plane;
			for (p = 0; p < 6; p++) {
				plane = planes[p];
				d = plane[0] * scx + plane[1] * scy + plane[2] * scz + plane[3];
				if (d <= -sr)
					return 0;
				if (d > sr)
					c++;
			}
			return (c === 6) ? 2 : 1;
		}
	});

	function Ray(origin, direction) {
		this.origin = origin || new Vec3(0, 0, 0);
		this.direction = direction || new Vec3(0, 0, -1);
	}
	Ray.prototype.set = function (origin, direction) {
		this.origin.copy(origin);
		this.direction.copy(direction);
		return this;
	};

	var tmpRay = new Ray();
	var tmpVec3 = new Vec3();
	var tmpSphere = new BoundingSphere();
	var tmpMat4 = new Mat4();
	function OrientedBox(worldTransform, halfExtents) {
		this.halfExtents = halfExtents || new Vec3(0.5, 0.5, 0.5);
		worldTransform = worldTransform || tmpMat4.setIdentity();
		this._modelTransform = worldTransform.clone().invert();
		this._worldTransform = worldTransform.clone();
		this._aabb = new BoundingBox(new Vec3(), this.halfExtents);
	}
	Object.assign(OrientedBox.prototype, {
		intersectsRay: function (ray, point) {
			this._modelTransform.transformPoint(ray.origin, tmpRay.origin);
			this._modelTransform.transformVector(ray.direction, tmpRay.direction);
			if (point) {
				var result = this._aabb._intersectsRay(tmpRay, point);
				tmpMat4.copy(this._modelTransform).invert().transformPoint(point, point);
				return result;
			}
			return this._aabb._fastIntersectsRay(tmpRay);
		},
		containsPoint: function (point) {
			this._modelTransform.transformPoint(point, tmpVec3);
			return this._aabb.containsPoint(tmpVec3);
		},
		intersectsBoundingSphere: function (sphere) {
			this._modelTransform.transformPoint(sphere.center, tmpSphere.center);
			tmpSphere.radius = sphere.radius;
			if (this._aabb.intersectsBoundingSphere(tmpSphere)) {
				return true;
			}
			return false;
		}
	});
	Object.defineProperty(OrientedBox.prototype, 'worldTransform', {
		get: function () {
			return this._worldTransform;
		},
		set: function (value) {
			this._worldTransform.copy(value);
			this._modelTransform.copy(value).invert();
		}
	});

	var tmpVecA$2 = new Vec3();
	function Plane(point, normal) {
		this.normal = normal || new Vec3(0, 0, 1);
		this.point = point || new Vec3(0, 0, 0);
	}
	Object.assign(Plane.prototype, {
		intersectsLine: function (start, end, point) {
			var d = -this.normal.dot(this.point);
			var d0 = this.normal.dot(start) + d;
			var d1 = this.normal.dot(end) + d;
			var t = d0 / (d0 - d1);
			var intersects = t >= 0 && t <= 1;
			if (intersects && point)
				point.lerp(start, end, t);
			return intersects;
		},
		intersectsRay: function (ray, point) {
			var pointToOrigin = tmpVecA$2.sub2(this.point, ray.origin);
			var t = this.normal.dot(pointToOrigin) / this.normal.dot(ray.direction);
			var intersects = t >= 0;
			if (intersects && point)
				point.copy(ray.direction).scale(t).add(ray.origin);
			return intersects;
		}
	});

	var ADDRESS_REPEAT = 0;
	var ADDRESS_CLAMP_TO_EDGE = 1;
	var ADDRESS_MIRRORED_REPEAT = 2;
	var BLENDMODE_ZERO = 0;
	var BLENDMODE_ONE = 1;
	var BLENDMODE_SRC_COLOR = 2;
	var BLENDMODE_ONE_MINUS_SRC_COLOR = 3;
	var BLENDMODE_DST_COLOR = 4;
	var BLENDMODE_ONE_MINUS_DST_COLOR = 5;
	var BLENDMODE_SRC_ALPHA = 6;
	var BLENDMODE_SRC_ALPHA_SATURATE = 7;
	var BLENDMODE_ONE_MINUS_SRC_ALPHA = 8;
	var BLENDMODE_DST_ALPHA = 9;
	var BLENDMODE_ONE_MINUS_DST_ALPHA = 10;
	var BLENDEQUATION_ADD = 0;
	var BLENDEQUATION_SUBTRACT = 1;
	var BLENDEQUATION_REVERSE_SUBTRACT = 2;
	var BLENDEQUATION_MIN = 3;
	var BLENDEQUATION_MAX = 4;
	var BUFFER_STATIC = 0;
	var BUFFER_DYNAMIC = 1;
	var BUFFER_STREAM = 2;
	var BUFFER_GPUDYNAMIC = 3;
	var CLEARFLAG_COLOR = 1;
	var CLEARFLAG_DEPTH = 2;
	var CLEARFLAG_STENCIL = 4;
	var CUBEFACE_POSX = 0;
	var CUBEFACE_NEGX = 1;
	var CUBEFACE_POSY = 2;
	var CUBEFACE_NEGY = 3;
	var CUBEFACE_POSZ = 4;
	var CUBEFACE_NEGZ = 5;
	var CULLFACE_NONE = 0;
	var CULLFACE_BACK = 1;
	var CULLFACE_FRONT = 2;
	var CULLFACE_FRONTANDBACK = 3;
	var FILTER_NEAREST = 0;
	var FILTER_LINEAR = 1;
	var FILTER_NEAREST_MIPMAP_NEAREST = 2;
	var FILTER_NEAREST_MIPMAP_LINEAR = 3;
	var FILTER_LINEAR_MIPMAP_NEAREST = 4;
	var FILTER_LINEAR_MIPMAP_LINEAR = 5;
	var FUNC_NEVER = 0;
	var FUNC_LESS = 1;
	var FUNC_EQUAL = 2;
	var FUNC_LESSEQUAL = 3;
	var FUNC_GREATER = 4;
	var FUNC_NOTEQUAL = 5;
	var FUNC_GREATEREQUAL = 6;
	var FUNC_ALWAYS = 7;
	var INDEXFORMAT_UINT8 = 0;
	var INDEXFORMAT_UINT16 = 1;
	var INDEXFORMAT_UINT32 = 2;
	var PIXELFORMAT_A8 = 0;
	var PIXELFORMAT_L8 = 1;
	var PIXELFORMAT_L8_A8 = 2;
	var PIXELFORMAT_R5_G6_B5 = 3;
	var PIXELFORMAT_R5_G5_B5_A1 = 4;
	var PIXELFORMAT_R4_G4_B4_A4 = 5;
	var PIXELFORMAT_R8_G8_B8 = 6;
	var PIXELFORMAT_R8_G8_B8_A8 = 7;
	var PIXELFORMAT_DXT1 = 8;
	var PIXELFORMAT_DXT3 = 9;
	var PIXELFORMAT_DXT5 = 10;
	var PIXELFORMAT_RGB16F = 11;
	var PIXELFORMAT_RGBA16F = 12;
	var PIXELFORMAT_RGB32F = 13;
	var PIXELFORMAT_RGBA32F = 14;
	var PIXELFORMAT_R32F = 15;
	var PIXELFORMAT_DEPTH = 16;
	var PIXELFORMAT_DEPTHSTENCIL = 17;
	var PIXELFORMAT_111110F = 18;
	var PIXELFORMAT_SRGB = 19;
	var PIXELFORMAT_SRGBA = 20;
	var PIXELFORMAT_ETC1 = 21;
	var PIXELFORMAT_ETC2_RGB = 22;
	var PIXELFORMAT_ETC2_RGBA = 23;
	var PIXELFORMAT_PVRTC_2BPP_RGB_1 = 24;
	var PIXELFORMAT_PVRTC_2BPP_RGBA_1 = 25;
	var PIXELFORMAT_PVRTC_4BPP_RGB_1 = 26;
	var PIXELFORMAT_PVRTC_4BPP_RGBA_1 = 27;
	var PIXELFORMAT_ASTC_4x4 = 28;
	var PIXELFORMAT_ATC_RGB = 29;
	var PIXELFORMAT_ATC_RGBA = 30;
	var PRIMITIVE_POINTS = 0;
	var PRIMITIVE_LINES = 1;
	var PRIMITIVE_LINELOOP = 2;
	var PRIMITIVE_LINESTRIP = 3;
	var PRIMITIVE_TRIANGLES = 4;
	var PRIMITIVE_TRISTRIP = 5;
	var PRIMITIVE_TRIFAN = 6;
	var SEMANTIC_POSITION = "POSITION";
	var SEMANTIC_NORMAL = "NORMAL";
	var SEMANTIC_TANGENT = "TANGENT";
	var SEMANTIC_BLENDWEIGHT = "BLENDWEIGHT";
	var SEMANTIC_BLENDINDICES = "BLENDINDICES";
	var SEMANTIC_COLOR = "COLOR";
	var SEMANTIC_TEXCOORD = "TEXCOORD";
	var SEMANTIC_TEXCOORD0 = "TEXCOORD0";
	var SEMANTIC_TEXCOORD1 = "TEXCOORD1";
	var SEMANTIC_TEXCOORD2 = "TEXCOORD2";
	var SEMANTIC_TEXCOORD3 = "TEXCOORD3";
	var SEMANTIC_TEXCOORD4 = "TEXCOORD4";
	var SEMANTIC_TEXCOORD5 = "TEXCOORD5";
	var SEMANTIC_TEXCOORD6 = "TEXCOORD6";
	var SEMANTIC_TEXCOORD7 = "TEXCOORD7";
	var SEMANTIC_ATTR = "ATTR";
	var SEMANTIC_ATTR0 = "ATTR0";
	var SEMANTIC_ATTR1 = "ATTR1";
	var SEMANTIC_ATTR2 = "ATTR2";
	var SEMANTIC_ATTR3 = "ATTR3";
	var SEMANTIC_ATTR4 = "ATTR4";
	var SEMANTIC_ATTR5 = "ATTR5";
	var SEMANTIC_ATTR6 = "ATTR6";
	var SEMANTIC_ATTR7 = "ATTR7";
	var SEMANTIC_ATTR8 = "ATTR8";
	var SEMANTIC_ATTR9 = "ATTR9";
	var SEMANTIC_ATTR10 = "ATTR10";
	var SEMANTIC_ATTR11 = "ATTR11";
	var SEMANTIC_ATTR12 = "ATTR12";
	var SEMANTIC_ATTR13 = "ATTR13";
	var SEMANTIC_ATTR14 = "ATTR14";
	var SEMANTIC_ATTR15 = "ATTR15";
	var SHADERTAG_MATERIAL = 1;
	var STENCILOP_KEEP = 0;
	var STENCILOP_ZERO = 1;
	var STENCILOP_REPLACE = 2;
	var STENCILOP_INCREMENT = 3;
	var STENCILOP_INCREMENTWRAP = 4;
	var STENCILOP_DECREMENT = 5;
	var STENCILOP_DECREMENTWRAP = 6;
	var STENCILOP_INVERT = 7;
	var TEXTURELOCK_READ = 1;
	var TEXTURELOCK_WRITE = 2;
	var TEXTURETYPE_DEFAULT = 'default';
	var TEXTURETYPE_RGBM = 'rgbm';
	var TEXTURETYPE_RGBE = 'rgbe';
	var TEXTURETYPE_SWIZZLEGGGR = 'swizzleGGGR';
	var TEXHINT_NONE = 0;
	var TEXHINT_SHADOWMAP = 1;
	var TEXHINT_ASSET = 2;
	var TEXHINT_LIGHTMAP = 3;
	var TYPE_INT8 = 0;
	var TYPE_UINT8 = 1;
	var TYPE_INT16 = 2;
	var TYPE_UINT16 = 3;
	var TYPE_INT32 = 4;
	var TYPE_UINT32 = 5;
	var TYPE_FLOAT32 = 6;
	var UNIFORMTYPE_BOOL = 0;
	var UNIFORMTYPE_INT = 1;
	var UNIFORMTYPE_FLOAT = 2;
	var UNIFORMTYPE_VEC2 = 3;
	var UNIFORMTYPE_VEC3 = 4;
	var UNIFORMTYPE_VEC4 = 5;
	var UNIFORMTYPE_IVEC2 = 6;
	var UNIFORMTYPE_IVEC3 = 7;
	var UNIFORMTYPE_IVEC4 = 8;
	var UNIFORMTYPE_BVEC2 = 9;
	var UNIFORMTYPE_BVEC3 = 10;
	var UNIFORMTYPE_BVEC4 = 11;
	var UNIFORMTYPE_MAT2 = 12;
	var UNIFORMTYPE_MAT3 = 13;
	var UNIFORMTYPE_MAT4 = 14;
	var UNIFORMTYPE_TEXTURE2D = 15;
	var UNIFORMTYPE_TEXTURECUBE = 16;
	var UNIFORMTYPE_FLOATARRAY = 17;
	var UNIFORMTYPE_TEXTURE2D_SHADOW = 18;
	var UNIFORMTYPE_TEXTURECUBE_SHADOW = 19;
	var UNIFORMTYPE_TEXTURE3D = 20;
	var UNIFORMTYPE_VEC2ARRAY = 21;
	var UNIFORMTYPE_VEC3ARRAY = 22;
	var UNIFORMTYPE_VEC4ARRAY = 23;
	var typedArrayTypes = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array];
	var typedArrayTypesByteSize = [1, 1, 2, 2, 4, 4, 4];
	var typedArrayToType = {
		"Int8Array": TYPE_INT8,
		"Uint8Array": TYPE_UINT8,
		"Int16Array": TYPE_INT16,
		"Uint16Array": TYPE_UINT16,
		"Int32Array": TYPE_INT32,
		"Uint32Array": TYPE_UINT32,
		"Float32Array": TYPE_FLOAT32
	};
	var typedArrayIndexFormats = [Uint8Array, Uint16Array, Uint32Array];
	var typedArrayIndexFormatsByteSize = [1, 2, 4];
	var semanticToLocation = {};
	semanticToLocation[SEMANTIC_POSITION] = 0;
	semanticToLocation[SEMANTIC_NORMAL] = 1;
	semanticToLocation[SEMANTIC_BLENDWEIGHT] = 2;
	semanticToLocation[SEMANTIC_BLENDINDICES] = 3;
	semanticToLocation[SEMANTIC_COLOR] = 4;
	semanticToLocation[SEMANTIC_TEXCOORD0] = 5;
	semanticToLocation[SEMANTIC_TEXCOORD1] = 6;
	semanticToLocation[SEMANTIC_TEXCOORD2] = 7;
	semanticToLocation[SEMANTIC_TEXCOORD3] = 8;
	semanticToLocation[SEMANTIC_TEXCOORD4] = 9;
	semanticToLocation[SEMANTIC_TEXCOORD5] = 10;
	semanticToLocation[SEMANTIC_TEXCOORD6] = 11;
	semanticToLocation[SEMANTIC_TEXCOORD7] = 12;
	semanticToLocation[SEMANTIC_TANGENT] = 13;
	semanticToLocation[SEMANTIC_ATTR0] = 0;
	semanticToLocation[SEMANTIC_ATTR1] = 1;
	semanticToLocation[SEMANTIC_ATTR2] = 2;
	semanticToLocation[SEMANTIC_ATTR3] = 3;
	semanticToLocation[SEMANTIC_ATTR4] = 4;
	semanticToLocation[SEMANTIC_ATTR5] = 5;
	semanticToLocation[SEMANTIC_ATTR6] = 6;
	semanticToLocation[SEMANTIC_ATTR7] = 7;
	semanticToLocation[SEMANTIC_ATTR8] = 8;
	semanticToLocation[SEMANTIC_ATTR9] = 9;
	semanticToLocation[SEMANTIC_ATTR10] = 10;
	semanticToLocation[SEMANTIC_ATTR11] = 11;
	semanticToLocation[SEMANTIC_ATTR12] = 12;
	semanticToLocation[SEMANTIC_ATTR13] = 13;
	semanticToLocation[SEMANTIC_ATTR14] = 14;
	semanticToLocation[SEMANTIC_ATTR15] = 15;

	var id = 0;
	function VertexBuffer(graphicsDevice, format, numVertices, usage, initialData) {
		this.usage = usage || BUFFER_STATIC;
		this.format = format;
		this.numVertices = numVertices;
		this.id = id++;
		this.numBytes = format.verticesByteSize ? format.verticesByteSize : format.size * numVertices;
		graphicsDevice._vram.vb += this.numBytes;
		this.device = graphicsDevice;
		if (initialData) {
			this.setData(initialData);
		} else {
			this.storage = new ArrayBuffer(this.numBytes);
		}
		this.device.buffers.push(this);
	}
	Object.assign(VertexBuffer.prototype, {
		destroy: function () {
			var device = this.device;
			var idx = device.buffers.indexOf(this);
			if (idx !== -1) {
				device.buffers.splice(idx, 1);
			}
			if (this.bufferId) {
				var gl = device.gl;
				device.boundVao = null;
				gl.bindVertexArray(null);
				gl.deleteBuffer(this.bufferId);
				device._vram.vb -= this.storage.byteLength;
				this.bufferId = null;
			}
		},
		getFormat: function () {
			return this.format;
		},
		getUsage: function () {
			return this.usage;
		},
		getNumVertices: function () {
			return this.numVertices;
		},
		lock: function () {
			return this.storage;
		},
		unlock: function () {
			var gl = this.device.gl;
			if (!this.bufferId) {
				this.bufferId = gl.createBuffer();
			}
			var glUsage;
			switch (this.usage) {
				case BUFFER_STATIC:
					glUsage = gl.STATIC_DRAW;
					break;
				case BUFFER_DYNAMIC:
					glUsage = gl.DYNAMIC_DRAW;
					break;
				case BUFFER_STREAM:
					glUsage = gl.STREAM_DRAW;
					break;
				case BUFFER_GPUDYNAMIC:
					if (this.device.webgl2) {
						glUsage = gl.DYNAMIC_COPY;
					} else {
						glUsage = gl.STATIC_DRAW;
					}
					break;
			}
			gl.bindBuffer(gl.ARRAY_BUFFER, this.bufferId);
			gl.bufferData(gl.ARRAY_BUFFER, this.storage, glUsage);
		},
		setData: function (data) {
			if (data.byteLength !== this.numBytes) {
				console.error("VertexBuffer: wrong initial data size: expected " + this.numBytes + ", got " + data.byteLength);
				return false;
			}
			this.storage = data;
			this.unlock();
			return true;
		}
	});

	function hashCode(str) {
		var hash = 0;
		for (var i = 0, len = str.length; i < len; i++) {
			hash = ((hash << 5) - hash) + str.charCodeAt(i);
			hash |= 0;
		}
		return hash;
	}

	function VertexFormat(graphicsDevice, description, vertexCount) {
		var i, len, element;
		this.elements = [];
		this.hasUv0 = false;
		this.hasUv1 = false;
		this.hasColor = false;
		this.hasTangents = false;
		this._defaultInstancingFormat = null;
		this.verticesByteSize = 0;
		this.vertexCount = vertexCount;
		this.interleaved = !vertexCount;
		this.size = description.reduce(function (total, desc) {
			return total + Math.ceil(desc.components * typedArrayTypesByteSize[desc.type] / 4) * 4;
		}, 0);
		var offset = 0, elementSize;
		for (i = 0, len = description.length; i < len; i++) {
			var elementDesc = description[i];
			elementSize = elementDesc.components * typedArrayTypesByteSize[elementDesc.type];
			if (vertexCount) {
				offset = math.roundUp(offset, elementSize);
			}
			element = {
				name: elementDesc.semantic,
				offset: (vertexCount ? offset : (elementDesc.hasOwnProperty('offset') ? elementDesc.offset : offset)),
				stride: (vertexCount ? elementSize : (elementDesc.hasOwnProperty('stride') ? elementDesc.stride : this.size)),
				dataType: elementDesc.type,
				numComponents: elementDesc.components,
				normalize: (elementDesc.normalize === undefined) ? false : elementDesc.normalize,
				size: elementSize
			};
			this.elements.push(element);
			if (vertexCount) {
				offset += elementSize * vertexCount;
			} else {
				offset += Math.ceil(elementSize / 4) * 4;
			}
			if (elementDesc.semantic === SEMANTIC_TEXCOORD0) {
				this.hasUv0 = true;
			} else if (elementDesc.semantic === SEMANTIC_TEXCOORD1) {
				this.hasUv1 = true;
			} else if (elementDesc.semantic === SEMANTIC_COLOR) {
				this.hasColor = true;
			} else if (elementDesc.semantic === SEMANTIC_TANGENT) {
				this.hasTangents = true;
			}
		}
		if (vertexCount) {
			this.verticesByteSize = offset;
		}
		this.update();
	}
	VertexFormat.init = function (graphicsDevice) {
		var formatDesc = [
			{ semantic: SEMANTIC_TEXCOORD2, components: 4, type: TYPE_FLOAT32 },
			{ semantic: SEMANTIC_TEXCOORD3, components: 4, type: TYPE_FLOAT32 },
			{ semantic: SEMANTIC_TEXCOORD4, components: 4, type: TYPE_FLOAT32 },
			{ semantic: SEMANTIC_TEXCOORD5, components: 4, type: TYPE_FLOAT32 }
		];
		this._defaultInstancingFormat = new VertexFormat(graphicsDevice, formatDesc);
	};
	Object.defineProperty(VertexFormat, 'defaultInstancingFormat', {
		get: (function () {
			return function () {
				return this._defaultInstancingFormat;
			};
		}())
	});
	Object.assign(VertexFormat.prototype, {
		update: function () {
			this._evaluateHash();
		},
		_evaluateHash: function () {
			var stringElementBatch, stringElementsBatch = [];
			var stringElementRender, stringElementsRender = [];
			var i, len = this.elements.length, element;
			for (i = 0; i < len; i++) {
				element = this.elements[i];
				stringElementBatch = element.name;
				stringElementBatch += element.dataType;
				stringElementBatch += element.numComponents;
				stringElementBatch += element.normalize;
				stringElementsBatch.push(stringElementBatch);
				stringElementRender = stringElementBatch;
				stringElementRender += element.offset;
				stringElementRender += element.stride;
				stringElementRender += element.size;
				stringElementsRender.push(stringElementRender);
			}
			stringElementsBatch.sort();
			this.batchingHash = hashCode(stringElementsBatch.join());
			this.renderingingHash = hashCode(stringElementsRender.join());
		}
	});

	function VertexIteratorAccessor(buffer, vertexElement, vertexFormat) {
		this.index = 0;
		this.numComponents = vertexElement.numComponents;
		if (vertexFormat.interleaved) {
			this.array = new typedArrayTypes[vertexElement.dataType](buffer, vertexElement.offset);
		} else {
			this.array = new typedArrayTypes[vertexElement.dataType](buffer, vertexElement.offset, vertexFormat.vertexCount * vertexElement.numComponents);
		}
		this.stride = vertexElement.stride / this.array.constructor.BYTES_PER_ELEMENT;
		switch (vertexElement.numComponents) {
			case 1:
				this.set = VertexIteratorAccessor_set1;
				this.getToArray = VertexIteratorAccessor_arrayGet1;
				this.setFromArray = VertexIteratorAccessor_arraySet1;
				break;
			case 2:
				this.set = VertexIteratorAccessor_set2;
				this.getToArray = VertexIteratorAccessor_arrayGet2;
				this.setFromArray = VertexIteratorAccessor_arraySet2;
				break;
			case 3:
				this.set = VertexIteratorAccessor_set3;
				this.getToArray = VertexIteratorAccessor_arrayGet3;
				this.setFromArray = VertexIteratorAccessor_arraySet3;
				break;
			case 4:
				this.set = VertexIteratorAccessor_set4;
				this.getToArray = VertexIteratorAccessor_arrayGet4;
				this.setFromArray = VertexIteratorAccessor_arraySet4;
				break;
		}
	}
	VertexIteratorAccessor.prototype.get = function (offset) {
		return this.array[this.index + offset];
	};
	VertexIteratorAccessor.prototype.set = function (a, b, c, d) {
	};
	function VertexIteratorAccessor_set1(a) {
		this.array[this.index] = a;
	}
	function VertexIteratorAccessor_set2(a, b) {
		this.array[this.index] = a;
		this.array[this.index + 1] = b;
	}
	function VertexIteratorAccessor_set3(a, b, c) {
		this.array[this.index] = a;
		this.array[this.index + 1] = b;
		this.array[this.index + 2] = c;
	}
	function VertexIteratorAccessor_set4(a, b, c, d) {
		this.array[this.index] = a;
		this.array[this.index + 1] = b;
		this.array[this.index + 2] = c;
		this.array[this.index + 3] = d;
	}
	VertexIteratorAccessor.prototype.setFromArray = function (index, inputArray, inputIndex) {
	};
	function VertexIteratorAccessor_arraySet1(index, inputArray, inputIndex) {
		this.array[index] = inputArray[inputIndex];
	}
	function VertexIteratorAccessor_arraySet2(index, inputArray, inputIndex) {
		this.array[index] = inputArray[inputIndex];
		this.array[index + 1] = inputArray[inputIndex + 1];
	}
	function VertexIteratorAccessor_arraySet3(index, inputArray, inputIndex) {
		this.array[index] = inputArray[inputIndex];
		this.array[index + 1] = inputArray[inputIndex + 1];
		this.array[index + 2] = inputArray[inputIndex + 2];
	}
	function VertexIteratorAccessor_arraySet4(index, inputArray, inputIndex) {
		this.array[index] = inputArray[inputIndex];
		this.array[index + 1] = inputArray[inputIndex + 1];
		this.array[index + 2] = inputArray[inputIndex + 2];
		this.array[index + 3] = inputArray[inputIndex + 3];
	}
	VertexIteratorAccessor.prototype.getToArray = function (offset, outputArray, outputIndex) {
	};
	function VertexIteratorAccessor_arrayGet1(offset, outputArray, outputIndex) {
		outputArray[outputIndex] = this.array[offset];
	}
	function VertexIteratorAccessor_arrayGet2(offset, outputArray, outputIndex) {
		outputArray[outputIndex] = this.array[offset];
		outputArray[outputIndex + 1] = this.array[offset + 1];
	}
	function VertexIteratorAccessor_arrayGet3(offset, outputArray, outputIndex) {
		outputArray[outputIndex] = this.array[offset];
		outputArray[outputIndex + 1] = this.array[offset + 1];
		outputArray[outputIndex + 2] = this.array[offset + 2];
	}
	function VertexIteratorAccessor_arrayGet4(offset, outputArray, outputIndex) {
		outputArray[outputIndex] = this.array[offset];
		outputArray[outputIndex + 1] = this.array[offset + 1];
		outputArray[outputIndex + 2] = this.array[offset + 2];
		outputArray[outputIndex + 3] = this.array[offset + 3];
	}
	function VertexIterator(vertexBuffer) {
		this.vertexBuffer = vertexBuffer;
		this.vertexFormatSize = vertexBuffer.getFormat().size;
		this.buffer = this.vertexBuffer.lock();
		this.accessors = [];
		this.element = {};
		var vertexFormat = this.vertexBuffer.getFormat();
		for (var i = 0; i < vertexFormat.elements.length; i++) {
			var vertexElement = vertexFormat.elements[i];
			this.accessors[i] = new VertexIteratorAccessor(this.buffer, vertexElement, vertexFormat);
			this.element[vertexElement.name] = this.accessors[i];
		}
	}
	Object.assign(VertexIterator.prototype, {
		next: function (count) {
			if (count === undefined) count = 1;
			var i = 0;
			var accessors = this.accessors;
			var numAccessors = this.accessors.length;
			while (i < numAccessors) {
				var accessor = accessors[i++];
				accessor.index += count * accessor.stride;
			}
		},
		end: function () {
			this.vertexBuffer.unlock();
		},
		writeData: function (semantic, data, numVertices) {
			var element = this.element[semantic];
			if (element) {
				if (numVertices > this.vertexBuffer.numVertices) {
					numVertices = this.vertexBuffer.numVertices;
				}
				var i, numComponents = element.numComponents;
				if (this.vertexBuffer.getFormat().interleaved) {
					var index = 0;
					for (i = 0; i < numVertices; i++) {
						element.setFromArray(index, data, i * numComponents);
						index += element.stride;
					}
				} else {
					if (data.length > numVertices * numComponents) {
						var copyCount = numVertices * numComponents;
						if (ArrayBuffer.isView(data)) {
							data = data.subarray(0, copyCount);
							element.array.set(data);
						} else {
							for (i = 0; i < copyCount; i++)
								element.array[i] = data[i];
						}
					} else {
						element.array.set(data);
					}
				}
			}
		},
		readData: function (semantic, data) {
			var element = this.element[semantic];
			var count = 0;
			if (element) {
				count = this.vertexBuffer.numVertices;
				var i, numComponents = element.numComponents;
				if (this.vertexBuffer.getFormat().interleaved) {
					if  (Array.isArray(data))
						data.length = 0;
					element.index = 0;
					var offset = 0;
					for (i = 0; i < count; i++) {
						element.getToArray(offset, data, i * numComponents);
						offset += element.stride;
					}
				} else {
					if (ArrayBuffer.isView(data)) {
						data.set(element.array);
					} else {
						data.length = 0;
						var copyCount = count * numComponents;
						for (i = 0; i < copyCount; i++)
							data[i] = element.array[i];
					}
				}
			}
			return count;
		}
	});

	var _postEffectQuadVB = null;
	var _postEffectQuadDraw = {
		type: PRIMITIVE_TRISTRIP,
		base: 0,
		count: 4,
		indexed: false
	};
	function drawQuadWithShader(device, target, shader, rect, scissorRect, useBlend) {
		if (_postEffectQuadVB === null) {
			var vertexFormat = new VertexFormat(device, [{
				semantic: SEMANTIC_POSITION,
				components: 2,
				type: TYPE_FLOAT32
			}]);
			_postEffectQuadVB = new VertexBuffer(device, vertexFormat, 4);
			var iterator = new VertexIterator(_postEffectQuadVB);
			iterator.element[SEMANTIC_POSITION].set(-1.0, -1.0);
			iterator.next();
			iterator.element[SEMANTIC_POSITION].set(1.0, -1.0);
			iterator.next();
			iterator.element[SEMANTIC_POSITION].set(-1.0, 1.0);
			iterator.next();
			iterator.element[SEMANTIC_POSITION].set(1.0, 1.0);
			iterator.end();
		}
		var oldRt = device.renderTarget;
		device.setRenderTarget(target);
		device.updateBegin();
		var x, y, w, h;
		var sx, sy, sw, sh;
		if (!rect) {
			w = target ? target.width : device.width;
			h = target ? target.height : device.height;
			x = 0;
			y = 0;
		} else {
			x = rect.x;
			y = rect.y;
			w = rect.z;
			h = rect.w;
		}
		if (!scissorRect) {
			sx = x;
			sy = y;
			sw = w;
			sh = h;
		} else {
			sx = scissorRect.x;
			sy = scissorRect.y;
			sw = scissorRect.z;
			sh = scissorRect.w;
		}
		var oldVx = device.vx;
		var oldVy = device.vy;
		var oldVw = device.vw;
		var oldVh = device.vh;
		device.setViewport(x, y, w, h);
		var oldSx = device.sx;
		var oldSy = device.sy;
		var oldSw = device.sw;
		var oldSh = device.sh;
		device.setScissor(sx, sy, sw, sh);
		var oldDepthTest = device.getDepthTest();
		var oldDepthWrite = device.getDepthWrite();
		var oldCullMode = device.getCullMode();
		var oldWR = device.writeRed;
		var oldWG = device.writeGreen;
		var oldWB = device.writeBlue;
		var oldWA = device.writeAlpha;
		device.setDepthTest(false);
		device.setDepthWrite(false);
		device.setCullMode(CULLFACE_NONE);
		device.setColorWrite(true, true, true, true);
		if (!useBlend) device.setBlending(false);
		device.setVertexBuffer(_postEffectQuadVB, 0);
		device.setShader(shader);
		device.draw(_postEffectQuadDraw);
		device.setDepthTest(oldDepthTest);
		device.setDepthWrite(oldDepthWrite);
		device.setCullMode(oldCullMode);
		device.setColorWrite(oldWR, oldWG, oldWB, oldWA);
		device.updateEnd();
		device.setRenderTarget(oldRt);
		device.updateBegin();
		device.setViewport(oldVx, oldVy, oldVw, oldVh);
		device.setScissor(oldSx, oldSy, oldSw, oldSh);
	}
	function destroyPostEffectQuad() {
		if (_postEffectQuadVB) {
			_postEffectQuadVB.destroy();
			_postEffectQuadVB = null;
		}
	}
	function drawTexture(device, texture, target, shader, rect, scissorRect, useBlend) {
		shader = shader || device.getCopyShader();
		device.constantTexSource.setValue(texture);
		drawQuadWithShader(device, target, shader, rect, scissorRect, useBlend);
	}

	function Shader(graphicsDevice, definition) {
		this.device = graphicsDevice;
		this.definition = definition;
		this.attributes = [];
		this.uniforms = [];
		this.samplers = [];
		this.ready = false;
		this.failed = false;
		this.device.createShader(this);
	}
	Object.assign(Shader.prototype, {
		destroy: function () {
			this.device.destroyShader(this);
		}
	});

	var alphaTestPS = "uniform float alpha_ref;\nvoid alphaTest(float a) {\n\tif (a < alpha_ref) discard;\n}\n";

	var ambientConstantPS = "void addAmbient() {\n\tdDiffuseLight += light_globalAmbient;\n}\n";

	var ambientPrefilteredCubePS = "#ifndef PMREM4\n#define PMREM4\nuniform samplerCube texture_prefilteredCubeMap4;\n#endif\nvoid addAmbient() {\n\tvec3 fixedReflDir = fixSeamsStatic(dNormalW, 1.0 - 1.0 / 4.0);\n\tfixedReflDir.x *= -1.0;\n\tdDiffuseLight += processEnvironment($DECODE(textureCube(texture_prefilteredCubeMap4, fixedReflDir)).rgb);\n}\n";

	var ambientPrefilteredCubeLodPS = "#ifndef PMREM4\n#define PMREM4\n#extension GL_EXT_shader_texture_lod : enable\nuniform samplerCube texture_prefilteredCubeMap128;\n#endif\nvoid addAmbient() {\n\tvec3 fixedReflDir = fixSeamsStatic(dNormalW, 1.0 - 1.0 / 4.0);\n\tfixedReflDir.x *= -1.0;\n\tdDiffuseLight += processEnvironment($DECODE( textureCubeLodEXT(texture_prefilteredCubeMap128, fixedReflDir, 5.0) ).rgb);\n}\n";

	var ambientSHPS = "uniform vec3 ambientSH[9];\nvoid addAmbient() {\n\tvec3 n = dNormalW;\n\tvec3 color =\n\t\tambientSH[0] +\n\t\tambientSH[1] * n.x +\n\t\tambientSH[2] * n.y +\n\t\tambientSH[3] * n.z +\n\t\tambientSH[4] * n.x * n.z +\n\t\tambientSH[5] * n.z * n.y +\n\t\tambientSH[6] * n.y * n.x +\n\t\tambientSH[7] * (3.0 * n.z * n.z - 1.0) +\n\t\tambientSH[8] * (n.x * n.x - n.y * n.y);\n\tdDiffuseLight += processEnvironment(max(color, vec3(0.0)));\n}\n";

	var aoPS = "#ifdef MAPTEXTURE\nuniform sampler2D texture_aoMap;\n#endif\nvoid applyAO() {\n\tdAo = 1.0;\n\t#ifdef MAPTEXTURE\n\tdAo *= texture2D(texture_aoMap, $UV).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tdAo *= saturate(vVertexColor.$VC);\n\t#endif\n\tdDiffuseLight *= dAo;\n}\n";

	var aoSpecOccPS = "uniform float material_occludeSpecularIntensity;\nvoid occludeSpecular() {\n\tfloat specPow = exp2(dGlossiness * 11.0);\n\tfloat specOcc = saturate(pow(dot(dNormalW, dViewDirW) + dAo, 0.01*specPow) - 1.0 + dAo);\n\tspecOcc = mix(1.0, specOcc, material_occludeSpecularIntensity);\n\tdSpecularLight *= specOcc;\n\tdReflection *= specOcc;\n}\n";

	var aoSpecOccConstPS = "void occludeSpecular() {\n\tfloat specPow = exp2(dGlossiness * 11.0);\n\tfloat specOcc = saturate(pow(dot(dNormalW, dViewDirW) + dAo, 0.01*specPow) - 1.0 + dAo);\n\tdSpecularLight *= specOcc;\n\tdReflection *= specOcc;\n}\n";

	var aoSpecOccConstSimplePS = "void occludeSpecular() {\n\tfloat specOcc = dAo;\n\tdSpecularLight *= specOcc;\n\tdReflection *= specOcc;\n}\n";

	var aoSpecOccSimplePS = "uniform float material_occludeSpecularIntensity;\nvoid occludeSpecular() {\n\tfloat specOcc = mix(1.0, dAo, material_occludeSpecularIntensity);\n\tdSpecularLight *= specOcc;\n\tdReflection *= specOcc;\n}\n";

	var bakeDirLmEndPS = "\tvec4 dirLm = texture2D(texture_dirLightMap, vUv1);\n\tif (bakeDir > 0.5) {\n\t\tif (dAtten > 0.00001) {\n\t\t\tdirLm.xyz = dirLm.xyz * 2.0 - vec3(1.0);\n\t\t\tdAtten = saturate(dAtten);\n\t\t\tgl_FragColor.rgb = normalize(dLightDirNormW.xyz*dAtten + dirLm.xyz*dirLm.w) * 0.5 + vec3(0.5);\n\t\t\tgl_FragColor.a = dirLm.w + dAtten;\n\t\t\tgl_FragColor.a = max(gl_FragColor.a, 1.0 / 255.0);\n\t\t} else {\n\t\t\tgl_FragColor = dirLm;\n\t\t}\n\t} else {\n\t\tgl_FragColor.rgb = dirLm.xyz;\n\t\tgl_FragColor.a = max(dirLm.w, dAtten > 0.00001? (1.0/255.0) : 0.0);\n\t}\n";

	var bakeLmEndPS = "\tgl_FragColor.rgb = dDiffuseLight;\n\tgl_FragColor.rgb = pow(gl_FragColor.rgb, vec3(0.5));\n\tgl_FragColor.rgb /= 8.0;\n\tgl_FragColor.a = clamp( max( max( gl_FragColor.r, gl_FragColor.g ), max( gl_FragColor.b, 1.0 / 255.0 ) ), 0.0,1.0 );\n\tgl_FragColor.a = ceil(gl_FragColor.a * 255.0) / 255.0;\n\tgl_FragColor.rgb /= gl_FragColor.a;\n";

	var basePS = "uniform vec3 view_position;\nuniform vec3 light_globalAmbient;\nfloat square(float x) {\n\treturn x*x;\n}\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\nvec3 saturate(vec3 x) {\n\treturn clamp(x, vec3(0.0), vec3(1.0));\n}\n";

	var baseVS = "attribute vec3 vertex_position;\nattribute vec3 vertex_normal;\nattribute vec4 vertex_tangent;\nattribute vec2 vertex_texCoord0;\nattribute vec2 vertex_texCoord1;\nattribute vec4 vertex_color;\nuniform mat4 matrix_viewProjection;\nuniform mat4 matrix_model;\nuniform mat3 matrix_normal;\nvec3 dPositionW;\nmat4 dModelMatrix;\nmat3 dNormalMatrix;\nvec3 dLightPosW;\nvec3 dLightDirNormW;\nvec3 dNormalW;\n";

	var baseNineSlicedPS = "#define NINESLICED\nvarying vec2 vMask;\nvarying vec2 vTiledUv;\nuniform mediump vec4 innerOffset;\nuniform mediump vec2 outerScale;\nuniform mediump vec4 atlasRect;\nvec2 nineSlicedUv;\n";

	var baseNineSlicedVS = "#define NINESLICED\nvarying vec2 vMask;\nvarying vec2 vTiledUv;\nuniform mediump vec4 innerOffset;\nuniform mediump vec2 outerScale;\nuniform mediump vec4 atlasRect;\n";

	var baseNineSlicedTiledPS = "#define NINESLICED\n#define NINESLICETILED\nvarying vec2 vMask;\nvarying vec2 vTiledUv;\nuniform mediump vec4 innerOffset;\nuniform mediump vec2 outerScale;\nuniform mediump vec4 atlasRect;\nvec2 nineSlicedUv;\n";

	var biasConstPS = "#define SHADOWBIAS\nfloat getShadowBias(float resolution, float maxBias) {\n\treturn maxBias;\n}\n";

	var blurVSMPS = "varying vec2 vUv0;\nuniform sampler2D source;\nuniform vec2 pixelOffset;\n#ifdef GAUSS\nuniform float weight[SAMPLES];\n#endif\n#ifdef PACKED\nfloat decodeFloatRG(vec2 rg) {\n\treturn rg.y*(1.0/255.0) + rg.x;\n}\nvec2 encodeFloatRG( float v ) {\n\tvec2 enc = vec2(1.0, 255.0) * v;\n\tenc = fract(enc);\n\tenc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);\n\treturn enc;\n}\n#endif\nvoid main(void) {\n\tvec3 moments = vec3(0.0);\n\tvec2 uv = vUv0 - pixelOffset * (float(SAMPLES) * 0.5);\n\tfor (int i=0; i<SAMPLES; i++) {\n\t\tvec4 c = texture2D(source, uv + pixelOffset * float(i));\n\t\t#ifdef PACKED\n\t\tc.xy = vec2(decodeFloatRG(c.xy), decodeFloatRG(c.zw));\n\t\t#endif\n\t\t#ifdef GAUSS\n\t\tmoments += c.xyz * weight[i];\n\t\t#else\n\t\tmoments += c.xyz;\n\t\t#endif\n\t}\n\t#ifndef GAUSS\n\tmoments /= float(SAMPLES);\n\t#endif\n\t#ifdef PACKED\n\tgl_FragColor = vec4(encodeFloatRG(moments.x), encodeFloatRG(moments.y));\n\t#else\n\tgl_FragColor = vec4(moments.x, moments.y, moments.z, 1.0);\n\t#endif\n}\n";

	var combineClearCoatPS = "vec3 combineColorCC() {\n\treturn combineColor()+(ccSpecularLight*ccSpecularity+ccReflection.rgb*ccSpecularity*ccReflection.a);\n}\n";

	var combineDiffusePS = "vec3 combineColor() {\n\treturn dAlbedo * dDiffuseLight;\n}\n";

	var combineDiffuseSpecularPS = "vec3 combineColor() {\n\treturn mix(dAlbedo * dDiffuseLight, dSpecularLight + dReflection.rgb * dReflection.a, dSpecularity);\n}\n";

	var combineDiffuseSpecularNoConservePS = "vec3 combineColor() {\n\treturn dAlbedo * dDiffuseLight + (dSpecularLight + dReflection.rgb * dReflection.a) * dSpecularity;\n}\n";

	var combineDiffuseSpecularNoReflPS = "vec3 combineColor() {\n\treturn dAlbedo * dDiffuseLight + dSpecularLight * dSpecularity;\n}\n";

	var combineDiffuseSpecularNoReflSeparateAmbientPS = "uniform vec3 material_ambient;\nvec3 combineColor() {\n\treturn (dDiffuseLight - light_globalAmbient) * dAlbedo + dSpecularLight * dSpecularity + material_ambient * light_globalAmbient;\n}\n";

	var combineDiffuseSpecularOldPS = "vec3 combineColor() {\n\treturn mix(dAlbedo * dDiffuseLight + dSpecularLight * dSpecularity, dReflection.rgb, dReflection.a);\n}\n";

	var cookiePS = "vec4 getCookie2D(sampler2D tex, mat4 transform, float intensity) {\n\tvec4 projPos = transform * vec4(vPositionW, 1.0);\n\tprojPos.xy /= projPos.w;\n\treturn mix(vec4(1.0), texture2D(tex, projPos.xy), intensity);\n}\nvec4 getCookie2DClip(sampler2D tex, mat4 transform, float intensity) {\n\tvec4 projPos = transform * vec4(vPositionW, 1.0);\n\tprojPos.xy /= projPos.w;\n\tif (projPos.x < 0.0 || projPos.x > 1.0 || projPos.y < 0.0 || projPos.y > 1.0 || projPos.z < 0.0) return vec4(0.0);\n\treturn mix(vec4(1.0), texture2D(tex, projPos.xy), intensity);\n}\nvec4 getCookie2DXform(sampler2D tex, mat4 transform, float intensity, vec4 cookieMatrix, vec2 cookieOffset) {\n\tvec4 projPos = transform * vec4(vPositionW, 1.0);\n\tprojPos.xy /= projPos.w;\n\tprojPos.xy += cookieOffset;\n\tvec2 uv = mat2(cookieMatrix) * (projPos.xy-vec2(0.5)) + vec2(0.5);\n\treturn mix(vec4(1.0), texture2D(tex, uv), intensity);\n}\nvec4 getCookie2DClipXform(sampler2D tex, mat4 transform, float intensity, vec4 cookieMatrix, vec2 cookieOffset) {\n\tvec4 projPos = transform * vec4(vPositionW, 1.0);\n\tprojPos.xy /= projPos.w;\n\tprojPos.xy += cookieOffset;\n\tif (projPos.x < 0.0 || projPos.x > 1.0 || projPos.y < 0.0 || projPos.y > 1.0 || projPos.z < 0.0) return vec4(0.0);\n\tvec2 uv = mat2(cookieMatrix) * (projPos.xy-vec2(0.5)) + vec2(0.5);\n\treturn mix(vec4(1.0), texture2D(tex, uv), intensity);\n}\nvec4 getCookieCube(samplerCube tex, mat4 transform, float intensity) {\n\treturn mix(vec4(1.0), textureCube(tex, dLightDirNormW * mat3(transform)), intensity);\n}\n";

	var cubeMapProjectBoxPS = "uniform vec3 envBoxMin, envBoxMax;\nvec3 cubeMapProject(vec3 nrdir) {\n\tvec3 rbmax = (envBoxMax - vPositionW) / nrdir;\n\tvec3 rbmin = (envBoxMin - vPositionW) / nrdir;\n\tvec3 rbminmax;\n\trbminmax.x = nrdir.x>0.0? rbmax.x : rbmin.x;\n\trbminmax.y = nrdir.y>0.0? rbmax.y : rbmin.y;\n\trbminmax.z = nrdir.z>0.0? rbmax.z : rbmin.z;\n\tfloat fa = min(min(rbminmax.x, rbminmax.y), rbminmax.z);\n\tvec3 posonbox = vPositionW + nrdir * fa;\n\tvec3 envBoxPos = (envBoxMin + envBoxMax) * 0.5;\n\treturn posonbox - envBoxPos;\n}\n";

	var cubeMapProjectNonePS = "vec3 cubeMapProject(vec3 dir) {\n\treturn dir;\n}\n";

	var detailModesPS = "vec3 detailMode_mul(vec3 c1, vec3 c2) {\n\treturn c1 * c2;\n}\nvec3 detailMode_add(vec3 c1, vec3 c2) {\n\treturn c1 + c2;\n}\nvec3 detailMode_screen(vec3 c1, vec3 c2) {\n\treturn 1.0 - (1.0 - c1)*(1.0 - c2);\n}\nvec3 detailMode_overlay(vec3 c1, vec3 c2) {\n\treturn mix(1.0 - 2.0*(1.0 - c1)*(1.0 - c2), 2.0*c1*c2, step(c1, vec3(0.5)));\n}\nvec3 detailMode_min(vec3 c1, vec3 c2) {\n\treturn min(c1, c2);\n}\nvec3 detailMode_max(vec3 c1, vec3 c2) {\n\treturn max(c1, c2);\n}\n";

	var diffusePS = "#ifdef MAPCOLOR\nuniform vec3 material_diffuse;\n#endif\n#ifdef MAPTEXTURE\nuniform sampler2D texture_diffuseMap;\n#endif\nvoid getAlbedo() {\n\tdAlbedo = vec3(1.0);\n\t#ifdef MAPCOLOR\n\tdAlbedo *= material_diffuse.rgb;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tdAlbedo *= gammaCorrectInput(addAlbedoDetail(texture2D(texture_diffuseMap, $UV).$CH));\n\t#endif\n\t#ifdef MAPVERTEX\n\tdAlbedo *= gammaCorrectInput(saturate(vVertexColor.$VC));\n\t#endif\n}\n";

	var diffuseDetailMapPS = "#ifdef MAPTEXTURE\nuniform sampler2D texture_diffuseDetailMap;\n#endif\nvec3 addAlbedoDetail(vec3 albedo) {\n\t#ifdef MAPTEXTURE\n\tvec3 albedoDetail = vec3(texture2D(texture_diffuseDetailMap, $UV).$CH);\n\treturn detailMode_$DETAILMODE(albedo, albedoDetail);\n\t#else\n\treturn albedo;\n\t#endif\n}\n";

	var dilatePS = "varying vec2 vUv0;\nuniform sampler2D source;\nuniform vec2 pixelOffset;\nvoid main(void) {\n\tvec4 c = texture2D(source, vUv0);\n\tc = c.a>0.0? c : texture2D(source, vUv0 - pixelOffset);\n\tc = c.a>0.0? c : texture2D(source, vUv0 + vec2(0, -pixelOffset.y));\n\tc = c.a>0.0? c : texture2D(source, vUv0 + vec2(pixelOffset.x, -pixelOffset.y));\n\tc = c.a>0.0? c : texture2D(source, vUv0 + vec2(-pixelOffset.x, 0));\n\tc = c.a>0.0? c : texture2D(source, vUv0 + vec2(pixelOffset.x, 0));\n\tc = c.a>0.0? c : texture2D(source, vUv0 + vec2(-pixelOffset.x, pixelOffset.y));\n\tc = c.a>0.0? c : texture2D(source, vUv0 + vec2(0, pixelOffset.y));\n\tc = c.a>0.0? c : texture2D(source, vUv0 + pixelOffset);\n\tgl_FragColor = c;\n}\n";

	var dpAtlasQuadPS = "varying vec2 vUv0;\nuniform sampler2D source;\nuniform vec4 params;\nvoid main(void) {\n\tvec2 uv = vUv0;\n\tuv = uv * 2.0 - vec2(1.0);\n\tuv *= params.xy;\n\tuv = uv * 0.5 + 0.5;\n\tgl_FragColor = texture2D(source, uv);\n}\n";

	var emissivePS = "#ifdef MAPCOLOR\nuniform vec3 material_emissive;\n#endif\n#ifdef MAPFLOAT\nuniform float material_emissiveIntensity;\n#endif\n#ifdef MAPTEXTURE\nuniform sampler2D texture_emissiveMap;\n#endif\nvec3 getEmission() {\n\tvec3 emission = vec3(1.0);\n\t#ifdef MAPFLOAT\n\temission *= material_emissiveIntensity;\n\t#endif\n\t#ifdef MAPCOLOR\n\temission *= material_emissive;\n\t#endif\n\t#ifdef MAPTEXTURE\n\temission *= $texture2DSAMPLE(texture_emissiveMap, $UV).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\temission *= gammaCorrectInput(saturate(vVertexColor.$VC));\n\t#endif\n\treturn emission;\n}\n";

	var endPS = "\t#ifdef CLEARCOAT\n\tgl_FragColor.rgb = combineColorCC();\n\t#else\n\tgl_FragColor.rgb = combineColor();\n\t#endif\n\tgl_FragColor.rgb += getEmission();\n\tgl_FragColor.rgb = addFog(gl_FragColor.rgb);\n\t#ifndef HDR\n\tgl_FragColor.rgb = toneMap(gl_FragColor.rgb);\n\tgl_FragColor.rgb = gammaCorrectOutput(gl_FragColor.rgb);\n\t#endif\n";

	var envConstPS = "vec3 processEnvironment(vec3 color) {\n\treturn color;\n}\n";

	var envMultiplyPS = "uniform float skyboxIntensity;\nvec3 processEnvironment(vec3 color) {\n\treturn color * skyboxIntensity;\n}\n";

	var extensionPS = "\n";

	var extensionVS = "\n";

	var falloffInvSquaredPS = "float getFalloffInvSquared(float lightRadius) {\n\tfloat sqrDist = dot(dLightDirW, dLightDirW);\n\tfloat falloff = 1.0 / (sqrDist + 1.0);\n\tfloat invRadius = 1.0 / lightRadius;\n\tfalloff *= 16.0;\n\tfalloff *= square( saturate( 1.0 - square( sqrDist * square(invRadius) ) ) );\n\treturn falloff;\n}\n";

	var falloffLinearPS = "float getFalloffLinear(float lightRadius) {\n\tfloat d = length(dLightDirW);\n\treturn max(((lightRadius - d) / lightRadius), 0.0);\n}\n";

	var fixCubemapSeamsNonePS = "vec3 fixSeams(vec3 vec, float mipmapIndex) {\n\treturn vec;\n}\nvec3 fixSeams(vec3 vec) {\n\treturn vec;\n}\nvec3 fixSeamsStatic(vec3 vec, float invRecMipSize) {\n\treturn vec;\n}\n";

	var fixCubemapSeamsStretchPS = "vec3 fixSeams(vec3 vec, float mipmapIndex) {\n\tfloat scale = 1.0 - exp2(mipmapIndex) / 128.0;\n\tfloat M = max(max(abs(vec.x), abs(vec.y)), abs(vec.z));\n\tif (abs(vec.x) != M) vec.x *= scale;\n\tif (abs(vec.y) != M) vec.y *= scale;\n\tif (abs(vec.z) != M) vec.z *= scale;\n\treturn vec;\n}\nvec3 fixSeams(vec3 vec) {\n\tfloat scale = 1.0 - 1.0 / 128.0;\n\tfloat M = max(max(abs(vec.x), abs(vec.y)), abs(vec.z));\n\tif (abs(vec.x) != M) vec.x *= scale;\n\tif (abs(vec.y) != M) vec.y *= scale;\n\tif (abs(vec.z) != M) vec.z *= scale;\n\treturn vec;\n}\nvec3 fixSeamsStatic(vec3 vec, float invRecMipSize) {\n\tfloat scale = invRecMipSize;\n\tfloat M = max(max(abs(vec.x), abs(vec.y)), abs(vec.z));\n\tif (abs(vec.x) != M) vec.x *= scale;\n\tif (abs(vec.y) != M) vec.y *= scale;\n\tif (abs(vec.z) != M) vec.z *= scale;\n\treturn vec;\n}\n";

	var fogExpPS = "uniform vec3 fog_color;\nuniform float fog_density;\nfloat dBlendModeFogFactor = 1.0;\nvec3 addFog(vec3 color) {\n\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\tfloat fogFactor = exp(-depth * fog_density);\n\tfogFactor = clamp(fogFactor, 0.0, 1.0);\n\treturn mix(fog_color * dBlendModeFogFactor, color, fogFactor);\n}\n";

	var fogExp2PS = "uniform vec3 fog_color;\nuniform float fog_density;\nfloat dBlendModeFogFactor = 1.0;\nvec3 addFog(vec3 color) {\n\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\tfloat fogFactor = exp(-depth * depth * fog_density * fog_density);\n\tfogFactor = clamp(fogFactor, 0.0, 1.0);\n\treturn mix(fog_color * dBlendModeFogFactor, color, fogFactor);\n}\n";

	var fogLinearPS = "uniform vec3 fog_color;\nuniform float fog_start;\nuniform float fog_end;\nfloat dBlendModeFogFactor = 1.0;\nvec3 addFog(vec3 color) {\n\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\tfloat fogFactor = (fog_end - depth) / (fog_end - fog_start);\n\tfogFactor = clamp(fogFactor, 0.0, 1.0);\n\tfogFactor = gammaCorrectInput(fogFactor);\n\treturn mix(fog_color * dBlendModeFogFactor, color, fogFactor);\n}\n";

	var fogNonePS = "float dBlendModeFogFactor = 1.0;\nvec3 addFog(vec3 color) {\n\treturn color;\n}\n";

	var fresnelSchlickPS = "\nuniform float material_fresnelFactor;\nvoid getFresnel() {\n\tfloat fresnel = 1.0 - max(dot(dNormalW, dViewDirW), 0.0);\n\tfloat fresnel2 = fresnel * fresnel;\n\tfresnel *= fresnel2 * fresnel2;\n\tfresnel *= dGlossiness * dGlossiness;\n\tdSpecularity = dSpecularity + (1.0 - dSpecularity) * fresnel;\n\t#ifdef CLEARCOAT\n\tfresnel = 1.0 - max(dot(ccNormalW, dViewDirW), 0.0);\n\tfresnel2 = fresnel * fresnel;\n\tfresnel *= fresnel2 * fresnel2;\n\tfresnel *= ccGlossiness * ccGlossiness;\n\tccSpecularity = ccSpecularity + (1.0 - ccSpecularity) * fresnel;\n\t#endif\n}\n";

	var fullscreenQuadPS = "varying vec2 vUv0;\nuniform sampler2D source;\nvoid main(void) {\n\tgl_FragColor = texture2D(source, vUv0);\n}\n";

	var fullscreenQuadVS = "attribute vec2 vertex_position;\nvarying vec2 vUv0;\nvoid main(void)\n{\n\tgl_Position = vec4(vertex_position, 0.5, 1.0);\n\tvUv0 = vertex_position.xy*0.5+0.5;\n}\n";

	var gamma1_0PS = "vec4 texture2DSRGB(sampler2D tex, vec2 uv) {\n\treturn texture2D(tex, uv);\n}\nvec4 texture2DSRGB(sampler2D tex, vec2 uv, float bias) {\n\treturn texture2D(tex, uv, bias);\n}\nvec4 textureCubeSRGB(samplerCube tex, vec3 uvw) {\n\treturn textureCube(tex, uvw);\n}\nvec3 gammaCorrectOutput(vec3 color) {\n\treturn color;\n}\nvec3 gammaCorrectInput(vec3 color) {\n\treturn color;\n}\nfloat gammaCorrectInput(float color) {\n\treturn color;\n}\nvec4 gammaCorrectInput(vec4 color) {\n\treturn color;\n}\n";

	var gamma2_2PS = "vec3 gammaCorrectInput(vec3 color) {\n\treturn pow(color, vec3(2.2));\n}\nfloat gammaCorrectInput(float color) {\n\treturn pow(color, 2.2);\n}\nvec4 gammaCorrectInput(vec4 color) {\n\treturn vec4(pow(color.rgb, vec3(2.2)), color.a);\n}\nvec4 texture2DSRGB(sampler2D tex, vec2 uv) {\n\tvec4 rgba = texture2D(tex, uv);\n\trgba.rgb = gammaCorrectInput(rgba.rgb);\n\treturn rgba;\n}\nvec4 texture2DSRGB(sampler2D tex, vec2 uv, float bias) {\n\tvec4 rgba = texture2D(tex, uv, bias);\n\trgba.rgb = gammaCorrectInput(rgba.rgb);\n\treturn rgba;\n}\nvec4 textureCubeSRGB(samplerCube tex, vec3 uvw) {\n\tvec4 rgba = textureCube(tex, uvw);\n\trgba.rgb = gammaCorrectInput(rgba.rgb);\n\treturn rgba;\n}\nvec3 gammaCorrectOutput(vec3 color) {\n\t#ifdef HDR\n\treturn color;\n\t#else\n\tcolor += vec3(0.0000001);\n\treturn pow(color, vec3(0.45));\n\t#endif\n}\n";

	var genParaboloidPS = "varying vec2 vUv0;\nuniform samplerCube source;\nuniform vec4 params;\nvoid main(void) {\n\tvec2 uv = vUv0;\n\tfloat side = uv.x < 0.5? 1.0 : -1.0;\n\tvec2 tc;\n\ttc.x = fract(uv.x * 2.0) * 2.0 - 1.0;\n\ttc.y = uv.y * 2.0 - 1.0;\n\tconst float scale = 1.1;\n\ttc *= scale;\n\tvec3 dir;\n\tdir.y = (dot(tc, tc) - 1.0) * side;\n\tdir.xz = tc * -2.0;\n\tdir.x *= -side * params.y;\n\tdir = fixSeams(dir, params.x);\n\tvec4 color = textureCube(source, dir, -100.0);\n\tgl_FragColor = color;\n}\n";

	var gles3PS = "#define varying in\nout highp vec4 pc_fragColor;\n#define gl_FragColor pc_fragColor\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad\n#define GL2\n";

	var gles3VS = "#define attribute in\n#define varying out\n#define texture2D texture\n#define GL2\n#define VERTEXSHADER\n";

	var glossPS = "#ifdef MAPFLOAT\nuniform float material_shininess;\n#endif\n#ifdef MAPTEXTURE\nuniform sampler2D texture_glossMap;\n#endif\n#ifdef CLEARCOAT\nuniform float material_clearCoatGlossiness;\n#endif\nvoid getGlossiness() {\n\tdGlossiness = 1.0;\n\t#ifdef MAPFLOAT\n\tdGlossiness *= material_shininess;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tdGlossiness *= texture2D(texture_glossMap, $UV).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tdGlossiness *= saturate(vVertexColor.$VC);\n\t#endif\n\tdGlossiness += 0.0000001;\n\t#ifdef CLEARCOAT\n\tccGlossiness = 1.0;\n\tccGlossiness *= material_clearCoatGlossiness;\n\tccGlossiness += 0.0000001;\n\t#endif\n}\n";

	var instancingVS = "attribute vec4 instance_line1;\nattribute vec4 instance_line2;\nattribute vec4 instance_line3;\nattribute vec4 instance_line4;\n";

	var lightDiffuseLambertPS = "float getLightDiffuse() {\n\treturn max(dot(dNormalW, -dLightDirNormW), 0.0);\n}\n";

	var lightDirPointPS = "void getLightDirPoint(vec3 lightPosW) {\n\tdLightDirW = vPositionW - lightPosW;\n\tdLightDirNormW = normalize(dLightDirW);\n\tdLightPosW = lightPosW;\n}\n";

	var lightmapDirPS = "uniform sampler2D texture_lightMap;\nuniform sampler2D texture_dirLightMap;\nvoid addLightMap() {\n\tvec3 color = $texture2DSAMPLE(texture_lightMap, $UV).$CH;\n\tvec4 dir = texture2D(texture_dirLightMap, $UV);\n\tif (dot(dir.xyz,vec3(1.0)) < 0.00001) {\n\t\tdDiffuseLight += color;\n\t\treturn;\n\t}\n\tdLightDirNormW = normalize(dir.xyz * 2.0 - vec3(1.0));\n\tfloat vlight = saturate(dot(dLightDirNormW, -dVertexNormalW));\n\tfloat flight = saturate(dot(dLightDirNormW, -dNormalW));\n\tfloat nlight = (flight / max(vlight,0.01)) * 0.5;\n\tdDiffuseLight += color * nlight * 2.0;\n}\nvoid addDirLightMap() {\n\tvec4 dir = texture2D(texture_dirLightMap, $UV);\n\tif (dot(dir.xyz,vec3(1.0)) < 0.00001) return;\n\tvec3 color = $texture2DSAMPLE(texture_lightMap, $UV).$CH;\n\tdLightDirNormW = normalize(dir.xyz * 2.0 - vec3(1.0));\n\tdSpecularLight += vec3(getLightSpecular()) * color;\n}\n";

	var lightmapSinglePS = "#ifdef MAPTEXTURE\nuniform sampler2D texture_lightMap;\n#endif\nvoid addLightMap() {\n\tvec3 lm = vec3(1.0);\n\t#ifdef MAPTEXTURE\n\tlm *= $texture2DSAMPLE(texture_lightMap, $UV).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tlm *= saturate(vVertexColor.$VC);\n\t#endif\n\tdDiffuseLight += lm;\n}\n";

	var lightmapSingleVertPS = "void addLightMap() {\n\tdDiffuseLight += saturate(vVertexColor.$CH);\n}\n";

	var lightSpecularAnisoGGXPS = "\nfloat calcLightSpecular(float tGlossiness, vec3 tNormalW) {\n\tfloat PI = 3.141592653589793;\n\tfloat roughness = max((1.0 - tGlossiness) * (1.0 - tGlossiness), 0.001);\n\tfloat anisotropy = material_anisotropy * roughness;\n\tfloat at = max((roughness + anisotropy), roughness / 4.0);\n\tfloat ab = max((roughness - anisotropy), roughness / 4.0);\n\tvec3 h = normalize(normalize(-dLightDirNormW) + normalize(dViewDirW));\n\tfloat NoH = dot(tNormalW, h);\n\tfloat ToH = dot(dTBN[0], h);\n\tfloat BoH = dot(dTBN[1], h);\n\tfloat a2 = at * ab;\n\tvec3 v = vec3(ab * ToH, at * BoH, a2 * NoH);\n\tfloat v2 = dot(v, v);\n\tfloat w2 = a2 / v2;\n\tfloat D = a2 * w2 * w2 * (1.0 / PI);\n\tfloat ToV = dot(dTBN[0], dViewDirW);\n\tfloat BoV = dot(dTBN[1], dViewDirW);\n\tfloat ToL = dot(dTBN[0], -dLightDirNormW);\n\tfloat BoL = dot(dTBN[1], -dLightDirNormW);\n\tfloat NoV = dot(tNormalW, dViewDirW);\n\tfloat NoL = dot(tNormalW, -dLightDirNormW);\n\tfloat lambdaV = NoL * length(vec3(at * ToV, ab * BoV, NoV));\n\tfloat lambdaL = NoV * length(vec3(at * ToL, ab * BoL, NoL));\n\tfloat G = 0.5 / (lambdaV + lambdaL);\n\treturn D * G;\n}\nfloat getLightSpecular() {\n\treturn calcLightSpecular(dGlossiness, dNormalW);\n}\nfloat getLightSpecularCC() {\n\treturn calcLightSpecular(ccGlossiness, ccNormalW);\n}\n";

	var lightSpecularBlinnPS = "\nfloat calcLightSpecular(float tGlossiness, vec3 tNormalW) {\n\tvec3 h = normalize( -dLightDirNormW + dViewDirW );\n\tfloat nh = max( dot( h, tNormalW ), 0.0 );\n\tfloat specPow = exp2(tGlossiness * 11.0);\n\tspecPow = antiAliasGlossiness(specPow);\n\tspecPow = max(specPow, 0.0001);\n\treturn pow(nh, specPow) * (specPow + 2.0) / 8.0;\n}\nfloat getLightSpecular() {\n\treturn calcLightSpecular(dGlossiness, dNormalW);\n}\nfloat getLightSpecularCC() {\n\treturn calcLightSpecular(ccGlossiness, ccNormalW);\n}\n";

	var lightSpecularPhongPS = "float calcLightSpecular(float tGlossiness, vec3 tReflDirW) {\n\tfloat specPow = tGlossiness;\n\tspecPow = antiAliasGlossiness(specPow);\n\treturn pow(max(dot(tReflDirW, -dLightDirNormW), 0.0), specPow + 0.0001);\n}\nfloat getLightSpecular() {\n\treturn calcLightSpecular(dGlossiness, dReflDirW);\n}\nfloat getLightSpecularCC() {\n\treturn calcLightSpecular(ccGlossiness, ccReflDirW);\n}\n";

	var metalnessPS = "void processMetalness(float metalness) {\n\tconst float dielectricF0 = 0.04;\n\tdSpecularity = mix(vec3(dielectricF0), dAlbedo, metalness);\n\tdAlbedo *= 1.0 - metalness;\n}\n#ifdef MAPFLOAT\nuniform float material_metalness;\n#endif\n#ifdef MAPTEXTURE\nuniform sampler2D texture_metalnessMap;\n#endif\n#ifdef CLEARCOAT\nuniform float material_clearCoatSpecularity;\n#endif\nvoid getSpecularity() {\n\tfloat metalness = 1.0;\n\t#ifdef MAPFLOAT\n\tmetalness *= material_metalness;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tmetalness *= texture2D(texture_metalnessMap, $UV).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tmetalness *= saturate(vVertexColor.$VC);\n\t#endif\n\tprocessMetalness(metalness);\n\t#ifdef CLEARCOAT\n\tccSpecularity = vec3(1.0);\n\tccSpecularity *= material_clearCoatSpecularity;\n\t#endif\n}\n";

	var msdfPS = "uniform sampler2D texture_msdfMap;\n#ifdef GL_OES_standard_derivatives\n#define USE_FWIDTH\n#endif\n#ifdef GL2\n#define USE_FWIDTH\n#endif\nfloat median(float r, float g, float b) {\n\treturn max(min(r, g), min(max(r, g), b));\n}\nfloat map (float min, float max, float v) {\n\treturn (v - min) / (max - min);\n}\nuniform float font_sdfIntensity;\nuniform float font_pxrange;\nuniform float font_textureWidth;\nuniform vec4 outline_color;\nuniform float outline_thickness;\nuniform vec4 shadow_color;\nuniform vec2 shadow_offset;\nvec4 applyMsdf(vec4 color) {\n\tvec3 tsample = texture2D(texture_msdfMap, vUv0).rgb;\n\tvec2 uvShdw = vUv0 - shadow_offset;\n\tvec3 ssample = texture2D(texture_msdfMap, uvShdw).rgb;\n\tfloat sigDist = median(tsample.r, tsample.g, tsample.b);\n\tfloat sigDistShdw = median(ssample.r, ssample.g, ssample.b);\n\t#ifdef USE_FWIDTH\n\tvec2 w = fwidth(vUv0);\n\tfloat smoothing = clamp(w.x * font_textureWidth / font_pxrange, 0.0, 0.5);\n\t#else\n\tfloat font_size = 16.0;\n\tfloat smoothing = clamp(font_pxrange / font_size, 0.0, 0.5);\n\t#endif\n\tfloat mapMin = 0.05;\n\tfloat mapMax = clamp(1.0 - font_sdfIntensity, mapMin, 1.0);\n\tfloat sigDistInner = map(mapMin, mapMax, sigDist);\n\tfloat sigDistOutline = map(mapMin, mapMax, sigDist + outline_thickness);\n\tsigDistShdw = map(mapMin, mapMax, sigDistShdw + outline_thickness);\n\tfloat center = 0.5;\n\tfloat inside = smoothstep(center-smoothing, center+smoothing, sigDistInner);\n\tfloat outline = smoothstep(center-smoothing, center+smoothing, sigDistOutline);\n\tfloat shadow = smoothstep(center-smoothing, center+smoothing, sigDistShdw);\n\tvec4 tcolor = (outline > inside) ? outline * vec4(outline_color.a * outline_color.rgb, outline_color.a) : vec4(0.0);\n\ttcolor = mix(tcolor, color, inside);\n\tvec4 scolor = (shadow > outline) ? shadow * vec4(shadow_color.a * shadow_color.rgb, shadow_color.a) : tcolor;\n\ttcolor = mix(scolor, tcolor, outline);\n\treturn tcolor;\n}\n";

	var normalVS = "#ifdef MORPHING_TEXTURE_BASED_NORMAL\nuniform highp sampler2D morphNormalTex;\n#endif\nvec3 getNormal() {\n\t#ifdef SKIN\n\tdNormalMatrix = mat3(dModelMatrix[0].xyz, dModelMatrix[1].xyz, dModelMatrix[2].xyz);\n\t#elif defined(INSTANCING)\n\tdNormalMatrix = mat3(instance_line1.xyz, instance_line2.xyz, instance_line3.xyz);\n\t#else\n\tdNormalMatrix = matrix_normal;\n\t#endif\n\tvec3 tempNormal = vertex_normal;\n\t#ifdef MORPHING\n\t#ifdef MORPHING_NRM03\n\ttempNormal += morph_weights_a[0] * morph_nrm0;\n\ttempNormal += morph_weights_a[1] * morph_nrm1;\n\ttempNormal += morph_weights_a[2] * morph_nrm2;\n\ttempNormal += morph_weights_a[3] * morph_nrm3;\n\t#endif\n\t#ifdef MORPHING_NRM47\n\ttempNormal += morph_weights_b[0] * morph_nrm4;\n\ttempNormal += morph_weights_b[1] * morph_nrm5;\n\ttempNormal += morph_weights_b[2] * morph_nrm6;\n\ttempNormal += morph_weights_b[3] * morph_nrm7;\n\t#endif\n\t#endif\n\t#ifdef MORPHING_TEXTURE_BASED_NORMAL\n\tvec2 morphUV = getTextureMorphCoords();\n\tvec3 morphNormal = texture2D(morphNormalTex, morphUV).xyz;\n\ttempNormal += morphNormal;\n\t#endif\n\treturn normalize(dNormalMatrix * tempNormal);\n}\n";

	var normalDetailMapPS = "#ifdef MAPTEXTURE\nuniform sampler2D texture_normalDetailMap;\nuniform float material_normalDetailMapBumpiness;\nvec3 blendNormals(vec3 n1, vec3 n2) {\n\tn1 += vec3(0, 0, 1);\n\tn2 *= vec3(-1, -1, 1);\n\treturn normalize(n1*dot(n1, n2)/n1.z - n2);\n}\n#endif\nvec3 addNormalDetail(vec3 normalMap) {\n\t#ifdef MAPTEXTURE\n\tvec3 normalDetailMap = unpackNormal(texture2D(texture_normalDetailMap, $UV));\n\tnormalDetailMap = normalize(mix(vec3(0.0, 0.0, 1.0), normalDetailMap, material_normalDetailMapBumpiness));\n\treturn blendNormals(normalMap, normalDetailMap);\n\t#else\n\treturn normalMap;\n\t#endif\n}\n";

	var normalInstancedVS = "vec3 getNormal() {\n\tdNormalMatrix = mat3(instance_line1.xyz, instance_line2.xyz, instance_line3.xyz);\n\treturn normalize(dNormalMatrix * vertex_normal);\n}\n";

	var normalMapPS = "uniform sampler2D texture_normalMap;\nuniform float material_bumpiness;\nvoid getNormal() {\n\tvec3 normalMap = unpackNormal(texture2D(texture_normalMap, $UV));\n\tnormalMap = normalize(mix(vec3(0.0, 0.0, 1.0), normalMap, material_bumpiness));\n\tdNormalMap = addNormalDetail(normalMap);\n\tdNormalW = dTBN * dNormalMap;\n\t#ifdef CLEARCOAT\n\tccNormalW = normalize(dVertexNormalW);\n\t#endif\n}\n";

	var normalMapFastPS = "uniform sampler2D texture_normalMap;\nvoid getNormal() {\n\tvec3 normalMap = unpackNormal(texture2D(texture_normalMap, $UV));\n\tdNormalMap = addNormalDetail(normalMap);\n\tdNormalW = dTBN * dNormalMap;\n\t#ifdef CLEARCOAT\n\tccNormalW = normalize(dVertexNormalW);\n\t#endif\n}\n";

	var normalSkinnedVS = "vec3 getNormal() {\n\tdNormalMatrix = mat3(dModelMatrix[0].xyz, dModelMatrix[1].xyz, dModelMatrix[2].xyz);\n\treturn normalize(dNormalMatrix * vertex_normal);\n}\n";

	var normalVertexPS = "void getNormal() {\n\tdNormalW = normalize(dVertexNormalW);\n\t#ifdef CLEARCOAT\n\tccNormalW = dNormalW;\n\t#endif\n}\n";

	var normalXYPS = "vec3 unpackNormal(vec4 nmap) {\n\tvec3 normal;\n\tnormal.xy = nmap.wy * 2.0 - 1.0;\n\tnormal.z = sqrt(1.0 - saturate(dot(normal.xy, normal.xy)));\n\treturn normal;\n}\n";

	var normalXYZPS = "vec3 unpackNormal(vec4 nmap) {\n\treturn nmap.xyz * 2.0 - 1.0;\n}\n";

	var opacityPS = "#ifdef MAPFLOAT\nuniform float material_opacity;\n#endif\n#ifdef MAPTEXTURE\nuniform sampler2D texture_opacityMap;\n#endif\nvoid getOpacity() {\n\tdAlpha = 1.0;\n\t#ifdef MAPFLOAT\n\tdAlpha *= material_opacity;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tdAlpha *= texture2D(texture_opacityMap, $UV).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tdAlpha *= clamp(vVertexColor.$VC, 0.0, 1.0);\n\t#endif\n}\n";

	var outputAlphaPS = "gl_FragColor.a = dAlpha;\n";

	var outputAlphaOpaquePS = "gl_FragColor.a = 1.0;\n";

	var outputAlphaPremulPS = "gl_FragColor.rgb *= dAlpha;\ngl_FragColor.a = dAlpha;\n";

	var outputCubemapPS = "varying vec2 vUv0;\nuniform samplerCube source;\nuniform vec4 params;\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\nvec4 encodeRGBM(vec4 color) {\n\tcolor.rgb = pow(color.rgb, vec3(0.5));\n\tcolor.rgb *= 1.0 / 8.0;\n\tcolor.a = saturate( max( max( color.r, color.g ), max( color.b, 1.0 / 255.0 ) ) );\n\tcolor.a = ceil(color.a * 255.0) / 255.0;\n\tcolor.rgb /= color.a;\n\treturn color;\n}\nvoid main(void) {\n\tvec2 st = vUv0 * 2.0 - 1.0;\n\tfloat face = params.x;\n\tvec3 vec;\n\tif (face==0.0) {\n\t\tvec = vec3(1, -st.y, -st.x);\n\t} else if (face==1.0) {\n\t\tvec = vec3(-1, -st.y, st.x);\n\t} else if (face==2.0) {\n\t\tvec = vec3(st.x, 1, st.y);\n\t} else if (face==3.0) {\n\t\tvec = vec3(st.x, -1, -st.y);\n\t} else if (face==4.0) {\n\t\tvec = vec3(st.x, -st.y, 1);\n\t} else {\n\t\tvec = vec3(-st.x, -st.y, -1);\n\t}\n\tgl_FragColor = textureCube(source, vec);\n\tif (params.w >= 2.0) gl_FragColor = encodeRGBM(gl_FragColor);\n}\n";

	var outputTex2DPS = "varying vec2 vUv0;\nuniform sampler2D source;\nvoid main(void) {\n\tgl_FragColor = texture2D(source, vUv0);\n}\n";

	var packDepthPS = "\nvec4 packFloat(float depth) {\n\tconst vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);\n\tconst vec4 bit_mask  = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);\n\tvec4 res = mod(depth * bit_shift * vec4(255), vec4(256) ) / vec4(255);\n\tres -= res.xxyz * bit_mask;\n\treturn res;\n}\n";

	var packDepthMaskPS = "vec4 packFloat(float depth) {\n\tconst vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);\n\tconst vec4 bit_mask  = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);\n\tvec4 res = mod(depth * bit_shift * vec4(255), vec4(256) ) / vec4(255);\n\tres.x = 0.0;\n\tres -= res.xxyz * bit_mask;\n\treturn res;\n}\n";

	var parallaxPS = "uniform sampler2D texture_heightMap;\nuniform float material_heightMapFactor;\nvoid getParallax() {\n\tfloat parallaxScale = material_heightMapFactor;\n\tfloat height = texture2D(texture_heightMap, $UV).$CH;\n\theight = height * parallaxScale - parallaxScale*0.5;\n\tvec3 viewDirT = dViewDirW * dTBN;\n\tviewDirT.z += 0.42;\n\tdUvOffset = height * (viewDirT.xy / viewDirT.z);\n}\n";

	var particlePS = "varying vec4 texCoordsAlphaLife;\nuniform sampler2D colorMap;\nuniform sampler2D colorParam;\nuniform float graphSampleSize;\nuniform float graphNumSamples;\n#ifndef CAMERAPLANES\n#define CAMERAPLANES\nuniform vec4 camera_params;\n#endif\nuniform float softening;\nuniform float colorMult;\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\n#ifndef UNPACKFLOAT\n#define UNPACKFLOAT\nfloat unpackFloat(vec4 rgbaDepth) {\n\tconst vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\n\tfloat depth = dot(rgbaDepth, bitShift);\n\treturn depth;\n}\n#endif\nvoid main(void) {\n\tvec4 tex  = texture2DSRGB(colorMap, texCoordsAlphaLife.xy);\n\tvec4 ramp = texture2DSRGB(colorParam, vec2(texCoordsAlphaLife.w, 0.0));\n\tramp.rgb *= colorMult;\n\tramp.a += texCoordsAlphaLife.z;\n\tvec3 rgb = tex.rgb * ramp.rgb;\n\tfloat a  = tex.a * ramp.a;\n";

	var particleVS = "vec3 unpack3NFloats(float src) {\n\tfloat r = fract(src);\n\tfloat g = fract(src * 256.0);\n\tfloat b = fract(src * 65536.0);\n\treturn vec3(r, g, b);\n}\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\nvec4 tex1Dlod_lerp(highp sampler2D tex, vec2 tc) {\n\treturn mix( texture2D(tex,tc), texture2D(tex,tc + graphSampleSize), fract(tc.x*graphNumSamples) );\n}\nvec4 tex1Dlod_lerp(highp sampler2D tex, vec2 tc, out vec3 w) {\n\tvec4 a = texture2D(tex,tc);\n\tvec4 b = texture2D(tex,tc + graphSampleSize);\n\tfloat c = fract(tc.x*graphNumSamples);\n\tvec3 unpackedA = unpack3NFloats(a.w);\n\tvec3 unpackedB = unpack3NFloats(b.w);\n\tw = mix(unpackedA, unpackedB, c);\n\treturn mix(a, b, c);\n}\nvec2 rotate(vec2 quadXY, float pRotation, out mat2 rotMatrix) {\n\tfloat c = cos(pRotation);\n\tfloat s = sin(pRotation);\n\tmat2 m = mat2(c, -s, s, c);\n\trotMatrix = m;\n\treturn m * quadXY;\n}\nvec3 billboard(vec3 InstanceCoords, vec2 quadXY) {\n\t#ifdef SCREEN_SPACE\n\t\tvec3 pos = vec3(-1, 0, 0) * quadXY.x + vec3(0, -1, 0) * quadXY.y;\n\t#else\n\t\tvec3 pos = -matrix_viewInverse[0].xyz * quadXY.x + -matrix_viewInverse[1].xyz * quadXY.y;\n\t#endif\n\treturn pos;\n}\nvec3 customFace(vec3 InstanceCoords, vec2 quadXY) {\n\tvec3 pos = faceTangent * quadXY.x + faceBinorm * quadXY.y;\n\treturn pos;\n}\nvec2 safeNormalize(vec2 v) {\n\tfloat l = length(v);\n\treturn (l > 1e-06) ? v / l : v;\n}\nvoid main(void) {\n\tvec3 meshLocalPos = particle_vertexData.xyz;\n\tfloat id = floor(particle_vertexData.w);\n\tfloat rndFactor = fract(sin(id + 1.0 + seed));\n\tvec3 rndFactor3 = vec3(rndFactor, fract(rndFactor*10.0), fract(rndFactor*100.0));\n\tfloat uv = id / numParticlesPot;\n\treadInput(uv);\n#ifdef LOCAL_SPACE\n\tinVel = mat3(matrix_model) * inVel;\n#endif\n\tvec2 velocityV = safeNormalize((mat3(matrix_view) * inVel).xy);\n\tfloat particleLifetime = lifetime;\n\tif (inLife <= 0.0 || inLife > particleLifetime || !inShow) meshLocalPos = vec3(0.0);\n\tvec2 quadXY = meshLocalPos.xy;\n\tfloat nlife = clamp(inLife / particleLifetime, 0.0, 1.0);\n\tvec3 paramDiv;\n\tvec4 params = tex1Dlod_lerp(internalTex2, vec2(nlife, 0), paramDiv);\n\tfloat scale = params.y;\n\tfloat scaleDiv = paramDiv.x;\n\tfloat alphaDiv = paramDiv.z;\n\tscale += (scaleDiv * 2.0 - 1.0) * scaleDivMult * fract(rndFactor*10000.0);\n#ifndef USE_MESH\n\ttexCoordsAlphaLife = vec4(quadXY * -0.5 + 0.5, (alphaDiv * 2.0 - 1.0) * alphaDivMult * fract(rndFactor*1000.0), nlife);\n#else\n\ttexCoordsAlphaLife = vec4(particle_uv, (alphaDiv * 2.0 - 1.0) * alphaDivMult * fract(rndFactor*1000.0), nlife);\n#endif\n\tvec3 particlePos = inPos;\n\tvec3 particlePosMoved = vec3(0.0);\n\tmat2 rotMatrix;\n";

	var particleAnimFrameClampVS = "\tfloat animFrame = min(floor(texCoordsAlphaLife.w * animTexParams.y) + animTexParams.x, animTexParams.z);\n";

	var particleAnimFrameLoopVS = "\tfloat animFrame = floor(mod(texCoordsAlphaLife.w * animTexParams.y + animTexParams.x, animTexParams.z + 1.0));\n";

	var particleAnimTexVS = "\tfloat animationIndex;\n\tif (animTexIndexParams.y == 1.0) {\n\t\tanimationIndex = floor((animTexParams.w + 1.0) * rndFactor3.z) * (animTexParams.z + 1.0);\n\t} else {\n\t\tanimationIndex = animTexIndexParams.x * (animTexParams.z + 1.0);\n\t}\n\tfloat atlasX = (animationIndex + animFrame) * animTexTilesParams.x;\n\tfloat atlasY = 1.0 - floor(atlasX + 1.0) * animTexTilesParams.y;\n\tatlasX = fract(atlasX);\n\ttexCoordsAlphaLife.xy *= animTexTilesParams.xy;\n\ttexCoordsAlphaLife.xy += vec2(atlasX, atlasY);\n";

	var particleInputFloatPS = "void readInput(float uv) {\n\tvec4 tex = texture2D(particleTexIN, vec2(uv, 0.25));\n\tvec4 tex2 = texture2D(particleTexIN, vec2(uv, 0.75));\n\tinPos = tex.xyz;\n\tinVel = tex2.xyz;\n\tinAngle = (tex.w < 0.0? -tex.w : tex.w) - 1000.0;\n\tinShow = tex.w >= 0.0;\n\tinLife = tex2.w;\n}\n";

	var particleInputRgba8PS = "\n#define PI2 6.283185307179586\nuniform vec3 inBoundsSize;\nuniform vec3 inBoundsCenter;\nuniform float maxVel;\nfloat decodeFloatRG(vec2 rg) {\n\treturn rg.y*(1.0/255.0) + rg.x;\n}\nfloat decodeFloatRGBA( vec4 rgba ) {\n  return dot( rgba, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/160581375.0) );\n}\nvoid readInput(float uv) {\n\tvec4 tex0 = texture2D(particleTexIN, vec2(uv, 0.125));\n\tvec4 tex1 = texture2D(particleTexIN, vec2(uv, 0.375));\n\tvec4 tex2 = texture2D(particleTexIN, vec2(uv, 0.625));\n\tvec4 tex3 = texture2D(particleTexIN, vec2(uv, 0.875));\n\tinPos = vec3(decodeFloatRG(tex0.rg), decodeFloatRG(tex0.ba), decodeFloatRG(tex1.rg));\n\tinPos = (inPos - vec3(0.5)) * inBoundsSize + inBoundsCenter;\n\tinVel = tex2.xyz;\n\tinVel = (inVel - vec3(0.5)) * maxVel;\n\tinAngle = decodeFloatRG(tex1.ba) * PI2;\n\tinShow = tex2.a > 0.5;\n\tinLife = decodeFloatRGBA(tex3);\n\tfloat maxNegLife = max(lifetime, (numParticles - 1.0) * (rate+rateDiv));\n\tfloat maxPosLife = lifetime+1.0;\n\tinLife = inLife * (maxNegLife + maxPosLife) - maxNegLife;\n}\n";

	var particleOutputFloatPS = "void writeOutput() {\n\tif (gl_FragCoord.y<1.0) {\n\t\tgl_FragColor = vec4(outPos, (outAngle + 1000.0) * visMode);\n\t} else {\n\t\tgl_FragColor = vec4(outVel, outLife);\n\t}\n}\n";

	var particleOutputRgba8PS = "uniform vec3 outBoundsMul;\nuniform vec3 outBoundsAdd;\nvec2 encodeFloatRG( float v ) {\n\tvec2 enc = vec2(1.0, 255.0) * v;\n\tenc = fract(enc);\n\tenc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);\n\treturn enc;\n}\nvec4 encodeFloatRGBA( float v ) {\n\tvec4 enc = vec4(1.0, 255.0, 65025.0, 160581375.0) * v;\n\tenc = fract(enc);\n\tenc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);\n\treturn enc;\n}\nvoid writeOutput() {\n\toutPos = outPos * outBoundsMul + outBoundsAdd;\n\toutAngle = fract(outAngle / PI2);\n\toutVel = (outVel / maxVel) + vec3(0.5);\n\tfloat maxNegLife = max(lifetime, (numParticles - 1.0) * (rate+rateDiv));\n\tfloat maxPosLife = lifetime+1.0;\n\toutLife = (outLife + maxNegLife) / (maxNegLife + maxPosLife);\n\tif (gl_FragCoord.y < 1.0) {\n\t\tgl_FragColor = vec4(encodeFloatRG(outPos.x), encodeFloatRG(outPos.y));\n\t} else if (gl_FragCoord.y < 2.0) {\n\t\tgl_FragColor = vec4(encodeFloatRG(outPos.z), encodeFloatRG(outAngle));\n\t} else if (gl_FragCoord.y < 3.0) {\n\t\tgl_FragColor = vec4(outVel, visMode*0.5+0.5);\n\t} else {\n\t\tgl_FragColor = encodeFloatRGBA(outLife);\n\t}\n}\n";

	var particleUpdaterAABBPS = "uniform mat3 spawnBounds;\nuniform vec3 spawnPosInnerRatio;\nvec3 calcSpawnPosition(vec3 inBounds, float rndFactor) {\n\tvec3 pos = inBounds - vec3(0.5);\n\tvec3 posAbs = abs(pos);\n\tvec3 maxPos = vec3(max(posAbs.x, max(posAbs.y, posAbs.z)));\n\tvec3 edge = maxPos + (vec3(0.5) - maxPos) * spawnPosInnerRatio;\n\tpos.x = edge.x * (maxPos.x == posAbs.x ? sign(pos.x) : 2.0 * pos.x);\n\tpos.y = edge.y * (maxPos.y == posAbs.y ? sign(pos.y) : 2.0 * pos.y);\n\tpos.z = edge.z * (maxPos.z == posAbs.z ? sign(pos.z) : 2.0 * pos.z);\n#ifndef LOCAL_SPACE\n\treturn emitterPos + spawnBounds * pos;\n#else\n\treturn spawnBounds * pos;\n#endif\n}\nvoid addInitialVelocity(inout vec3 localVelocity, vec3 inBounds) {\n\tlocalVelocity -= vec3(0, 0, initialVelocity);\n}\n";

	var particleUpdaterEndPS = "\twriteOutput();\n}\n";

	var particleUpdaterInitPS = "varying vec2 vUv0;\nuniform highp sampler2D particleTexIN;\nuniform highp sampler2D internalTex0;\nuniform highp sampler2D internalTex1;\nuniform highp sampler2D internalTex2;\nuniform highp sampler2D internalTex3;\nuniform mat3 emitterMatrix, emitterMatrixInv;\nuniform vec3 emitterScale;\nuniform vec3 emitterPos, frameRandom, localVelocityDivMult, velocityDivMult;\nuniform float delta, rate, rateDiv, lifetime, numParticles, rotSpeedDivMult, radialSpeedDivMult, seed;\nuniform float startAngle, startAngle2;\nuniform float initialVelocity;\nuniform float graphSampleSize;\nuniform float graphNumSamples;\nvec3 inPos;\nvec3 inVel;\nfloat inAngle;\nbool inShow;\nfloat inLife;\nfloat visMode;\nvec3 outPos;\nvec3 outVel;\nfloat outAngle;\nbool outShow;\nfloat outLife;\n";

	var particleUpdaterNoRespawnPS = "\tif (outLife >= lifetime) {\n\t\toutLife -= max(lifetime, (numParticles - 1.0) * particleRate);\n\t\tvisMode = -1.0;\n\t}\n";

	var particleUpdaterOnStopPS = "\tvisMode = outLife < 0.0? -1.0: visMode;\n";

	var particleUpdaterRespawnPS = "\tif (outLife >= lifetime) {\n\t\toutLife -= max(lifetime, (numParticles - 1.0) * particleRate);\n\t\tvisMode = 1.0;\n\t}\n\tvisMode = outLife < 0.0? 1.0: visMode;\n";

	var particleUpdaterSpherePS = "uniform float spawnBoundsSphere;\nuniform float spawnBoundsSphereInnerRatio;\nvec3 calcSpawnPosition(vec3 inBounds, float rndFactor) {\n\tfloat rnd4 = fract(rndFactor * 1000.0);\n\tvec3 norm = normalize(inBounds.xyz - vec3(0.5));\n\tfloat r = rnd4 * (1.0 - spawnBoundsSphereInnerRatio) + spawnBoundsSphereInnerRatio;\n#ifndef LOCAL_SPACE\n\treturn emitterPos + norm * r * spawnBoundsSphere;\n#else\n\treturn norm * r * spawnBoundsSphere;\n#endif\n}\nvoid addInitialVelocity(inout vec3 localVelocity, vec3 inBounds) {\n\tlocalVelocity += normalize(inBounds - vec3(0.5)) * initialVelocity;\n}\n";

	var particleUpdaterStartPS = "float saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\nvec3 unpack3NFloats(float src) {\n\tfloat r = fract(src);\n\tfloat g = fract(src * 256.0);\n\tfloat b = fract(src * 65536.0);\n\treturn vec3(r, g, b);\n}\nvec3 tex1Dlod_lerp(highp sampler2D tex, vec2 tc, out vec3 w) {\n\tvec4 a = texture2D(tex, tc);\n\tvec4 b = texture2D(tex, tc + graphSampleSize);\n\tfloat c = fract(tc.x * graphNumSamples);\n\tvec3 unpackedA = unpack3NFloats(a.w);\n\tvec3 unpackedB = unpack3NFloats(b.w);\n\tw = mix(unpackedA, unpackedB, c);\n\treturn mix(a.xyz, b.xyz, c);\n}\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\nvec4 hash41(float p) {\n\tvec4 p4 = fract(vec4(p) * HASHSCALE4);\n\tp4 += dot(p4, p4.wzxy+19.19);\n\treturn fract(vec4((p4.x + p4.y)*p4.z, (p4.x + p4.z)*p4.y, (p4.y + p4.z)*p4.w, (p4.z + p4.w)*p4.x));\n}\nvoid main(void) {\n\tif (gl_FragCoord.x > numParticles) discard;\n\treadInput(vUv0.x);\n\tvisMode = inShow? 1.0 : -1.0;\n\tvec4 rndFactor = hash41(gl_FragCoord.x + seed);\n\tfloat particleRate = rate + rateDiv * rndFactor.x;\n\toutLife = inLife + delta;\n\tfloat nlife = clamp(outLife / lifetime, 0.0, 1.0);\n\tvec3 localVelocityDiv;\n\tvec3 velocityDiv;\n\tvec3 paramDiv;\n\tvec3 localVelocity = tex1Dlod_lerp(internalTex0, vec2(nlife, 0), localVelocityDiv);\n\tvec3 velocity =\t  tex1Dlod_lerp(internalTex1, vec2(nlife, 0), velocityDiv);\n\tvec3 params =\t\ttex1Dlod_lerp(internalTex2, vec2(nlife, 0), paramDiv);\n\tfloat rotSpeed = params.x;\n\tfloat rotSpeedDiv = paramDiv.y;\n\tvec3 radialParams = tex1Dlod_lerp(internalTex3, vec2(nlife, 0), paramDiv);\n\tfloat radialSpeed = radialParams.x;\n\tfloat radialSpeedDiv = radialParams.y;\n\tbool respawn = inLife <= 0.0 || outLife >= lifetime;\n\tinPos = respawn ? calcSpawnPosition(rndFactor.xyz, rndFactor.x) : inPos;\n\tinAngle = respawn ? mix(startAngle, startAngle2, rndFactor.x) : inAngle;\n#ifndef LOCAL_SPACE\n\tvec3 radialVel = inPos - emitterPos;\n#else\n\tvec3 radialVel = inPos;\n#endif\n\tradialVel = (dot(radialVel, radialVel) > 1.0E-8) ? radialSpeed * normalize(radialVel) : vec3(0.0);\n\tradialVel += (radialSpeedDiv * vec3(2.0) - vec3(1.0)) * radialSpeedDivMult * rndFactor.xyz;\n\tlocalVelocity +=\t(localVelocityDiv * vec3(2.0) - vec3(1.0)) * localVelocityDivMult * rndFactor.xyz;\n\tvelocity +=\t\t (velocityDiv * vec3(2.0) - vec3(1.0)) * velocityDivMult * rndFactor.xyz;\n\trotSpeed +=\t\t (rotSpeedDiv * 2.0 - 1.0) * rotSpeedDivMult * rndFactor.y;\n\taddInitialVelocity(localVelocity, rndFactor.xyz);\n#ifndef LOCAL_SPACE\n\toutVel = emitterMatrix * localVelocity + (radialVel + velocity) * emitterScale;\n#else\n\toutVel = (localVelocity + radialVel) / emitterScale + emitterMatrixInv * velocity;\n#endif\n\toutPos = inPos + outVel * delta;\n\toutAngle = inAngle + rotSpeed * delta;\n";

	var particle_billboardVS = "\tquadXY = rotate(quadXY, inAngle, rotMatrix);\n\tvec3 localPos = billboard(particlePos, quadXY);\n";

	var particle_blendAddPS = "\tdBlendModeFogFactor = 0.0;\n\trgb *= saturate(gammaCorrectInput(max(a, 0.0)));\n\tif ((rgb.r + rgb.g + rgb.b) < 0.000001) discard;\n";

	var particle_blendMultiplyPS = "\trgb = mix(vec3(1.0), rgb, vec3(a));\n\tif (rgb.r + rgb.g + rgb.b > 2.99) discard;\n";

	var particle_blendNormalPS = "\tif (a < 0.01) discard;\n";

	var particle_cpuVS = "attribute vec4 particle_vertexData;\nattribute vec4 particle_vertexData2;\nattribute vec4 particle_vertexData3;\nattribute float particle_vertexData4;\n#ifndef USE_MESH\n#define VDATA5TYPE vec2\n#else\n#define VDATA5TYPE vec4\n#endif\nattribute VDATA5TYPE particle_vertexData5;\nuniform mat4 matrix_viewProjection;\nuniform mat4 matrix_model;\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nuniform mat3 matrix_normal;\nuniform mat4 matrix_viewInverse;\nuniform float numParticles;\nuniform float lifetime;\nuniform float stretch;\nuniform float seed;\nuniform vec3 wrapBounds, emitterScale, faceTangent, faceBinorm;\nuniform sampler2D texLifeAndSourcePosOUT;\nuniform highp sampler2D internalTex0;\nuniform highp sampler2D internalTex1;\nuniform highp sampler2D internalTex2;\nuniform vec3 emitterPos;\nvarying vec4 texCoordsAlphaLife;\nvec2 rotate(vec2 quadXY, float pRotation, out mat2 rotMatrix)\n{\n\tfloat c = cos(pRotation);\n\tfloat s = sin(pRotation);\n\tmat2 m = mat2(c, -s, s, c);\n\trotMatrix = m;\n\treturn m * quadXY;\n}\nvec3 billboard(vec3 InstanceCoords, vec2 quadXY)\n{\n\tvec3 pos = -matrix_viewInverse[0].xyz * quadXY.x + -matrix_viewInverse[1].xyz * quadXY.y;\n\treturn pos;\n}\nvec3 customFace(vec3 InstanceCoords, vec2 quadXY)\n{\n\tvec3 pos = faceTangent * quadXY.x + faceBinorm * quadXY.y;\n\treturn pos;\n}\nvoid main(void)\n{\n\tvec3 particlePos = particle_vertexData.xyz;\n\tvec3 inPos = particlePos;\n\tvec3 vertPos = particle_vertexData3.xyz;\n\tvec3 inVel = vec3(particle_vertexData2.w, particle_vertexData3.w, particle_vertexData5.x);\n\tfloat id = floor(particle_vertexData4);\n\tfloat rndFactor = fract(sin(id + 1.0 + seed));\n\tvec3 rndFactor3 = vec3(rndFactor, fract(rndFactor*10.0), fract(rndFactor*100.0));\n#ifdef LOCAL_SPACE\n\tinVel = mat3(matrix_model) * inVel;\n#endif\n\tvec2 velocityV = normalize((mat3(matrix_view) * inVel).xy);\n\tvec2 quadXY = vertPos.xy;\n#ifndef USE_MESH\n\ttexCoordsAlphaLife = vec4(quadXY * -0.5 + 0.5, particle_vertexData2.z, particle_vertexData.w);\n#else\n\ttexCoordsAlphaLife = vec4(particle_vertexData5.zw, particle_vertexData2.z, particle_vertexData.w);\n#endif\n\tmat2 rotMatrix;\n\tfloat inAngle = particle_vertexData2.x;\n\tvec3 particlePosMoved = vec3(0.0);\n\tvec3 meshLocalPos = particle_vertexData3.xyz;\n";

	var particle_cpu_endVS = "\tlocalPos *= particle_vertexData2.y * emitterScale;\n\tlocalPos += particlePos;\n\tgl_Position = matrix_viewProjection * vec4(localPos, 1.0);\n";

	var particle_customFaceVS = "\tquadXY = rotate(quadXY, inAngle, rotMatrix);\n\tvec3 localPos = customFace(particlePos, quadXY);\n";

	var particle_endPS = "\trgb = addFog(rgb);\n\trgb = toneMap(rgb);\n\trgb = gammaCorrectOutput(rgb);\n\tgl_FragColor = vec4(rgb, a);\n}\n";

	var particle_endVS = "\tlocalPos *= scale * emitterScale;\n\tlocalPos += particlePos;\n\t#ifdef SCREEN_SPACE\n\tgl_Position = vec4(localPos.x, localPos.y, 0.0, 1.0);\n\t#else\n\tgl_Position = matrix_viewProjection * vec4(localPos.xyz, 1.0);\n\t#endif\n";

	var particle_halflambertPS = "\tvec3 negNormal = normal*0.5+0.5;\n\tvec3 posNormal = -normal*0.5+0.5;\n\tnegNormal *= negNormal;\n\tposNormal *= posNormal;\n";

	var particle_initVS = "attribute vec4 particle_vertexData;\n#ifdef USE_MESH\nattribute vec2 particle_uv;\n#endif\nuniform mat4 matrix_viewProjection;\nuniform mat4 matrix_model;\nuniform mat3 matrix_normal;\nuniform mat4 matrix_viewInverse;\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nuniform float numParticles, numParticlesPot;\nuniform float graphSampleSize;\nuniform float graphNumSamples;\nuniform float stretch;\nuniform vec3 wrapBounds;\nuniform vec3 emitterScale, emitterPos, faceTangent, faceBinorm;\nuniform float rate, rateDiv, lifetime, deltaRandomnessStatic, scaleDivMult, alphaDivMult, seed, delta;\nuniform sampler2D particleTexOUT, particleTexIN;\nuniform highp sampler2D internalTex0;\nuniform highp sampler2D internalTex1;\nuniform highp sampler2D internalTex2;\n#ifndef CAMERAPLANES\n#define CAMERAPLANES\nuniform vec4 camera_params;\n#endif\nvarying vec4 texCoordsAlphaLife;\nvec3 inPos;\nvec3 inVel;\nfloat inAngle;\nbool inShow;\nfloat inLife;\n";

	var particle_lambertPS = "\tvec3 negNormal = max(normal, vec3(0.0));\n\tvec3 posNormal = max(-normal, vec3(0.0));\n";

	var particle_lightingPS = "\tvec3 light = negNormal.x*lightCube[0] + posNormal.x*lightCube[1] +\n\t\t\t\t\t\tnegNormal.y*lightCube[2] + posNormal.y*lightCube[3] +\n\t\t\t\t\t\tnegNormal.z*lightCube[4] + posNormal.z*lightCube[5];\n\trgb *= light;\n";

	var particle_localShiftVS = "\tparticlePos = (matrix_model * vec4(particlePos, 1.0)).xyz;\n";

	var particle_meshVS = "\tvec3 localPos = meshLocalPos;\n\tlocalPos.xy = rotate(localPos.xy, inAngle, rotMatrix);\n\tlocalPos.yz = rotate(localPos.yz, inAngle, rotMatrix);\n\tbillboard(particlePos, quadXY);\n";

	var particle_normalVS = "\tNormal = normalize(localPos + matrix_viewInverse[2].xyz);\n";

	var particle_normalMapPS = "\tvec3 normalMap = normalize(texture2D(normalMap, texCoordsAlphaLife.xy).xyz * 2.0 - 1.0);\n\tvec3 normal = ParticleMat * normalMap;\n";

	var particle_pointAlongVS = "\tinAngle = atan(velocityV.x, velocityV.y);\n";

	var particle_softPS = "\tfloat depth = getLinearScreenDepth();\n\tfloat particleDepth = vDepth;\n\tfloat depthDiff = saturate(abs(particleDepth - depth) * softening);\n\ta *= depthDiff;\n";

	var particle_softVS = "\tvDepth = getLinearDepth(localPos);\n";

	var particle_stretchVS = "\tvec3 moveDir = inVel * stretch;\n\tvec3 posPrev = particlePos - moveDir;\n\tposPrev += particlePosMoved;\n\tvec2 centerToVertexV = normalize((mat3(matrix_view) * localPos).xy);\n\tfloat interpolation = dot(-velocityV, centerToVertexV) * 0.5 + 0.5;\n\tparticlePos = mix(particlePos, posPrev, interpolation);\n";

	var particle_TBNVS = "\tmat3 rot3 = mat3(rotMatrix[0][0], rotMatrix[0][1], 0.0, rotMatrix[1][0], rotMatrix[1][1], 0.0, 0.0, 0.0, 1.0);\n\tParticleMat = mat3(-matrix_viewInverse[0].xyz, -matrix_viewInverse[1].xyz, matrix_viewInverse[2].xyz) * rot3;\n";

	var particle_wrapVS = "\tvec3 origParticlePos = particlePos;\n\tparticlePos -= matrix_model[3].xyz;\n\tparticlePos = mod(particlePos, wrapBounds) - wrapBounds * 0.5;\n\tparticlePos += matrix_model[3].xyz;\n\tparticlePosMoved = particlePos - origParticlePos;\n";

	var precisionTestPS = "void main(void) {\n\tgl_FragColor = vec4(2147483648.0);\n}\n";

	var precisionTest2PS = "uniform sampler2D source;\nvec4 packFloat(float depth) {\n\tconst vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);\n\tconst vec4 bit_mask  = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);\n\tvec4 res = mod(depth * bit_shift * vec4(255), vec4(256) ) / vec4(255);\n\tres -= res.xxyz * bit_mask;\n\treturn res;\n}\nvoid main(void) {\n\tfloat c = texture2D(source, vec2(0.0)).r;\n\tfloat diff = abs(c - 2147483648.0) / 2147483648.0;\n\tgl_FragColor = packFloat(diff);\n}\n";

	var prefilterCubemapPS = "varying vec2 vUv0;\nuniform samplerCube source;\nuniform vec4 params;\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\nfloat rnd(vec2 uv) {\n\treturn fract(sin(dot(uv, vec2(12.9898, 78.233) * 2.0)) * 43758.5453);\n}\nconst float PI = 3.14159265358979;\nvec3 hemisphereSample_cos(vec2 uv, mat3 vecSpace, vec3 cubeDir, float gloss) {\n\tfloat phi = uv.y * 2.0 * PI;\n\tfloat cosTheta = sqrt(1.0 - uv.x);\n\tfloat sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n\tvec3 sampleDir = vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);\n\treturn normalize(mix(vecSpace * sampleDir, cubeDir, params.y));\n}\nvec3 hemisphereSample_phong(vec2 uv, mat3 vecSpace, vec3 cubeDir, float specPow) {\n\tfloat phi = uv.y * 2.0 * PI;\n\tfloat cosTheta = pow(1.0 - uv.x, 1.0 / (specPow + 1.0));\n\tfloat sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n\tvec3 sampleDir = vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);\n\treturn vecSpace * sampleDir;\n}\nmat3 matrixFromVector(vec3 n) {\n\tfloat a = 1.0 / (1.0 + n.z);\n\tfloat b = -n.x * n.y * a;\n\tvec3 b1 = vec3(1.0 - n.x * n.x * a, b, -n.x);\n\tvec3 b2 = vec3(b, 1.0 - n.y * n.y * a, -n.y);\n\treturn mat3(b1, b2, n);\n}\nvec4 encodeRGBM(vec3 color) {\n\tvec4 encoded;\n\tencoded.rgb = pow(color.rgb, vec3(0.5));\n\tencoded.rgb *= 1.0 / 8.0;\n\tencoded.a = saturate( max( max( encoded.r, encoded.g ), max( encoded.b, 1.0 / 255.0 ) ) );\n\tencoded.a = ceil(encoded.a * 255.0) / 255.0;\n\tencoded.rgb /= encoded.a;\n\treturn encoded;\n}\nvoid main(void) {\n\tvec2 st = vUv0 * 2.0 - 1.0;\n\tif (params.w==1.0 || params.w==3.0) {\n\t\tst = 2.0 * floor(gl_FragCoord.xy) / (params.z - 1.0) - 1.0;\n\t}\n\tfloat face = params.x;\n\tvec3 vec;\n\tif (face==0.0) {\n\t\tvec = vec3(1, -st.y, -st.x);\n\t} else if (face==1.0) {\n\t\tvec = vec3(-1, -st.y, st.x);\n\t} else if (face==2.0) {\n\t\tvec = vec3(st.x, 1, st.y);\n\t} else if (face==3.0) {\n\t\tvec = vec3(st.x, -1, -st.y);\n\t} else if (face==4.0) {\n\t\tvec = vec3(st.x, -st.y, 1);\n\t} else {\n\t\tvec = vec3(-st.x, -st.y, -1);\n\t}\n\tmat3 vecSpace = matrixFromVector(normalize(vec));\n\tvec3 color = vec3(0.0);\n\tconst int samples = $NUMSAMPLES;\n\tvec3 vect;\n\tfor(int i=0; i<samples; i++) {\n\t\tfloat sini = sin(float(i));\n\t\tfloat cosi = cos(float(i));\n\t\tfloat rand = rnd(vec2(sini, cosi));\n\t\tvect = hemisphereSample_$METHOD(vec2(float(i) / float(samples), rand), vecSpace, vec, params.y);\n\t\tcolor += $textureCube(source, vect).rgb;\n\t}\n\tcolor /= float(samples);\n\tgl_FragColor = params.w < 2.0? vec4(color, 1.0) : encodeRGBM(color);\n}\n";

	var reflDirPS = "void getReflDir() {\n\tdReflDirW = normalize(-reflect(dViewDirW, dNormalW));\n\t#ifdef CLEARCOAT\n\t\tccReflDirW = normalize(-reflect(dViewDirW, ccNormalW));\n\t#endif\n}\n";

	var reflDirAnisoPS = "void getReflDir() {\n\tfloat roughness = sqrt(1.0 - min(dGlossiness, 1.0));\n\tfloat anisotropy = material_anisotropy * roughness;\n\tvec3 anisotropicDirection = anisotropy >= 0.0 ? dTBN[1] : dTBN[0];\n\tvec3 anisotropicTangent = cross(anisotropicDirection, dViewDirW);\n\tvec3 anisotropicNormal = cross(anisotropicTangent, anisotropicDirection);\n\tvec3 bentNormal = normalize(mix(normalize(dNormalW), normalize(anisotropicNormal), anisotropy));\n\tdReflDirW = reflect(-dViewDirW, bentNormal);\n\t#ifdef CLEARCOAT\n\t\tccReflDirW = normalize(-reflect(dViewDirW, ccNormalW));\n\t#endif\n}\n";

	var reflectionCCPS = "#ifdef CLEARCOAT\nuniform float material_clearCoatReflectivity;\nvoid addReflectionCC() {\n\tccReflection += vec4(calcReflection(ccReflDirW, ccGlossiness), material_clearCoatReflectivity);\n}\n#endif\n";

	var reflectionCubePS = "uniform samplerCube texture_cubeMap;\nuniform float material_reflectivity;\nvec3 calcReflection(vec3 tReflDirW, float tGlossiness) {\n\tvec3 lookupVec = fixSeams(cubeMapProject(tReflDirW));\n\tlookupVec.x *= -1.0;\n\treturn $textureCubeSAMPLE(texture_cubeMap, lookupVec).rgb;\n}\nvoid addReflection() {\n\tdReflection += vec4(calcReflection(dReflDirW, dGlossiness), material_reflectivity);\n}\n";

	var reflectionDpAtlasPS = "uniform sampler2D texture_sphereMap;\nuniform float material_reflectivity;\nvec2 getDpAtlasUv(vec2 uv, float mip) {\n\tvec4 rect;\n\tfloat sx = saturate(mip - 2.0);\n\trect.x = sx * 0.5;\n\tfloat t = mip - rect.x * 6.0;\n\tfloat i = 1.0 - rect.x;\n\trect.y = min(t * 0.5, 0.75) * i + rect.x;\n\tfloat st = saturate(t);\n\trect.z = (1.0 - st * 0.5) * i;\n\trect.w = rect.z * 0.5;\n\tfloat rcRectZ = 1.0 / rect.z;\n\tfloat scaleFactor = 0.00390625 * rcRectZ;\n\tvec2 scale = vec2(scaleFactor, scaleFactor * 2.0);\n\tuv = uv * (vec2(1.0) - scale) + scale * 0.5;\n\tuv = uv * rect.zw + rect.xy;\n\treturn uv;\n}\nvec3 calcReflection(vec3 tReflDirW, float tGlossiness) {\n\tvec3 reflDir = normalize(cubeMapProject(tReflDirW));\n\tbool up = reflDir.y > 0.0;\n\tfloat scale = 0.90909090909090909090909090909091;\n\tvec3 reflDirWarp = reflDir.xzx * vec3(-0.25, 0.5, 0.25);\n\tfloat reflDirVer = abs(reflDir.y) + 1.0;\n\treflDirWarp /= reflDirVer;\n\treflDirWarp *= scale;\n\treflDirWarp = vec3(0.75, 0.5, 0.25) - reflDirWarp;\n\tvec2 tc = up? reflDirWarp.xy : reflDirWarp.zy;\n\tfloat bias = saturate(1.0 - tGlossiness) * 5.0;\n\tfloat mip = floor(bias);\n\tvec3 tex1 = $texture2DSAMPLE(texture_sphereMap, getDpAtlasUv(tc, mip)).rgb;\n\tmip = min(mip + 1.0, 5.0);\n\tvec3 tex2 = $texture2DSAMPLE(texture_sphereMap, getDpAtlasUv(tc, mip)).rgb;\n\ttex1 = mix(tex1, tex2, fract(bias));\n\ttex1 = processEnvironment(tex1);\n\treturn tex1;\n}\nvoid addReflection() {\n\tdReflection += vec4(calcReflection(dReflDirW, dGlossiness), material_reflectivity);\n}\n";

	var reflectionPrefilteredCubePS = "uniform samplerCube texture_prefilteredCubeMap128;\nuniform samplerCube texture_prefilteredCubeMap64;\nuniform samplerCube texture_prefilteredCubeMap32;\nuniform samplerCube texture_prefilteredCubeMap16;\nuniform samplerCube texture_prefilteredCubeMap8;\n#ifndef PMREM4\n#define PMREM4\nuniform samplerCube texture_prefilteredCubeMap4;\n#endif\nuniform float material_reflectivity;\nvec3 calcReflection(vec3 tReflDirW, float tGlossiness) {\n\tfloat bias = saturate(1.0 - tGlossiness) * 5.0;\n\tint index1 = int(bias);\n\tint index2 = int(min(bias + 1.0, 7.0));\n\tvec3 fixedReflDir = fixSeams(cubeMapProject(tReflDirW), bias);\n\tfixedReflDir.x *= -1.0;\n\tvec4 cubes[6];\n\tcubes[0] = textureCube(texture_prefilteredCubeMap128, fixedReflDir);\n\tcubes[1] = textureCube(texture_prefilteredCubeMap64, fixedReflDir);\n\tcubes[2] = textureCube(texture_prefilteredCubeMap32, fixedReflDir);\n\tcubes[3] = textureCube(texture_prefilteredCubeMap16, fixedReflDir);\n\tcubes[4] = textureCube(texture_prefilteredCubeMap8, fixedReflDir);\n\tcubes[5] = textureCube(texture_prefilteredCubeMap4, fixedReflDir);\n\tvec4 cube[2];\n\tfor(int i = 0; i < 6; i++) {\n\t\tif (i == index1) {\n\t\t\tcube[0] = cubes[i];\n\t\t}\n\t\tif (i == index2) {\n\t\t\tcube[1] = cubes[i];\n\t\t}\n\t}\n\tvec4 cubeFinal = mix(cube[0], cube[1], fract(bias));\n\tvec3 refl = processEnvironment($DECODE(cubeFinal).rgb);\n\treturn refl;\n}\nvoid addReflection() {\n\tdReflection += vec4(calcReflection(dReflDirW, dGlossiness), material_reflectivity);\n}\n";

	var reflectionPrefilteredCubeLodPS = "#ifndef PMREM4\n#define PMREM4\n#extension GL_EXT_shader_texture_lod : enable\nuniform samplerCube texture_prefilteredCubeMap128;\n#endif\nuniform float material_reflectivity;\nvec3 calcReflection(vec3 tReflDirW, float tGlossiness) {\n\tfloat bias = saturate(1.0 - tGlossiness) * 5.0;\n\tvec3 fixedReflDir = fixSeams(cubeMapProject(tReflDirW), bias);\n\tfixedReflDir.x *= -1.0;\n\tvec3 refl = processEnvironment($DECODE( textureCubeLodEXT(texture_prefilteredCubeMap128, fixedReflDir, bias) ).rgb);\n\treturn refl;\n}\nvoid addReflection() {\n\tdReflection += vec4(calcReflection(dReflDirW, dGlossiness), material_reflectivity);\n}\n";

	var reflectionSpherePS = "#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nuniform sampler2D texture_sphereMap;\nuniform float material_reflectivity;\nvec3 calcReflection(vec3 tReflDirW, float tGlossiness) {\n\tvec3 reflDirV = (mat3(matrix_view) * tReflDirW).xyz;\n\tfloat m = 2.0 * sqrt( dot(reflDirV.xy, reflDirV.xy) + (reflDirV.z+1.0)*(reflDirV.z+1.0) );\n\tvec2 sphereMapUv = reflDirV.xy / m + 0.5;\n\treturn $texture2DSAMPLE(texture_sphereMap, sphereMapUv).rgb;\n}\nvoid addReflection() {\n\tdReflection += vec4(calcReflection(dReflDirW, dGlossiness), material_reflectivity);\n}\n";

	var reflectionSphereLowPS = "uniform sampler2D texture_sphereMap;\nuniform float material_reflectivity;\nvec3 calcReflection(vec3 tReflDirW, float tGlossiness) {\n\tvec3 reflDirV = vNormalV;\n\tvec2 sphereMapUv = reflDirV.xy * 0.5 + 0.5;\n\treturn $texture2DSAMPLE(texture_sphereMap, sphereMapUv).rgb;\n}\nvoid addReflection() {\n\tdReflection += vec4(calcReflection(dReflDirW, dGlossiness), material_reflectivity);\n}\n";

	var refractionPS = "uniform float material_refraction, material_refractionIndex;\nvec3 refract2(vec3 viewVec, vec3 Normal, float IOR) {\n\tfloat vn = dot(viewVec, Normal);\n\tfloat k = 1.0 - IOR * IOR * (1.0 - vn * vn);\n\tvec3 refrVec = IOR * viewVec - (IOR * vn + sqrt(k)) * Normal;\n\treturn refrVec;\n}\nvoid addRefraction() {\n\tvec3 tmp = dReflDirW;\n\tvec4 tmp2 = dReflection;\n\tdReflection = vec4(0.0);\n\tdReflDirW = refract2(-dViewDirW, dNormalW, material_refractionIndex);\n\taddReflection();\n\tdDiffuseLight = mix(dDiffuseLight, dReflection.rgb * dAlbedo, material_refraction);\n\tdReflDirW = tmp;\n\tdReflection = tmp2;\n}\n";

	var reprojectPS = "\nvarying vec2 vUv0;\nuniform sampler2D sourceTex;\nuniform samplerCube sourceCube;\nuniform vec4 params;\nfloat PI = 3.141592653589793;\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\nvec3 decodeLinear(vec4 source) {\n\treturn source.rgb;\n}\nvec4 encodeLinear(vec3 source) {\n\treturn vec4(source, 1.0);\n}\nvec3 decodeGamma(vec4 source) {\n\treturn pow(source.xyz, vec3(2.2));\n}\nvec4 encodeGamma(vec3 source) {\n\treturn vec4(pow(source + 0.0000001, vec3(1.0 / 2.2)), 1.0);\n}\nvec3 decodeRGBM(vec4 rgbm) {\n\tvec3 color = (8.0 * rgbm.a) * rgbm.rgb;\n\treturn color * color;\n}\nvec4 encodeRGBM(vec3 source) {\n\tvec4 result;\n\tresult.rgb = pow(source.rgb, vec3(0.5));\n\tresult.rgb *= 1.0 / 8.0;\n\tresult.a = saturate( max( max( result.r, result.g ), max( result.b, 1.0 / 255.0 ) ) );\n\tresult.a = ceil(result.a * 255.0) / 255.0;\n\tresult.rgb /= result.a;\n\treturn result;\n}\nvec3 decodeRGBE(vec4 source) {\n\tif (source.a == 0.0) {\n\t\treturn vec3(0.0, 0.0, 0.0);\n\t} else {\n\t\treturn source.xyz * pow(2.0, source.w * 255.0 - 128.0);\n\t}\n}\nvec4 encodeRGBE(vec3 source) {\n\tfloat maxVal = max(source.x, max(source.y, source.z));\n\tif (maxVal < 1e-32) {\n\t\treturn vec4(0, 0, 0, 0);\n\t} else {\n\t\tfloat e = ceil(log2(maxVal));\n\t\treturn vec4(source / pow(2.0, e), (e + 128.0) / 255.0);\n\t}\n}\nvec2 toSpherical(vec3 dir) {\n\treturn vec2(atan(dir.z, dir.x) * -1.0, asin(dir.y));\n}\nvec3 fromSpherical(vec2 uv) {\n\treturn vec3(cos(uv.y) * cos(-uv.x),\n\t\t\t\tsin(uv.y),\n\t\t\t\tcos(uv.y) * sin(-uv.x));\n}\nvec4 sampleEquirect(vec2 sph) {\n\treturn texture2D(sourceTex, sph / vec2(PI * 2.0, PI) + 0.5);\n}\nvec4 sampleEquirect(vec3 dir) {\n\treturn sampleEquirect(toSpherical(dir));\n}\nvec4 sampleCubemap(vec3 dir) {\n\treturn textureCube(sourceCube, dir);\n}\nvec4 sampleCubemap(vec2 sph) {\n\treturn sampleCubemap(fromSpherical(sph));\n}\nvec3 getDirectionEquirect() {\n\treturn fromSpherical((vUv0 * 2.0 - 1.0) * vec2(PI, PI * 0.5));\n}\nvec3 getDirectionCubemap() {\n\tvec2 st = vUv0 * 2.0 - 1.0;\n\tfloat face = params.x;\n\tvec3 vec;\n\tif (face==0.0) {\n\t\tvec = vec3(1, -st.y, -st.x);\n\t} else if (face==1.0) {\n\t\tvec = vec3(-1, -st.y, st.x);\n\t} else if (face==2.0) {\n\t\tvec = vec3(st.x, 1, st.y);\n\t} else if (face==3.0) {\n\t\tvec = vec3(st.x, -1, -st.y);\n\t} else if (face==4.0) {\n\t\tvec = vec3(st.x, -st.y, 1);\n\t} else {\n\t\tvec = vec3(-st.x, -st.y, -1);\n\t}\n\treturn normalize(vec);\n}\nmat3 matrixFromVector(vec3 n) {\n\tfloat a = 1.0 / (1.0 + n.z);\n\tfloat b = -n.x * n.y * a;\n\tvec3 b1 = vec3(1.0 - n.x * n.x * a, b, -n.x);\n\tvec3 b2 = vec3(b, 1.0 - n.y * n.y * a, -n.y);\n\treturn mat3(b1, b2, n);\n}\nfloat rnd(int i) {\n\tfloat sini = sin(float(i));\n\tfloat cosi = cos(float(i));\n\treturn fract(sin(dot(vec2(sini, cosi), vec2(12.9898, 78.233) * 2.0)) * 43758.5453);\n}\nvec3 hemisphereSamplePhong(vec2 uv, float specPow) {\n\tfloat phi = uv.y * 2.0 * PI;\n\tfloat cosTheta = pow(1.0 - uv.x, 1.0 / (specPow + 1.0));\n\tfloat sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n\treturn vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);\n}\nvec4 reproject() {\n\tif (NUM_SAMPLES <= 1) {\n\t\treturn ENCODE_FUNC(DECODE_FUNC(SOURCE_FUNC(TARGET_FUNC())));\n\t} else {\n\t\tvec2 sph = toSpherical(TARGET_FUNC());\n\t\tvec2 sphu = dFdx(sph);\n\t\tvec2 sphv = dFdy(sph);\n\t\tconst float num = sqrt(float(NUM_SAMPLES));\n\t\tvec3 result = vec3(0.0);\n\t\tfor (float u=0.0; u<num; ++u) {\n\t\t\tfor (float v=0.0; v<num; ++v) {\n\t\t\t\tresult += DECODE_FUNC(SOURCE_FUNC(sph +\n\t\t\t\t\t\t\t\t\t\t\t\t  sphu * (u / num - 0.5) +\n\t\t\t\t\t\t\t\t\t\t\t\t  sphv * (v / num - 0.5)));\n\t\t\t}\n\t\t}\n\t\treturn ENCODE_FUNC(result / (num * num));\n\t}\n}\nvec4 prefilter() {\n\tvec3 vec = TARGET_FUNC();\n\tmat3 vecSpace = matrixFromVector(vec);\n\tvec3 result = vec3(0.0);\n\tfor (int i=0; i<NUM_SAMPLES; ++i) {\n\t\tvec2 uv = vec2(float(i) / float(NUM_SAMPLES), rnd(i));\n\t\tvec3 dir = vecSpace * hemisphereSamplePhong(uv, params.y);\n\t\tresult += DECODE_FUNC(SOURCE_FUNC(dir));\n\t}\n\treturn ENCODE_FUNC(result / float(NUM_SAMPLES));\n}\nvoid main(void) {\n\tgl_FragColor = (params.z == 0.0) ? reproject() : prefilter();\n}\n";

	var rgbmPS = "vec3 decodeRGBM(vec4 rgbm) {\n\tvec3 color = (8.0 * rgbm.a) * rgbm.rgb;\n\treturn color * color;\n}\nvec3 texture2DRGBM(sampler2D tex, vec2 uv) {\n\treturn decodeRGBM(texture2D(tex, uv));\n}\nvec3 textureCubeRGBM(samplerCube tex, vec3 uvw) {\n\treturn decodeRGBM(textureCube(tex, uvw));\n}\n";

	var screenDepthPS = "uniform sampler2D uDepthMap;\n#ifndef SCREENSIZE\n#define SCREENSIZE\nuniform vec4 uScreenSize;\n#endif\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\n#ifndef CAMERAPLANES\n#define CAMERAPLANES\nuniform vec4 camera_params;\n#endif\n#ifdef GL2\nfloat linearizeDepth(float z) {\n\tz = z * 2.0 - 1.0;\n\treturn 1.0 / (camera_params.z * z + camera_params.w);\n}\n#else\n#ifndef UNPACKFLOAT\n#define UNPACKFLOAT\nfloat unpackFloat(vec4 rgbaDepth) {\n\tconst vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\n\treturn dot(rgbaDepth, bitShift);\n}\n#endif\n#endif\nfloat getLinearScreenDepth(vec2 uv) {\n\t#ifdef GL2\n\treturn linearizeDepth(texture2D(uDepthMap, uv).r) * camera_params.y;\n\t#else\n\treturn unpackFloat(texture2D(uDepthMap, uv)) * camera_params.y;\n\t#endif\n}\n#ifndef VERTEXSHADER\nfloat getLinearScreenDepth() {\n\tvec2 uv = gl_FragCoord.xy * uScreenSize.zw;\n\treturn getLinearScreenDepth(uv);\n}\n#endif\nfloat getLinearDepth(vec3 pos) {\n\treturn -(matrix_view * vec4(pos, 1.0)).z;\n}\n";

	var shadowCommonPS = "void normalOffsetPointShadow(vec4 shadowParams) {\n\tfloat distScale = length(dLightDirW);\n\tvec3 wPos = vPositionW + dVertexNormalW * shadowParams.y * clamp(1.0 - dot(dVertexNormalW, -dLightDirNormW), 0.0, 1.0) * distScale;\n\tvec3 dir = wPos - dLightPosW;\n\tdLightDirW = dir;\n}\n";

	var shadowCoordPS = "void _getShadowCoordOrtho(mat4 shadowMatrix, vec3 shadowParams, vec3 wPos) {\n\tdShadowCoord = (shadowMatrix * vec4(wPos, 1.0)).xyz;\n\tdShadowCoord.z = saturate(dShadowCoord.z) - 0.0001;\n\t#ifdef SHADOWBIAS\n\tdShadowCoord.z += getShadowBias(shadowParams.x, shadowParams.z);\n\t#endif\n}\nvoid _getShadowCoordPersp(mat4 shadowMatrix, vec4 shadowParams, vec3 wPos) {\n\tvec4 projPos = shadowMatrix * vec4(wPos, 1.0);\n\tprojPos.xy /= projPos.w;\n\tdShadowCoord.xy = projPos.xy;\n\tdShadowCoord.z = length(dLightDirW) * shadowParams.w;\n\t#ifdef SHADOWBIAS\n\tdShadowCoord.z += getShadowBias(shadowParams.x, shadowParams.z);\n\t#endif\n}\nvoid getShadowCoordOrtho(mat4 shadowMatrix, vec3 shadowParams) {\n\t_getShadowCoordOrtho(shadowMatrix, shadowParams, vPositionW);\n}\nvoid getShadowCoordPersp(mat4 shadowMatrix, vec4 shadowParams) {\n\t_getShadowCoordPersp(shadowMatrix, shadowParams, vPositionW);\n}\nvoid getShadowCoordPerspNormalOffset(mat4 shadowMatrix, vec4 shadowParams) {\n\tfloat distScale = abs(dot(vPositionW - dLightPosW, dLightDirNormW));\n\tvec3 wPos = vPositionW + dVertexNormalW * shadowParams.y * clamp(1.0 - dot(dVertexNormalW, -dLightDirNormW), 0.0, 1.0) * distScale;\n\t_getShadowCoordPersp(shadowMatrix, shadowParams, wPos);\n}\nvoid getShadowCoordOrthoNormalOffset(mat4 shadowMatrix, vec3 shadowParams) {\n\tvec3 wPos = vPositionW + dVertexNormalW * shadowParams.y * clamp(1.0 - dot(dVertexNormalW, -dLightDirNormW), 0.0, 1.0);\n\t_getShadowCoordOrtho(shadowMatrix, shadowParams, wPos);\n}\n";

	var shadowCoordVS = "void getLightDirPoint(vec3 lightPosW) {\n\tvec3 lightDirW = vPositionW - lightPosW;\n\tdLightDirNormW = normalize(lightDirW);\n\tdLightPosW = lightPosW;\n}\nvoid _getShadowCoordOrtho(mat4 shadowMatrix, vec3 shadowParams, vec3 wPos) {\n\tvec4 projPos = shadowMatrix * vec4(wPos, 1.0);\n\tvMainShadowUv = projPos;\n}\nvoid _getShadowCoordPersp(mat4 shadowMatrix, vec3 shadowParams, vec3 wPos) {\n\tvec4 projPos = shadowMatrix * vec4(wPos, 1.0);\n\tvMainShadowUv = projPos;\n}\nvoid getShadowCoordOrtho(mat4 shadowMatrix, vec3 shadowParams) {\n\t_getShadowCoordOrtho(shadowMatrix, shadowParams, vPositionW);\n}\nvoid getShadowCoordPersp(mat4 shadowMatrix, vec3 shadowParams) {\n\t_getShadowCoordPersp(shadowMatrix, shadowParams, vPositionW);\n}\nvoid getShadowCoordPerspNormalOffset(mat4 shadowMatrix, vec3 shadowParams) {\n\tfloat distScale = abs(dot(vPositionW - dLightPosW, dLightDirNormW));\n\tvec3 wPos = vPositionW + dNormalW * shadowParams.y * clamp(1.0 - dot(dNormalW, -dLightDirNormW), 0.0, 1.0) * distScale;\n\t_getShadowCoordPersp(shadowMatrix, shadowParams, wPos);\n}\nvoid getShadowCoordOrthoNormalOffset(mat4 shadowMatrix, vec3 shadowParams) {\n\tvec3 wPos = vPositionW + dNormalW * shadowParams.y * clamp(1.0 - dot(dNormalW, -dLightDirNormW), 0.0, 1.0);\n\t_getShadowCoordOrtho(shadowMatrix, shadowParams, wPos);\n}\n";

	var shadowCoordPerspZbufferPS = "void _getShadowCoordPerspZbuffer(mat4 shadowMatrix, vec4 shadowParams, vec3 wPos) {\n\tvec4 projPos = shadowMatrix * vec4(wPos, 1.0);\n\tprojPos.xyz /= projPos.w;\n\tdShadowCoord = projPos.xyz;\n}\nvoid getShadowCoordPerspZbufferNormalOffset(mat4 shadowMatrix, vec4 shadowParams) {\n\tfloat distScale = abs(dot(vPositionW - dLightPosW, dLightDirNormW));\n\tvec3 wPos = vPositionW + dVertexNormalW * shadowParams.y * clamp(1.0 - dot(dVertexNormalW, -dLightDirNormW), 0.0, 1.0) * distScale;\n\t_getShadowCoordPerspZbuffer(shadowMatrix, shadowParams, wPos);\n}\nvoid getShadowCoordPerspZbuffer(mat4 shadowMatrix, vec4 shadowParams) {\n\t_getShadowCoordPerspZbuffer(shadowMatrix, shadowParams, vPositionW);\n}\n";

	var shadowEVSMPS = "float VSM$(sampler2D tex, vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {\n\tvec3 moments = texture2D(tex, texCoords).xyz;\n\treturn calculateEVSM(moments, Z, vsmBias, exponent);\n}\nfloat getShadowVSM$(sampler2D shadowMap, vec3 shadowParams, float exponent) {\n\treturn VSM$(shadowMap, dShadowCoord.xy, shadowParams.x, dShadowCoord.z, shadowParams.y, exponent);\n}\nfloat getShadowSpotVSM$(sampler2D shadowMap, vec4 shadowParams, float exponent) {\n\treturn VSM$(shadowMap, dShadowCoord.xy, shadowParams.x, length(dLightDirW) * shadowParams.w + shadowParams.z, shadowParams.y, exponent);\n}\n";

	var shadowEVSMnPS = "float VSM$(sampler2D tex, vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {\n\tfloat pixelSize = 1.0 / resolution;\n\ttexCoords -= vec2(pixelSize);\n\tvec3 s00 = texture2D(tex, texCoords).xyz;\n\tvec3 s10 = texture2D(tex, texCoords + vec2(pixelSize, 0)).xyz;\n\tvec3 s01 = texture2D(tex, texCoords + vec2(0, pixelSize)).xyz;\n\tvec3 s11 = texture2D(tex, texCoords + vec2(pixelSize)).xyz;\n\tvec2 fr = fract(texCoords * resolution);\n\tvec3 h0 = mix(s00, s10, fr.x);\n\tvec3 h1 = mix(s01, s11, fr.x);\n\tvec3 moments = mix(h0, h1, fr.y);\n\treturn calculateEVSM(moments, Z, vsmBias, exponent);\n}\nfloat getShadowVSM$(sampler2D shadowMap, vec3 shadowParams, float exponent) {\n\treturn VSM$(shadowMap, dShadowCoord.xy, shadowParams.x, dShadowCoord.z, shadowParams.y, exponent);\n}\nfloat getShadowSpotVSM$(sampler2D shadowMap, vec4 shadowParams, float exponent) {\n\treturn VSM$(shadowMap, dShadowCoord.xy, shadowParams.x, length(dLightDirW) * shadowParams.w + shadowParams.z, shadowParams.y, exponent);\n}\n";

	var shadowStandardPS = "vec3 lessThan2(vec3 a, vec3 b) {\n\treturn clamp((b - a)*1000.0, 0.0, 1.0);\n}\n#ifndef UNPACKFLOAT\n#define UNPACKFLOAT\nfloat unpackFloat(vec4 rgbaDepth) {\n\tconst vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\n\treturn dot(rgbaDepth, bitShift);\n}\n#endif\n#ifdef GL2\nfloat _getShadowPCF3x3(sampler2DShadow shadowMap, vec3 shadowParams) {\n\tfloat z = dShadowCoord.z;\n\tvec2 uv = dShadowCoord.xy * shadowParams.x;\n\tfloat shadowMapSizeInv = 1.0 / shadowParams.x;\n\tvec2 base_uv = floor(uv + 0.5);\n\tfloat s = (uv.x + 0.5 - base_uv.x);\n\tfloat t = (uv.y + 0.5 - base_uv.y);\n\tbase_uv -= vec2(0.5);\n\tbase_uv *= shadowMapSizeInv;\n\tfloat sum = 0.0;\n\tfloat uw0 = (3.0 - 2.0 * s);\n\tfloat uw1 = (1.0 + 2.0 * s);\n\tfloat u0 = (2.0 - s) / uw0 - 1.0;\n\tfloat u1 = s / uw1 + 1.0;\n\tfloat vw0 = (3.0 - 2.0 * t);\n\tfloat vw1 = (1.0 + 2.0 * t);\n\tfloat v0 = (2.0 - t) / vw0 - 1.0;\n\tfloat v1 = t / vw1 + 1.0;\n\tu0 = u0 * shadowMapSizeInv + base_uv.x;\n\tv0 = v0 * shadowMapSizeInv + base_uv.y;\n\tu1 = u1 * shadowMapSizeInv + base_uv.x;\n\tv1 = v1 * shadowMapSizeInv + base_uv.y;\n\tsum += uw0 * vw0 * texture(shadowMap, vec3(u0, v0, z));\n\tsum += uw1 * vw0 * texture(shadowMap, vec3(u1, v0, z));\n\tsum += uw0 * vw1 * texture(shadowMap, vec3(u0, v1, z));\n\tsum += uw1 * vw1 * texture(shadowMap, vec3(u1, v1, z));\n\tsum *= 1.0f / 16.0;\n\treturn sum;\n}\nfloat getShadowPCF3x3(sampler2DShadow shadowMap, vec3 shadowParams) {\n\treturn _getShadowPCF3x3(shadowMap, shadowParams);\n}\nfloat getShadowSpotPCF3x3(sampler2DShadow shadowMap, vec4 shadowParams) {\n\treturn _getShadowPCF3x3(shadowMap, shadowParams.xyz);\n}\n#else\nfloat _xgetShadowPCF3x3(mat3 depthKernel, sampler2D shadowMap, vec3 shadowParams) {\n\tmat3 shadowKernel;\n\tvec3 shadowCoord = dShadowCoord;\n\tvec3 shadowZ = vec3(shadowCoord.z);\n\tshadowKernel[0] = vec3(greaterThan(depthKernel[0], shadowZ));\n\tshadowKernel[1] = vec3(greaterThan(depthKernel[1], shadowZ));\n\tshadowKernel[2] = vec3(greaterThan(depthKernel[2], shadowZ));\n\tvec2 fractionalCoord = fract( shadowCoord.xy * shadowParams.x );\n\tshadowKernel[0] = mix(shadowKernel[0], shadowKernel[1], fractionalCoord.x);\n\tshadowKernel[1] = mix(shadowKernel[1], shadowKernel[2], fractionalCoord.x);\n\tvec4 shadowValues;\n\tshadowValues.x = mix(shadowKernel[0][0], shadowKernel[0][1], fractionalCoord.y);\n\tshadowValues.y = mix(shadowKernel[0][1], shadowKernel[0][2], fractionalCoord.y);\n\tshadowValues.z = mix(shadowKernel[1][0], shadowKernel[1][1], fractionalCoord.y);\n\tshadowValues.w = mix(shadowKernel[1][1], shadowKernel[1][2], fractionalCoord.y);\n\treturn dot( shadowValues, vec4( 1.0 ) ) * 0.25;\n}\nfloat _getShadowPCF3x3(sampler2D shadowMap, vec3 shadowParams) {\n\tvec3 shadowCoord = dShadowCoord;\n\tfloat xoffset = 1.0 / shadowParams.x;\n\tfloat dx0 = -xoffset;\n\tfloat dx1 = xoffset;\n\tmat3 depthKernel;\n\tdepthKernel[0][0] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx0, dx0)));\n\tdepthKernel[0][1] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx0, 0.0)));\n\tdepthKernel[0][2] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx0, dx1)));\n\tdepthKernel[1][0] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(0.0, dx0)));\n\tdepthKernel[1][1] = unpackFloat(texture2D(shadowMap, shadowCoord.xy));\n\tdepthKernel[1][2] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(0.0, dx1)));\n\tdepthKernel[2][0] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx1, dx0)));\n\tdepthKernel[2][1] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx1, 0.0)));\n\tdepthKernel[2][2] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx1, dx1)));\n\treturn _xgetShadowPCF3x3(depthKernel, shadowMap, shadowParams);\n}\nfloat getShadowPCF3x3(sampler2D shadowMap, vec3 shadowParams) {\n\treturn _getShadowPCF3x3(shadowMap, shadowParams);\n}\nfloat getShadowSpotPCF3x3(sampler2D shadowMap, vec4 shadowParams) {\n\treturn _getShadowPCF3x3(shadowMap, shadowParams.xyz);\n}\n#endif\nfloat _getShadowPoint(samplerCube shadowMap, vec4 shadowParams, vec3 dir) {\n\tvec3 tc = normalize(dir);\n\tvec3 tcAbs = abs(tc);\n\tvec4 dirX = vec4(1,0,0, tc.x);\n\tvec4 dirY = vec4(0,1,0, tc.y);\n\tfloat majorAxisLength = tc.z;\n\tif ((tcAbs.x > tcAbs.y) && (tcAbs.x > tcAbs.z)) {\n\t\tdirX = vec4(0,0,1, tc.z);\n\t\tdirY = vec4(0,1,0, tc.y);\n\t\tmajorAxisLength = tc.x;\n\t} else if ((tcAbs.y > tcAbs.x) && (tcAbs.y > tcAbs.z)) {\n\t\tdirX = vec4(1,0,0, tc.x);\n\t\tdirY = vec4(0,0,1, tc.z);\n\t\tmajorAxisLength = tc.y;\n\t}\n\tfloat shadowParamsInFaceSpace = ((1.0/shadowParams.x) * 2.0) * abs(majorAxisLength);\n\tvec3 xoffset = (dirX.xyz * shadowParamsInFaceSpace);\n\tvec3 yoffset = (dirY.xyz * shadowParamsInFaceSpace);\n\tvec3 dx0 = -xoffset;\n\tvec3 dy0 = -yoffset;\n\tvec3 dx1 = xoffset;\n\tvec3 dy1 = yoffset;\n\tmat3 shadowKernel;\n\tmat3 depthKernel;\n\tdepthKernel[0][0] = unpackFloat(textureCube(shadowMap, tc + dx0 + dy0));\n\tdepthKernel[0][1] = unpackFloat(textureCube(shadowMap, tc + dx0));\n\tdepthKernel[0][2] = unpackFloat(textureCube(shadowMap, tc + dx0 + dy1));\n\tdepthKernel[1][0] = unpackFloat(textureCube(shadowMap, tc + dy0));\n\tdepthKernel[1][1] = unpackFloat(textureCube(shadowMap, tc));\n\tdepthKernel[1][2] = unpackFloat(textureCube(shadowMap, tc + dy1));\n\tdepthKernel[2][0] = unpackFloat(textureCube(shadowMap, tc + dx1 + dy0));\n\tdepthKernel[2][1] = unpackFloat(textureCube(shadowMap, tc + dx1));\n\tdepthKernel[2][2] = unpackFloat(textureCube(shadowMap, tc + dx1 + dy1));\n\tvec3 shadowZ = vec3(length(dir) * shadowParams.w + shadowParams.z);\n\tshadowKernel[0] = vec3(lessThan2(depthKernel[0], shadowZ));\n\tshadowKernel[1] = vec3(lessThan2(depthKernel[1], shadowZ));\n\tshadowKernel[2] = vec3(lessThan2(depthKernel[2], shadowZ));\n\tvec2 uv = (vec2(dirX.w, dirY.w) / abs(majorAxisLength)) * 0.5;\n\tvec2 fractionalCoord = fract( uv * shadowParams.x );\n\tshadowKernel[0] = mix(shadowKernel[0], shadowKernel[1], fractionalCoord.x);\n\tshadowKernel[1] = mix(shadowKernel[1], shadowKernel[2], fractionalCoord.x);\n\tvec4 shadowValues;\n\tshadowValues.x = mix(shadowKernel[0][0], shadowKernel[0][1], fractionalCoord.y);\n\tshadowValues.y = mix(shadowKernel[0][1], shadowKernel[0][2], fractionalCoord.y);\n\tshadowValues.z = mix(shadowKernel[1][0], shadowKernel[1][1], fractionalCoord.y);\n\tshadowValues.w = mix(shadowKernel[1][1], shadowKernel[1][2], fractionalCoord.y);\n\treturn 1.0 - dot( shadowValues, vec4( 1.0 ) ) * 0.25;\n}\nfloat getShadowPointPCF3x3(samplerCube shadowMap, vec4 shadowParams) {\n\treturn _getShadowPoint(shadowMap, shadowParams, dLightDirW);\n}\n";

	var shadowStandardGL2PS = "float _getShadowPCF5x5(sampler2DShadow shadowMap, vec3 shadowParams) {\n\tfloat z = dShadowCoord.z;\n\tvec2 uv = dShadowCoord.xy * shadowParams.x;\n\tfloat shadowMapSizeInv = 1.0 / shadowParams.x;\n\tvec2 base_uv = floor(uv + 0.5);\n\tfloat s = (uv.x + 0.5 - base_uv.x);\n\tfloat t = (uv.y + 0.5 - base_uv.y);\n\tbase_uv -= vec2(0.5);\n\tbase_uv *= shadowMapSizeInv;\n\tfloat uw0 = (4.0 - 3.0 * s);\n\tfloat uw1 = 7.0;\n\tfloat uw2 = (1.0 + 3.0 * s);\n\tfloat u0 = (3.0 - 2.0 * s) / uw0 - 2.0;\n\tfloat u1 = (3.0 + s) / uw1;\n\tfloat u2 = s / uw2 + 2.0;\n\tfloat vw0 = (4.0 - 3.0 * t);\n\tfloat vw1 = 7.0;\n\tfloat vw2 = (1.0 + 3.0 * t);\n\tfloat v0 = (3.0 - 2.0 * t) / vw0 - 2.0;\n\tfloat v1 = (3.0 + t) / vw1;\n\tfloat v2 = t / vw2 + 2.0;\n\tfloat sum = 0.0;\n\tu0 = u0 * shadowMapSizeInv + base_uv.x;\n\tv0 = v0 * shadowMapSizeInv + base_uv.y;\n\tu1 = u1 * shadowMapSizeInv + base_uv.x;\n\tv1 = v1 * shadowMapSizeInv + base_uv.y;\n\tu2 = u2 * shadowMapSizeInv + base_uv.x;\n\tv2 = v2 * shadowMapSizeInv + base_uv.y;\n\tsum += uw0 * vw0 * texture(shadowMap, vec3(u0, v0, z));\n\tsum += uw1 * vw0 * texture(shadowMap, vec3(u1, v0, z));\n\tsum += uw2 * vw0 * texture(shadowMap, vec3(u2, v0, z));\n\tsum += uw0 * vw1 * texture(shadowMap, vec3(u0, v1, z));\n\tsum += uw1 * vw1 * texture(shadowMap, vec3(u1, v1, z));\n\tsum += uw2 * vw1 * texture(shadowMap, vec3(u2, v1, z));\n\tsum += uw0 * vw2 * texture(shadowMap, vec3(u0, v2, z));\n\tsum += uw1 * vw2 * texture(shadowMap, vec3(u1, v2, z));\n\tsum += uw2 * vw2 * texture(shadowMap, vec3(u2, v2, z));\n\tsum *= 1.0f / 144.0;\n\tsum = gammaCorrectInput(sum);\n\tsum = saturate(sum);\n\treturn sum;\n}\nfloat getShadowPCF5x5(sampler2DShadow shadowMap, vec3 shadowParams) {\n\treturn _getShadowPCF5x5(shadowMap, shadowParams);\n}\nfloat getShadowSpotPCF5x5(sampler2DShadow shadowMap, vec4 shadowParams) {\n\treturn _getShadowPCF5x5(shadowMap, shadowParams.xyz);\n}\n";

	var shadowStandardGL2VSPS = "float getShadowPCF5x5VS(sampler2DShadow shadowMap, vec3 shadowParams) {\n\tdShadowCoord = vMainShadowUv.xyz;\n\tdShadowCoord.z = saturate(dShadowCoord.z) - 0.0001;\n\treturn _getShadowPCF5x5(shadowMap, shadowParams);\n}\n";

	var shadowStandardVSPS = "#ifdef GL2\n#define SHADOW_SAMPLERVS sampler2DShadow\n#else\n#define SHADOW_SAMPLERVS sampler2D\n#endif\nfloat getShadowPCF3x3VS(SHADOW_SAMPLERVS shadowMap, vec3 shadowParams) {\n\tdShadowCoord = vMainShadowUv.xyz;\n\tdShadowCoord.z = saturate(dShadowCoord.z) - 0.0001;\n\t#ifdef SHADOWBIAS\n\tdShadowCoord.z += getShadowBias(shadowParams.x, shadowParams.z);\n\t#endif\n\treturn _getShadowPCF3x3(shadowMap, shadowParams);\n}\n";

	var shadowVSM8PS = "float calculateVSM8(vec3 moments, float Z, float vsmBias) {\n\tfloat VSMBias = vsmBias;\n\tfloat depthScale = VSMBias * Z;\n\tfloat minVariance1 = depthScale * depthScale;\n\treturn chebyshevUpperBound(moments.xy, Z, minVariance1, 0.1);\n}\nfloat decodeFloatRG(vec2 rg) {\n\treturn rg.y*(1.0/255.0) + rg.x;\n}\nfloat VSM8(sampler2D tex, vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {\n\tvec4 c = texture2D(tex, texCoords);\n\tvec3 moments = vec3(decodeFloatRG(c.xy), decodeFloatRG(c.zw), 0.0);\n\treturn calculateVSM8(moments, Z, vsmBias);\n}\nfloat getShadowVSM8(sampler2D shadowMap, vec3 shadowParams, float exponent) {\n\treturn VSM8(shadowMap, dShadowCoord.xy, shadowParams.x, dShadowCoord.z, shadowParams.y, 0.0);\n}\nfloat getShadowSpotVSM8(sampler2D shadowMap, vec4 shadowParams, float exponent) {\n\treturn VSM8(shadowMap, dShadowCoord.xy, shadowParams.x, length(dLightDirW) * shadowParams.w + shadowParams.z, shadowParams.y, 0.0);\n}\n";

	var shadowVSMVSPS = "float getShadowVSM$VS(sampler2D shadowMap, vec3 shadowParams, float exponent) {\n\tdShadowCoord = vMainShadowUv.xyz;\n\tdShadowCoord.z += shadowParams.z;\n\tdShadowCoord.xyz /= vMainShadowUv.w;\n\tdShadowCoord.z = min(dShadowCoord.z, 1.0);\n\treturn $VSM(shadowMap, dShadowCoord.xy, shadowParams.x, dShadowCoord.z, shadowParams.y, exponent);\n}\n";

	var shadowVSM_commonPS = "float linstep(float a, float b, float v) {\n\treturn saturate((v - a) / (b - a));\n}\nfloat reduceLightBleeding(float pMax, float amount) {\n   return linstep(amount, 1.0, pMax);\n}\nfloat chebyshevUpperBound(vec2 moments, float mean, float minVariance, float lightBleedingReduction) {\n\tfloat variance = moments.y - (moments.x * moments.x);\n\tvariance = max(variance, minVariance);\n\tfloat d = mean - moments.x;\n\tfloat pMax = variance / (variance + (d * d));\n\tpMax = reduceLightBleeding(pMax, lightBleedingReduction);\n\treturn (mean <= moments.x ? 1.0 : pMax);\n}\nfloat calculateEVSM(vec3 moments, float Z, float vsmBias, float exponent) {\n\tZ = 2.0 * Z - 1.0;\n\tfloat warpedDepth = exp(exponent * Z);\n\tmoments.xy += vec2(warpedDepth, warpedDepth*warpedDepth) * (1.0 - moments.z);\n\tfloat VSMBias = vsmBias;\n\tfloat depthScale = VSMBias * exponent * warpedDepth;\n\tfloat minVariance1 = depthScale * depthScale;\n\treturn chebyshevUpperBound(moments.xy, warpedDepth, minVariance1, 0.1);\n}\n";

	var skinBatchConstVS = "attribute float vertex_boneIndices;\nuniform vec4 matrix_pose[BONE_LIMIT * 3];\nmat4 getBoneMatrix(const in float i) {\n\tvec4 v1 = matrix_pose[int(3.0 * i)];\n\tvec4 v2 = matrix_pose[int(3.0 * i + 1.0)];\n\tvec4 v3 = matrix_pose[int(3.0 * i + 2.0)];\n\treturn mat4(\n\t\tv1.x, v2.x, v3.x, 0,\n\t\tv1.y, v2.y, v3.y, 0,\n\t\tv1.z, v2.z, v3.z, 0,\n\t\tv1.w, v2.w, v3.w, 1\n\t);\n}\n";

	var skinBatchTexVS = "attribute float vertex_boneIndices;\nuniform highp sampler2D texture_poseMap;\nuniform vec4 texture_poseMapSize;\nmat4 getBoneMatrix(const in float i) {\n\tfloat j = i * 3.0;\n\tfloat dx = texture_poseMapSize.z;\n\tfloat dy = texture_poseMapSize.w;\n\tfloat y = floor(j * dx);\n\tfloat x = j - (y * texture_poseMapSize.x);\n\ty = dy * (y + 0.5);\n\tvec4 v1 = texture2D(texture_poseMap, vec2(dx * (x + 0.5), y));\n\tvec4 v2 = texture2D(texture_poseMap, vec2(dx * (x + 1.5), y));\n\tvec4 v3 = texture2D(texture_poseMap, vec2(dx * (x + 2.5), y));\n\treturn mat4(\n\t\tv1.x, v2.x, v3.x, 0,\n\t\tv1.y, v2.y, v3.y, 0,\n\t\tv1.z, v2.z, v3.z, 0,\n\t\tv1.w, v2.w, v3.w, 1\n\t);\n}\n";

	var skinConstVS = "attribute vec4 vertex_boneWeights;\nattribute vec4 vertex_boneIndices;\nuniform vec4 matrix_pose[BONE_LIMIT * 3];\nvoid getBoneMatrix(const in float i, out vec4 v1, out vec4 v2, out vec4 v3) {\n\tv1 = matrix_pose[int(3.0 * i)];\n\tv2 = matrix_pose[int(3.0 * i + 1.0)];\n\tv3 = matrix_pose[int(3.0 * i + 2.0)];\n}\nmat4 getSkinMatrix(const in vec4 indices, const in vec4 weights) {\n\tvec4 a1, a2, a3;\n\tgetBoneMatrix(indices.x, a1, a2, a3);\n\tvec4 b1, b2, b3;\n\tgetBoneMatrix(indices.y, b1, b2, b3);\n\tvec4 c1, c2, c3;\n\tgetBoneMatrix(indices.z, c1, c2, c3);\n\tvec4 d1, d2, d3;\n\tgetBoneMatrix(indices.w, d1, d2, d3);\n\tvec4 v1 = a1 * weights.x + b1 * weights.y + c1 * weights.z + d1 * weights.w;\n\tvec4 v2 = a2 * weights.x + b2 * weights.y + c2 * weights.z + d2 * weights.w;\n\tvec4 v3 = a3 * weights.x + b3 * weights.y + c3 * weights.z + d3 * weights.w;\n\tfloat one = dot(weights, vec4(1.0));\n\treturn mat4(\n\t\tv1.x, v2.x, v3.x, 0,\n\t\tv1.y, v2.y, v3.y, 0,\n\t\tv1.z, v2.z, v3.z, 0,\n\t\tv1.w, v2.w, v3.w, one\n\t);\n}\n";

	var skinTexVS = "attribute vec4 vertex_boneWeights;\nattribute vec4 vertex_boneIndices;\nuniform highp sampler2D texture_poseMap;\nuniform vec4 texture_poseMapSize;\nvoid getBoneMatrix(const in float i, out vec4 v1, out vec4 v2, out vec4 v3) {\n\tfloat j = i * 3.0;\n\tfloat dx = texture_poseMapSize.z;\n\tfloat dy = texture_poseMapSize.w;\n\tfloat y = floor(j * dx);\n\tfloat x = j - (y * texture_poseMapSize.x);\n\ty = dy * (y + 0.5);\n\tv1 = texture2D(texture_poseMap, vec2(dx * (x + 0.5), y));\n\tv2 = texture2D(texture_poseMap, vec2(dx * (x + 1.5), y));\n\tv3 = texture2D(texture_poseMap, vec2(dx * (x + 2.5), y));\n}\nmat4 getSkinMatrix(const in vec4 indices, const in vec4 weights) {\n\tvec4 a1, a2, a3;\n\tgetBoneMatrix(indices.x, a1, a2, a3);\n\tvec4 b1, b2, b3;\n\tgetBoneMatrix(indices.y, b1, b2, b3);\n\tvec4 c1, c2, c3;\n\tgetBoneMatrix(indices.z, c1, c2, c3);\n\tvec4 d1, d2, d3;\n\tgetBoneMatrix(indices.w, d1, d2, d3);\n\tvec4 v1 = a1 * weights.x + b1 * weights.y + c1 * weights.z + d1 * weights.w;\n\tvec4 v2 = a2 * weights.x + b2 * weights.y + c2 * weights.z + d2 * weights.w;\n\tvec4 v3 = a3 * weights.x + b3 * weights.y + c3 * weights.z + d3 * weights.w;\n\tfloat one = dot(weights, vec4(1.0));\n\treturn mat4(\n\t\tv1.x, v2.x, v3.x, 0,\n\t\tv1.y, v2.y, v3.y, 0,\n\t\tv1.z, v2.z, v3.z, 0,\n\t\tv1.w, v2.w, v3.w, one\n\t);\n}\n";

	var skyboxPS = "varying vec3 vViewDir;\nuniform samplerCube texture_cubeMap;\nvoid main(void) {\n\tgl_FragColor = textureCube(texture_cubeMap, fixSeams(vViewDir));\n}\n";

	var skyboxVS = "attribute vec3 aPosition;\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nuniform mat4 matrix_projectionSkybox;\nvarying vec3 vViewDir;\nvoid main(void) {\n\tmat4 view = matrix_view;\n\tview[3][0] = view[3][1] = view[3][2] = 0.0;\n\tgl_Position = matrix_projectionSkybox * view * vec4(aPosition, 1.0);\n\tgl_Position.z = gl_Position.w - 0.00001;\n\tvViewDir = aPosition;\n\tvViewDir.x *= -1.0;\n}\n";

	var skyboxHDRPS = "varying vec3 vViewDir;\nuniform samplerCube texture_cubeMap;\nvoid main(void) {\n\tvec3 color = processEnvironment($textureCubeSAMPLE(texture_cubeMap, fixSeamsStatic(vViewDir, $FIXCONST)).rgb);\n\tcolor = toneMap(color);\n\tcolor = gammaCorrectOutput(color);\n\tgl_FragColor = vec4(color, 1.0);\n}\n";

	var skyboxPrefilteredCubePS = "varying vec3 vViewDir;\nuniform samplerCube texture_cubeMap;\nvec3 fixSeamsStretch(vec3 vec, float mipmapIndex, float cubemapSize) {\n\tfloat scale = 1.0 - exp2(mipmapIndex) / cubemapSize;\n\tfloat M = max(max(abs(vec.x), abs(vec.y)), abs(vec.z));\n\tif (abs(vec.x) != M) vec.x *= scale;\n\tif (abs(vec.y) != M) vec.y *= scale;\n\tif (abs(vec.z) != M) vec.z *= scale;\n\treturn vec;\n}\nvoid main(void) {\n\tvec3 color = textureCubeRGBM(texture_cubeMap, fixSeamsStretch(vViewDir, 0.0, 128.0));\n\tcolor = toneMap(color);\n\tcolor = gammaCorrectOutput(color);\n\tgl_FragColor = vec4(color, 1.0);\n}\n";

	var specularPS = "#ifdef MAPCOLOR\nuniform vec3 material_specular;\n#endif\n#ifdef MAPTEXTURE\nuniform sampler2D texture_specularMap;\n#endif\n#ifdef CLEARCOAT\nuniform float material_clearCoatSpecularity;\n#endif\nvoid getSpecularity() {\n\tdSpecularity = vec3(1.0);\n\t#ifdef MAPCOLOR\n\tdSpecularity *= material_specular;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tdSpecularity *= texture2D(texture_specularMap, $UV).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tdSpecularity *= saturate(vVertexColor.$VC);\n\t#endif\n\t#ifdef CLEARCOAT\n\tccSpecularity = vec3(1.0);\n\tccSpecularity *= material_clearCoatSpecularity;\n\t#endif\n}\n";

	var specularAaNonePS = "float antiAliasGlossiness(float power) {\n\treturn power;\n}\n";

	var specularAaToksvigPS = "float antiAliasGlossiness(float power) {\n\tfloat rlen = 1.0 / saturate(length(dNormalMap));\n\tfloat toksvig = 1.0 / (1.0 + power * (rlen - 1.0));\n\treturn power * mix(1.0, toksvig, material_bumpiness);\n}\n";

	var specularAaToksvigFastPS = "float antiAliasGlossiness(float power) {\n\tfloat rlen = 1.0 / saturate(length(dNormalMap));\n\tfloat toksvig = 1.0 / (1.0 + power * (rlen - 1.0));\n\treturn power * toksvig;\n}\n";

	var spotPS = "float getSpotEffect(vec3 lightSpotDirW, float lightInnerConeAngle, float lightOuterConeAngle) {\n\tfloat cosAngle = dot(dLightDirNormW, lightSpotDirW);\n\treturn smoothstep(lightOuterConeAngle, lightInnerConeAngle, cosAngle);\n}\n";

	var startPS = "void main(void) {\n\tdDiffuseLight = vec3(0);\n\tdSpecularLight = vec3(0);\n\tdReflection = vec4(0);\n\tdSpecularity = vec3(0);\n\t#ifdef CLEARCOAT\n\tccSpecularLight = vec3(0);\n\tccReflection = vec4(0);\n\tccSpecularity = vec3(0);\n\t#endif\n";

	var startVS = "void main(void) {\n\tgl_Position = getPosition();\n";

	var startNineSlicedPS = "\tnineSlicedUv = vUv0;\n";

	var startNineSlicedTiledPS = "\tvec2 tileMask = step(vMask, vec2(0.99999));\n\tvec2 clampedUv = mix(innerOffset.xy*0.5, vec2(1.0) - innerOffset.zw*0.5, fract(vTiledUv));\n\tclampedUv = clampedUv * atlasRect.zw + atlasRect.xy;\n\tnineSlicedUv = vUv0 * tileMask + clampedUv * (vec2(1.0) - tileMask);\n";

	var storeEVSMPS = "float exponent = VSM_EXPONENT;\ndepth = 2.0 * depth - 1.0;\ndepth =  exp(exponent * depth);\ngl_FragColor = vec4(depth, depth*depth, 1.0, 1.0);\n";

	var tangentBinormalVS = "vec3 getTangent() {\n\treturn normalize(dNormalMatrix * vertex_tangent.xyz);\n}\nvec3 getBinormal() {\n\treturn cross(vNormalW, vTangentW) * vertex_tangent.w;\n}\nvec3 getObjectSpaceUp() {\n\treturn normalize(dNormalMatrix * vec3(0, 1, 0));\n}\n";

	var TBNPS = "void getTBN() {\n\tdTBN = mat3(normalize(dTangentW), normalize(dBinormalW), normalize(dVertexNormalW));\n}\n";

	var TBNderivativePS = "\nvoid getTBN() {\n\tvec2 uv = $UV;\n\tvec3 dp1 = dFdx( vPositionW );\n\tvec3 dp2 = dFdy( vPositionW );\n\tvec2 duv1 = dFdx( uv );\n\tvec2 duv2 = dFdy( uv );\n\tvec3 dp2perp = cross( dp2, dVertexNormalW );\n\tvec3 dp1perp = cross( dVertexNormalW, dp1 );\n\tvec3 T = dp2perp * duv1.x + dp1perp * duv2.x;\n\tvec3 B = dp2perp * duv1.y + dp1perp * duv2.y;\n\tfloat invmax = 1.0 / sqrt( max( dot(T,T), dot(B,B) ) );\n\tdTBN = mat3( T * invmax, B * invmax, dVertexNormalW );\n}\n";

	var TBNfastPS = "void getTBN() {\n\tdTBN = mat3(dTangentW, dBinormalW, dVertexNormalW);\n}\n";

	var TBNObjectSpacePS = "void getTBN() {\n\tvec3 B = cross(dVertexNormalW, vObjectSpaceUpW);\n\tvec3 T = cross(dVertexNormalW, B);\n\tif (dot(B,B)==0.0)\n\t{\n\t\tfloat major=max(max(dVertexNormalW.x, dVertexNormalW.y),dVertexNormalW.z);\n\t\tif (dVertexNormalW.x==major)\n\t\t{\n\t\t\tB=cross(dVertexNormalW, vec3(0,1,0));\n\t\t\tT=cross(dVertexNormalW, B);\n\t\t}\n\t\telse if (dVertexNormalW.y==major)\n\t\t{\n\t\t\tB=cross(dVertexNormalW, vec3(0,0,1));\n\t\t\tT=cross(dVertexNormalW, B);\n\t\t}\n\t\telse if (dVertexNormalW.z==major)\n\t\t{\n\t\t\tB=cross(dVertexNormalW, vec3(1,0,0));\n\t\t\tT=cross(dVertexNormalW, B);\n\t\t}\n\t}\n\tdTBN = mat3(normalize(T), normalize(B), normalize(dVertexNormalW));\n}\n";

	var tonemappingAcesPS = "uniform float exposure;\nvec3 toneMap(vec3 color) {\n\tfloat tA = 2.51;\n\tfloat tB = 0.03;\n\tfloat tC = 2.43;\n\tfloat tD = 0.59;\n\tfloat tE = 0.14;\n\tvec3 x = color * exposure;\n\treturn (x*(tA*x+tB))/(x*(tC*x+tD)+tE);\n}\n";

	var tonemappingAces2PS = "uniform float exposure;\nconst mat3 ACESInputMat = mat3(\n\t0.59719, 0.35458, 0.04823,\n\t0.07600, 0.90834, 0.01566,\n\t0.02840, 0.13383, 0.83777\n);\nconst mat3 ACESOutputMat = mat3(\n\t 1.60475, -0.53108, -0.07367,\n\t-0.10208,  1.10813, -0.00605,\n\t-0.00327, -0.07276,  1.07602\n);\nvec3 RRTAndODTFit(vec3 v) {\n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n\treturn a / b;\n}\nvec3 toneMap(vec3 color) {\n\tcolor *= exposure;\n\tcolor = color * ACESInputMat;\n\tcolor = RRTAndODTFit(color);\n\tcolor = color * ACESOutputMat;\n\tcolor = clamp(color, 0.0, 1.0);\n\treturn color;\n}\n";

	var tonemappingFilmicPS = "const float A =  0.15;\nconst float B =  0.50;\nconst float C =  0.10;\nconst float D =  0.20;\nconst float E =  0.02;\nconst float F =  0.30;\nconst float W =  11.2;\nuniform float exposure;\nvec3 uncharted2Tonemap(vec3 x) {\n   return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\n}\nvec3 toneMap(vec3 color) {\n\tcolor = uncharted2Tonemap(color * exposure);\n\tvec3 whiteScale = 1.0 / uncharted2Tonemap(vec3(W,W,W));\n\tcolor = color * whiteScale;\n\treturn color;\n}\n";

	var tonemappingHejlPS = "uniform float exposure;\nvec3 toneMap(vec3 color) {\n\tcolor *= exposure;\n\tconst float  A = 0.22, B = 0.3, C = .1, D = 0.2, E = .01, F = 0.3;\n\tconst float Scl = 1.25;\n\tvec3 h = max( vec3(0.0), color - vec3(0.004) );\n\treturn (h*((Scl*A)*h+Scl*vec3(C*B,C*B,C*B))+Scl*vec3(D*E,D*E,D*E)) / (h*(A*h+vec3(B,B,B))+vec3(D*F,D*F,D*F)) - Scl*vec3(E/F,E/F,E/F);\n}\n";

	var tonemappingLinearPS = "uniform float exposure;\nvec3 toneMap(vec3 color) {\n\treturn color * exposure;\n}\n";

	var tonemappingNonePS = "vec3 toneMap(vec3 color) {\n\treturn color;\n}\n";

	var transformVS = "#ifdef PIXELSNAP\nuniform vec4 uScreenSize;\n#endif\n#ifdef MORPHING\nuniform vec4 morph_weights_a;\nuniform vec4 morph_weights_b;\n#endif\n#ifdef MORPHING_TEXTURE_BASED\nuniform vec4 morph_tex_params;\nvec2 getTextureMorphCoords() {\n\tfloat vertexId = morph_vertex_id;\n\tvec2 textureSize = morph_tex_params.xy;\n\tvec2 invTextureSize = morph_tex_params.zw;\n\tfloat morphGridV = floor(vertexId * invTextureSize.x);\n\tfloat morphGridU = vertexId - (morphGridV * textureSize.x);\n\treturn (vec2(morphGridU, morphGridV) * invTextureSize) + (0.5 * invTextureSize);\n}\n#endif\n#ifdef MORPHING_TEXTURE_BASED_POSITION\nuniform highp sampler2D morphPositionTex;\n#endif\nmat4 getModelMatrix() {\n\t#ifdef DYNAMICBATCH\n\treturn getBoneMatrix(vertex_boneIndices);\n\t#elif defined(SKIN)\n\treturn matrix_model * getSkinMatrix(vertex_boneIndices, vertex_boneWeights);\n\t#elif defined(INSTANCING)\n\treturn mat4(instance_line1, instance_line2, instance_line3, instance_line4);\n\t#else\n\treturn matrix_model;\n\t#endif\n}\nvec4 getPosition() {\n\tdModelMatrix = getModelMatrix();\n\tvec3 localPos = vertex_position;\n\t#ifdef NINESLICED\n\tlocalPos.xz *= outerScale;\n\tvec2 positiveUnitOffset = clamp(vertex_position.xz, vec2(0.0), vec2(1.0));\n\tvec2 negativeUnitOffset = clamp(-vertex_position.xz, vec2(0.0), vec2(1.0));\n\tlocalPos.xz += (-positiveUnitOffset * innerOffset.xy + negativeUnitOffset * innerOffset.zw) * vertex_texCoord0.xy;\n\tvTiledUv = (localPos.xz - outerScale + innerOffset.xy) * -0.5 + 1.0;\n\tlocalPos.xz *= -0.5;\n\tlocalPos = localPos.xzy;\n\t#endif\n\t#ifdef MORPHING\n\t#ifdef MORPHING_POS03\n\tlocalPos.xyz += morph_weights_a[0] * morph_pos0;\n\tlocalPos.xyz += morph_weights_a[1] * morph_pos1;\n\tlocalPos.xyz += morph_weights_a[2] * morph_pos2;\n\tlocalPos.xyz += morph_weights_a[3] * morph_pos3;\n\t#endif\n\t#ifdef MORPHING_POS47\n\tlocalPos.xyz += morph_weights_b[0] * morph_pos4;\n\tlocalPos.xyz += morph_weights_b[1] * morph_pos5;\n\tlocalPos.xyz += morph_weights_b[2] * morph_pos6;\n\tlocalPos.xyz += morph_weights_b[3] * morph_pos7;\n\t#endif\n\t#endif\n\t#ifdef MORPHING_TEXTURE_BASED_POSITION\n\tvec2 morphUV = getTextureMorphCoords();\n\tvec3 morphPos = texture2D(morphPositionTex, morphUV).xyz;\n\tlocalPos += morphPos;\n\t#endif\n\tvec4 posW = dModelMatrix * vec4(localPos, 1.0);\n\t#ifdef SCREENSPACE\n\tposW.zw = vec2(0.0, 1.0);\n\t#endif\n\tdPositionW = posW.xyz;\n\tvec4 screenPos;\n\t#ifdef UV1LAYOUT\n\tscreenPos = vec4(vertex_texCoord1.xy * 2.0 - 1.0, 0.5, 1);\n\t#else\n\t#ifdef SCREENSPACE\n\tscreenPos = posW;\n\t#else\n\tscreenPos = matrix_viewProjection * posW;\n\t#endif\n\t#ifdef PIXELSNAP\n\tscreenPos.xy = (screenPos.xy * 0.5) + 0.5;\n\tscreenPos.xy *= uScreenSize.xy;\n\tscreenPos.xy = floor(screenPos.xy);\n\tscreenPos.xy *= uScreenSize.zw;\n\tscreenPos.xy = (screenPos.xy * 2.0) - 1.0;\n\t#endif\n\t#endif\n\treturn screenPos;\n}\nvec3 getWorldPosition() {\n\treturn dPositionW;\n}\n";

	var transformDeclVS = "attribute vec3 vertex_position;\nuniform mat4 matrix_model;\nuniform mat4 matrix_viewProjection;\nvec3 dPositionW;\nmat4 dModelMatrix;\n";

	var uv0VS = "#ifdef NINESLICED\nvec2 getUv0() {\n\tvec2 uv = vertex_position.xz;\n\tvec2 positiveUnitOffset = clamp(vertex_position.xz, vec2(0.0), vec2(1.0));\n\tvec2 negativeUnitOffset = clamp(-vertex_position.xz, vec2(0.0), vec2(1.0));\n\tuv += (-positiveUnitOffset * innerOffset.xy + negativeUnitOffset * innerOffset.zw) * vertex_texCoord0.xy;\n\tuv = uv * -0.5 + 0.5;\n\tuv = uv * atlasRect.zw + atlasRect.xy;\n\tvMask = vertex_texCoord0.xy;\n\treturn uv;\n}\n#else\nvec2 getUv0() {\n\treturn vertex_texCoord0;\n}\n#endif\n";

	var uv1VS = "vec2 getUv1() {\n\treturn vertex_texCoord1;\n}\n";

	var viewDirPS = "void getViewDir() {\n\tdViewDirW = normalize(view_position - vPositionW);\n}\n";

	var viewNormalVS = "#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nvec3 getViewNormal() {\n\treturn mat3(matrix_view) * vNormalW;\n}\n";

	var shaderChunks = {
		alphaTestPS: alphaTestPS,
		ambientConstantPS: ambientConstantPS,
		ambientPrefilteredCubePS: ambientPrefilteredCubePS,
		ambientPrefilteredCubeLodPS: ambientPrefilteredCubeLodPS,
		ambientSHPS: ambientSHPS,
		aoPS: aoPS,
		aoSpecOccPS: aoSpecOccPS,
		aoSpecOccConstPS: aoSpecOccConstPS,
		aoSpecOccConstSimplePS: aoSpecOccConstSimplePS,
		aoSpecOccSimplePS: aoSpecOccSimplePS,
		bakeDirLmEndPS: bakeDirLmEndPS,
		bakeLmEndPS: bakeLmEndPS,
		basePS: basePS,
		baseVS: baseVS,
		baseNineSlicedPS: baseNineSlicedPS,
		baseNineSlicedVS: baseNineSlicedVS,
		baseNineSlicedTiledPS: baseNineSlicedTiledPS,
		biasConstPS: biasConstPS,
		blurVSMPS: blurVSMPS,
		combineClearCoatPS: combineClearCoatPS,
		combineDiffusePS: combineDiffusePS,
		combineDiffuseSpecularPS: combineDiffuseSpecularPS,
		combineDiffuseSpecularNoConservePS: combineDiffuseSpecularNoConservePS,
		combineDiffuseSpecularNoReflPS: combineDiffuseSpecularNoReflPS,
		combineDiffuseSpecularNoReflSeparateAmbientPS: combineDiffuseSpecularNoReflSeparateAmbientPS,
		combineDiffuseSpecularOldPS: combineDiffuseSpecularOldPS,
		cookiePS: cookiePS,
		cubeMapProjectBoxPS: cubeMapProjectBoxPS,
		cubeMapProjectNonePS: cubeMapProjectNonePS,
		detailModesPS: detailModesPS,
		diffusePS: diffusePS,
		diffuseDetailMapPS: diffuseDetailMapPS,
		dilatePS: dilatePS,
		dpAtlasQuadPS: dpAtlasQuadPS,
		emissivePS: emissivePS,
		endPS: endPS,
		envConstPS: envConstPS,
		envMultiplyPS: envMultiplyPS,
		extensionPS: extensionPS,
		extensionVS: extensionVS,
		falloffInvSquaredPS: falloffInvSquaredPS,
		falloffLinearPS: falloffLinearPS,
		fixCubemapSeamsNonePS: fixCubemapSeamsNonePS,
		fixCubemapSeamsStretchPS: fixCubemapSeamsStretchPS,
		fogExpPS: fogExpPS,
		fogExp2PS: fogExp2PS,
		fogLinearPS: fogLinearPS,
		fogNonePS: fogNonePS,
		fresnelSchlickPS: fresnelSchlickPS,
		fullscreenQuadPS: fullscreenQuadPS,
		fullscreenQuadVS: fullscreenQuadVS,
		gamma1_0PS: gamma1_0PS,
		gamma2_2PS: gamma2_2PS,
		genParaboloidPS: genParaboloidPS,
		gles3PS: gles3PS,
		gles3VS: gles3VS,
		glossPS: glossPS,
		instancingVS: instancingVS,
		lightDiffuseLambertPS: lightDiffuseLambertPS,
		lightDirPointPS: lightDirPointPS,
		lightmapDirPS: lightmapDirPS,
		lightmapSinglePS: lightmapSinglePS,
		lightmapSingleVertPS: lightmapSingleVertPS,
		lightSpecularAnisoGGXPS: lightSpecularAnisoGGXPS,
		lightSpecularBlinnPS: lightSpecularBlinnPS,
		lightSpecularPhongPS: lightSpecularPhongPS,
		metalnessPS: metalnessPS,
		msdfPS: msdfPS,
		normalVS: normalVS,
		normalDetailMapPS: normalDetailMapPS,
		normalInstancedVS: normalInstancedVS,
		normalMapPS: normalMapPS,
		normalMapFastPS: normalMapFastPS,
		normalSkinnedVS: normalSkinnedVS,
		normalVertexPS: normalVertexPS,
		normalXYPS: normalXYPS,
		normalXYZPS: normalXYZPS,
		opacityPS: opacityPS,
		outputAlphaPS: outputAlphaPS,
		outputAlphaOpaquePS: outputAlphaOpaquePS,
		outputAlphaPremulPS: outputAlphaPremulPS,
		outputCubemapPS: outputCubemapPS,
		outputTex2DPS: outputTex2DPS,
		packDepthPS: packDepthPS,
		packDepthMaskPS: packDepthMaskPS,
		parallaxPS: parallaxPS,
		particlePS: particlePS,
		particleVS: particleVS,
		particleAnimFrameClampVS: particleAnimFrameClampVS,
		particleAnimFrameLoopVS: particleAnimFrameLoopVS,
		particleAnimTexVS: particleAnimTexVS,
		particleInputFloatPS: particleInputFloatPS,
		particleInputRgba8PS: particleInputRgba8PS,
		particleOutputFloatPS: particleOutputFloatPS,
		particleOutputRgba8PS: particleOutputRgba8PS,
		particleUpdaterAABBPS: particleUpdaterAABBPS,
		particleUpdaterEndPS: particleUpdaterEndPS,
		particleUpdaterInitPS: particleUpdaterInitPS,
		particleUpdaterNoRespawnPS: particleUpdaterNoRespawnPS,
		particleUpdaterOnStopPS: particleUpdaterOnStopPS,
		particleUpdaterRespawnPS: particleUpdaterRespawnPS,
		particleUpdaterSpherePS: particleUpdaterSpherePS,
		particleUpdaterStartPS: particleUpdaterStartPS,
		particle_billboardVS: particle_billboardVS,
		particle_blendAddPS: particle_blendAddPS,
		particle_blendMultiplyPS: particle_blendMultiplyPS,
		particle_blendNormalPS: particle_blendNormalPS,
		particle_cpuVS: particle_cpuVS,
		particle_cpu_endVS: particle_cpu_endVS,
		particle_customFaceVS: particle_customFaceVS,
		particle_endPS: particle_endPS,
		particle_endVS: particle_endVS,
		particle_halflambertPS: particle_halflambertPS,
		particle_initVS: particle_initVS,
		particle_lambertPS: particle_lambertPS,
		particle_lightingPS: particle_lightingPS,
		particle_localShiftVS: particle_localShiftVS,
		particle_meshVS: particle_meshVS,
		particle_normalVS: particle_normalVS,
		particle_normalMapPS: particle_normalMapPS,
		particle_pointAlongVS: particle_pointAlongVS,
		particle_softPS: particle_softPS,
		particle_softVS: particle_softVS,
		particle_stretchVS: particle_stretchVS,
		particle_TBNVS: particle_TBNVS,
		particle_wrapVS: particle_wrapVS,
		precisionTestPS: precisionTestPS,
		precisionTest2PS: precisionTest2PS,
		prefilterCubemapPS: prefilterCubemapPS,
		reflDirPS: reflDirPS,
		reflDirAnisoPS: reflDirAnisoPS,
		reflectionCCPS: reflectionCCPS,
		reflectionCubePS: reflectionCubePS,
		reflectionDpAtlasPS: reflectionDpAtlasPS,
		reflectionPrefilteredCubePS: reflectionPrefilteredCubePS,
		reflectionPrefilteredCubeLodPS: reflectionPrefilteredCubeLodPS,
		reflectionSpherePS: reflectionSpherePS,
		reflectionSphereLowPS: reflectionSphereLowPS,
		refractionPS: refractionPS,
		reprojectPS: reprojectPS,
		rgbmPS: rgbmPS,
		screenDepthPS: screenDepthPS,
		shadowCommonPS: shadowCommonPS,
		shadowCoordPS: shadowCoordPS,
		shadowCoordVS: shadowCoordVS,
		shadowCoordPerspZbufferPS: shadowCoordPerspZbufferPS,
		shadowEVSMPS: shadowEVSMPS,
		shadowEVSMnPS: shadowEVSMnPS,
		shadowStandardPS: shadowStandardPS,
		shadowStandardGL2PS: shadowStandardGL2PS,
		shadowStandardGL2VSPS: shadowStandardGL2VSPS,
		shadowStandardVSPS: shadowStandardVSPS,
		shadowVSM8PS: shadowVSM8PS,
		shadowVSMVSPS: shadowVSMVSPS,
		shadowVSM_commonPS: shadowVSM_commonPS,
		skinBatchConstVS: skinBatchConstVS,
		skinBatchTexVS: skinBatchTexVS,
		skinConstVS: skinConstVS,
		skinTexVS: skinTexVS,
		skyboxPS: skyboxPS,
		skyboxVS: skyboxVS,
		skyboxHDRPS: skyboxHDRPS,
		skyboxPrefilteredCubePS: skyboxPrefilteredCubePS,
		specularPS: specularPS,
		specularAaNonePS: specularAaNonePS,
		specularAaToksvigPS: specularAaToksvigPS,
		specularAaToksvigFastPS: specularAaToksvigFastPS,
		spotPS: spotPS,
		startPS: startPS,
		startVS: startVS,
		startNineSlicedPS: startNineSlicedPS,
		startNineSlicedTiledPS: startNineSlicedTiledPS,
		storeEVSMPS: storeEVSMPS,
		tangentBinormalVS: tangentBinormalVS,
		TBNPS: TBNPS,
		TBNderivativePS: TBNderivativePS,
		TBNfastPS: TBNfastPS,
		TBNObjectSpacePS: TBNObjectSpacePS,
		tonemappingAcesPS: tonemappingAcesPS,
		tonemappingAces2PS: tonemappingAces2PS,
		tonemappingFilmicPS: tonemappingFilmicPS,
		tonemappingHejlPS: tonemappingHejlPS,
		tonemappingLinearPS: tonemappingLinearPS,
		tonemappingNonePS: tonemappingNonePS,
		transformVS: transformVS,
		transformDeclVS: transformDeclVS,
		uv0VS: uv0VS,
		uv1VS: uv1VS,
		viewDirPS: viewDirPS,
		viewNormalVS: viewNormalVS
	};

	var BLEND_SUBTRACTIVE = 0;
	var BLEND_ADDITIVE = 1;
	var BLEND_NORMAL = 2;
	var BLEND_NONE = 3;
	var BLEND_PREMULTIPLIED = 4;
	var BLEND_MULTIPLICATIVE = 5;
	var BLEND_ADDITIVEALPHA = 6;
	var BLEND_MULTIPLICATIVE2X = 7;
	var BLEND_SCREEN = 8;
	var BLEND_MIN = 9;
	var BLEND_MAX = 10;
	var FOG_NONE = 'none';
	var FOG_LINEAR = 'linear';
	var FOG_EXP = 'exp';
	var FOG_EXP2 = 'exp2';
	var FRESNEL_NONE = 0;
	var FRESNEL_SCHLICK = 2;
	var LAYER_HUD = 0;
	var LAYER_GIZMO = 1;
	var LAYER_FX = 2;
	var LAYER_WORLD = 15;
	var LAYERID_WORLD = 0;
	var LAYERID_DEPTH = 1;
	var LAYERID_SKYBOX = 2;
	var LAYERID_IMMEDIATE = 3;
	var LAYERID_UI = 4;
	var LIGHTTYPE_DIRECTIONAL = 0;
	var LIGHTTYPE_POINT = 1;
	var LIGHTTYPE_SPOT = 2;
	var LIGHTFALLOFF_LINEAR = 0;
	var LIGHTFALLOFF_INVERSESQUARED = 1;
	var SHADOW_PCF3 = 0;
	var SHADOW_DEPTH = 0;
	var SHADOW_VSM8 = 1;
	var SHADOW_VSM16 = 2;
	var SHADOW_VSM32 = 3;
	var SHADOW_PCF5 = 4;
	var BLUR_BOX = 0;
	var BLUR_GAUSSIAN = 1;
	var PARTICLESORT_NONE = 0;
	var PARTICLESORT_DISTANCE = 1;
	var PARTICLESORT_NEWER_FIRST = 2;
	var PARTICLESORT_OLDER_FIRST = 3;
	var PARTICLEMODE_GPU = 0;
	var PARTICLEMODE_CPU = 1;
	var EMITTERSHAPE_BOX = 0;
	var EMITTERSHAPE_SPHERE = 1;
	var PARTICLEORIENTATION_SCREEN = 0;
	var PARTICLEORIENTATION_WORLD = 1;
	var PARTICLEORIENTATION_EMITTER = 2;
	var PROJECTION_PERSPECTIVE = 0;
	var PROJECTION_ORTHOGRAPHIC = 1;
	var RENDERSTYLE_SOLID = 0;
	var RENDERSTYLE_WIREFRAME = 1;
	var RENDERSTYLE_POINTS = 2;
	var CUBEPROJ_NONE = 0;
	var CUBEPROJ_BOX = 1;
	var SPECULAR_PHONG = 0;
	var SPECULAR_BLINN = 1;
	var DETAILMODE_MUL = 'mul';
	var DETAILMODE_ADD = 'add';
	var DETAILMODE_SCREEN = 'screen';
	var DETAILMODE_OVERLAY = 'overlay';
	var DETAILMODE_MIN = 'min';
	var DETAILMODE_MAX = 'max';
	var GAMMA_NONE = 0;
	var GAMMA_SRGB = 1;
	var GAMMA_SRGBFAST = 2;
	var GAMMA_SRGBHDR = 3;
	var TONEMAP_LINEAR = 0;
	var TONEMAP_FILMIC = 1;
	var TONEMAP_HEJL = 2;
	var TONEMAP_ACES = 3;
	var TONEMAP_ACES2 = 4;
	var SPECOCC_NONE = 0;
	var SPECOCC_AO = 1;
	var SPECOCC_GLOSSDEPENDENT = 2;
	var SHADERDEF_NOSHADOW = 1;
	var SHADERDEF_SKIN = 2;
	var SHADERDEF_UV0 = 4;
	var SHADERDEF_UV1 = 8;
	var SHADERDEF_VCOLOR = 16;
	var SHADERDEF_INSTANCING = 32;
	var SHADERDEF_LM = 64;
	var SHADERDEF_DIRLM = 128;
	var SHADERDEF_SCREENSPACE = 256;
	var SHADERDEF_TANGENTS = 512;
	var SHADERDEF_MORPH_POSITION = 1024;
	var SHADERDEF_MORPH_NORMAL = 2048;
	var SHADERDEF_MORPH_TEXTURE_BASED = 4096;
	var LINEBATCH_WORLD = 0;
	var LINEBATCH_OVERLAY = 1;
	var LINEBATCH_GIZMO = 2;
	var SHADOWUPDATE_NONE = 0;
	var SHADOWUPDATE_THISFRAME = 1;
	var SHADOWUPDATE_REALTIME = 2;
	var SORTKEY_FORWARD = 0;
	var SORTKEY_DEPTH = 1;
	var MASK_DYNAMIC = 1;
	var MASK_BAKED = 2;
	var MASK_LIGHTMAP = 4;
	var SHADER_FORWARD = 0;
	var SHADER_FORWARDHDR = 1;
	var SHADER_DEPTH = 2;
	var SHADER_SHADOW = 3;
	var SHADER_PICK = 18;
	var SPRITE_RENDERMODE_SIMPLE = 0;
	var SPRITE_RENDERMODE_SLICED = 1;
	var SPRITE_RENDERMODE_TILED = 2;
	var BAKE_COLOR = 0;
	var BAKE_COLORDIR = 1;
	var VIEW_CENTER = 0;
	var VIEW_LEFT = 1;
	var VIEW_RIGHT = 2;
	var SORTMODE_NONE = 0;
	var SORTMODE_MANUAL = 1;
	var SORTMODE_MATERIALMESH = 2;
	var SORTMODE_BACK2FRONT = 3;
	var SORTMODE_FRONT2BACK = 4;
	var SORTMODE_CUSTOM = 5;
	var COMPUPDATED_INSTANCES = 1;
	var COMPUPDATED_LIGHTS = 2;
	var COMPUPDATED_CAMERAS = 4;
	var COMPUPDATED_BLEND = 8;
	var ASPECT_AUTO = 0;
	var ASPECT_MANUAL = 1;
	var ORIENTATION_HORIZONTAL = 0;
	var ORIENTATION_VERTICAL = 1;

	function gammaCode(value, chunks) {
		if (!chunks) chunks = shaderChunks;
		if (value === GAMMA_SRGB || value === GAMMA_SRGBFAST) {
			return chunks.gamma2_2PS ? chunks.gamma2_2PS : shaderChunks.gamma2_2PS;
		} else if (value === GAMMA_SRGBHDR) {
			return "#define HDR\n" + (chunks.gamma2_2PS ? chunks.gamma2_2PS : shaderChunks.gamma2_2PS);
		}
		return chunks.gamma1_0PS ? chunks.gamma1_0PS : shaderChunks.gamma1_0PS;
	}
	function tonemapCode(value, chunks) {
		if (!chunks) chunks = shaderChunks;
		if (value === TONEMAP_FILMIC) {
			return chunks.tonemappingFilmicPS ? chunks.tonemappingFilmicPS : shaderChunks.tonemappingFilmicPS;
		} else if (value === TONEMAP_LINEAR) {
			return chunks.tonemappingLinearPS ? chunks.tonemappingLinearPS : shaderChunks.tonemappingLinearPS;
		} else if (value === TONEMAP_HEJL) {
			return chunks.tonemappingHejlPS ? chunks.tonemappingHejlPS : shaderChunks.tonemappingHejlPS;
		} else if (value === TONEMAP_ACES) {
			return chunks.tonemappingAcesPS ? chunks.tonemappingAcesPS : shaderChunks.tonemappingAcesPS;
		} else if (value === TONEMAP_ACES2) {
			return chunks.tonemappingAces2PS ? chunks.tonemappingAces2PS : shaderChunks.tonemappingAces2PS;
		}
		return chunks.tonemapingNonePS ? chunks.tonemapingNonePS : shaderChunks.tonemappingNonePS;
	}
	function fogCode(value, chunks) {
		if (!chunks) chunks = shaderChunks;
		if (value === 'linear') {
			return chunks.fogLinearPS ? chunks.fogLinearPS : shaderChunks.fogLinearPS;
		} else if (value === 'exp') {
			return chunks.fogExpPS ? chunks.fogExpPS : shaderChunks.fogExpPS;
		} else if (value === 'exp2') {
			return chunks.fogExp2PS ? chunks.fogExp2PS : shaderChunks.fogExp2PS;
		}
		return chunks.fogNonePS ? chunks.fogNonePS : shaderChunks.fogNonePS;
	}
	function skinCode(device, chunks) {
		if (!chunks) chunks = shaderChunks;
		if (device.supportsBoneTextures) {
			return chunks.skinTexVS;
		}
		return "#define BONE_LIMIT " + device.getBoneLimit() + "\n" + chunks.skinConstVS;
	}
	function precisionCode(device) {
		var pcode = 'precision ' + device.precision + ' float;\n';
		if (device.webgl2) {
			pcode += '#ifdef GL2\nprecision ' + device.precision + ' sampler2DShadow;\n#endif\n';
		}
		return pcode;
	}
	function versionCode(device) {
		return device.webgl2 ? "#version 300 es\n" : "";
	}
	function dummyFragmentCode() {
		return "void main(void) {gl_FragColor = vec4(0.0);}";
	}
	function begin() {
		return 'void main(void)\n{\n';
	}
	function end() {
		return '}\n';
	}

	var attrib2Semantic = {
		vertex_position: SEMANTIC_POSITION,
		vertex_normal: SEMANTIC_NORMAL,
		vertex_tangent: SEMANTIC_TANGENT,
		vertex_texCoord0: SEMANTIC_TEXCOORD0,
		vertex_texCoord1: SEMANTIC_TEXCOORD1,
		vertex_texCoord2: SEMANTIC_TEXCOORD2,
		vertex_texCoord3: SEMANTIC_TEXCOORD3,
		vertex_texCoord4: SEMANTIC_TEXCOORD4,
		vertex_texCoord5: SEMANTIC_TEXCOORD5,
		vertex_texCoord6: SEMANTIC_TEXCOORD6,
		vertex_texCoord7: SEMANTIC_TEXCOORD7,
		vertex_color: SEMANTIC_COLOR,
		vertex_boneIndices: SEMANTIC_BLENDINDICES,
		vertex_boneWeights: SEMANTIC_BLENDWEIGHT
	};
	function collectAttribs(vsCode) {
		var attribs = {};
		var attrs = 0;
		var found = vsCode.indexOf("attribute");
		while (found >= 0) {
			if (found > 0 && vsCode[found - 1] === "/") break;
			var endOfLine = vsCode.indexOf(';', found);
			var startOfAttribName = vsCode.lastIndexOf(' ', endOfLine);
			var attribName = vsCode.substr(startOfAttribName + 1, endOfLine - (startOfAttribName + 1));
			var semantic = attrib2Semantic[attribName];
			if (semantic !== undefined) {
				attribs[attribName] = semantic;
			} else {
				attribs[attribName] = "ATTR" + attrs;
				attrs++;
			}
			found = vsCode.indexOf("attribute", found + 1);
		}
		return attribs;
	}
	function createShader(device, vsName, psName, useTransformFeedback) {
		var vsCode = shaderChunks[vsName];
		var psCode = precisionCode(device) + "\n" + shaderChunks[psName];
		var attribs = collectAttribs(vsCode);
		if (device.webgl2) {
			vsCode = versionCode(device) + shaderChunks.gles3VS + vsCode;
			psCode = versionCode(device) + shaderChunks.gles3PS + psCode;
		}
		return new Shader(device, {
			attributes: attribs,
			vshader: vsCode,
			fshader: psCode,
			useTransformFeedback: useTransformFeedback
		});
	}
	function createShaderFromCode(device, vsCode, psCode, uName, useTransformFeedback, psPreamble) {
		var shaderCache = device.programLib._cache;
		var cached = shaderCache[uName];
		if (cached !== undefined) return cached;
		psCode = precisionCode(device) + "\n" + (psCode || dummyFragmentCode());
		var attribs = collectAttribs(vsCode);
		if (device.webgl2) {
			vsCode = versionCode(device) + shaderChunks.gles3VS + vsCode;
			psCode = versionCode(device) + shaderChunks.gles3PS + psCode;
		}
		shaderCache[uName] = new Shader(device, {
			attributes: attribs,
			vshader: vsCode,
			fshader: (psPreamble ? psPreamble : "") + psCode,
			useTransformFeedback: useTransformFeedback
		});
		return shaderCache[uName];
	}
	shaderChunks.collectAttribs = collectAttribs;
	shaderChunks.createShader = createShader;
	shaderChunks.createShaderFromCode = createShaderFromCode;

	var basic = {
		generateKey: function (options) {
			var key = 'basic';
			if (options.fog)		  key += '_fog';
			if (options.alphaTest)	key += '_atst';
			if (options.vertexColors) key += '_vcol';
			if (options.diffuseMap)   key += '_diff';
			key += '_' + options.pass;
			return key;
		},
		createShaderDefinition: function (device, options) {
			var attributes = {
				vertex_position: SEMANTIC_POSITION
			};
			if (options.skin) {
				attributes.vertex_boneWeights = SEMANTIC_BLENDWEIGHT;
				attributes.vertex_boneIndices = SEMANTIC_BLENDINDICES;
			}
			if (options.vertexColors) {
				attributes.vertex_color = SEMANTIC_COLOR;
			}
			if (options.diffuseMap) {
				attributes.vertex_texCoord0 = SEMANTIC_TEXCOORD0;
			}
			var code = '';
			code += shaderChunks.transformDeclVS;
			if (options.skin) {
				code += skinCode(device);
				code += shaderChunks.transformSkinnedVS;
			} else {
				code += shaderChunks.transformVS;
			}
			if (options.vertexColors) {
				code += 'attribute vec4 vertex_color;\n';
				code += 'varying vec4 vColor;\n';
			}
			if (options.diffuseMap) {
				code += 'attribute vec2 vertex_texCoord0;\n';
				code += 'varying vec2 vUv0;\n';
			}
			if (options.pass === SHADER_DEPTH) {
				code += 'varying float vDepth;\n';
				code += '#ifndef VIEWMATRIX\n';
				code += '#define VIEWMATRIX\n';
				code += 'uniform mat4 matrix_view;\n';
				code += '#endif\n';
				code += '#ifndef CAMERAPLANES\n';
				code += '#define CAMERAPLANES\n';
				code += 'uniform vec4 camera_params;\n\n';
				code += '#endif\n';
			}
			code += begin();
			code += "   gl_Position = getPosition();\n";
			if (options.pass === SHADER_DEPTH) {
				code += "	vDepth = -(matrix_view * vec4(getWorldPosition(),1.0)).z * camera_params.x;\n";
			}
			if (options.vertexColors) {
				code += '	vColor = vertex_color;\n';
			}
			if (options.diffuseMap) {
				code += '	vUv0 = vertex_texCoord0;\n';
			}
			code += end();
			var vshader = code;
			code = precisionCode(device);
			if (options.vertexColors) {
				code += 'varying vec4 vColor;\n';
			} else {
				code += 'uniform vec4 uColor;\n';
			}
			if (options.diffuseMap) {
				code += 'varying vec2 vUv0;\n';
				code += 'uniform sampler2D texture_diffuseMap;\n';
			}
			if (options.fog) {
				code += fogCode(options.fog);
			}
			if (options.alphatest) {
				code += shaderChunks.alphaTestPS;
			}
			if (options.pass === SHADER_DEPTH) {
				code += 'varying float vDepth;\n';
				code += shaderChunks.packDepthPS;
			}
			code += begin();
			if (options.vertexColors) {
				code += '	gl_FragColor = vColor;\n';
			} else {
				code += '	gl_FragColor = uColor;\n';
			}
			if (options.diffuseMap) {
				code += '	gl_FragColor *= texture2D(texture_diffuseMap, vUv0);\n';
			}
			if (options.alphatest) {
				code += "   alphaTest(gl_FragColor.a);\n";
			}
			if (options.pass === SHADER_PICK) ; else if (options.pass === SHADER_DEPTH) {
				code += "	gl_FragColor = packFloat(vDepth);\n";
			} else {
				if (options.fog) {
					code += "   glFragColor.rgb = addFog(gl_FragColor.rgb);\n";
				}
			}
			code += end();
			var fshader = code;
			return {
				attributes: attributes,
				vshader: vshader,
				fshader: fshader
			};
		}
	};

	var particle = {
		generateKey: function (options) {
			var key = "particle";
			for (var prop in options) {
				if (options.hasOwnProperty(prop)) {
					key += options[prop];
				}
			}
			return key;
		},
		_animTex: function (options) {
			var vshader = "";
			vshader += options.animTexLoop ? shaderChunks.particleAnimFrameLoopVS : shaderChunks.particleAnimFrameClampVS;
			vshader += shaderChunks.particleAnimTexVS;
			return vshader;
		},
		createShaderDefinition: function (device, options) {
			var vshader = "";
			var fshader = precisionCode(device) + "\n";
			if (device.webgl2) {
				vshader += "#define GL2\n";
				fshader += "#define GL2\n";
			}
			vshader += "#define VERTEXSHADER\n";
			if (options.mesh) vshader += "#define USE_MESH\n";
			if (options.localSpace) vshader += "#define LOCAL_SPACE\n";
			if (options.screenSpace) vshader += "#define SCREEN_SPACE\n";
			if (options.animTex) vshader += "\nuniform vec2 animTexTilesParams;\n";
			if (options.animTex) vshader += "\nuniform vec4 animTexParams;\n";
			if (options.animTex) vshader += "\nuniform vec2 animTexIndexParams;\n";
			if (options.normal == 2) vshader += "\nvarying mat3 ParticleMat;\n";
			if (options.normal == 1) vshader += "\nvarying vec3 Normal;\n";
			if (options.soft) vshader += "\nvarying float vDepth;\n";
			var faceVS = options.customFace ? shaderChunks.particle_customFaceVS : shaderChunks.particle_billboardVS;
			if (!options.useCpu) {
				vshader += shaderChunks.particle_initVS;
				vshader += (options.pack8 ? shaderChunks.particleInputRgba8PS : shaderChunks.particleInputFloatPS);
				if (options.soft > 0) vshader += shaderChunks.screenDepthPS;
				vshader += shaderChunks.particleVS;
				if (options.localSpace) vshader += shaderChunks.particle_localShiftVS;
				if (options.animTex) vshader += this._animTex(options);
				if (options.wrap) vshader += shaderChunks.particle_wrapVS;
				if (options.alignToMotion) vshader += shaderChunks.particle_pointAlongVS;
				vshader += options.mesh ? shaderChunks.particle_meshVS : faceVS;
				if (options.normal == 1) vshader += shaderChunks.particle_normalVS;
				if (options.normal == 2) vshader += shaderChunks.particle_TBNVS;
				if (options.stretch > 0.0) vshader += shaderChunks.particle_stretchVS;
				vshader += shaderChunks.particle_endVS;
				if (options.soft > 0) vshader += shaderChunks.particle_softVS;
			} else {
				if (options.soft > 0) vshader += shaderChunks.screenDepthPS;
				vshader += shaderChunks.particle_cpuVS;
				if (options.localSpace) vshader += shaderChunks.particle_localShiftVS;
				if (options.animTex) vshader += this._animTex(options);
				if (options.alignToMotion) vshader += shaderChunks.particle_pointAlongVS;
				vshader += options.mesh ? shaderChunks.particle_meshVS : faceVS;
				if (options.normal == 1) vshader += shaderChunks.particle_normalVS;
				if (options.normal == 2) vshader += shaderChunks.particle_TBNVS;
				if (options.stretch > 0.0) vshader += shaderChunks.particle_stretchVS;
				vshader += shaderChunks.particle_cpu_endVS;
				if (options.soft > 0) vshader += shaderChunks.particle_softVS;
			}
			vshader += "}\n";
			if (options.normal > 0) {
				if (options.normal == 1) {
					fshader += "\nvarying vec3 Normal;\n";
				} else if (options.normal == 2) {
					fshader += "\nvarying mat3 ParticleMat;\n";
				}
				fshader += "\nuniform vec3 lightCube[6];\n";
			}
			if (options.soft) fshader += "\nvarying float vDepth;\n";
			if ((options.normal === 0) && (options.fog === "none")) options.srgb = false;
			fshader += gammaCode(options.gamma);
			fshader += tonemapCode(options.toneMap);
			if (options.fog === 'linear') {
				fshader += shaderChunks.fogLinearPS;
			} else if (options.fog === 'exp') {
				fshader += shaderChunks.fogExpPS;
			} else if (options.fog === 'exp2') {
				fshader += shaderChunks.fogExp2PS;
			} else {
				fshader += shaderChunks.fogNonePS;
			}
			if (options.normal == 2) fshader += "\nuniform sampler2D normalMap;\n";
			if (options.soft > 0) fshader += shaderChunks.screenDepthPS;
			fshader += shaderChunks.particlePS;
			if (options.soft > 0) fshader += shaderChunks.particle_softPS;
			if (options.normal == 1) fshader += "\nvec3 normal = Normal;\n";
			if (options.normal == 2) fshader += shaderChunks.particle_normalMapPS;
			if (options.normal > 0) fshader += options.halflambert ? shaderChunks.particle_halflambertPS : shaderChunks.particle_lambertPS;
			if (options.normal > 0) fshader += shaderChunks.particle_lightingPS;
			if (options.blend == BLEND_NORMAL) {
				fshader += shaderChunks.particle_blendNormalPS;
			} else if (options.blend == BLEND_ADDITIVE) {
				fshader += shaderChunks.particle_blendAddPS;
			} else if (options.blend == BLEND_MULTIPLICATIVE) {
				fshader += shaderChunks.particle_blendMultiplyPS;
			}
			fshader += shaderChunks.particle_endPS;
			var attributes = collectAttribs(vshader);
			return {
				attributes: attributes,
				vshader: vshader,
				fshader: fshader
			};
		}
	};

	var skybox = {
		generateKey: function (options) {
			var key = "skybox" + options.rgbm + " " + options.hdr + " " + options.fixSeams + "" +
					  options.toneMapping + "" + options.gamma + "" + options.useIntensity + "" + options.mip;
			return key;
		},
		createShaderDefinition: function (device, options) {
			var mip2size = [128, 64, 32, 16, 8, 4, 2];
			var fshader;
			fshader  = precisionCode(device);
			fshader += options.mip ? shaderChunks.fixCubemapSeamsStretchPS : shaderChunks.fixCubemapSeamsNonePS;
			fshader += options.useIntensity ? shaderChunks.envMultiplyPS : shaderChunks.envConstPS;
			fshader += gammaCode(options.gamma);
			fshader += tonemapCode(options.toneMapping);
			fshader += shaderChunks.rgbmPS;
			fshader += shaderChunks.skyboxHDRPS
				.replace(/\$textureCubeSAMPLE/g, options.rgbm ? "textureCubeRGBM" : (options.hdr ? "textureCube" : "textureCubeSRGB"))
				.replace(/\$FIXCONST/g, (1 - 1 / mip2size[options.mip]) + "");
			return {
				attributes: {
					aPosition: SEMANTIC_POSITION
				},
				vshader: shaderChunks.skyboxVS,
				fshader: fshader
			};
		}
	};

	var shadergraph_nodeRegistry = {};
	shadergraph_nodeRegistry.registerNode = function (name, node)
	{
		shadergraph_nodeRegistry[name] = node;
	};
	shadergraph_nodeRegistry.getNode = function (name)
	{
		return shadergraph_nodeRegistry[name];
	};

	var _oldChunkFloat = function (s, o, p) {
		return "\n#ifdef MAPFLOAT\n" + s + "\n#else\n" + shaderChunks[o] + "\n#endif\n";
	};
	var _oldChunkColor = function (s, o, p) {
		return "\n#ifdef MAPCOLOR\n" + s + "\n#else\n" + shaderChunks[o] + "\n#endif\n";
	};
	var _oldChunkTex = function (s, o, p) {
		return "\n#ifdef MAPTEXTURE\n" + s + "\n#else\n" + shaderChunks[o] + "\n#endif\n";
	};
	var _oldChunkTexColor = function (s, o, p) {
		return "#undef MAPTEXTURECOLOR\n#ifdef MAPTEXTURE\n#ifdef MAPCOLOR\n#define MAPTEXTURECOLOR\n#endif\n#endif\n" +
				"#ifdef MAPTEXTURECOLOR\n" + s + "\n#else\n" + shaderChunks[o] + "\n#endif\n";
	};
	var _oldChunkTexFloat = function (s, o, p) {
		return "#undef MAPTEXTUREFLOAT\n#ifdef MAPTEXTURE\n#ifdef MAPFLOAT\n#define MAPTEXTUREFLOAT\n#endif\n#endif\n" +
				"#ifdef MAPTEXTUREFLOAT\n" + s + "\n#else\n" + shaderChunks[o] + "\n#endif\n";
	};
	var _oldChunkVert = function (s, o, p) {
		return "\n#ifdef MAPVERTEX\n" + s + "\n#else\n" + shaderChunks[o] + "\n#endif\n";
	};
	var _oldChunkVertColor = function (s, o, p) {
		return "#undef MAPVERTEXCOLOR\n#ifdef MAPVERTEX\n#ifdef MAPCOLOR\n#define MAPVERTEXCOLOR\n#endif\n#endif\n" +
				"#ifdef MAPVERTEXCOLOR\n" + s + "\n#else\n" + shaderChunks[o] + "\n#endif\n";
	};
	var _oldChunkVertFloat = function (s, o, p) {
		return "#undef MAPVERTEXFLOAT\n#ifdef MAPVERTEX\n#ifdef MAPFLOAT\n#define MAPVERTEXFLOAT\n#endif\n#endif\n" +
				"#ifdef MAPVERTEXFLOAT\n" + s + "\n#else\n" + shaderChunks[o] + "\n#endif\n";
	};
	var _oldChunkTransformSkin = function (s, o, p) {
		return "\n#ifdef SKIN\n" + s + "\n#else\n" + shaderChunks[o] + "\n#endif\n";
	};
	var _oldChunkTransformDynbatch = function (s, o, p) {
		return "\n#ifdef DYNAMICBATCH\n" + s + "\n#else\n" + shaderChunks[o] + "\n#endif\n";
	};
	var _oldChunkTransformInstanced = function (s, o, p) {
		return "\n#ifdef INSTANCING\n" + s + "\n#else\n" + shaderChunks[o] + "\n#endif\n";
	};
	var _oldChunkTransformPixelSnap = function (s, o, p) {
		return "\n#ifdef PIXELSNAP\n" + s + "\n#else\n" + shaderChunks[o] + "\n#endif\n";
	};
	var _oldChunkTransformScreenSpace = function (s, o, p) {
		return "\n#ifdef SCREENSPACE\n" + s + "\n#else\n" + shaderChunks[o] + "\n#endif\n";
	};
	var _oldChunkTransformScreenSpaceBatch = function (s, o, p) {
		return "#undef SCREENSPACEBATCH\n#ifdef SCREENSPACE\n#ifdef BATCH\n#define SCREENSPACEBATCH\n#endif\n#endif\n" +
				"#ifdef SCREENSPACEBATCH\n" + s + "\n#else\n" + shaderChunks[o] + "\n#endif\n";
	};
	var _oldChunkTransformUv1 = function (s, o, p) {
		return "\n#ifdef UV1LAYOUT\n" + s + "\n#else\n" + shaderChunks[o] + "\n#endif\n";
	};
	var _matTex2D = [];
	var standard = {
		_oldChunkToNew: {
			aoTexPS: { n: "aoPS", f: _oldChunkTex },
			aoVertPS: { n: "aoPS", f: _oldChunkVert },
			diffuseConstPS: { n: "diffusePS", f: _oldChunkColor },
			diffuseTexPS: { n: "diffusePS", f: _oldChunkTex },
			diffuseTexConstPS: { n: "diffusePS", f: _oldChunkTexColor },
			diffuseVertPS: { n: "diffusePS", f: _oldChunkVert },
			diffuseVertConstPS: { n: "diffusePS", f: _oldChunkVertColor },
			emissiveConstPS: { n: "emissivePS", f: _oldChunkColor },
			emissiveTexPS: { n: "emissivePS", f: _oldChunkTex },
			emissiveTexConstPS: { n: "emissivePS", f: _oldChunkTexColor },
			emissiveTexConstFloatPS: { n: "emissivePS", f: _oldChunkTexFloat },
			emissiveVertPS: { n: "emissivePS", f: _oldChunkVert },
			emissiveVertConstPS: { n: "emissivePS", f: _oldChunkVertColor },
			emissiveVertConstFloatPS: { n: "emissivePS", f: _oldChunkVertFloat },
			glossConstPS: { n: "glossPS", f: _oldChunkFloat },
			glossTexPS: { n: "glossPS", f: _oldChunkTex },
			glossTexConstPS: { n: "glossPS", f: _oldChunkTexFloat },
			glossVertPS: { n: "glossPS", f: _oldChunkVert },
			glossVertConstPS: { n: "glossPS", f: _oldChunkVertFloat },
			metalnessConstPS: { n: "metalnessPS", f: _oldChunkFloat },
			metalnessTexPS: { n: "metalnessPS", f: _oldChunkTex },
			metalnessTexConstPS: { n: "metalnessPS", f: _oldChunkTexFloat },
			metalnessVertPS: { n: "metalnessPS", f: _oldChunkVert },
			metalnessVertConstPS: { n: "metalnessPS", f: _oldChunkVertFloat },
			opacityConstPS: { n: "opacityPS", f: _oldChunkFloat },
			opacityTexPS: { n: "opacityPS", f: _oldChunkTex },
			opacityTexConstPS: { n: "opacityPS", f: _oldChunkTexFloat },
			opacityVertPS: { n: "opacityPS", f: _oldChunkVert },
			opacityVertConstPS: { n: "opacityPS", f: _oldChunkVertFloat },
			specularConstPS: { n: "specularPS", f: _oldChunkColor },
			specularTexPS: { n: "specularPS", f: _oldChunkTex },
			specularTexConstPS: { n: "specularPS", f: _oldChunkTexColor },
			specularVertPS: { n: "specularPS", f: _oldChunkVert },
			specularVertConstPS: { n: "specularPS", f: _oldChunkVertColor },
			transformBatchSkinnedVS: { n: "transformVS", f: _oldChunkTransformDynbatch },
			transformInstancedVS: { n: "transformVS", f: _oldChunkTransformInstanced },
			transformPixelSnapVS: { n: "transformVS", f: _oldChunkTransformPixelSnap },
			transformScreenSpaceVS: { n: "transformVS", f: _oldChunkTransformScreenSpace },
			transformScreenSpaceBatchSkinned: { n: "transformVS", f: _oldChunkTransformScreenSpaceBatch },
			transformSkinned: { n: "transformVS", f: _oldChunkTransformSkin },
			transformUv1: { n: "transformVS", f: _oldChunkTransformUv1 }
		},
		optionsContext: {},
		optionsContextMin: {},
		generateKey: function (options) {
			var buildPropertiesList = function (options) {
				var props = [];
				for (var prop in options) {
					if (options.hasOwnProperty(prop) && prop !== "chunks" && prop !== "lights")
						props.push(prop);
				}
				return props.sort();
			};
			var props;
			if (options === this.optionsContextMin) {
				if (!this.propsMin) this.propsMin = buildPropertiesList(options);
				props = this.propsMin;
			} else if (options === this.optionsContext) {
				if (!this.props) this.props = buildPropertiesList(options);
				props = this.props;
			} else {
				props = buildPropertiesList(options);
			}
			var key = "standard";
			var i;
			for (i = 0; i < props.length; i++) {
				if (options[props[i]])
					key += props[i] + options[props[i]];
			}
			if (options.chunks) {
				var chunks = [];
				for (var p in options.chunks) {
					if (options.chunks.hasOwnProperty(p)) {
						chunks.push(p + options.chunks[p]);
					}
				}
				chunks.sort();
				key += chunks;
			}
			if (options.lights) {
				for (i = 0; i < options.lights.length; i++) {
					key += options.lights[i].key;
				}
			}
			if (options._shaderGraphChunk) {
				key += options._shaderGraphChunk;
			}
			return hashCode(key);
		},
		_correctChannel: function (p, chan) {
			if (_matTex2D[p] > 0) {
				if (_matTex2D[p] < chan.length) {
					return chan.substring(0, _matTex2D[p]);
				} else if (_matTex2D[p] > chan.length) {
					var str = chan;
					var chr = str.charAt(str.length - 1);
					var addLen = _matTex2D[p] - str.length;
					for (var i = 0; i < addLen; i++) str += chr;
					return str;
				}
				return chan;
			}
		},
		_setMapTransform: function (codes, name, id, uv) {
			codes[0] += "uniform vec4 texture_" + name + "MapTransform;\n";
			var checkId = id + uv * 100;
			if (!codes[3][checkId]) {
				codes[1] += "varying vec2 vUV" + uv + "_" + id + ";\n";
				codes[2] += "   vUV" + uv + "_" + id + " = uv" + uv + " * texture_" + name + "MapTransform.xy + texture_" + name + "MapTransform.zw;\n";
				codes[3][checkId] = true;
			}
			return codes;
		},
		_getUvSourceExpression: function (transformPropName, uVPropName, options) {
			var transformId = options[transformPropName];
			var uvChannel = options[uVPropName];
			var expression;
			var isMainPass = (options.pass === SHADER_FORWARD || options.pass === SHADER_FORWARDHDR);
			if (isMainPass && options.nineSlicedMode === SPRITE_RENDERMODE_SLICED) {
				expression = "nineSlicedUv";
			} else if (isMainPass && options.nineSlicedMode === SPRITE_RENDERMODE_TILED) {
				expression = "nineSlicedUv, -1000.0";
			} else {
				if (transformId === 0) {
					expression = "vUv" + uvChannel;
				} else {
					expression = "vUV" + uvChannel + "_" + transformId;
				}
				if (options.heightMap && transformPropName !== "heightMapTransform") {
					expression += " + dUvOffset";
				}
			}
			return expression;
		},
		_addMapDef: function (name, enabled) {
			var s = "\n#undef " + name + "\n";
			if (enabled) s += " #define " + name + "\n";
			return s;
		},
		_addMapDefs: function (float, color, vertex, map) {
			var s = "";
			s += this._addMapDef("MAPFLOAT", float);
			s += this._addMapDef("MAPCOLOR", color);
			s += this._addMapDef("MAPVERTEX", vertex);
			s += this._addMapDef("MAPTEXTURE", map);
			return s;
		},
		_addMap: function (propName, chunkName, options, chunks, samplerFormat) {
			var mapPropName = propName + "Map";
			var uVPropName = mapPropName + "Uv";
			var transformPropName = mapPropName + "Transform";
			var channelPropName = mapPropName + "Channel";
			var vertexColorChannelPropName = propName + "VertexColorChannel";
			var tintPropName = propName + "Tint";
			var vertexColorPropName = propName + "VertexColor";
			var detailModePropName = propName + "Mode";
			var tintOption = options[tintPropName];
			var vertexColorOption = options[vertexColorPropName];
			var textureOption = options[mapPropName];
			var detailModeOption = options[detailModePropName];
			var subCode = chunks[chunkName];
			if (textureOption) {
				var uv = this._getUvSourceExpression(transformPropName, uVPropName, options);
				subCode = subCode.replace(/\$UV/g, uv).replace(/\$CH/g, options[channelPropName]);
				if (samplerFormat !== undefined) {
					var fmt = samplerFormat === 0 ? "texture2DSRGB" : (samplerFormat === 1 ? "texture2DRGBM" : "texture2D");
					subCode = subCode.replace(/\$texture2DSAMPLE/g, fmt);
				}
			}
			if (vertexColorOption) {
				subCode = subCode.replace(/\$VC/g, options[vertexColorChannelPropName]);
			}
			if (detailModeOption) {
				subCode = subCode.replace(/\$DETAILMODE/g, detailModeOption);
			}
			var isFloatTint = (tintOption === 1);
			var isVecTint = (tintOption === 3);
			subCode = this._addMapDefs(isFloatTint, isVecTint, vertexColorOption, textureOption) + subCode;
			return subCode.replace(/\$/g, "");
		},
		_nonPointShadowMapProjection: function (device, light, shadowCoordArgs) {
			if (!light._normalOffsetBias || light._isVsm) {
				if (light._type === LIGHTTYPE_SPOT) {
					if (light._isPcf && (device.webgl2 || device.extStandardDerivatives)) {
						return "	   getShadowCoordPerspZbuffer" + shadowCoordArgs;
					}
					return "	   getShadowCoordPersp" + shadowCoordArgs;
				}
				return "	   getShadowCoordOrtho" + shadowCoordArgs;
			}
			if (light._type === LIGHTTYPE_SPOT) {
				if (light._isPcf && (device.webgl2 || device.extStandardDerivatives)) {
					return "	   getShadowCoordPerspZbufferNormalOffset" + shadowCoordArgs;
				}
				return "	   getShadowCoordPerspNormalOffset" + shadowCoordArgs;
			}
			return "	   getShadowCoordOrthoNormalOffset" + shadowCoordArgs;
		},
		_addVaryingIfNeeded: function (code, type, name) {
			return code.indexOf(name) >= 0 ? ("varying " + type + " " + name + ";\n") : "";
		},
		_vsAddTransformCode: function (code, device, chunks, options) {
			code += chunks.transformVS;
			return code;
		},
		_vsAddBaseCode: function (code, device, chunks, options) {
			code += chunks.baseVS;
			if (options.nineSlicedMode === SPRITE_RENDERMODE_SLICED ||
				options.nineSlicedMode === SPRITE_RENDERMODE_TILED) {
				code += chunks.baseNineSlicedVS;
			}
			return code;
		},
		_fsAddBaseCode: function (code, device, chunks, options) {
			code += chunks.basePS;
			if (options.nineSlicedMode === SPRITE_RENDERMODE_SLICED) {
				code += chunks.baseNineSlicedPS;
			} else if (options.nineSlicedMode === SPRITE_RENDERMODE_TILED) {
				code += chunks.baseNineSlicedTiledPS;
			}
			return code;
		},
		_fsAddStartCode: function (code, device, chunks, options) {
			code += chunks.startPS;
			if (options.nineSlicedMode === SPRITE_RENDERMODE_SLICED) {
				code += chunks.startNineSlicedPS;
			} else if (options.nineSlicedMode === SPRITE_RENDERMODE_TILED) {
				code += chunks.startNineSlicedTiledPS;
			}
			return code;
		},
		createShaderDefinition: function (device, options) {
			var rootShaderGraph = null;
			var rootDeclGLSL = '';
			var rootCallGLSL = '';
			if (options._shaderGraphChunk)
			{
				rootShaderGraph = shadergraph_nodeRegistry.getNode(options._shaderGraphChunk);
				rootDeclGLSL = rootShaderGraph.generateRootDeclGlsl();
				rootCallGLSL = rootShaderGraph.generateRootCallGlsl();
			}
			var i, p;
			var lighting = options.lights.length > 0;
			if (options.dirLightMap) {
				lighting = true;
				options.useSpecular = true;
			}
			if (options.shadingModel === SPECULAR_PHONG) {
				options.fresnelModel = 0;
				options.specularAntialias = false;
				options.prefilteredCubemap = false;
				options.dpAtlas = false;
				options.ambientSH = false;
			} else {
				options.fresnelModel = (options.fresnelModel === 0) ? FRESNEL_SCHLICK : options.fresnelModel;
			}
			var cubemapReflection = (options.cubeMap || (options.prefilteredCubemap && options.useSpecular)) && !options.sphereMap && !options.dpAtlas;
			var reflections = options.sphereMap || cubemapReflection || options.dpAtlas;
			var useTexCubeLod = options.useTexCubeLod;
			if (options.cubeMap) options.sphereMap = null;
			if (options.dpAtlas) options.prefilteredCubemap = null;
			if (!options.useSpecular) options.specularMap = options.glossMap = null;
			var needsNormal = lighting || reflections || options.ambientSH || options.prefilteredCubemap || options.heightMap || options.enableGGXSpecular;
			var shadowPass = options.pass >= SHADER_SHADOW && options.pass <= 17;
			needsNormal = needsNormal || options._shaderGraphChunk;
			this.options = options;
			var code = '';
			var codeBody = '';
			var varyings = "";
			var chunks = shaderChunks;
			var lightType;
			var shadowCoordArgs;
			var chunk;
			var attributes = {
				vertex_position: SEMANTIC_POSITION
			};
			if (options.chunks) {
				var customChunks = {};
				var newP;
				for (p in chunks) {
					if (chunks.hasOwnProperty(p)) {
						if (!options.chunks[p]) {
							customChunks[p] = chunks[p];
						} else {
							chunk = options.chunks[p];
							if (chunk.indexOf("vertex_normal") >= 0) {
								attributes.vertex_normal = SEMANTIC_NORMAL;
							}
							if (chunk.indexOf("vertex_tangent") >= 0) {
								attributes.vertex_tangent = SEMANTIC_TANGENT;
							}
							if (chunk.indexOf("vertex_texCoord0") >= 0) {
								attributes.vertex_texCoord0 = SEMANTIC_TEXCOORD0;
							}
							if (chunk.indexOf("vertex_texCoord1") >= 0) {
								attributes.vertex_texCoord1 = SEMANTIC_TEXCOORD1;
							}
							if (chunk.indexOf("vertex_color") >= 0) {
								attributes.vertex_color = SEMANTIC_COLOR;
							}
							if (chunk.indexOf("vertex_boneWeights") >= 0) {
								attributes.vertex_boneWeights = SEMANTIC_BLENDWEIGHT;
							}
							if (chunk.indexOf("vertex_boneIndices") >= 0) {
								attributes.vertex_boneIndices = SEMANTIC_BLENDINDICES;
							}
							customChunks[p] = chunk;
						}
					}
				}
				for (p in options.chunks) {
					newP = this._oldChunkToNew[p];
					if (newP) {
						customChunks[newP.n] = newP.f(options.chunks[p], newP.n, p);
					}
				}
				chunks = customChunks;
			}
			code = this._vsAddBaseCode(code, device, chunks, options);
			var mainShadowLight = -1;
			if (!options.noShadow && !options.twoSidedLighting) {
				for (i = 0; i < options.lights.length; i++) {
					lightType = options.lights[i]._type;
					if (options.lights[i].castShadows) {
						if (lightType === LIGHTTYPE_DIRECTIONAL) {
							code += "uniform mat4 light" + i + "_shadowMatrixVS;\n";
							code += "uniform vec3 light" + i + "_shadowParamsVS;\n";
							code += "uniform vec3 light" + i + (lightType === LIGHTTYPE_DIRECTIONAL ? "_directionVS" : "_positionVS") + ";\n";
							mainShadowLight = i;
							break;
						}
					}
				}
				if (mainShadowLight >= 0) {
					code += chunks.shadowCoordVS;
				}
			}
			codeBody += "   vPositionW	= getWorldPosition();\n";
			if (options.pass === SHADER_DEPTH) {
				code += 'varying float vDepth;\n';
				code += '#ifndef VIEWMATRIX\n';
				code += '#define VIEWMATRIX\n';
				code += 'uniform mat4 matrix_view;\n';
				code += '#endif\n';
				code += '#ifndef CAMERAPLANES\n';
				code += '#define CAMERAPLANES\n';
				code += 'uniform vec4 camera_params;\n\n';
				code += '#endif\n';
				codeBody += "	vDepth = -(matrix_view * vec4(vPositionW,1.0)).z * camera_params.x;\n";
			}
			if (options.useInstancing) {
				attributes.instance_line1 = SEMANTIC_TEXCOORD2;
				attributes.instance_line2 = SEMANTIC_TEXCOORD3;
				attributes.instance_line3 = SEMANTIC_TEXCOORD4;
				attributes.instance_line4 = SEMANTIC_TEXCOORD5;
				code += chunks.instancingVS;
			}
			if (needsNormal) {
				attributes.vertex_normal = SEMANTIC_NORMAL;
				codeBody += "   vNormalW	= dNormalW = getNormal();\n";
				if ((options.sphereMap) && (device.fragmentUniformsCount <= 16)) {
					code += chunks.viewNormalVS;
					codeBody += "   vNormalV	= getViewNormal();\n";
				}
				if ((options.heightMap || options.normalMap || options.enableGGXSpecular) && options.hasTangents) {
					attributes.vertex_tangent = SEMANTIC_TANGENT;
					code += chunks.tangentBinormalVS;
					codeBody += "   vTangentW   = getTangent();\n";
					codeBody += "   vBinormalW  = getBinormal();\n";
				} else if (options.enableGGXSpecular) {
					code += chunks.tangentBinormalVS;
					codeBody += "   vObjectSpaceUpW  = getObjectSpaceUp();\n";
				}
				if (mainShadowLight >= 0) {
					lightType = options.lights[mainShadowLight]._type;
					if (lightType === LIGHTTYPE_DIRECTIONAL) {
						codeBody += "   dLightDirNormW = light" + mainShadowLight + "_directionVS;\n";
					} else {
						codeBody += "   getLightDirPoint(light" + mainShadowLight + "_positionVS);\n";
					}
					shadowCoordArgs = "(light" + mainShadowLight + "_shadowMatrixVS, light" + mainShadowLight + "_shadowParamsVS);\n";
					codeBody += this._nonPointShadowMapProjection(device, options.lights[mainShadowLight], shadowCoordArgs);
				}
			}
			var useUv = [];
			var useUnmodifiedUv = [];
			var maxUvSets = 2;
			var cname, mname, tname, uname;
			for (p in _matTex2D) {
				mname = p + "Map";
				if (options[p + "VertexColor"]) {
					cname = p + "VertexColorChannel";
					options[cname] = this._correctChannel(p, options[cname]);
				}
				if (options[mname]) {
					cname = mname + "Channel";
					tname = mname + "Transform";
					uname = mname + "Uv";
					options[uname] = Math.min(options[uname], maxUvSets - 1);
					options[cname] = this._correctChannel(p, options[cname]);
					var uvSet = options[uname];
					useUv[uvSet] = true;
					useUnmodifiedUv[uvSet] = useUnmodifiedUv[uvSet] || (options[mname] && !options[tname]);
				}
			}
			if (options.forceUv1) useUv[1] = true;
			for (i = 0; i < maxUvSets; i++) {
				if (useUv[i]) {
					attributes["vertex_texCoord" + i] = "TEXCOORD" + i;
					code += chunks["uv" + i + "VS"];
					codeBody += "   vec2 uv" + i + " = getUv" + i + "();\n";
				}
				if (useUnmodifiedUv[i]) {
					codeBody += "   vUv" + i + " = uv" + i + ";\n";
				}
			}
			var codes = [code, varyings, codeBody, []];
			for (p in _matTex2D) {
				mname = p + "Map";
				if (options[mname]) {
					tname = mname + "Transform";
					if (options[tname]) {
						uname = mname + "Uv";
						this._setMapTransform(codes, p, options[tname], options[uname]);
					}
				}
			}
			code = codes[0];
			varyings = codes[1];
			codeBody = codes[2];
			if (options.vertexColors) {
				attributes.vertex_color = SEMANTIC_COLOR;
				codeBody += "   vVertexColor = vertex_color;\n";
			}
			if (options.useMorphPosition || options.useMorphNormal) {
				if (options.useMorphTextureBased) {
					code += "#define MORPHING_TEXTURE_BASED\n";
					if (options.useMorphPosition) {
						code += "#define MORPHING_TEXTURE_BASED_POSITION\n";
					}
					if (options.useMorphNormal) {
						code += "#define MORPHING_TEXTURE_BASED_NORMAL\n";
					}
					attributes.morph_vertex_id = SEMANTIC_ATTR15;
					code += "attribute float morph_vertex_id;\n";
				} else {
					code += "#define MORPHING\n";
					if (options.useMorphPosition) {
						attributes.morph_pos0 = SEMANTIC_ATTR8;
						attributes.morph_pos1 = SEMANTIC_ATTR9;
						attributes.morph_pos2 = SEMANTIC_ATTR10;
						attributes.morph_pos3 = SEMANTIC_ATTR11;
						code += "#define MORPHING_POS03\n";
						code += "attribute vec3 morph_pos0;\n";
						code += "attribute vec3 morph_pos1;\n";
						code += "attribute vec3 morph_pos2;\n";
						code += "attribute vec3 morph_pos3;\n";
					} else if (options.useMorphNormal) {
						attributes.morph_nrm0 = SEMANTIC_ATTR8;
						attributes.morph_nrm1 = SEMANTIC_ATTR9;
						attributes.morph_nrm2 = SEMANTIC_ATTR10;
						attributes.morph_nrm3 = SEMANTIC_ATTR11;
						code += "#define MORPHING_NRM03\n";
						code += "attribute vec3 morph_nrm0;\n";
						code += "attribute vec3 morph_nrm1;\n";
						code += "attribute vec3 morph_nrm2;\n";
						code += "attribute vec3 morph_nrm3;\n";
					}
					if (!options.useMorphNormal) {
						attributes.morph_pos4 = SEMANTIC_ATTR12;
						attributes.morph_pos5 = SEMANTIC_ATTR13;
						attributes.morph_pos6 = SEMANTIC_ATTR14;
						attributes.morph_pos7 = SEMANTIC_ATTR15;
						code += "#define MORPHING_POS47\n";
						code += "attribute vec3 morph_pos4;\n";
						code += "attribute vec3 morph_pos5;\n";
						code += "attribute vec3 morph_pos6;\n";
						code += "attribute vec3 morph_pos7;\n";
					} else {
						attributes.morph_nrm4 = SEMANTIC_ATTR12;
						attributes.morph_nrm5 = SEMANTIC_ATTR13;
						attributes.morph_nrm6 = SEMANTIC_ATTR14;
						attributes.morph_nrm7 = SEMANTIC_ATTR15;
						code += "#define MORPHING_NRM47\n";
						code += "attribute vec3 morph_nrm4;\n";
						code += "attribute vec3 morph_nrm5;\n";
						code += "attribute vec3 morph_nrm6;\n";
						code += "attribute vec3 morph_nrm7;\n";
					}
				}
			}
			if (options.skin) {
				attributes.vertex_boneWeights = SEMANTIC_BLENDWEIGHT;
				attributes.vertex_boneIndices = SEMANTIC_BLENDINDICES;
				code += skinCode(device, chunks);
				code += "#define SKIN\n";
			} else if (options.useInstancing) {
				code += "#define INSTANCING\n";
			}
			if (options.screenSpace) {
				code += "#define SCREENSPACE\n";
			}
			if (options.pixelSnap) {
				code += "#define PIXELSNAP\n";
			}
			code = this._vsAddTransformCode(code, device, chunks, options);
			if (needsNormal) code += chunks.normalVS;
			if (options._shaderGraphChunk)
			{
				code += "#define SG_VS\n";
				code += rootDeclGLSL;
			}
			code += "\n";
			code += chunks.startVS;
			code += codeBody;
			if (options._shaderGraphChunk)
			{
				if (rootShaderGraph.getGraphVarByName('OUT_vertOff'))
				{
					code += rootCallGLSL;
					code += "   vPositionW = vPositionW+OUT_vertOff;\n";
					code += "   gl_Position = matrix_viewProjection*vec4(vPositionW,1);\n";
				}
			}
			code += "}";
			var vshader = code;
			var oldVars = varyings;
			varyings = "";
			varyings += this._addVaryingIfNeeded(code, "vec4", "vMainShadowUv");
			varyings += this._addVaryingIfNeeded(code, "vec4", "vVertexColor");
			varyings += this._addVaryingIfNeeded(code, "vec3", "vPositionW");
			varyings += this._addVaryingIfNeeded(code, "vec3", "vNormalV");
			varyings += this._addVaryingIfNeeded(code, "vec3", "vNormalW");
			varyings += this._addVaryingIfNeeded(code, "vec3", "vTangentW");
			varyings += this._addVaryingIfNeeded(code, "vec3", "vBinormalW");
			varyings += this._addVaryingIfNeeded(code, "vec3", "vObjectSpaceUpW");
			varyings += this._addVaryingIfNeeded(code, "vec2", "vUv0");
			varyings += this._addVaryingIfNeeded(code, "vec2", "vUv1");
			varyings += oldVars;
			vshader = varyings + vshader;
			var startCode = "";
			if (device.webgl2) {
				startCode = versionCode(device);
				if (chunks.extensionVS) {
					startCode += chunks.extensionVS + "\n";
				}
				vshader = startCode + chunks.gles3VS + vshader;
			} else {
				if (chunks.extensionVS) {
					startCode = chunks.extensionVS + "\n";
				}
				vshader = startCode + vshader;
			}
			if (options.forceFragmentPrecision && options.forceFragmentPrecision != "highp" &&
				options.forceFragmentPrecision !== "mediump" && options.forceFragmentPrecision !== "lowp")
				options.forceFragmentPrecision = null;
			if (options.forceFragmentPrecision) {
				if (options.forceFragmentPrecision === "highp" && device.maxPrecision !== "highp") options.forceFragmentPrecision = "mediump";
				if (options.forceFragmentPrecision === "mediump" && device.maxPrecision === "lowp") options.forceFragmentPrecision = "lowp";
			}
			var fshader;
			code = '';
			if (device.webgl2) {
				code += versionCode(device);
			}
			if (device.extStandardDerivatives && !device.webgl2) {
				code += "#extension GL_OES_standard_derivatives : enable\n\n";
			}
			if (chunks.extensionPS) {
				code += chunks.extensionPS + "\n";
			}
			if (device.webgl2) {
				code += chunks.gles3PS;
			}
			code += options.forceFragmentPrecision ? "precision " + options.forceFragmentPrecision + " float;\n\n" : precisionCode(device);
			if (options.pass === SHADER_PICK) {
				code += "uniform vec4 uColor;\n";
				code += varyings;
				if (options.alphaTest) {
					code += "float dAlpha;\n";
					code += this._addMap("opacity", "opacityPS", options, chunks);
					code += chunks.alphaTestPS;
				}
				code += begin();
				if (options.alphaTest) {
					code += "   getOpacity();\n";
					code += "   alphaTest(dAlpha);\n";
				}
				code += "	gl_FragColor = uColor;\n";
				code += end();
				return {
					attributes: attributes,
					vshader: vshader,
					fshader: code
				};
			} else if (options.pass === SHADER_DEPTH) {
				code += 'varying float vDepth;\n';
				code += varyings;
				code += chunks.packDepthPS;
				if (options.alphaTest) {
					code += "float dAlpha;\n";
					code += this._addMap("opacity", "opacityPS", options, chunks);
					code += chunks.alphaTestPS;
				}
				code += begin();
				if (options.alphaTest) {
					code += "   getOpacity();\n";
					code += "   alphaTest(dAlpha);\n";
				}
				code += "	gl_FragColor = packFloat(vDepth);\n";
				code += end();
				return {
					attributes: attributes,
					vshader: vshader,
					fshader: code
				};
			} else if (shadowPass) {
				var smode = options.pass - SHADER_SHADOW;
				var numShadowModes = 5;
				lightType = Math.floor(smode / numShadowModes);
				var shadowType = smode - lightType * numShadowModes;
				if (device.extStandardDerivatives && !device.webgl2) {
					code += 'uniform vec2 polygonOffset;\n';
				}
				if (shadowType === SHADOW_VSM32) {
					if (device.textureFloatHighPrecision) {
						code += '#define VSM_EXPONENT 15.0\n\n';
					} else {
						code += '#define VSM_EXPONENT 5.54\n\n';
					}
				} else if (shadowType === SHADOW_VSM16) {
					code += '#define VSM_EXPONENT 5.54\n\n';
				}
				if (lightType !== LIGHTTYPE_DIRECTIONAL) {
					code += 'uniform vec3 view_position;\n';
					code += 'uniform float light_radius;\n';
				}
				code += varyings;
				if (options.alphaTest) {
					code += "float dAlpha;\n";
					code += this._addMap("opacity", "opacityPS", options, chunks);
					code += chunks.alphaTestPS;
				}
				if (shadowType === SHADOW_PCF3 && (!device.webgl2 || lightType === LIGHTTYPE_POINT)) {
					code += chunks.packDepthPS;
				} else if (shadowType === SHADOW_VSM8) {
					code += "vec2 encodeFloatRG( float v ) {\n";
					code += "	vec2 enc = vec2(1.0, 255.0) * v;\n";
					code += "	enc = fract(enc);\n";
					code += "	enc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);\n";
					code += "	return enc;\n";
					code += "}\n\n";
				}
				code += begin();
				if (options.alphaTest) {
					code += "   getOpacity();\n";
					code += "   alphaTest(dAlpha);\n";
				}
				var isVsm = shadowType === SHADOW_VSM8 || shadowType === SHADOW_VSM16 || shadowType === SHADOW_VSM32;
				if (lightType === LIGHTTYPE_POINT || (isVsm && lightType !== LIGHTTYPE_DIRECTIONAL)) {
					code += "   float depth = min(distance(view_position, vPositionW) / light_radius, 0.99999);\n";
				} else {
					code += "   float depth = gl_FragCoord.z;\n";
				}
				if (shadowType === SHADOW_PCF3 && (!device.webgl2 || lightType === LIGHTTYPE_POINT)) {
					if (device.extStandardDerivatives && !device.webgl2) {
						code += "   float minValue = 2.3374370500153186e-10; //(1.0 / 255.0) / (256.0 * 256.0 * 256.0);\n";
						code += "   depth += polygonOffset.x * max(abs(dFdx(depth)), abs(dFdy(depth))) + minValue * polygonOffset.y;\n";
						code += "   gl_FragColor = packFloat(depth);\n";
					} else {
						code += "   gl_FragColor = packFloat(depth);\n";
					}
				} else if (shadowType === SHADOW_PCF3 || shadowType === SHADOW_PCF5) {
					code += "   gl_FragColor = vec4(1.0);\n";
				} else if (shadowType === SHADOW_VSM8) {
					code += "   gl_FragColor = vec4(encodeFloatRG(depth), encodeFloatRG(depth*depth));\n";
				} else {
					code += chunks.storeEVSMPS;
				}
				code += end();
				return {
					attributes: attributes,
					vshader: vshader,
					fshader: code
				};
			}
			if (options.customFragmentShader) {
				fshader = code + options.customFragmentShader;
				return {
					attributes: attributes,
					vshader: vshader,
					fshader: fshader,
					tag: SHADERTAG_MATERIAL
				};
			}
			code += varyings;
			code = this._fsAddBaseCode(code, device, chunks, options);
			if (options.detailModes) {
				code += chunks.detailModesPS;
			}
			var codeBegin = code;
			code = "";
			if (options.clearCoat > 0) {
				code += '#define CLEARCOAT\n';
			}
			var numShadowLights = 0;
			var shadowTypeUsed = [];
			var useVsm = false;
			var usePerspZbufferShadow = false;
			var light;
			for (i = 0; i < options.lights.length; i++) {
				light = options.lights[i];
				lightType = light._type;
				code += "uniform vec3 light" + i + "_color;\n";
				if (lightType === LIGHTTYPE_DIRECTIONAL) {
					code += "uniform vec3 light" + i + "_direction;\n";
				} else {
					code += "uniform vec3 light" + i + "_position;\n";
					code += "uniform float light" + i + "_radius;\n";
					if (lightType === LIGHTTYPE_SPOT) {
						code += "uniform vec3 light" + i + "_direction;\n";
						code += "uniform float light" + i + "_innerConeAngle;\n";
						code += "uniform float light" + i + "_outerConeAngle;\n";
					}
				}
				if (light.castShadows && !options.noShadow) {
					code += "uniform mat4 light" + i + "_shadowMatrix;\n";
					if (lightType !== LIGHTTYPE_DIRECTIONAL) {
						code += "uniform vec4 light" + i + "_shadowParams;\n";
					} else {
						code += "uniform vec3 light" + i + "_shadowParams;\n";
					}
					if (lightType === LIGHTTYPE_POINT) {
						code += "uniform samplerCube light" + i + "_shadowMap;\n";
					} else {
						if (light._isPcf && device.webgl2) {
							code += "uniform sampler2DShadow light" + i + "_shadowMap;\n";
						} else {
							code += "uniform sampler2D light" + i + "_shadowMap;\n";
						}
					}
					numShadowLights++;
					shadowTypeUsed[light._shadowType] = true;
					if (light._isVsm) useVsm = true;
					if (light._isPcf && (device.webgl2 || device.extStandardDerivatives) && lightType === LIGHTTYPE_SPOT) usePerspZbufferShadow = true;
				}
				if (light._cookie) {
					if (light._cookie._cubemap) {
						if (lightType === LIGHTTYPE_POINT) {
							code += "uniform samplerCube light" + i + "_cookie;\n";
							code += "uniform float light" + i + "_cookieIntensity;\n";
							if (!light.castShadows || options.noShadow) code += "uniform mat4 light" + i + "_shadowMatrix;\n";
						}
					} else {
						if (lightType === LIGHTTYPE_SPOT) {
							code += "uniform sampler2D light" + i + "_cookie;\n";
							code += "uniform float light" + i + "_cookieIntensity;\n";
							if (!light.castShadows || options.noShadow) code += "uniform mat4 light" + i + "_shadowMatrix;\n";
							if (light._cookieTransform) {
								code += "uniform vec4 light" + i + "_cookieMatrix;\n";
								code += "uniform vec2 light" + i + "_cookieOffset;\n";
							}
						}
					}
				}
			}
			code += "\n";
			var tbn;
			if (!options.hasTangents && device.extStandardDerivatives) {
				tbn = chunks.TBNderivativePS;
			} else if (options.fastTbn) {
				tbn = chunks.TBNfastPS;
			} else {
				tbn = chunks.TBNPS;
			}
			if (needsNormal) {
				if (options.normalMap) {
					code += options.packedNormal ? chunks.normalXYPS : chunks.normalXYZPS;
					if (options.normalDetail) {
						code += this._addMap("normalDetail", "normalDetailMapPS", options, chunks);
					}
					var transformedNormalMapUv = this._getUvSourceExpression("normalMapTransform", "normalMapUv", options);
					if (options.normalizeNormalMap) {
						code += chunks.normalMapPS.replace(/\$UV/g, transformedNormalMapUv);
					} else {
						code += chunks.normalMapFastPS.replace(/\$UV/g, transformedNormalMapUv);
					}
					if (!options.hasTangents) tbn = tbn.replace(/\$UV/g, transformedNormalMapUv);
					code += tbn;
				} else {
					code += chunks.normalVertexPS;
					if (options.enableGGXSpecular) {
						code += chunks.TBNObjectSpacePS;
					}
				}
			}
			code += gammaCode(options.gamma, chunks);
			code += tonemapCode(options.toneMap, chunks);
			code += fogCode(options.fog, chunks);
			if (options.useRgbm) code += chunks.rgbmPS;
			if (cubemapReflection || options.prefilteredCubemap) {
				code += options.fixSeams ? chunks.fixCubemapSeamsStretchPS : chunks.fixCubemapSeamsNonePS;
			}
			if (needsNormal) {
				code += options.cubeMapProjection > 0 ? chunks.cubeMapProjectBoxPS : chunks.cubeMapProjectNonePS;
				code += options.skyboxIntensity ? chunks.envMultiplyPS : chunks.envConstPS;
			}
			if (options.diffuseDetail) {
				code += this._addMap("diffuseDetail", "diffuseDetailMapPS", options, chunks);
			}
			code += this._addMap("diffuse", "diffusePS", options, chunks);
			if (options.blendType !== BLEND_NONE || options.alphaTest || options.alphaToCoverage) {
				code += this._addMap("opacity", "opacityPS", options, chunks);
			}
			code += this._addMap("emissive", "emissivePS", options, chunks, options.emissiveFormat);
			if (options.useSpecular && (lighting || reflections)) {
				if (options.specularAntialias && options.normalMap) {
					if (options.normalizeNormalMap && needsNormal) {
						code += chunks.specularAaToksvigPS;
					} else {
						code += chunks.specularAaToksvigFastPS;
					}
				} else {
					code += chunks.specularAaNonePS;
				}
				var specularPropName = options.useMetalness ? "metalness" : "specular";
				code += this._addMap(specularPropName, specularPropName + "PS", options, chunks);
				code += this._addMap("gloss", "glossPS", options, chunks);
				if (options.fresnelModel === FRESNEL_SCHLICK) {
					code += chunks.fresnelSchlickPS;
				}
			}
			if (options.heightMap) {
				if (!options.normalMap) {
					var transformedHeightMapUv = this._getUvSourceExpression("heightMapTransform", "heightMapUv", options);
					if (!options.hasTangents) tbn = tbn.replace(/\$UV/g, transformedHeightMapUv);
					code += tbn;
				}
				code += this._addMap("height", "parallaxPS", options, chunks);
			}
			var useAo = options.aoMap || options.aoVertexColor;
			if (useAo) {
				code += this._addMap("ao", "aoPS", options, chunks);
				if (options.occludeSpecular) {
					if (options.occludeSpecular === SPECOCC_AO) {
						code += options.occludeSpecularFloat ? chunks.aoSpecOccSimplePS : chunks.aoSpecOccConstSimplePS;
					} else {
						code += options.occludeSpecularFloat ? chunks.aoSpecOccPS : chunks.aoSpecOccConstPS;
					}
				}
			}
			var reflectionDecode = options.rgbmReflection ? "decodeRGBM" : (options.hdrReflection ? "" : "gammaCorrectInput");
			if (options.sphereMap) {
				var scode = device.fragmentUniformsCount > 16 ? chunks.reflectionSpherePS : chunks.reflectionSphereLowPS;
				scode = scode.replace(/\$texture2DSAMPLE/g, options.rgbmReflection ? "texture2DRGBM" : (options.hdrReflection ? "texture2D" : "texture2DSRGB"));
				code += scode;
			} else if (cubemapReflection) {
				if (options.prefilteredCubemap) {
					if (useTexCubeLod) {
						code += chunks.reflectionPrefilteredCubeLodPS.replace(/\$DECODE/g, reflectionDecode);
					} else {
						code += chunks.reflectionPrefilteredCubePS.replace(/\$DECODE/g, reflectionDecode);
					}
				} else {
					code += chunks.reflectionCubePS.replace(/\$textureCubeSAMPLE/g,
															options.rgbmReflection ? "textureCubeRGBM" : (options.hdrReflection ? "textureCube" : "textureCubeSRGB"));
				}
			} else if (options.dpAtlas) {
				code += chunks.reflectionDpAtlasPS.replace(/\$texture2DSAMPLE/g, options.rgbmReflection ? "texture2DRGBM" : (options.hdrReflection ? "texture2D" : "texture2DSRGB"));
			}
			if (cubemapReflection || options.sphereMap || options.dpAtlas) {
				if (options.clearCoat > 0){
					code += chunks.reflectionCCPS;
				}
				if (options.refraction){
					code += chunks.refractionPS;
				}
			}
			if (numShadowLights > 0) {
				if (shadowTypeUsed[SHADOW_PCF3]) {
					code += chunks.shadowStandardPS;
				}
				if (shadowTypeUsed[SHADOW_PCF5]) {
					code += chunks.shadowStandardGL2PS;
				}
				if (useVsm) {
					code += chunks.shadowVSM_commonPS;
					if (shadowTypeUsed[SHADOW_VSM8]) {
						code += chunks.shadowVSM8PS;
					}
					if (shadowTypeUsed[SHADOW_VSM16]) {
						code += device.extTextureHalfFloatLinear ? chunks.shadowEVSMPS.replace(/\$/g, "16") : chunks.shadowEVSMnPS.replace(/\$/g, "16");
					}
					if (shadowTypeUsed[SHADOW_VSM32]) {
						code += device.extTextureFloatLinear ? chunks.shadowEVSMPS.replace(/\$/g, "32") : chunks.shadowEVSMnPS.replace(/\$/g, "32");
					}
				}
				if (device.webgl2 || device.extStandardDerivatives) ; else {
					code += chunks.biasConstPS;
				}
				code += chunks.shadowCoordPS + chunks.shadowCommonPS;
				if (usePerspZbufferShadow) code += chunks.shadowCoordPerspZbufferPS;
				if (mainShadowLight >= 0) {
					if (shadowTypeUsed[SHADOW_PCF3]) {
						code += chunks.shadowStandardVSPS;
					}
					if (shadowTypeUsed[SHADOW_PCF5]) {
						code += chunks.shadowStandardGL2VSPS;
					}
					if (useVsm) {
						if (shadowTypeUsed[SHADOW_VSM8]) {
							code += chunks.shadowVSMVSPS.replace(/\$VSM/g, "VSM8").replace(/\$/g, "8");
						}
						if (shadowTypeUsed[SHADOW_VSM16]) {
							code += chunks.shadowVSMVSPS.replace(/\$VSM/g, "VSM16").replace(/\$/g, "16");
						}
						if (shadowTypeUsed[SHADOW_VSM32]) {
							code += chunks.shadowVSMVSPS.replace(/\$VSM/g, "VSM32").replace(/\$/g, "32");
						}
					}
				}
			}
			if (options.enableGGXSpecular) code += "uniform float material_anisotropy;\n";
			if (lighting) code += chunks.lightDiffuseLambertPS;
			var useOldAmbient = false;
			if (options.useSpecular) {
				if (lighting) code += options.shadingModel === SPECULAR_PHONG ? chunks.lightSpecularPhongPS : (options.enableGGXSpecular) ? chunks.lightSpecularAnisoGGXPS : chunks.lightSpecularBlinnPS;
				if (options.sphereMap || cubemapReflection || options.dpAtlas || (options.fresnelModel > 0)) {
					if (options.fresnelModel > 0) {
						if (options.conserveEnergy) {
							code += chunks.combineDiffuseSpecularPS;
						} else {
							code += chunks.combineDiffuseSpecularNoConservePS;
						}
					} else {
						code += chunks.combineDiffuseSpecularOldPS;
					}
				} else {
					if (options.diffuseMap) {
						code += chunks.combineDiffuseSpecularNoReflPS;
					} else {
						code += chunks.combineDiffuseSpecularNoReflSeparateAmbientPS;
						useOldAmbient = true;
					}
				}
			} else {
				code += chunks.combineDiffusePS;
			}
			if (options.clearCoat > 0 ) {
				code += chunks.combineClearCoatPS;
			}
			var addAmbient = true;
			if (options.lightMap || options.lightVertexColor) {
				var lightmapChunkPropName = options.dirLightMap ? 'lightmapDirPS' : 'lightmapSinglePS';
				code += this._addMap("light", lightmapChunkPropName, options, chunks, options.lightMapFormat);
				addAmbient = options.lightMapWithoutAmbient;
			}
			if (addAmbient) {
				var ambientDecode = options.rgbmAmbient ? "decodeRGBM" : (options.hdrAmbient ? "" : "gammaCorrectInput");
				if (options.ambientSH) {
					code += chunks.ambientSHPS;
				} else if (options.prefilteredCubemap) {
					if (useTexCubeLod) {
						code += chunks.ambientPrefilteredCubeLodPS.replace(/\$DECODE/g, ambientDecode);
					} else {
						code += chunks.ambientPrefilteredCubePS.replace(/\$DECODE/g, ambientDecode);
					}
				} else {
					code += chunks.ambientConstantPS;
				}
			}
			if (options.ambientTint && !useOldAmbient) {
				code += "uniform vec3 material_ambient;\n";
			}
			if (options.alphaTest) {
				code += chunks.alphaTestPS;
			}
			if (options.msdf) {
				code += chunks.msdfPS;
			}
			if (needsNormal) {
				code += chunks.viewDirPS;
				if (options.useSpecular) {
					code += (options.enableGGXSpecular) ? chunks.reflDirAnisoPS : chunks.reflDirPS;
				}
			}
			if (options._shaderGraphChunk)
			{
				code += "#define SG_PS\n";
				code += rootDeclGLSL;
			}
			var hasPointLights = false;
			var usesLinearFalloff = false;
			var usesInvSquaredFalloff = false;
			var usesSpot = false;
			var usesCookie = false;
			var usesCookieNow;
			code = this._fsAddStartCode(code, device, chunks, options);
			if (needsNormal) {
				if (options.twoSidedLighting) {
					code += "   dVertexNormalW = gl_FrontFacing ? vNormalW : -vNormalW;\n";
				} else {
					code += "   dVertexNormalW = vNormalW;\n";
				}
				if ((options.heightMap || options.normalMap) && options.hasTangents) {
					if (options.twoSidedLighting) {
						code += "   dTangentW = gl_FrontFacing ? vTangentW : -vTangentW;\n";
						code += "   dBinormalW = gl_FrontFacing ? vBinormalW : -vBinormalW;\n";
					} else {
						code += "   dTangentW = vTangentW;\n";
						code += "   dBinormalW = vBinormalW;\n";
					}
				}
			}
			var opacityParallax = false;
			if (options.blendType === BLEND_NONE && !options.alphaTest && !options.alphaToCoverage) {
				code += "   dAlpha = 1.0;\n";
			} else {
				if (options.heightMap && options.opacityMap) {
					opacityParallax = true;
				} else {
					code += "   getOpacity();\n";
					if (options.alphaTest) {
						if (!options._shaderGraphChunk) code += "   alphaTest(dAlpha);\n";
					}
				}
			}
			var getGlossinessCalled = false;
			if (needsNormal) {
				code += "   getViewDir();\n";
				if (options.heightMap || options.normalMap || options.enableGGXSpecular) {
					code += "   getTBN();\n";
				}
				if (options.heightMap) {
					code += "   getParallax();\n";
				}
				if (opacityParallax) {
					code += "   getOpacity();\n";
					if (options.alphaTest) {
						if (!options._shaderGraphChunk) code += "   alphaTest(dAlpha);\n";
					}
				}
				code += "   getNormal();\n";
				if (options.useSpecular) {
					if (options.enableGGXSpecular) {
						code += "   getGlossiness();\n";
						getGlossinessCalled = true;
					}
					if (!options._shaderGraphChunk) code += "   getReflDir();\n";
				}
			}
			code += "   getAlbedo();\n";
			if (options._shaderGraphChunk)
			{
				code += rootCallGLSL;
				if (rootShaderGraph.getGraphVarByName('OUT_dAlpha'))
				{
					code += 'dAlpha=OUT_dAlpha;\n';
				}
				if (options.alphaTest) {
					code += "   alphaTest(dAlpha);\n";
				}
				if (rootShaderGraph.getGraphVarByName('OUT_dNormalW'))
				{
					code += 'dNormalW=OUT_dNormalW;\n';
				}
				if (rootShaderGraph.getGraphVarByName('OUT_dGlossiness'))
				{
					code += 'dGlossiness=OUT_dGlossiness;\n';
				}
				if (options.useSpecular) {
					code += "   getReflDir();\n";
				}
				if (rootShaderGraph.getGraphVarByName('OUT_dAlbedo'))
				{
					code += 'dAlbedo=OUT_dAlbedo;\n';
				}
			}
			if ((lighting && options.useSpecular) || reflections) {
				code += "   getSpecularity();\n";
				if (!getGlossinessCalled) code += "   getGlossiness();\n";
				if (options.fresnelModel > 0) code += "   getFresnel();\n";
			}
			if (addAmbient) {
				code += "   addAmbient();\n";
			}
			if (options.ambientTint && !useOldAmbient) {
				code += "   dDiffuseLight *= material_ambient;\n";
			}
			if (useAo && !options.occludeDirect) {
				code += "	applyAO();\n";
			}
			if (options.lightMap || options.lightVertexColor) {
				code += "   addLightMap();\n";
			}
			if (lighting || reflections) {
				if (cubemapReflection || options.sphereMap || options.dpAtlas) {
					if (options.clearCoat > 0){
						code += "   addReflectionCC();\n";
					}
					code += "   addReflection();\n";
				}
				if (options.dirLightMap) {
					code += "   addDirLightMap();\n";
				}
				for (i = 0; i < options.lights.length; i++) {
					light = options.lights[i];
					lightType = light._type;
					usesCookieNow = false;
					if (lightType === LIGHTTYPE_DIRECTIONAL) {
						code += "   dLightDirNormW = light" + i + "_direction;\n";
						code += "   dAtten = 1.0;\n";
					} else {
						if (light._cookie) {
							if (lightType === LIGHTTYPE_SPOT && !light._cookie._cubemap) {
								usesCookie = true;
								usesCookieNow = true;
							} else if (lightType === LIGHTTYPE_POINT && light._cookie._cubemap) {
								usesCookie = true;
								usesCookieNow = true;
							}
						}
						code += "   getLightDirPoint(light" + i + "_position);\n";
						hasPointLights = true;
						if (usesCookieNow) {
							if (lightType === LIGHTTYPE_SPOT) {
								code += "   dAtten3 = getCookie2D" + (light._cookieFalloff ? "" : "Clip") + (light._cookieTransform ? "Xform" : "") + "(light" + i + "_cookie, light" + i + "_shadowMatrix, light" + i + "_cookieIntensity" + (light._cookieTransform ? ", light" + i + "_cookieMatrix, light" + i + "_cookieOffset" : "") + ")." + light._cookieChannel + ";\n";
							} else {
								code += "   dAtten3 = getCookieCube(light" + i + "_cookie, light" + i + "_shadowMatrix, light" + i + "_cookieIntensity)." + light._cookieChannel + ";\n";
							}
						}
						if (light._falloffMode === LIGHTFALLOFF_LINEAR) {
							code += "   dAtten = getFalloffLinear(light" + i + "_radius);\n";
							usesLinearFalloff = true;
						} else {
							code += "   dAtten = getFalloffInvSquared(light" + i + "_radius);\n";
							usesInvSquaredFalloff = true;
						}
						code += "   if (dAtten > 0.00001) {\n";
						if (lightType === LIGHTTYPE_SPOT) {
							if (!(usesCookieNow && !light._cookieFalloff)) {
								code += "	   dAtten *= getSpotEffect(light" + i + "_direction, light" + i + "_innerConeAngle, light" + i + "_outerConeAngle);\n";
								usesSpot = true;
							}
						}
					}
					code += "	   dAtten *= getLightDiffuse();\n";
					if (light.castShadows && !options.noShadow) {
						var shadowReadMode = null;
						var evsmExp;
						if (light._shadowType === SHADOW_VSM8) {
							shadowReadMode = "VSM8";
							evsmExp = "0.0";
						} else if (light._shadowType === SHADOW_VSM16) {
							shadowReadMode = "VSM16";
							evsmExp = "5.54";
						} else if (light._shadowType === SHADOW_VSM32) {
							shadowReadMode = "VSM32";
							if (device.textureFloatHighPrecision) {
								evsmExp = "15.0";
							} else {
								evsmExp = "5.54";
							}
						} else if (light._shadowType === SHADOW_PCF5) {
							shadowReadMode = "PCF5x5";
						} else {
							shadowReadMode = "PCF3x3";
						}
						if (shadowReadMode !== null) {
							if (lightType === LIGHTTYPE_POINT) {
								shadowCoordArgs = "(light" + i + "_shadowMap, light" + i + "_shadowParams);\n";
								if (light._normalOffsetBias) {
									code += "	   normalOffsetPointShadow(light" + i + "_shadowParams);\n";
								}
								code += "	   dAtten *= getShadowPoint" + shadowReadMode + shadowCoordArgs;
							} else {
								if (mainShadowLight === i) {
									shadowReadMode += "VS";
								} else {
									shadowCoordArgs = "(light" + i + "_shadowMatrix, light" + i + "_shadowParams);\n";
									code += this._nonPointShadowMapProjection(device, options.lights[i], shadowCoordArgs);
								}
								if (lightType === LIGHTTYPE_SPOT) shadowReadMode = "Spot" + shadowReadMode;
								code += "	   dAtten *= getShadow" + shadowReadMode + "(light" + i + "_shadowMap, light" + i + "_shadowParams" + (light._isVsm ? ", " + evsmExp : "") + ");\n";
							}
						}
					}
					code += "	   dDiffuseLight += dAtten * light" + i + "_color" + (usesCookieNow ? " * dAtten3" : "") + ";\n";
					if (options.clearCoat > 0 ) {
						code += "	   ccSpecularLight += getLightSpecularCC() * dAtten * light" + i + "_color" + (usesCookieNow ? " * dAtten3" : "") + ";\n";
					}
					if (options.useSpecular) {
						code += "	   dAtten *= getLightSpecular();\n";
						code += "	   dSpecularLight += dAtten * light" + i + "_color" + (usesCookieNow ? " * dAtten3" : "") + ";\n";
					}
					if (lightType !== LIGHTTYPE_DIRECTIONAL) {
						code += "   }\n";
					}
					code += "\n";
				}
				if ((cubemapReflection || options.sphereMap || options.dpAtlas) && options.refraction) {
					code += "   addRefraction();\n";
				}
			}
			code += "\n";
			if (useAo) {
				if (options.occludeDirect) {
					code += "	applyAO();\n";
				}
				if (options.occludeSpecular) {
					code += "	occludeSpecular();\n";
				}
			}
			code += chunks.endPS;
			if (options.blendType === BLEND_NORMAL || options.blendType === BLEND_ADDITIVEALPHA || options.alphaToCoverage) {
				code += chunks.outputAlphaPS;
			} else if (options.blendType === BLEND_PREMULTIPLIED) {
				code += chunks.outputAlphaPremulPS;
			} else {
				code += chunks.outputAlphaOpaquePS;
			}
			if (options.msdf) {
				code += "   gl_FragColor = applyMsdf(gl_FragColor);\n";
			}
			if (options._shaderGraphChunk)
			{
				if (rootShaderGraph.getGraphVarByName('OUT_fragOut'))
				{
					code += 'gl_FragColor = OUT_fragOut;\n';
				}
				if (rootShaderGraph.getGraphVarByName('OUT_dEmission'))
				{
					code += 'gl_FragColor.rgb += OUT_dEmission;\n';
				}
			}
			code += "\n";
			code += end();
			if (hasPointLights) {
				code = chunks.lightDirPointPS + code;
			}
			if (usesLinearFalloff) {
				code = chunks.falloffLinearPS + code;
			}
			if (usesInvSquaredFalloff) {
				code = chunks.falloffInvSquaredPS + code;
			}
			if (usesSpot) {
				code = chunks.spotPS + code;
			}
			if (usesCookie) {
				code = chunks.cookiePS + code;
			}
			var structCode = "";
			if (code.includes("dReflection")) structCode += "vec4 dReflection;\n";
			if (code.includes("dTBN")) structCode += "mat3 dTBN;\n";
			if (code.includes("dAlbedo")) structCode += "vec3 dAlbedo;\n";
			if (code.includes("dEmission")) structCode += "vec3 dEmission;\n";
			if (code.includes("dNormalW")) structCode += "vec3 dNormalW;\n";
			if (code.includes("dVertexNormalW")) structCode += "vec3 dVertexNormalW;\n";
			if (code.includes("dTangentW")) structCode += "vec3 dTangentW;\n";
			if (code.includes("dBinormalW")) structCode += "vec3 dBinormalW;\n";
			if (code.includes("dViewDirW")) structCode += "vec3 dViewDirW;\n";
			if (code.includes("dReflDirW")) structCode += "vec3 dReflDirW;\n";
			if (code.includes("dDiffuseLight")) structCode += "vec3 dDiffuseLight;\n";
			if (code.includes("dSpecularLight")) structCode += "vec3 dSpecularLight;\n";
			if (code.includes("dLightDirNormW")) structCode += "vec3 dLightDirNormW;\n";
			if (code.includes("dLightDirW")) structCode += "vec3 dLightDirW;\n";
			if (code.includes("dLightPosW")) structCode += "vec3 dLightPosW;\n";
			if (code.includes("dShadowCoord")) structCode += "vec3 dShadowCoord;\n";
			if (code.includes("dNormalMap")) structCode += "vec3 dNormalMap;\n";
			if (code.includes("dSpecularity")) structCode += "vec3 dSpecularity;\n";
			if (code.includes("dUvOffset")) structCode += "vec2 dUvOffset;\n";
			if (code.includes("dGlossiness")) structCode += "float dGlossiness;\n";
			if (code.includes("dAlpha")) structCode += "float dAlpha;\n";
			if (code.includes("dAtten")) structCode += "float dAtten;\n";
			if (code.includes("dAtten3")) structCode += "vec3 dAtten3;\n";
			if (code.includes("dAo")) structCode += "float dAo;\n";
			if (code.includes("dMsdf")) structCode += "vec4 dMsdf;\n";
			if (code.includes("ccReflection")) structCode += "vec4 ccReflection;\n";
			if (code.includes("ccNormalW")) structCode += "vec3 ccNormalW;\n";
			if (code.includes("ccReflDirW")) structCode += "vec3 ccReflDirW;\n";
			if (code.includes("ccSpecularLight")) structCode += "vec3 ccSpecularLight;\n";
			if (code.includes("ccSpecularity")) structCode += "vec3 ccSpecularity;\n";
			if (code.includes("ccGlossiness")) structCode += "float ccGlossiness=0.9;\n";
			code = codeBegin + structCode + code;
			fshader = code;
			return {
				attributes: attributes,
				vshader: vshader,
				fshader: fshader,
				tag: SHADERTAG_MATERIAL
			};
		}
	};

	var node = {
		generateKey: function (options) {
			var key = 'node';
			if (options.fog)		  key += '_fog';
			if (options.alphaTest)	key += '_atst';
			if (options.shaderGraph) key += options.shaderGraph.key;
			return key;
		},
		_generateVertexShader: function (device, options, rootDeclGLSL, rootCallGLSL) {
			var chunks = shaderChunks;
			var code = '';
			code += chunks.transformDeclVS;
			if (options.skin) {
				code += skinCode(device);
				code += chunks.transformSkinnedVS;
			} else {
				code += chunks.transformVS;
			}
			code += 'varying vec3 vPosition;\n';
			code += 'attribute vec3 vertex_normal;\n';
			code += 'varying vec3 vNormal;\n';
			code += 'attribute vec4 vertex_color;\n';
			code += 'varying vec4 vColor;\n';
			code += 'attribute vec2 vertex_texCoord0;\n';
			code += 'varying vec2 vUv0;\n';
			code += 'vec3 getWorldPositionNM(){return (getModelMatrix()*vec4(vertex_position, 1.0)).xyz;}\n';
			code += 'vec3 getWorldNormalNM(){return (getModelMatrix()*vec4(vertex_normal, 0.0)).xyz;}\n';
			if (options.shaderGraph) {
				code += "#define MAX_VS_LIGHTS " + Math.floor(options.maxVertexLights) + "\n";
				code += "#define SG_VS\n";
				code += rootDeclGLSL;
			}
			code += begin();
			if (options.shaderGraph) {
				code += rootCallGLSL;
				code += "   vPosition = getWorldPositionNM()+OUT_vertOff;\n";
				code += "   gl_Position = matrix_viewProjection*vec4(vPosition,1);\n";
			} else {
				code += "   vPosition = getWorldPositionNM();\n";
				code += "   gl_Position = matrix_viewProjection*vec4(vPosition,1);\n";
			}
			code += '	vNormal = normalize(getWorldNormalNM());\n';
			code += '	vColor = vertex_color;\n';
			code += '	vUv0 = vertex_texCoord0;\n';
			code += end();
			var vshader = code;
			var startCode = "";
			if (device.webgl2) {
				startCode = versionCode(device);
				if (chunks.extensionVS) {
					startCode += chunks.extensionVS + "\n";
				}
				vshader = startCode + chunks.gles3VS + vshader;
			} else {
				if (chunks.extensionVS) {
					startCode = chunks.extensionVS + "\n";
				}
				vshader = startCode + vshader;
			}
			return vshader;
		},
		_generateFragmentShader: function (device, options, rootDeclGLSL, rootCallGLSL) {
			var chunks = shaderChunks;
			if (options.forceFragmentPrecision && options.forceFragmentPrecision != "highp" &&
				options.forceFragmentPrecision !== "mediump" && options.forceFragmentPrecision !== "lowp")
				options.forceFragmentPrecision = null;
			if (options.forceFragmentPrecision) {
				if (options.forceFragmentPrecision === "highp" && device.maxPrecision !== "highp") options.forceFragmentPrecision = "mediump";
				if (options.forceFragmentPrecision === "mediump" && device.maxPrecision === "lowp") options.forceFragmentPrecision = "lowp";
			}
			var code = '';
			if (device.webgl2) {
				code += versionCode(device);
			}
			if (device.extStandardDerivatives && !device.webgl2) {
				code += "#extension GL_OES_standard_derivatives : enable\n\n";
			}
			if (chunks.extensionPS) {
				code += chunks.extensionPS + "\n";
			}
			if (device.webgl2) {
				code += chunks.gles3PS;
			}
			code += options.forceFragmentPrecision ? "precision " + options.forceFragmentPrecision + " float;\n\n" : precisionCode(device);
			code += 'uniform vec3 view_position;\n';
			code += 'varying vec3 vPosition;\n';
			code += 'varying vec3 vNormal;\n';
			code += 'varying vec4 vColor;\n';
			code += 'varying vec2 vUv0;\n';
			if (options.fog) {
				code += fogCode(options.fog);
			}
			if (options.alphatest) {
				code += chunks.alphaTestPS;
			}
			if (options.shaderGraph) {
				code += "#define MAX_PS_LIGHTS " + Math.floor(options.maxPixelLights) + "\n";
				code += "#define SG_PS\n";
				code += rootDeclGLSL;
			}
			code += begin();
			if (options.shaderGraph) {
				code += rootCallGLSL;
				code += 'gl_FragColor=OUT_fragOut;\n';
			}
			if (options.alphatest) {
				code += "   alphaTest(gl_FragColor.a);\n";
			}
			if (options.fog) {
				code += "   glFragColor.rgb = addFog(gl_FragColor.rgb);\n";
			}
			code += end();
			return code;
		},
		createShaderDefinition: function (device, options) {
			var rootDeclGLSL = options.shaderGraph.generateRootDeclGlsl();
			var rootCallGLSL = options.shaderGraph.generateRootCallGlsl();
			var attributes = {
				vertex_position: SEMANTIC_POSITION,
				vertex_normal: SEMANTIC_NORMAL,
				vertex_color: SEMANTIC_COLOR,
				vertex_texCoord0: SEMANTIC_TEXCOORD0
			};
			if (options.skin) {
				attributes.vertex_boneWeights = SEMANTIC_BLENDWEIGHT;
				attributes.vertex_boneIndices = SEMANTIC_BLENDINDICES;
			}
			var vshader = this._generateVertexShader(device, options, rootDeclGLSL, rootCallGLSL);
			var fshader = this._generateFragmentShader(device, options, rootDeclGLSL, rootCallGLSL);
			return {
				attributes: attributes,
				vshader: vshader,
				fshader: fshader
			};
		}
	};

	var programlib = {
		begin: begin,
		dummyFragmentCode: dummyFragmentCode,
		end: end,
		fogCode: fogCode,
		gammaCode: gammaCode,
		precisionCode: precisionCode,
		skinCode: skinCode,
		tonemapCode: tonemapCode,
		versionCode: versionCode,
		basic: basic,
		particle: particle,
		skybox: skybox,
		standard: standard,
		node: node
	};

	function Texture(graphicsDevice, options) {
		this.device = graphicsDevice;
		this.name = null;
		this._width = 4;
		this._height = 4;
		this._depth = 1;
		this._format = PIXELFORMAT_R8_G8_B8_A8;
		this.type = TEXTURETYPE_DEFAULT;
		this._cubemap = false;
		this._volume = false;
		this.fixCubemapSeams = false;
		this._flipY = true;
		this._premultiplyAlpha = false;
		this._mipmaps = true;
		this._minFilter = FILTER_LINEAR_MIPMAP_LINEAR;
		this._magFilter = FILTER_LINEAR;
		this._anisotropy = 1;
		this._addressU = ADDRESS_REPEAT;
		this._addressV = ADDRESS_REPEAT;
		this._addressW = ADDRESS_REPEAT;
		this._compareOnRead = false;
		this._compareFunc = FUNC_LESS;
		if (options !== undefined) {
			if (options.name !== undefined) {
				this.name = options.name;
			}
			this._width = (options.width !== undefined) ? options.width : this._width;
			this._height = (options.height !== undefined) ? options.height : this._height;
			this._format = (options.format !== undefined) ? options.format : this._format;
			if (options.hasOwnProperty('type')) {
				this.type = options.type;
			} else if (options.hasOwnProperty('rgbm')) {
				this.type = options.rgbm ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT;
			} else if (options.hasOwnProperty('swizzleGGGR')) {
				this.type = options.swizzleGGGR ? TEXTURETYPE_SWIZZLEGGGR : TEXTURETYPE_DEFAULT;
			}
			if (options.mipmaps !== undefined) {
				this._mipmaps = options.mipmaps;
			} else {
				this._mipmaps = (options.autoMipmap !== undefined) ? options.autoMipmap : this._mipmaps;
			}
			this._levels = options.levels;
			this._cubemap = (options.cubemap !== undefined) ? options.cubemap : this._cubemap;
			this.fixCubemapSeams = (options.fixCubemapSeams !== undefined) ? options.fixCubemapSeams : this.fixCubemapSeams;
			this._minFilter = (options.minFilter !== undefined) ? options.minFilter : this._minFilter;
			this._magFilter = (options.magFilter !== undefined) ? options.magFilter : this._magFilter;
			this._anisotropy = (options.anisotropy !== undefined) ? options.anisotropy : this._anisotropy;
			this._addressU = (options.addressU !== undefined) ? options.addressU : this._addressU;
			this._addressV = (options.addressV !== undefined) ? options.addressV : this._addressV;
			this._compareOnRead = (options.compareOnRead !== undefined) ? options.compareOnRead : this._compareOnRead;
			this._compareFunc = (options._compareFunc !== undefined) ? options._compareFunc : this._compareFunc;
			this._flipY = (options.flipY !== undefined) ? options.flipY : this._flipY;
			this._premultiplyAlpha = (options.premultiplyAlpha !== undefined) ? options.premultiplyAlpha : this._premultiplyAlpha;
			if (graphicsDevice.webgl2) {
				this._depth = (options.depth !== undefined) ? options.depth : this._depth;
				this._volume = (options.volume !== undefined) ? options.volume : this._volume;
				this._addressW = (options.addressW !== undefined) ? options.addressW : this._addressW;
			}
		}
		this._compressed = (this._format === PIXELFORMAT_DXT1 ||
							this._format === PIXELFORMAT_DXT3 ||
							this._format === PIXELFORMAT_DXT5 ||
							this._format >= PIXELFORMAT_ETC1);
		this._invalid = false;
		this._lockedLevel = -1;
		if (!this._levels) {
			this._levels = this._cubemap ? [[null, null, null, null, null, null]] : [null];
		}
		this.dirtyAll();
		this._gpuSize = 0;
	}
	Object.defineProperties(Texture.prototype, {
		minFilter: {
			get: function () {
				return this._minFilter;
			},
			set: function (v) {
				if (this._minFilter !== v) {
					this._minFilter = v;
					this._parameterFlags |= 1;
				}
			}
		},
		magFilter: {
			get: function () {
				return this._magFilter;
			},
			set: function (v) {
				if (this._magFilter !== v) {
					this._magFilter = v;
					this._parameterFlags |= 2;
				}
			}
		},
		addressU: {
			get: function () {
				return this._addressU;
			},
			set: function (v) {
				if (this._addressU !== v) {
					this._addressU = v;
					this._parameterFlags |= 4;
				}
			}
		},
		addressV: {
			get: function () {
				return this._addressV;
			},
			set: function (v) {
				if (this._addressV !== v) {
					this._addressV = v;
					this._parameterFlags |= 8;
				}
			}
		},
		addressW: {
			get: function () {
				return this._addressW;
			},
			set: function (addressW) {
				if (!this.device.webgl2) return;
				if (!this._volume) {
					return;
				}
				if (addressW !== this._addressW) {
					this._addressW = addressW;
					this._parameterFlags |= 16;
				}
			}
		},
		compareOnRead: {
			get: function () {
				return this._compareOnRead;
			},
			set: function (v) {
				if (this._compareOnRead !== v) {
					this._compareOnRead = v;
					this._parameterFlags |= 32;
				}
			}
		},
		compareFunc: {
			get: function () {
				return this._compareFunc;
			},
			set: function (v) {
				if (this._compareFunc !== v) {
					this._compareFunc = v;
					this._parameterFlags |= 64;
				}
			}
		},
		anisotropy: {
			get: function () {
				return this._anisotropy;
			},
			set: function (v) {
				if (this._anisotropy !== v) {
					this._anisotropy = v;
					this._parameterFlags |= 128;
				}
			}
		},
		autoMipmap: {
			get: function () {
				return this._mipmaps;
			},
			set: function (v) {
				this._mipmaps = v;
			}
		},
		mipmaps: {
			get: function () {
				return this._mipmaps;
			},
			set: function (v) {
				if (this._mipmaps !== v) {
					this._mipmaps = v;
					this._minFilterDirty = true;
					if (v) this._needsMipmapsUpload = true;
				}
			}
		},
		width: {
			get: function () {
				return this._width;
			}
		},
		height: {
			get: function () {
				return this._height;
			}
		},
		depth: {
			get: function () {
				return this._depth;
			}
		},
		format: {
			get: function () {
				return this._format;
			}
		},
		cubemap: {
			get: function () {
				return this._cubemap;
			}
		},
		gpuSize: {
			get: function () {
				var mips = this.pot && this._mipmaps && !(this._compressed && this._levels.length === 1);
				return Texture.calcGpuSize(this._width, this._height, this._depth, this._format, mips, this._cubemap);
			}
		},
		volume: {
			get: function () {
				return this._volume;
			}
		},
		flipY: {
			get: function () {
				return this._flipY;
			},
			set: function (flipY) {
				if (this._flipY !== flipY) {
					this._flipY = flipY;
					this._needsUpload = true;
				}
			}
		},
		premultiplyAlpha: {
			get: function () {
				return this._premultiplyAlpha;
			},
			set: function (premultiplyAlpha) {
				if (this._premultiplyAlpha !== premultiplyAlpha) {
					this._premultiplyAlpha = premultiplyAlpha;
					this._needsUpload = true;
				}
			}
		},
		pot: {
			get: function () {
				return math.powerOfTwo(this._width) && math.powerOfTwo(this._height);
			}
		}
	});
	var _pixelSizeTable = null;
	var _blockSizeTable = null;
	Object.assign(Texture, {
		calcGpuSize: function (width, height, depth, format, mipmaps, cubemap) {
			if (!_pixelSizeTable) {
				_pixelSizeTable = [];
				_pixelSizeTable[PIXELFORMAT_A8] = 1;
				_pixelSizeTable[PIXELFORMAT_L8] = 1;
				_pixelSizeTable[PIXELFORMAT_L8_A8] = 2;
				_pixelSizeTable[PIXELFORMAT_R5_G6_B5] = 2;
				_pixelSizeTable[PIXELFORMAT_R5_G5_B5_A1] = 2;
				_pixelSizeTable[PIXELFORMAT_R4_G4_B4_A4] = 2;
				_pixelSizeTable[PIXELFORMAT_R8_G8_B8] = 4;
				_pixelSizeTable[PIXELFORMAT_R8_G8_B8_A8] = 4;
				_pixelSizeTable[PIXELFORMAT_RGB16F] = 8;
				_pixelSizeTable[PIXELFORMAT_RGBA16F] = 8;
				_pixelSizeTable[PIXELFORMAT_RGB32F] = 16;
				_pixelSizeTable[PIXELFORMAT_RGBA32F] = 16;
				_pixelSizeTable[PIXELFORMAT_R32F] = 4;
				_pixelSizeTable[PIXELFORMAT_DEPTH] = 4;
				_pixelSizeTable[PIXELFORMAT_DEPTHSTENCIL] = 4;
				_pixelSizeTable[PIXELFORMAT_111110F] = 4;
				_pixelSizeTable[PIXELFORMAT_SRGB] = 4;
				_pixelSizeTable[PIXELFORMAT_SRGBA] = 4;
			}
			if (!_blockSizeTable) {
				_blockSizeTable = [];
				_blockSizeTable[PIXELFORMAT_ETC1] = 8;
				_blockSizeTable[PIXELFORMAT_ETC2_RGB] = 8;
				_blockSizeTable[PIXELFORMAT_PVRTC_2BPP_RGB_1] = 8;
				_blockSizeTable[PIXELFORMAT_PVRTC_2BPP_RGBA_1] = 8;
				_blockSizeTable[PIXELFORMAT_PVRTC_4BPP_RGB_1] = 8;
				_blockSizeTable[PIXELFORMAT_PVRTC_4BPP_RGBA_1] = 8;
				_blockSizeTable[PIXELFORMAT_DXT1] = 8;
				_blockSizeTable[PIXELFORMAT_ATC_RGB] = 8;
				_blockSizeTable[PIXELFORMAT_ETC2_RGBA] = 16;
				_blockSizeTable[PIXELFORMAT_DXT3] = 16;
				_blockSizeTable[PIXELFORMAT_DXT5] = 16;
				_blockSizeTable[PIXELFORMAT_ASTC_4x4] = 16;
				_blockSizeTable[PIXELFORMAT_ATC_RGBA] = 16;
			}
			var pixelSize = _pixelSizeTable.hasOwnProperty(format) ? _pixelSizeTable[format] : 0;
			var blockSize = _blockSizeTable.hasOwnProperty(format) ? _blockSizeTable[format] : 0;
			var result = 0;
			while (1) {
				if (pixelSize > 0) {
					result += width * height * depth * pixelSize;
				} else {
					var blockWidth = Math.floor((width + 3) / 4);
					var blockHeight = Math.floor((height + 3) / 4);
					var blockDepth = Math.floor((depth + 3) / 4);
					if (format === PIXELFORMAT_PVRTC_2BPP_RGB_1 ||
						format === PIXELFORMAT_PVRTC_2BPP_RGBA_1) {
						blockWidth = Math.floor(blockWidth / 2, 1);
					}
					result += blockWidth * blockHeight * blockDepth * blockSize;
				}
				if (!mipmaps || ((width === 1) && (height === 1) && (depth === 1))) {
					break;
				}
				width = Math.max(Math.floor(width / 2), 1);
				height = Math.max(Math.floor(height / 2), 1);
				depth = Math.max(Math.floor(depth / 2), 1);
			}
			return result * (cubemap ? 6 : 1);
		}
	});
	Object.assign(Texture.prototype, {
		destroy: function () {
			if (this.device) {
				this.device.destroyTexture(this);
			}
			this.device = null;
			this._levels = null;
		},
		dirtyAll: function () {
			this._levelsUpdated = this._cubemap ? [[true, true, true, true, true, true]] : [true];
			this._needsUpload = true;
			this._needsMipmapsUpload = this._mipmaps;
			this._mipmapsUploaded = false;
			this._parameterFlags = 255;
		},
		lock: function (options) {
			options = options || { level: 0, face: 0, mode: TEXTURELOCK_WRITE };
			if (options.level === undefined) {
				options.level = 0;
			}
			if (options.face === undefined) {
				options.face = 0;
			}
			if (options.mode === undefined) {
				options.mode = TEXTURELOCK_WRITE;
			}
			this._lockedLevel = options.level;
			if (this._levels[options.level] === null) {
				switch (this._format) {
					case PIXELFORMAT_A8:
					case PIXELFORMAT_L8:
						this._levels[options.level] = new Uint8Array(this._width * this._height * this._depth);
						break;
					case PIXELFORMAT_L8_A8:
						this._levels[options.level] = new Uint8Array(this._width * this._height *  this._depth * 2);
						break;
					case PIXELFORMAT_R5_G6_B5:
					case PIXELFORMAT_R5_G5_B5_A1:
					case PIXELFORMAT_R4_G4_B4_A4:
						this._levels[options.level] = new Uint16Array(this._width * this._height * this._depth);
						break;
					case PIXELFORMAT_R8_G8_B8:
						this._levels[options.level] = new Uint8Array(this._width * this._height * this._depth * 3);
						break;
					case PIXELFORMAT_R8_G8_B8_A8:
						this._levels[options.level] = new Uint8Array(this._width * this._height * this._depth * 4);
						break;
					case PIXELFORMAT_DXT1:
						this._levels[options.level] = new Uint8Array(Math.floor((this._width + 3) / 4) * Math.floor((this._height + 3) / 4) * 8 * this._depth);
						break;
					case PIXELFORMAT_DXT3:
					case PIXELFORMAT_DXT5:
						this._levels[options.level] = new Uint8Array(Math.floor((this._width + 3) / 4) * Math.floor((this._height + 3) / 4) * 16 * this._depth);
						break;
					case PIXELFORMAT_RGB16F:
						this._levels[options.level] = new Uint16Array(this._width * this._height * this._depth * 3);
						break;
					case PIXELFORMAT_RGB32F:
						this._levels[options.level] = new Float32Array(this._width * this._height * this._depth * 3);
						break;
					case PIXELFORMAT_RGBA16F:
						this._levels[options.level] = new Uint16Array(this._width * this._height * this._depth * 4);
						break;
					case PIXELFORMAT_RGBA32F:
						this._levels[options.level] = new Float32Array(this._width * this._height * this._depth * 4);
						break;
				}
			}
			return this._levels[options.level];
		},
		setSource: function (source, mipLevel) {
			var i;
			var invalid = false;
			var width, height;
			mipLevel = mipLevel || 0;
			if (this._cubemap) {
				if (source[0]) {
					width = source[0].width || 0;
					height = source[0].height || 0;
					for (i = 0; i < 6; i++) {
						var face = source[i];
						if (!face ||
							face.width !== width ||
							face.height !== height ||
							!this.device._isBrowserInterface(face)) {
							invalid = true;
							break;
						}
					}
				} else {
					invalid = true;
				}
				if (!invalid) {
					for (i = 0; i < 6; i++) {
						if (this._levels[mipLevel][i] !== source[i])
							this._levelsUpdated[mipLevel][i] = true;
					}
				}
			} else {
				if (!this.device._isBrowserInterface(source))
					invalid = true;
				if (!invalid) {
					if (source !== this._levels[mipLevel])
						this._levelsUpdated[mipLevel] = true;
					width = source.width;
					height = source.height;
				}
			}
			if (invalid) {
				this._width = 4;
				this._height = 4;
				if (this._cubemap) {
					for (i = 0; i < 6; i++) {
						this._levels[mipLevel][i] = null;
						this._levelsUpdated[mipLevel][i] = true;
					}
				} else {
					this._levels[mipLevel] = null;
					this._levelsUpdated[mipLevel] = true;
				}
			} else {
				if (mipLevel === 0) {
					this._width = width;
					this._height = height;
				}
				this._levels[mipLevel] = source;
			}
			if (this._invalid !== invalid || !invalid) {
				this._invalid = invalid;
				this.upload();
			}
		},
		getSource: function (mipLevel) {
			mipLevel = mipLevel || 0;
			return this._levels[mipLevel];
		},
		unlock: function () {
			this.upload();
			this._lockedLevel = -1;
		},
		upload: function () {
			this._needsUpload = true;
			this._needsMipmapsUpload = this._mipmaps;
		},
		getDds: function () {
			if (this.format !== PIXELFORMAT_R8_G8_B8_A8)
				console.error("This format is not implemented yet");
			var fsize = 128;
			var i = 0;
			var j;
			var face;
			while (this._levels[i]) {
				var mipSize;
				if (!this.cubemap) {
					mipSize = this._levels[i].length;
					if (!mipSize) {
						console.error("No byte array for mip " + i);
						return;
					}
					fsize += mipSize;
				} else {
					for (face = 0; face < 6; face++) {
						if (!this._levels[i][face]) {
							console.error('No level data for mip ' + i + ', face ' + face);
							return;
						}
						mipSize = this._levels[i][face].length;
						if (!mipSize) {
							console.error("No byte array for mip " + i + ", face " + face);
							return;
						}
						fsize += mipSize;
					}
				}
				fsize += this._levels[i].length;
				i++;
			}
			var buff = new ArrayBuffer(fsize);
			var header = new Uint32Array(buff, 0, 128 / 4);
			var DDS_MAGIC = 542327876;
			var DDS_HEADER_SIZE = 124;
			var DDS_FLAGS_REQUIRED = 0x01 | 0x02 | 0x04 | 0x1000 | 0x80000;
			var DDS_FLAGS_MIPMAP = 0x20000;
			var DDS_PIXELFORMAT_SIZE = 32;
			var DDS_PIXELFLAGS_RGBA8 = 0x01 | 0x40;
			var DDS_CAPS_REQUIRED = 0x1000;
			var DDS_CAPS_MIPMAP = 0x400000;
			var DDS_CAPS_COMPLEX = 0x8;
			var DDS_CAPS2_CUBEMAP = 0x200 | 0x400 | 0x800 | 0x1000 | 0x2000 | 0x4000 | 0x8000;
			var flags = DDS_FLAGS_REQUIRED;
			if (this._levels.length > 1) flags |= DDS_FLAGS_MIPMAP;
			var caps = DDS_CAPS_REQUIRED;
			if (this._levels.length > 1) caps |= DDS_CAPS_MIPMAP;
			if (this._levels.length > 1 || this.cubemap) caps |= DDS_CAPS_COMPLEX;
			var caps2 = this.cubemap ? DDS_CAPS2_CUBEMAP : 0;
			header[0] = DDS_MAGIC;
			header[1] = DDS_HEADER_SIZE;
			header[2] = flags;
			header[3] = this.height;
			header[4] = this.width;
			header[5] = this.width * this.height * 4;
			header[6] = 0;
			header[7] = this._levels.length;
			for (i = 0; i < 11; i++) header[8 + i] = 0;
			header[19] = DDS_PIXELFORMAT_SIZE;
			header[20] = DDS_PIXELFLAGS_RGBA8;
			header[21] = 0;
			header[22] = 32;
			header[23] = 0x00FF0000;
			header[24] = 0x0000FF00;
			header[25] = 0x000000FF;
			header[26] = 0xFF000000;
			header[27] = caps;
			header[28] = caps2;
			header[29] = 0;
			header[30] = 0;
			header[31] = 0;
			var offset = 128;
			var level, mip;
			if (!this.cubemap) {
				for (i = 0; i < this._levels.length; i++) {
					level = this._levels[i];
					mip = new Uint8Array(buff, offset, level.length);
					for (j = 0; j < level.length; j++) mip[j] = level[j];
					offset += level.length;
				}
			} else {
				for (face = 0; face < 6; face++) {
					for (i = 0; i < this._levels.length; i++) {
						level = this._levels[i][face];
						mip = new Uint8Array(buff, offset, level.length);
						for (j = 0; j < level.length; j++) mip[j] = level[j];
						offset += level.length;
					}
				}
			}
			return buff;
		}
	});

	var dpMult = 2.0;
	function paraboloidFromCubemap(device, sourceCubemap, fixSeamsAmount, dontFlipX) {
		var seamsCode = sourceCubemap.fixCubemapSeams ? shaderChunks.fixCubemapSeamsStretchPS : shaderChunks.fixCubemapSeamsNonePS;
		var shader = createShaderFromCode(device,
										  shaderChunks.fullscreenQuadVS,
										  seamsCode + shaderChunks.genParaboloidPS,
										  "genParaboloid");
		var constantTexSource = device.scope.resolve("source");
		var constantParams = device.scope.resolve("params");
		var params = new Vec4();
		var size = sourceCubemap.width;
		var format = sourceCubemap.format;
		size = Math.max(size, 8) * dpMult;
		var tex = new Texture(device, {
			type: sourceCubemap.type,
			format: format,
			width: size * 2,
			height: size,
			mipmaps: false
		});
		tex.name = 'paraboloid';
		var targ = new RenderTarget(device, tex, {
			depth: false
		});
		params.x = fixSeamsAmount;
		params.y = dontFlipX ? -1.0 : 1.0;
		constantTexSource.setValue(sourceCubemap);
		constantParams.setValue(params.data);
		drawQuadWithShader(device, targ, shader);
		return tex;
	}
	function getDpAtlasRect(rect, mip) {
		rect.x = math.clamp(mip - 2.0, 0, 1) * 0.5;
		var t = mip - rect.x * 6.0;
		var i = 1.0 - rect.x;
		rect.y = Math.min(t * 0.5, 0.75) * i + rect.x;
		rect.z = (1.0 - math.clamp(t, 0, 1) * 0.5) * i;
		rect.w = rect.z * 0.5;
		return 1.0 / rect.z;
	}
	function generateDpAtlas(device, sixCubemaps, dontFlipX) {
		var dp, rect;
		rect = new Vec4();
		var params = new Vec4();
		var size = sixCubemaps[0].width * 2 * dpMult;
		var shader = createShaderFromCode(device,
										  shaderChunks.fullscreenQuadVS,
										  shaderChunks.dpAtlasQuadPS,
										  "dpAtlasQuad");
		var constantTexSource = device.scope.resolve("source");
		var constantParams = device.scope.resolve("params");
		var tex = new Texture(device, {
			type: sixCubemaps[0].type,
			format: sixCubemaps[0].format,
			width: size,
			height: size,
			mipmaps: false
		});
		tex.name = 'paraboloid';
		var targ = new RenderTarget(device, tex, {
			depth: false
		});
		var borderSize = 2;
		var mip0Width = size;
		var scaleFactor = (mip0Width + borderSize) / mip0Width - 1;
		var scaleAmount;
		for (var i = 0; i < 6; i++) {
			dp = paraboloidFromCubemap(device, sixCubemaps[i], i, dontFlipX);
			constantTexSource.setValue(dp);
			scaleAmount = getDpAtlasRect(rect, i);
			params.x = scaleAmount * scaleFactor;
			params.y = params.x * 2;
			params.x += 1;
			params.y += 1;
			constantParams.setValue(params.data);
			rect.x *= size;
			rect.y *= size;
			rect.z *= size;
			rect.w *= size;
			drawQuadWithShader(device, targ, shader, rect);
		}
		return tex;
	}

	function IndexBuffer(graphicsDevice, format, numIndices, usage, initialData) {
		this.usage = usage || BUFFER_STATIC;
		this.format = format;
		this.numIndices = numIndices;
		this.device = graphicsDevice;
		var gl = this.device.gl;
		var bytesPerIndex;
		if (format === INDEXFORMAT_UINT8) {
			bytesPerIndex = 1;
			this.glFormat = gl.UNSIGNED_BYTE;
		} else if (format === INDEXFORMAT_UINT16) {
			bytesPerIndex = 2;
			this.glFormat = gl.UNSIGNED_SHORT;
		} else if (format === INDEXFORMAT_UINT32) {
			bytesPerIndex = 4;
			this.glFormat = gl.UNSIGNED_INT;
		}
		this.bytesPerIndex = bytesPerIndex;
		this.numBytes = this.numIndices * bytesPerIndex;
		if (initialData) {
			this.setData(initialData);
		} else {
			this.storage = new ArrayBuffer(this.numBytes);
		}
		graphicsDevice._vram.ib += this.numBytes;
		this.device.buffers.push(this);
	}
	Object.assign(IndexBuffer.prototype, {
		destroy: function () {
			var device = this.device;
			var idx = device.buffers.indexOf(this);
			if (idx !== -1) {
				device.buffers.splice(idx, 1);
			}
			if (this.bufferId) {
				var gl = this.device.gl;
				gl.deleteBuffer(this.bufferId);
				this.device._vram.ib -= this.storage.byteLength;
				this.bufferId = null;
				if (this.device.indexBuffer === this) {
					this.device.indexBuffer = null;
				}
			}
		},
		getFormat: function () {
			return this.format;
		},
		getNumIndices: function () {
			return this.numIndices;
		},
		lock: function () {
			return this.storage;
		},
		unlock: function () {
			var gl = this.device.gl;
			if (!this.bufferId) {
				this.bufferId = gl.createBuffer();
			}
			var glUsage;
			switch (this.usage) {
				case BUFFER_STATIC:
					glUsage = gl.STATIC_DRAW;
					break;
				case BUFFER_DYNAMIC:
					glUsage = gl.DYNAMIC_DRAW;
					break;
				case BUFFER_STREAM:
					glUsage = gl.STREAM_DRAW;
					break;
				case BUFFER_GPUDYNAMIC:
					if (this.device.webgl2) {
						glUsage = gl.DYNAMIC_COPY;
					} else {
						glUsage = gl.STATIC_DRAW;
					}
					break;
			}
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.bufferId);
			gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.storage, glUsage);
		},
		setData: function (data) {
			if (data.byteLength !== this.numBytes) {
				return false;
			}
			this.storage = data;
			this.unlock();
			return true;
		},
		_lockTypedArray: function () {
			var lock = this.lock();
			var indices = this.format === INDEXFORMAT_UINT32 ? new Uint32Array(lock) :
				(this.format === INDEXFORMAT_UINT16 ? new Uint16Array(lock) : new Uint8Array(lock) );
			return indices;
		},
		writeData: function (data, count) {
			var indices = this._lockTypedArray();
			if (data.length > count) {
				if (ArrayBuffer.isView(data)) {
					data = data.subarray(0, count);
					indices.set(data);
				} else {
					var i;
					for (i = 0; i < count; i++)
						indices[i] = data[i];
				}
			} else {
				indices.set(data);
			}
			this.unlock();
		},
		readData: function (data) {
			var indices = this._lockTypedArray();
			var count = this.numIndices;
			if (ArrayBuffer.isView(data)) {
				data.set(indices);
			} else {
				data.length = 0;
				var i;
				for (i = 0; i < count; i++)
					data[i] = indices[i];
			}
			return count;
		}
	});

	var id$1 = 0;
	function GeometryData() {
		this.initDefaults();
	}
	Object.assign(GeometryData.prototype, {
		initDefaults: function () {
			this.recreate = false;
			this.verticesUsage = BUFFER_STATIC;
			this.indicesUsage = BUFFER_STATIC;
			this.maxVertices = 0;
			this.maxIndices = 0;
			this.vertexCount = 0;
			this.indexCount = 0;
			this.vertexStreamsUpdated = false;
			this.indexStreamUpdated = false;
			this.vertexStreamDictionary = {};
			this.indices = null;
		},
		_validateVertexCount: function (count, semantic) {
		},
		_changeVertexCount: function (count, semantic) {
			if (!this.vertexCount) {
				this.vertexCount = count;
			} else {
				this._validateVertexCount(count, semantic);
			}
		}
	});
	Object.defineProperties(GeometryData, {
		DEFAULT_COMPONENTS_POSITION: { value: 3 },
		DEFAULT_COMPONENTS_NORMAL: { value: 3 },
		DEFAULT_COMPONENTS_UV: { value: 2 },
		DEFAULT_COMPONENTS_COLORS: { value: 4 }
	});
	function GeometryVertexStream(data, componentCount, dataType, dataTypeNormalize) {
		this.data = data;
		this.componentCount = componentCount;
		this.dataType = dataType;
		this.dataTypeNormalize = dataTypeNormalize;
	}
	function Mesh(graphicsDevice) {
		this._refCount = 0;
		this.id = id$1++;
		this.device = graphicsDevice || Application.getApplication().graphicsDevice;
		this.vertexBuffer = null;
		this.indexBuffer = [null];
		this.primitive = [{
			type: 0,
			base: 0,
			count: 0
		}];
		this.skin = null;
		this.morph = null;
		this._geometryData = null;
		this._aabb = new BoundingBox();
		this.boneAabb = null;
	}
	Object.defineProperties(Mesh.prototype, {
		'aabb': {
			get: function () {
				return this._aabb;
			},
			set: function (aabb) {
				this._aabb = aabb;
			}
		},
		'refCount': {
			get: function () {
				return this._refCount;
			}
		}
	});
	Object.assign(Mesh.prototype, {
		incReference: function () {
			this._refCount++;
		},
		decReference: function () {
			this._refCount--;
		},
		destroy: function () {
			if (this.vertexBuffer) {
				this.vertexBuffer.destroy();
				this.vertexBuffer = null;
			}
			var j, ib;
			for (j = 0; j < this.indexBuffer.length; j++) {
				ib = this.indexBuffer[j];
				if (ib)
					ib.destroy();
			}
			this.indexBuffer.length = 0;
			this._geometryData = null;
		},
		_initBoneAabbs: function (morphTargets) {
			this.boneAabb = [];
			this.boneUsed = [];
			var numVerts = this.vertexBuffer.numVertices;
			var i, j, k, l;
			var x, y, z;
			var bMax, bMin;
			var boneMin = [];
			var boneMax = [];
			var boneUsed = this.boneUsed;
			var numBones = this.skin.boneNames.length;
			var aabb;
			var boneWeight, boneIndex;
			var minMorphX, minMorphY, minMorphZ;
			var maxMorphX, maxMorphY, maxMorphZ;
			var dx, dy, dz;
			var target;
			for (i = 0; i < numBones; i++) {
				boneMin[i] = new Vec3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
				boneMax[i] = new Vec3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
			}
			var iterator = new VertexIterator(this.vertexBuffer);
			var posElement = iterator.element[SEMANTIC_POSITION];
			var weightsElement = iterator.element[SEMANTIC_BLENDWEIGHT];
			var indicesElement = iterator.element[SEMANTIC_BLENDINDICES];
			for (j = 0; j < numVerts; j++) {
				for (k = 0; k < 4; k++) {
					boneWeight = weightsElement.array[weightsElement.index + k];
					if (boneWeight > 0) {
						boneIndex = indicesElement.array[indicesElement.index + k];
						boneUsed[boneIndex] = true;
						x = posElement.array[posElement.index];
						y = posElement.array[posElement.index + 1];
						z = posElement.array[posElement.index + 2];
						bMax = boneMax[boneIndex];
						bMin = boneMin[boneIndex];
						if (bMin.x > x) bMin.x = x;
						if (bMin.y > y) bMin.y = y;
						if (bMin.z > z) bMin.z = z;
						if (bMax.x < x) bMax.x = x;
						if (bMax.y < y) bMax.y = y;
						if (bMax.z < z) bMax.z = z;
						if (morphTargets) {
							minMorphX = maxMorphX = x;
							minMorphY = maxMorphY = y;
							minMorphZ = maxMorphZ = z;
							for (l = 0; l < morphTargets.length; l++) {
								target = morphTargets[l];
								dx = target.deltaPositions[j * 3];
								dy = target.deltaPositions[j * 3 + 1];
								dz = target.deltaPositions[j * 3 + 2];
								if (dx < 0) {
									minMorphX += dx;
								} else {
									maxMorphX += dx;
								}
								if (dy < 0) {
									minMorphY += dy;
								} else {
									maxMorphY += dy;
								}
								if (dz < 0) {
									minMorphZ += dz;
								} else {
									maxMorphZ += dz;
								}
							}
							if (bMin.x > minMorphX) bMin.x = minMorphX;
							if (bMin.y > minMorphY) bMin.y = minMorphY;
							if (bMin.z > minMorphZ) bMin.z = minMorphZ;
							if (bMax.x < maxMorphX) bMax.x = maxMorphX;
							if (bMax.y < maxMorphY) bMax.y = maxMorphY;
							if (bMax.z < maxMorphZ) bMax.z = maxMorphZ;
						}
					}
				}
				iterator.next();
			}
			for (i = 0; i < numBones; i++) {
				aabb = new BoundingBox();
				aabb.setMinMax(boneMin[i], boneMax[i]);
				this.boneAabb.push(aabb);
			}
		},
		_initGeometryData: function () {
			if (!this._geometryData) {
				this._geometryData = new GeometryData();
				if (this.vertexBuffer) {
					this._geometryData.vertexCount = this.vertexBuffer.numVertices;
					this._geometryData.maxVertices = this.vertexBuffer.numVertices;
				}
				if (this.indexBuffer.length > 0 && this.indexBuffer[0]) {
					this._geometryData.indexCount = this.indexBuffer[0].numIndices;
					this._geometryData.maxIndices = this.indexBuffer[0].numIndices;
				}
			}
		},
		clear: function (verticesDynamic, indicesDynamic, maxVertices, maxIndices) {
			this._initGeometryData();
			this._geometryData.initDefaults();
			this._geometryData.recreate = true;
			this._geometryData.maxVertices = maxVertices || 0;
			this._geometryData.maxIndices = maxIndices || 0;
			this._geometryData.verticesUsage = verticesDynamic ? BUFFER_STATIC : BUFFER_DYNAMIC;
			this._geometryData.indicesUsage = indicesDynamic ? BUFFER_STATIC : BUFFER_DYNAMIC;
		},
		setVertexStream: function (semantic, data, componentCount, numVertices, dataType, dataTypeNormalize) {
			this._initGeometryData();
			var vertexCount = numVertices || data.length / componentCount;
			this._geometryData._changeVertexCount(vertexCount, semantic);
			this._geometryData.vertexStreamsUpdated = true;
			this._geometryData.vertexStreamDictionary[semantic] = new GeometryVertexStream(
				data,
				componentCount,
				dataType || TYPE_FLOAT32,
				dataTypeNormalize || false
			);
		},
		getVertexStream: function (semantic, data) {
			var count = 0;
			var done = false;
			if (this._geometryData) {
				var stream = this._geometryData.vertexStreamDictionary[semantic];
				if (stream) {
					done = true;
					count = this._geometryData.vertexCount;
					if (ArrayBuffer.isView(data)) {
						data.set(stream.data);
					} else {
						data.length = 0;
						data.push(stream.data);
					}
				}
			}
			if (!done) {
				if (this.vertexBuffer) {
					var iterator = new VertexIterator(this.vertexBuffer);
					count = iterator.readData(semantic, data);
				}
			}
			return count;
		},
		setPositions: function (positions, componentCount, numVertices) {
			this.setVertexStream(SEMANTIC_POSITION, positions, componentCount || GeometryData.DEFAULT_COMPONENTS_POSITION, numVertices, TYPE_FLOAT32, false);
		},
		setNormals: function (normals, componentCount, numVertices) {
			this.setVertexStream(SEMANTIC_NORMAL, normals, componentCount || GeometryData.DEFAULT_COMPONENTS_NORMAL, numVertices, TYPE_FLOAT32, false);
		},
		setUvs: function (channel, uvs, componentCount, numVertices) {
			this.setVertexStream(SEMANTIC_TEXCOORD + channel, uvs, componentCount || GeometryData.DEFAULT_COMPONENTS_UV, numVertices, TYPE_FLOAT32, false);
		},
		setColors: function (colors, componentCount, numVertices) {
			this.setVertexStream(SEMANTIC_COLOR, colors, componentCount || GeometryData.DEFAULT_COMPONENTS_COLORS, numVertices, TYPE_FLOAT32, false);
		},
		setColors32: function (colors, numVertices) {
			this.setVertexStream(SEMANTIC_COLOR, colors, GeometryData.DEFAULT_COMPONENTS_COLORS, numVertices, TYPE_UINT8, true);
		},
		setIndices: function (indices, numIndices) {
			this._initGeometryData();
			this._geometryData.indexStreamUpdated = true;
			this._geometryData.indices = indices;
			this._geometryData.indexCount = numIndices || indices.length;
		},
		getPositions: function (positions) {
			return this.getVertexStream(SEMANTIC_POSITION, positions);
		},
		getNormals: function (normals) {
			return this.getVertexStream(SEMANTIC_NORMAL, normals);
		},
		getUvs: function (channel, uvs) {
			return this.getVertexStream(SEMANTIC_TEXCOORD + channel, uvs);
		},
		getColors: function (colors) {
			return this.getVertexStream(SEMANTIC_COLOR, colors);
		},
		getIndices: function (indices) {
			var count = 0;
			if (this._geometryData && this._geometryData.indices) {
				var streamIndices = this._geometryData.indices;
				count = this._geometryData.indexCount;
				if (ArrayBuffer.isView(indices)) {
					indices.set(streamIndices);
				} else {
					indices.length = 0;
					indices.push(streamIndices);
				}
			} else {
				if (this.indexBuffer.length > 0 && this.indexBuffer[0]) {
					var indexBuffer = this.indexBuffer[0];
					count = indexBuffer.readData(indices);
				}
			}
			return count;
		},
		update: function (primitiveType, updateBoundingBox) {
			if (this._geometryData) {
				if (updateBoundingBox || updateBoundingBox === undefined) {
					var stream = this._geometryData.vertexStreamDictionary[SEMANTIC_POSITION];
					if (stream) {
						if (stream.componentCount == 3) {
							this._aabb.compute(stream.data, this._geometryData.vertexCount);
						}
					}
				}
				var destroyVB = this._geometryData.recreate;
				if (this._geometryData.vertexCount > this._geometryData.maxVertices) {
					destroyVB = true;
					this._geometryData.maxVertices = this._geometryData.vertexCount;
				}
				if (destroyVB) {
					if (this.vertexBuffer) {
						this.vertexBuffer.destroy();
						this.vertexBuffer = null;
					}
				}
				var destroyIB = this._geometryData.recreate;
				if (this._geometryData.indexCount > this._geometryData.maxIndices) {
					destroyIB = true;
					this._geometryData.maxIndices = this._geometryData.indexCount;
				}
				if (destroyIB) {
					if (this.indexBuffer.length > 0 && this.indexBuffer[0]) {
						this.indexBuffer[0].destroy();
						this.indexBuffer[0] = null;
					}
				}
				if (this._geometryData.vertexStreamsUpdated) {
					this._updateVertexBuffer();
				}
				if (this._geometryData.indexStreamUpdated) {
					this._updateIndexBuffer();
				}
				this.primitive[0].type = (primitiveType === undefined ? PRIMITIVE_TRIANGLES : primitiveType);
				if (this.indexBuffer.length > 0 && this.indexBuffer[0]) {
					if (this._geometryData.indexStreamUpdated) {
						this.primitive[0].count = this._geometryData.indexCount;
						this.primitive[0].indexed = true;
					}
				} else {
					if (this._geometryData.vertexStreamsUpdated) {
						this.primitive[0].count = this._geometryData.vertexCount;
						this.primitive[0].indexed = false;
					}
				}
				this._geometryData.vertexCount = 0;
				this._geometryData.indexCount = 0;
				this._geometryData.vertexStreamsUpdated = false;
				this._geometryData.indexStreamUpdated = false;
				this._geometryData.recreate = false;
			}
		},
		_buildVertexFormat: function (vertexCount) {
			var vertexDesc = [];
			for (var semantic in this._geometryData.vertexStreamDictionary) {
				var stream = this._geometryData.vertexStreamDictionary[semantic];
				vertexDesc.push({
					semantic: semantic,
					components: stream.componentCount,
					type: stream.dataType,
					normalize: stream.dataTypeNormalize
				});
			}
			return new VertexFormat(this.device, vertexDesc, vertexCount);
		},
		_updateVertexBuffer: function () {
			if (!this.vertexBuffer) {
				var allocateVertexCount = this._geometryData.maxVertices;
				var format = this._buildVertexFormat(allocateVertexCount);
				this.vertexBuffer = new VertexBuffer(this.device, format, allocateVertexCount, this._geometryData.verticesUsage);
			}
			var iterator = new VertexIterator(this.vertexBuffer);
			var numVertices = this._geometryData.vertexCount;
			for (var semantic in this._geometryData.vertexStreamDictionary) {
				var stream = this._geometryData.vertexStreamDictionary[semantic];
				iterator.writeData(semantic, stream.data, numVertices);
				delete this._geometryData.vertexStreamDictionary[semantic];
			}
			iterator.end();
		},
		_updateIndexBuffer: function () {
			if (this.indexBuffer.length <= 0 || !this.indexBuffer[0]) {
				var createFormat = this._geometryData.maxVertices > 0xffff ? INDEXFORMAT_UINT32 : INDEXFORMAT_UINT16;
				this.indexBuffer[0] = new IndexBuffer(this.device, createFormat, this._geometryData.maxIndices, this._geometryData.indicesUsage);
			}
			var srcIndices = this._geometryData.indices;
			if (srcIndices) {
				var indexBuffer = this.indexBuffer[0];
				indexBuffer.writeData(srcIndices, this._geometryData.indexCount);
				this._geometryData.indices = null;
			}
		},
		generateWireframe: function () {
			var typedArray = function (indexBuffer) {
				switch (indexBuffer.format) {
					case INDEXFORMAT_UINT8:
						return new Uint8Array(indexBuffer.storage);
					case INDEXFORMAT_UINT16:
						return new Uint16Array(indexBuffer.storage);
					case INDEXFORMAT_UINT32:
						return new Uint32Array(indexBuffer.storage);
					default:
						return null;
				}
			};
			var lines = [];
			var format;
			if (this.indexBuffer.length > 0 && this.indexBuffer[0]) {
				var offsets = [[0, 1], [1, 2], [2, 0]];
				var base = this.primitive[RENDERSTYLE_SOLID].base;
				var count = this.primitive[RENDERSTYLE_SOLID].count;
				var indexBuffer = this.indexBuffer[RENDERSTYLE_SOLID];
				var srcIndices = typedArray(indexBuffer);
				var uniqueLineIndices = {};
				for (var j = base; j < base + count; j += 3) {
					for (var k = 0; k < 3; k++) {
						var i1 = srcIndices[j + offsets[k][0]];
						var i2 = srcIndices[j + offsets[k][1]];
						var line = (i1 > i2) ? ((i2 << 16) | i1) : ((i1 << 16) | i2);
						if (uniqueLineIndices[line] === undefined) {
							uniqueLineIndices[line] = 0;
							lines.push(i1, i2);
						}
					}
				}
				format = indexBuffer.format;
			} else {
				for (var i = 0; i < this.vertexBuffer.numVertices; i += 3) {
					lines.push(i, i + 1, i + 1, i + 2, i + 2, i);
				}
				format = lines.length > 65535 ? INDEXFORMAT_UINT32 : INDEXFORMAT_UINT16;
			}
			var wireBuffer = new IndexBuffer(this.vertexBuffer.device, format, lines.length);
			var dstIndices = typedArray(wireBuffer);
			dstIndices.set(lines);
			wireBuffer.unlock();
			this.primitive[RENDERSTYLE_WIREFRAME] = {
				type: PRIMITIVE_LINES,
				base: 0,
				count: lines.length,
				indexed: true
			};
			this.indexBuffer[RENDERSTYLE_WIREFRAME] = wireBuffer;
		}
	});

	var _tmpAabb = new BoundingBox();
	var _tempBoneAabb = new BoundingBox();
	function MeshInstance(node, mesh, material) {
		this._key = [0, 0];
		this._shader = [null, null, null];
		this.isStatic = false;
		this._staticLightList = null;
		this._staticSource = null;
		this.node = node;
		this._mesh = mesh;
		mesh.incReference();
		this.material = material;
		this._shaderDefs = MASK_DYNAMIC << 16;
		this._shaderDefs |= mesh.vertexBuffer.format.hasUv0 ? SHADERDEF_UV0 : 0;
		this._shaderDefs |= mesh.vertexBuffer.format.hasUv1 ? SHADERDEF_UV1 : 0;
		this._shaderDefs |= mesh.vertexBuffer.format.hasColor ? SHADERDEF_VCOLOR : 0;
		this._shaderDefs |= mesh.vertexBuffer.format.hasTangents ? SHADERDEF_TANGENTS : 0;
		this._lightHash = 0;
		this.visible = true;
		this.layer = LAYER_WORLD;
		this.renderStyle = RENDERSTYLE_SOLID;
		this.castShadow = false;
		this._receiveShadow = true;
		this._screenSpace = false;
		this._noDepthDrawGl1 = false;
		this.cull = true;
		this.pick = true;
		this._updateAabb = true;
		this._updateAabbFunc = null;
		this._calculateSortDistance = null;
		this.updateKey();
		this._skinInstance = null;
		this._morphInstance = null;
		this.instancingData = null;
		this.aabb = new BoundingBox();
		this._aabbVer = -1;
		this.drawOrder = 0;
		this.visibleThisFrame = 0;
		this.isVisibleFunc = null;
		this.parameters = {};
		this.stencilFront = null;
		this.stencilBack = null;
		this.flipFaces = false;
	}
	Object.defineProperty(MeshInstance.prototype, 'mesh', {
		get: function () {
			return this._mesh;
		},
		set: function (mesh) {
			if (this._mesh) this._mesh.decReference();
			this._mesh = mesh;
			if (mesh) mesh.incReference();
		}
	});
	Object.defineProperty(MeshInstance.prototype, 'aabb', {
		get: function () {
			var i;
			if (!this._updateAabb) {
				return this._aabb;
			}
			if (this._updateAabbFunc) {
				return this._updateAabbFunc(this._aabb);
			}
			if (this.skinInstance) {
				if (!this.mesh.boneAabb) {
					var morphTargets = this._morphInstance ? this._morphInstance.morph._targets : null;
					this.mesh._initBoneAabbs(morphTargets);
				}
				var boneUsed = this.mesh.boneUsed;
				var rootNodeTransform = this.node.getWorldTransform();
				var first = true;
				for (i = 0; i < this.mesh.boneAabb.length; i++) {
					if (boneUsed[i]) {
						_tempBoneAabb.setFromTransformedAabb(this.mesh.boneAabb[i], this.skinInstance.matrices[i]);
						if (first) {
							first = false;
							_tmpAabb.center.copy(_tempBoneAabb.center);
							_tmpAabb.halfExtents.copy(_tempBoneAabb.halfExtents);
						} else {
							_tmpAabb.add(_tempBoneAabb);
						}
					}
				}
				this._aabb.setFromTransformedAabb(_tmpAabb, rootNodeTransform);
			} else if (this.node._aabbVer !== this._aabbVer) {
				if (this.mesh) {
					_tmpAabb.center.copy(this.mesh.aabb.center);
					_tmpAabb.halfExtents.copy(this.mesh.aabb.halfExtents);
				} else {
					_tmpAabb.center.set(0, 0, 0);
					_tmpAabb.halfExtents.set(0, 0, 0);
				}
				if (this.mesh && this.mesh.morph) {
					_tmpAabb._expand(this.mesh.morph.aabb.getMin(), this.mesh.morph.aabb.getMax());
				}
				this._aabb.setFromTransformedAabb(_tmpAabb, this.node.getWorldTransform());
				this._aabbVer = this.node._aabbVer;
			}
			return this._aabb;
		},
		set: function (aabb) {
			this._aabb = aabb;
		}
	});
	Object.defineProperty(MeshInstance.prototype, 'material', {
		get: function () {
			return this._material;
		},
		set: function (material) {
			var i;
			for (i = 0; i < this._shader.length; i++) {
				this._shader[i] = null;
			}
			if (this._material) {
				var meshInstances = this._material.meshInstances;
				i = meshInstances.indexOf(this);
				if (i !== -1) {
					meshInstances.splice(i, 1);
				}
			}
			var prevMat = this._material;
			this._material = material;
			if (this._material) {
				this._material.meshInstances.push(this);
				this.updateKey();
				var prevBlend = prevMat && (prevMat.blendType !== BLEND_NONE);
				var thisBlend = this._material.blendType !== BLEND_NONE;
				if (prevBlend !== thisBlend) {
					var scene = this._material._scene;
					if (!scene && prevMat && prevMat._scene) scene = prevMat._scene;
					if (scene) {
						scene.layers._dirtyBlend = true;
					} else {
						this._material._dirtyBlend = true;
					}
				}
			}
		}
	});
	Object.defineProperty(MeshInstance.prototype, 'layer', {
		get: function () {
			return this._layer;
		},
		set: function (layer) {
			this._layer = layer;
			this.updateKey();
		}
	});
	Object.defineProperty(MeshInstance.prototype, 'calculateSortDistance', {
		get: function () {
			return this._calculateSortDistance;
		},
		set: function (calculateSortDistance) {
			this._calculateSortDistance = calculateSortDistance;
		}
	});
	Object.defineProperty(MeshInstance.prototype, 'receiveShadow', {
		get: function () {
			return this._receiveShadow;
		},
		set: function (val) {
			this._receiveShadow = val;
			this._shaderDefs = val ? (this._shaderDefs & ~SHADERDEF_NOSHADOW) : (this._shaderDefs | SHADERDEF_NOSHADOW);
			this._shader[SHADER_FORWARD] = null;
			this._shader[SHADER_FORWARDHDR] = null;
		}
	});
	Object.defineProperty(MeshInstance.prototype, 'skinInstance', {
		get: function () {
			return this._skinInstance;
		},
		set: function (val) {
			this._skinInstance = val;
			this._shaderDefs = val ? (this._shaderDefs | SHADERDEF_SKIN) : (this._shaderDefs & ~SHADERDEF_SKIN);
			for (var i = 0; i < this._shader.length; i++) {
				this._shader[i] = null;
			}
		}
	});
	Object.defineProperty(MeshInstance.prototype, 'morphInstance', {
		get: function () {
			return this._morphInstance;
		},
		set: function (val) {
			this._morphInstance = val;
			if (this._morphInstance) {
				this._morphInstance.meshInstance = this;
			}
			this._shaderDefs = (val && val.morph.useTextureMorph) ? (this._shaderDefs | SHADERDEF_MORPH_TEXTURE_BASED) : (this._shaderDefs & ~SHADERDEF_MORPH_TEXTURE_BASED);
			this._shaderDefs = (val && val.morph.morphPositions) ? (this._shaderDefs | SHADERDEF_MORPH_POSITION) : (this._shaderDefs & ~SHADERDEF_MORPH_POSITION);
			this._shaderDefs = (val && val.morph.morphNormals) ? (this._shaderDefs | SHADERDEF_MORPH_NORMAL) : (this._shaderDefs & ~SHADERDEF_MORPH_NORMAL);
			for (var i = 0; i < this._shader.length; i++) {
				this._shader[i] = null;
			}
		}
	});
	Object.defineProperty(MeshInstance.prototype, 'screenSpace', {
		get: function () {
			return this._screenSpace;
		},
		set: function (val) {
			this._screenSpace = val;
			this._shaderDefs = val ? (this._shaderDefs | SHADERDEF_SCREENSPACE) : (this._shaderDefs & ~SHADERDEF_SCREENSPACE);
			this._shader[SHADER_FORWARD] = null;
		}
	});
	Object.defineProperty(MeshInstance.prototype, 'key', {
		get: function () {
			return this._key[SORTKEY_FORWARD];
		},
		set: function (val) {
			this._key[SORTKEY_FORWARD] = val;
		}
	});
	Object.defineProperty(MeshInstance.prototype, 'mask', {
		get: function () {
			return this._shaderDefs >> 16;
		},
		set: function (val) {
			var toggles = this._shaderDefs & 0x0000FFFF;
			this._shaderDefs = toggles | (val << 16);
			this._shader[SHADER_FORWARD] = null;
			this._shader[SHADER_FORWARDHDR] = null;
		}
	});
	Object.defineProperty(MeshInstance.prototype, 'instancingCount', {
		get: function () {
			return this.instancingData ? this.instancingData.count : 0;
		},
		set: function (value) {
			if (this.instancingData)
				this.instancingData.count = value;
		}
	});
	Object.assign(MeshInstance.prototype, {
		syncAabb: function () {
		},
		updateKey: function () {
			var material = this.material;
			this._key[SORTKEY_FORWARD] = getKey(this.layer,
												(material.alphaToCoverage || material.alphaTest) ? BLEND_NORMAL : material.blendType,
												false, material.id);
		},
		setInstancing: function (vertexBuffer) {
			if (vertexBuffer) {
				this.instancingData = new InstancingData(vertexBuffer.numVertices);
				this.instancingData.vertexBuffer = vertexBuffer;
				vertexBuffer.instancing = true;
				this.cull = false;
			} else {
				this.instancingData = null;
				this.cull = true;
			}
		},
		clearParameters: function () {
			this.parameters = {};
		},
		getParameters: function () {
			return this.parameters;
		},
		getParameter: function (name) {
			return this.parameters[name];
		},
		setParameter: function (name, data, passFlags) {
			if (passFlags === undefined) passFlags = -524285;
			if (data === undefined && typeof name === 'object') {
				var uniformObject = name;
				if (uniformObject.length) {
					for (var i = 0; i < uniformObject.length; i++) {
						this.setParameter(uniformObject[i]);
					}
					return;
				}
				name = uniformObject.name;
				data = uniformObject.value;
			}
			var param = this.parameters[name];
			if (param) {
				param.data = data;
				param.passFlags = passFlags;
			} else {
				this.parameters[name] = {
					scopeId: null,
					data: data,
					passFlags: passFlags
				};
			}
		},
		deleteParameter: function (name) {
			if (this.parameters[name]) {
				delete this.parameters[name];
			}
		},
		setParameters: function () {
			for (var paramName in this.parameters) {
				var parameter = this.parameters[paramName];
				parameter.scopeId.setValue(parameter.data);
			}
		}
	});
	function Command(layer, blendType, command) {
		this._key = [];
		this._key[SORTKEY_FORWARD] = getKey(layer, blendType, true, 0);
		this.command = command;
	}
	Object.defineProperty(Command.prototype, 'key', {
		get: function () {
			return this._key[SORTKEY_FORWARD];
		},
		set: function (val) {
			this._key[SORTKEY_FORWARD] = val;
		}
	});
	function InstancingData(numObjects) {
		this.count = numObjects;
		this.vertexBuffer = null;
	}
	function getKey(layer, blendType, isCommand, materialId) {
		return ((layer & 0x0f) << 27) |
			   ((blendType === BLEND_NONE ? 1 : 0) << 26) |
			   ((isCommand ? 1 : 0) << 25) |
			   ((materialId & 0x1ffffff) << 0);
	}

	function Morph(targets, graphicsDevice) {
		this.device = graphicsDevice || Application.getApplication().graphicsDevice;
		this._targets = targets;
		if (this.device.supportsMorphTargetTexturesCore) {
			if (this.device.extTextureHalfFloat && this.device.textureHalfFloatRenderable) {
				this._renderTextureFormat = Morph.FORMAT_HALF_FLOAT;
			} else if (this.device.extTextureFloat && this.device.textureFloatRenderable) {
				this._renderTextureFormat = Morph.FORMAT_FLOAT;
			}
			if (this.device.extTextureHalfFloat && this.device.textureHalfFloatUpdatable) {
				this._textureFormat = Morph.FORMAT_HALF_FLOAT;
			} else  if (this.device.extTextureFloat) {
				this._textureFormat = Morph.FORMAT_FLOAT;
			}
			if (this._renderTextureFormat !== undefined && this._textureFormat !== undefined) {
				this._useTextureMorph = true;
			}
		}
		this._init();
		this._updateMorphFlags();
		this._calculateAabb();
	}
	Object.defineProperties(Morph, {
		FORMAT_FLOAT: { value: 0 },
		FORMAT_HALF_FLOAT: { value: 1 }
	});
	Object.defineProperties(Morph.prototype, {
		'morphPositions': {
			get: function () {
				return this._morphPositions;
			}
		},
		'morphNormals': {
			get: function () {
				return this._morphNormals;
			}
		},
		'maxActiveTargets': {
			get: function () {
				if (this._useTextureMorph)
					return this._targets.length;
				return (this._morphPositions && this._morphNormals) ? 4 : 8;
			}
		},
		'useTextureMorph': {
			get: function () {
				return this._useTextureMorph;
			}
		}
	});
	Object.assign(Morph.prototype, {
		_init: function () {
			if (this._useTextureMorph) {
				this._useTextureMorph = this._initTextureBased();
			}
			var i;
			if (!this._useTextureMorph) {
				for (i = 0; i < this._targets.length; i++) {
					this._targets[i]._initVertexBuffers(this.device);
				}
			}
			for (i = 0; i < this._targets.length; i++) {
				this._targets[i]._postInit();
			}
		},
		_initTextureBased: function () {
			var target, i, v;
			var deltaArrays = [], deltaInfos = [];
			for (i = 0; i < this._targets.length; i++) {
				target = this._targets[i];
				if (target.options.deltaPositions) {
					deltaArrays.push(target.options.deltaPositions);
					deltaInfos.push( { target: target, name: 'texturePositions' } );
				}
				if (target.options.deltaNormals) {
					deltaArrays.push(target.options.deltaNormals);
					deltaInfos.push( { target: target, name: 'textureNormals' } );
				}
			}
			var ids = [], usedDataIndices = [];
			var vertexUsed, data;
			var freeIndex = 1;
			var dataCount = deltaArrays[0].length;
			for (v = 0; v < dataCount; v += 3) {
				vertexUsed = false;
				for (i = 0; i < deltaArrays.length; i++) {
					data = deltaArrays[i];
					if (data[v] !== 0 || data[v + 1] !== 0 || data[v + 2] !== 0) {
						vertexUsed = true;
						break;
					}
				}
				if (vertexUsed) {
					ids.push(freeIndex);
					usedDataIndices.push(v / 3);
					freeIndex++;
				} else {
					ids.push(0);
				}
			}
			var maxTextureSize = Math.min(this.device.maxTextureSize, 4096);
			var morphTextureWidth = Math.ceil(Math.sqrt(freeIndex));
			morphTextureWidth = Math.min(morphTextureWidth, maxTextureSize);
			var morphTextureHeight = Math.ceil(freeIndex / morphTextureWidth);
			if (morphTextureHeight > maxTextureSize) {
				return false;
			}
			this.morphTextureWidth = morphTextureWidth;
			this.morphTextureHeight = morphTextureHeight;
			var halfFloat = false;
			var numComponents = 3;
			var float2Half = math.float2Half;
			if (this._textureFormat === Morph.FORMAT_HALF_FLOAT) {
				halfFloat = true;
				numComponents = 4;
			}
			var arraySize = this.morphTextureWidth * this.morphTextureHeight * numComponents;
			var packedDeltas = halfFloat ? new Uint16Array(arraySize) : new Float32Array(arraySize);
			for (i = 0; i < deltaArrays.length; i++) {
				data = deltaArrays[i];
				for (v = 0; v < usedDataIndices.length; v++) {
					var index = usedDataIndices[v];
					if (halfFloat) {
						packedDeltas[v * numComponents + numComponents] = float2Half(data[index * 3]);
						packedDeltas[v * numComponents + numComponents + 1] = float2Half(data[index * 3 + 1]);
						packedDeltas[v * numComponents + numComponents + 2] = float2Half(data[index * 3 + 2]);
					} else {
						packedDeltas[v * numComponents + numComponents] = data[index * 3];
						packedDeltas[v * numComponents + numComponents + 1] = data[index * 3 + 1];
						packedDeltas[v * numComponents + numComponents + 2] = data[index * 3 + 2];
					}
				}
				target = deltaInfos[i].target;
				var format = this._textureFormat === Morph.FORMAT_FLOAT ? PIXELFORMAT_RGB32F : PIXELFORMAT_RGBA16F;
				target._setTexture(deltaInfos[i].name, this._createTexture("MorphTarget", format, packedDeltas));
			}
			var formatDesc = [{ semantic: SEMANTIC_ATTR15, components: 1, type: TYPE_FLOAT32 }];
			this.vertexBufferIds = new VertexBuffer(this.device, new VertexFormat(this.device, formatDesc), ids.length, BUFFER_STATIC, new Float32Array(ids));
			return true;
		},
		destroy: function () {
			if (this.vertexBufferIds) {
				this.vertexBufferIds.destroy();
				this.vertexBufferIds = null;
			}
			for (var i = 0; i < this._targets.length; i++) {
				this._targets[i].destroy();
			}
			this._targets.length = 0;
		},
		getTarget: function (index) {
			return this._targets[index];
		},
		_updateMorphFlags: function () {
			this._morphPositions = false;
			this._morphNormals = false;
			var target;
			for (var i = 0; i < this._targets.length; i++) {
				target = this._targets[i];
				if (target.morphPositions) {
					this._morphPositions = true;
				}
				if (target.morphNormals) {
					this._morphNormals = true;
				}
			}
		},
		_calculateAabb: function () {
			this.aabb = new BoundingBox(new Vec3(0, 0, 0), new Vec3(0, 0, 0));
			var target;
			for (var i = 0; i < this._targets.length; i++) {
				target = this._targets[i];
				this.aabb._expand(target.aabb.getMin(), target.aabb.getMax());
			}
		},
		_createTexture: function (name, format, pixelData) {
			var texture = new Texture(this.device, {
				width: this.morphTextureWidth,
				height: this.morphTextureHeight,
				format: format,
				cubemap: false,
				mipmaps: false,
				minFilter: FILTER_NEAREST,
				magFilter: FILTER_NEAREST,
				addressU: ADDRESS_CLAMP_TO_EDGE,
				addressV: ADDRESS_CLAMP_TO_EDGE
			});
			texture.name = name;
			if (pixelData) {
				var pixels = texture.lock();
				pixels.set(pixelData);
				texture.unlock();
			}
			return texture;
		}
	});

	var textureMorphVertexShader =
		'attribute vec2 vertex_position;\n' +
		'varying vec2 uv0;\n' +
		'void main(void) {\n' +
		'	gl_Position = vec4(vertex_position, 0.5, 1.0);\n' +
		'	uv0 = vertex_position.xy * 0.5 + 0.5;\n' +
		'}\n';
	function MorphInstance(morph) {
		this.morph = morph;
		this.device = morph.device;
		this.meshInstance = null;
		this._weights = [];
		for (var v = 0; v < morph._targets.length; v++) {
			this.setWeight(v, morph._targets[v].defaultWeight);
		}
		this._activeTargets = [];
		if (morph.useTextureMorph) {
			this.shaderCache = {};
			this.maxSubmitCount = this.device.maxTextures;
			this.maxSubmitCount = 2;
			this._shaderMorphWeights = new Float32Array(this.maxSubmitCount);
			var createRT = function (name, textureVar) {
				var format = morph._renderTextureFormat === Morph.FORMAT_FLOAT ? PIXELFORMAT_RGBA32F : PIXELFORMAT_RGBA16F;
				this[textureVar] = morph._createTexture(name, format);
				return new RenderTarget({
					colorBuffer: this[textureVar],
					depth: false
				});
			}.bind(this);
			if (morph.morphPositions) {
				this.rtPositions = createRT("MorphRTPos", "texturePositions");
			}
			if (morph.morphNormals) {
				this.rtNormals = createRT("MorphRTNrm", "textureNormals");
			}
			this._textureParams = new Float32Array([morph.morphTextureWidth, morph.morphTextureHeight,
				1 / morph.morphTextureWidth, 1 / morph.morphTextureHeight]);
			for (var i = 0; i < this.maxSubmitCount; i++) {
				this["morphBlendTex" + i] = this.device.scope.resolve("morphBlendTex" + i);
			}
			this.morphFactor =  this.device.scope.resolve("morphFactor[0]");
		} else {
			this.maxSubmitCount = 8;
			this._shaderMorphWeights = new Float32Array(this.maxSubmitCount);
			this._shaderMorphWeightsA = new Float32Array(this._shaderMorphWeights.buffer, 0, 4);
			this._shaderMorphWeightsB = new Float32Array(this._shaderMorphWeights.buffer, 4 * 4, 4);
			this._activeVertexBuffers = new Array(this.maxSubmitCount);
		}
	}
	Object.assign(MorphInstance.prototype, {
		destroy: function () {
			this.meshInstance = null;
			this.shader = null;
			if (this.morph) {
				this.morph.destroy();
				this.morph = null;
			}
			if (this.rtPositions) {
				this.rtPositions.destroy();
				this.rtPositions = null;
			}
			if (this.texturePositions) {
				this.texturePositions.destroy();
				this.texturePositions = null;
			}
			if (this.rtNormals) {
				this.rtNormals.destroy();
				this.rtNormals = null;
			}
			if (this.textureNormals) {
				this.textureNormals.destroy();
				this.textureNormals = null;
			}
		},
		getWeight: function (index) {
			return this._weights[index];
		},
		setWeight: function (index, weight) {
			this._weights[index] = weight;
			this._dirty = true;
		},
		_getFragmentShader: function (numTextures) {
			var i, fragmentShader = '';
			if (numTextures > 0) {
				fragmentShader += 'varying vec2 uv0;\n' +
					'uniform highp float morphFactor[' + numTextures + '];\n';
			}
			for (i = 0; i < numTextures; i++) {
				fragmentShader += 'uniform highp sampler2D morphBlendTex' + i + ';\n';
			}
			fragmentShader += 'void main (void) {\n' +
				'	highp vec4 color = vec4(0, 0, 0, 1);\n';
			for (i = 0; i < numTextures; i++) {
				fragmentShader += '	color.xyz += morphFactor[' + i + '] * texture2D(morphBlendTex' + i + ', uv0).xyz;\n';
			}
			fragmentShader += '	gl_FragColor = color;\n' +
				'}\n';
			return fragmentShader;
		},
		_getShader: function (count) {
			var shader = this.shaderCache[count];
			if (!shader) {
				var fs = this._getFragmentShader(count);
				shader = createShaderFromCode(this.device, textureMorphVertexShader, fs, "textureMorph" + count);
				this.shaderCache[count] = shader;
			}
			return shader;
		},
		_updateTextureRenderTarget: function (renderTarget, srcTextureName) {
			var device = this.device;
			var submitBatch = function (usedCount, blending) {
				this.morphFactor.setValue(this._shaderMorphWeights);
				device.setBlending(blending);
				if (blending) {
					device.setBlendFunction(BLENDMODE_ONE, BLENDMODE_ONE);
					device.setBlendEquation(BLENDEQUATION_ADD);
				}
				var shader = this._getShader(usedCount);
				drawQuadWithShader(device, renderTarget, shader, undefined, undefined, blending);
			}.bind(this);
			var usedCount = 0;
			var blending = false;
			var count = this._activeTargets.length;
			for (var i = 0; i < count; i++) {
				var activeTarget = this._activeTargets[i];
				var tex = activeTarget.target[srcTextureName];
				if (tex) {
					this["morphBlendTex" + usedCount].setValue(tex);
					this._shaderMorphWeights[usedCount] = activeTarget.weight;
					usedCount++;
					if (usedCount >= this.maxSubmitCount) {
						submitBatch(usedCount, blending);
						usedCount = 0;
						blending = true;
					}
				}
			}
			if (usedCount > 0) {
				submitBatch(usedCount, blending);
			}
		},
		_updateTextureMorph: function () {
			var device = this.device;
			if (this._activeTargets.length > 0) {
				this._updateTextureRenderTarget(this.rtPositions, 'texturePositions');
				this._updateTextureRenderTarget(this.rtNormals, 'textureNormals');
			}
		},
		_updateVertexMorph: function () {
			var i, count = this.maxSubmitCount;
			for (i = 0; i < count; i++) {
				this._shaderMorphWeights[i] = 0;
				this._activeVertexBuffers[i] = null;
			}
			var posIndex = 0;
			var nrmIndex = this.morph.morphPositions ? 4 : 0;
			var target;
			for (i = 0; i < this._activeTargets.length; i++) {
				target = this._activeTargets[i].target;
				if (target._vertexBufferPositions) {
					this._activeVertexBuffers[posIndex] = target._vertexBufferPositions;
					this._shaderMorphWeights[posIndex] = this._activeTargets[i].weight;
					posIndex++;
				}
				if (target._vertexBufferNormals) {
					this._activeVertexBuffers[nrmIndex] = target._vertexBufferNormals;
					this._shaderMorphWeights[nrmIndex] = this._activeTargets[i].weight;
					nrmIndex++;
				}
			}
		},
		update: function () {
			this._dirty = false;
			var targets = this.morph._targets;
			var activeCount = 0, activeTarget;
			var i, absWeight, epsilon = 0.00001;
			for (i = 0; i < targets.length; i++) {
				absWeight = Math.abs(this.getWeight(i));
				if (absWeight > epsilon) {
					if (this._activeTargets.length <= activeCount) {
						this._activeTargets[activeCount] = {};
					}
					activeTarget = this._activeTargets[activeCount++];
					activeTarget.absWeight = absWeight;
					activeTarget.weight = this.getWeight(i);
					activeTarget.target = targets[i];
				}
			}
			this._activeTargets.length = activeCount;
			var maxActiveTargets = this.morph.maxActiveTargets;
			if (this._activeTargets.length > maxActiveTargets) {
				this._activeTargets.sort(function (l, r) {
					return (l.absWeight < r.absWeight) ? 1 : (r.absWeight < l.absWeight ? -1 : 0);
				});
				this._activeTargets.length = maxActiveTargets;
			}
			if (this.morph.useTextureMorph) {
				this._updateTextureMorph();
			} else {
				this._updateVertexMorph();
			}
		}
	});

	var _invMatrix = new Mat4();
	function Skin(graphicsDevice, ibp, boneNames) {
		this.device = graphicsDevice;
		this.inverseBindPose = ibp;
		this.boneNames = boneNames;
	}
	function SkinInstance(skin) {
		this._dirty = true;
		if (skin) {
			this.initSkin(skin);
		}
	}
	Object.assign(SkinInstance.prototype, {
		init: function (device, numBones) {
			if (device.supportsBoneTextures) {
				var numPixels = numBones * 3;
				var width = Math.ceil(Math.sqrt(numPixels));
				width = math.roundUp(width, 3);
				var height = Math.ceil(numPixels / width);
				this.boneTexture = new Texture(device, {
					width: width,
					height: height,
					format: PIXELFORMAT_RGBA32F,
					mipmaps: false,
					minFilter: FILTER_NEAREST,
					magFilter: FILTER_NEAREST
				});
				this.boneTexture.name = 'skin';
				this.matrixPalette = this.boneTexture.lock();
			} else {
				this.matrixPalette = new Float32Array(numBones * 12);
			}
		},
		initSkin: function (skin) {
			this.skin = skin;
			this.bones = [];
			var numBones = skin.inverseBindPose.length;
			this.init(skin.device, numBones);
			this.matrices = [];
			for (var i = 0; i < numBones; i++) {
				this.matrices[i] = new Mat4();
			}
		},
		uploadBones: function (device) {
			if (device.supportsBoneTextures) {
				this.boneTexture.lock();
				this.boneTexture.unlock();
			}
		},
		updateMatrices: function (rootNode) {
			_invMatrix.copy(rootNode.getWorldTransform()).invert();
			for (var i = this.bones.length - 1; i >= 0; i--) {
				this.matrices[i].mulAffine2(_invMatrix, this.bones[i].getWorldTransform());
				this.matrices[i].mulAffine2(this.matrices[i], this.skin.inverseBindPose[i]);
			}
		},
		updateMatrixPalette: function () {
			var pe;
			var mp = this.matrixPalette;
			var base;
			var count = this.bones.length;
			for (var i = 0; i < count; i++) {
				pe = this.matrices[i].data;
				base = i * 12;
				mp[base] = pe[0];
				mp[base + 1] = pe[4];
				mp[base + 2] = pe[8];
				mp[base + 3] = pe[12];
				mp[base + 4] = pe[1];
				mp[base + 5] = pe[5];
				mp[base + 6] = pe[9];
				mp[base + 7] = pe[13];
				mp[base + 8] = pe[2];
				mp[base + 9] = pe[6];
				mp[base + 10] = pe[10];
				mp[base + 11] = pe[14];
			}
			this.uploadBones(this.skin.device);
		}
	});

	function Model() {
		this.graph = null;
		this.meshInstances = [];
		this.skinInstances = [];
		this.morphInstances = [];
		this.cameras = [];
		this.lights = [];
		this._shadersVersion = 0;
		this._immutable = false;
	}
	Object.assign(Model.prototype, {
		getGraph: function () {
			return this.graph;
		},
		setGraph: function (graph) {
			this.graph = graph;
		},
		getCameras: function () {
			return this.cameras;
		},
		setCameras: function (cameras) {
			this.cameras = cameras;
		},
		getLights: function () {
			return this.lights;
		},
		setLights: function (lights) {
			this.lights = lights;
		},
		getMaterials: function () {
			var i;
			var materials = [];
			for (i = 0; i < this.meshInstances.length; i++) {
				var meshInstance = this.meshInstances[i];
				if (materials.indexOf(meshInstance.material) === -1) {
					materials.push(meshInstance.material);
				}
			}
			return materials;
		},
		clone: function () {
			var i, j;
			var srcNodes = [];
			var cloneNodes = [];
			var _duplicate = function (node) {
				var newNode = node.clone();
				srcNodes.push(node);
				cloneNodes.push(newNode);
				for (var idx = 0; idx < node._children.length; idx++) {
					newNode.addChild(_duplicate(node._children[idx]));
				}
				return newNode;
			};
			var cloneGraph = _duplicate(this.graph);
			var cloneMeshInstances = [];
			var cloneSkinInstances = [];
			var cloneMorphInstances = [];
			for (i = 0; i < this.skinInstances.length; i++) {
				var skin = this.skinInstances[i].skin;
				var cloneSkinInstance = new SkinInstance(skin);
				var bones = [];
				for (j = 0; j < skin.boneNames.length; j++) {
					var boneName = skin.boneNames[j];
					var bone = cloneGraph.findByName(boneName);
					bones.push(bone);
				}
				cloneSkinInstance.bones = bones;
				cloneSkinInstances.push(cloneSkinInstance);
			}
			for (i = 0; i < this.morphInstances.length; i++) {
				var morph = this.morphInstances[i].morph;
				var cloneMorphInstance = new MorphInstance(morph);
				cloneMorphInstances.push(cloneMorphInstance);
			}
			for (i = 0; i < this.meshInstances.length; i++) {
				var meshInstance = this.meshInstances[i];
				var nodeIndex = srcNodes.indexOf(meshInstance.node);
				var cloneMeshInstance = new MeshInstance(cloneNodes[nodeIndex], meshInstance.mesh, meshInstance.material);
				if (meshInstance.skinInstance) {
					var skinInstanceIndex = this.skinInstances.indexOf(meshInstance.skinInstance);
					cloneMeshInstance.skinInstance = cloneSkinInstances[skinInstanceIndex];
				}
				if (meshInstance.morphInstance) {
					var morphInstanceIndex = this.morphInstances.indexOf(meshInstance.morphInstance);
					cloneMeshInstance.morphInstance = cloneMorphInstances[morphInstanceIndex];
				}
				cloneMeshInstances.push(cloneMeshInstance);
			}
			var clone = new Model();
			clone.graph = cloneGraph;
			clone.meshInstances = cloneMeshInstances;
			clone.skinInstances = cloneSkinInstances;
			clone.morphInstances = cloneMorphInstances;
			clone.getGraph().syncHierarchy();
			return clone;
		},
		destroy: function () {
			var meshInstances = this.meshInstances;
			var meshInstance, mesh, skin, morph, boneTex;
			for (var i = 0; i < meshInstances.length; i++) {
				meshInstance = meshInstances[i];
				mesh = meshInstance.mesh;
				if (mesh) {
					meshInstance.mesh = null;
					if (mesh.refCount < 1) {
						mesh.destroy();
					}
				}
				skin = meshInstance.skinInstance;
				if (skin) {
					boneTex = skin.boneTexture;
					if (boneTex) {
						boneTex.destroy();
					}
				}
				meshInstance.skinInstance = null;
				morph = meshInstance.morphInstance;
				if (morph) {
					morph.destroy();
				}
				meshInstance.morphInstance = null;
				meshInstance.material = null;
			}
		},
		generateWireframe: function () {
			var i;
			var mesh;
			var meshes = [];
			for (i = 0; i < this.meshInstances.length; i++) {
				mesh = this.meshInstances[i].mesh;
				if (meshes.indexOf(mesh) === -1) {
					meshes.push(mesh);
				}
			}
			for (i = 0; i < meshes.length; ++i) {
				mesh = meshes[i];
				if (!mesh.primitive[RENDERSTYLE_WIREFRAME]) {
					mesh.generateWireframe();
				}
			}
		}
	});

	function Batch(meshInstances, dynamic, batchGroupId) {
		this.origMeshInstances = meshInstances;
		this._aabb = new BoundingBox();
		this.meshInstance = null;
		this.model = null;
		this.dynamic = dynamic;
		this.batchGroupId = batchGroupId;
		this.refCounter = 0;
	}
	function BatchGroup(id, name, dynamic, maxAabbSize, layers) {
		this.dynamic = dynamic;
		this.maxAabbSize = maxAabbSize;
		this.id = id;
		this.name = name;
		this.layers = layers === undefined ? [LAYERID_WORLD] : layers;
		this._ui = false;
		this._sprite = false;
		this._obj = {
			model: [],
			element: [],
			sprite: []
		};
	}
	BatchGroup.MODEL = 'model';
	BatchGroup.ELEMENT = 'element';
	BatchGroup.SPRITE = 'sprite';
	function SkinBatchInstance(device, nodes, rootNode) {
		SkinInstance.call(this);
		var numBones = nodes.length;
		SkinInstance.prototype.init.call(this, device, numBones);
		this.device = device;
		this.rootNode = rootNode;
		this.bones = nodes;
	}
	SkinBatchInstance.prototype = Object.create(SkinBatchInstance.prototype);
	SkinBatchInstance.prototype.constructor = SkinBatchInstance;
	Object.assign(SkinBatchInstance.prototype, {
		updateMatrices: function (rootNode) {
		},
		updateMatrixPalette: function () {
			var pe;
			var mp = this.matrixPalette;
			var base;
			var count = this.bones.length;
			for (var i = 0; i < count; i++) {
				pe = this.bones[i].getWorldTransform().data;
				base = i * 12;
				mp[base] = pe[0];
				mp[base + 1] = pe[4];
				mp[base + 2] = pe[8];
				mp[base + 3] = pe[12];
				mp[base + 4] = pe[1];
				mp[base + 5] = pe[5];
				mp[base + 6] = pe[9];
				mp[base + 7] = pe[13];
				mp[base + 8] = pe[2];
				mp[base + 9] = pe[6];
				mp[base + 10] = pe[10];
				mp[base + 11] = pe[14];
			}
			SkinInstance.prototype.uploadBones.call(this, this.device);
		}
	});
	function BatchManager(device, root, scene) {
		this.device = device;
		this.rootNode = root;
		this.scene = scene;
		this._init = false;
		this._batchGroups = {};
		this._batchGroupCounter = 0;
		this._batchList = [];
		this._dirtyGroups = [];
	}
	BatchManager.prototype.destroyManager = function () {
		this.device = null;
		this.rootNode = null;
		this.scene = null;
		this._batchGroups = {};
		this._batchList = [];
		this._dirtyGroups = [];
	};
	BatchManager.prototype.addGroup = function (name, dynamic, maxAabbSize, id, layers) {
		if (id === undefined) {
			id = this._batchGroupCounter;
			this._batchGroupCounter++;
		}
		if (this._batchGroups[id]) {
			return;
		}
		var group;
		this._batchGroups[id] = group = new BatchGroup(id, name, dynamic, maxAabbSize, layers);
		return group;
	};
	BatchManager.prototype.removeGroup = function (id) {
		if (!this._batchGroups[id]) {
			return;
		}
		var newBatchList = [];
		for (var i = 0; i < this._batchList.length; i++) {
			if (this._batchList[i].batchGroupId !== id) {
				newBatchList.push(this._batchList[i]);
				continue;
			}
			this.destroy(this._batchList[i]);
		}
		this._batchList = newBatchList;
		this._removeModelsFromBatchGroup(this.rootNode, id);
		delete this._batchGroups[id];
	};
	BatchManager.prototype.markGroupDirty = function (id) {
		if (this._dirtyGroups.indexOf(id) < 0) {
			this._dirtyGroups.push(id);
		}
	};
	BatchManager.prototype.getGroupByName = function (name) {
		var groups = this._batchGroups;
		for (var group in groups) {
			if (!groups.hasOwnProperty(group)) continue;
			if (groups[group].name === name) {
				return groups[group];
			}
		}
		return null;
	};
	BatchManager.prototype.getBatches = function (batchGroupId) {
		var results = [];
		var len = this._batchList.length;
		for (var i = 0; i < len; i++) {
			var batch = this._batchList[i];
			if (batch.batchGroupId === batchGroupId) {
				results.push(batch);
			}
		}
		return results;
	};
	BatchManager.prototype._removeModelsFromBatchGroup = function (node, id) {
		if (!node.enabled) return;
		if (node.model && node.model.batchGroupId === id) {
			node.model.batchGroupId = -1;
		}
		if (node.element && node.element.batchGroupId === id) {
			node.element.batchGroupId = -1;
		}
		if (node.sprite && node.sprite.batchGroupId === id) {
			node.sprite.batchGroupId = -1;
		}
		for (var i = 0; i < node._children.length; i++) {
			this._removeModelsFromBatchGroup(node._children[i], id);
		}
	};
	BatchManager.prototype.insert = function (type, groupId, node) {
		var group = this._batchGroups[groupId];
		if (group) {
			if (group._obj[type].indexOf(node) < 0) {
				group._obj[type].push(node);
				this.markGroupDirty(groupId);
			}
		}
	};
	BatchManager.prototype.remove = function (type, groupId, node) {
		var group = this._batchGroups[groupId];
		if (group) {
			var idx = group._obj[type].indexOf(node);
			if (idx >= 0) {
				group._obj[type].splice(idx, 1);
				this.markGroupDirty(groupId);
			}
		}
	};
	BatchManager.prototype._extractModel = function (node, arr, group, groupMeshInstances) {
		if (!node.model || !node.model.model) return arr;
		var i;
		if (node.model.isStatic) {
			var drawCalls = this.scene.drawCalls;
			var nodeMeshInstances = node.model.meshInstances;
			for (i = 0; i < drawCalls.length; i++) {
				if (!drawCalls[i]._staticSource) continue;
				if (nodeMeshInstances.indexOf(drawCalls[i]._staticSource) < 0) continue;
				arr.push(drawCalls[i]);
			}
			for (i = 0; i < nodeMeshInstances.length; i++) {
				if (drawCalls.indexOf(nodeMeshInstances[i]) >= 0) {
					arr.push(nodeMeshInstances[i]);
				}
			}
		} else {
			arr = groupMeshInstances[node.model.batchGroupId] = arr.concat(node.model.meshInstances);
		}
		node.model.removeModelFromLayers();
		return arr;
	};
	BatchManager.prototype._extractElement = function (node, arr, group) {
		if (!node.element) return;
		var valid = false;
		if (node.element._text && node.element._text._model.meshInstances.length > 0) {
			arr.push(node.element._text._model.meshInstances[0]);
			node.element.removeModelFromLayers(node.element._text._model);
			valid = true;
		} else if (node.element._image) {
			arr.push(node.element._image._renderable.meshInstance);
			node.element.removeModelFromLayers(node.element._image._renderable.model);
			if (node.element._image._renderable.unmaskMeshInstance) {
				arr.push(node.element._image._renderable.unmaskMeshInstance);
				if (!node.element._image._renderable.unmaskMeshInstance.stencilFront ||
					!node.element._image._renderable.unmaskMeshInstance.stencilBack) {
					node.element._dirtifyMask();
					node.element._onPrerender();
				}
			}
			valid = true;
		}
		if (valid) {
			group._ui = true;
		}
	};
	BatchManager.prototype._collectAndRemoveModels = function (groupMeshInstances, groupIds) {
		var node, group, arr, id;
		for (var g = 0; g < groupIds.length; g++) {
			id = groupIds[g];
			group = this._batchGroups[id];
			if (!group) continue;
			arr = groupMeshInstances[id];
			if (!arr) arr = groupMeshInstances[id] = [];
			for (var m = 0; m < group._obj.model.length; m++) {
				arr = this._extractModel(group._obj.model[m], arr, group, groupMeshInstances);
			}
			for (var e = 0; e < group._obj.element.length; e++) {
				this._extractElement(group._obj.element[e], arr, group);
			}
			for (var s = 0; s < group._obj.sprite.length; s++) {
				node = group._obj.sprite[s];
				if (node.sprite && node.sprite._meshInstance &&
					(group.dynamic || node.sprite.sprite._renderMode === SPRITE_RENDERMODE_SIMPLE)) {
					arr.push(node.sprite._meshInstance);
					node.sprite.removeModelFromLayers();
					group._sprite = true;
					node.sprite._batchGroup = group;
				}
			}
		}
	};
	BatchManager.prototype.generate = function (groupIds) {
		var i, j;
		var groupMeshInstances = {};
		if (!groupIds) {
			groupIds = Object.keys(this._batchGroups);
		}
		var newBatchList = [];
		for (i = 0; i < this._batchList.length; i++) {
			if (groupIds.indexOf(this._batchList[i].batchGroupId) < 0) {
				newBatchList.push(this._batchList[i]);
				continue;
			}
			this.destroy(this._batchList[i]);
		}
		this._batchList = newBatchList;
		this._collectAndRemoveModels(groupMeshInstances, groupIds);
		if (groupIds === this._dirtyGroups) {
			this._dirtyGroups.length = 0;
		} else {
			var newDirtyGroups = [];
			for (i = 0; i < this._dirtyGroups.length; i++) {
				if (groupIds.indexOf(this._dirtyGroups[i]) < 0) newDirtyGroups.push(this._dirtyGroups[i]);
			}
			this._dirtyGroups = newDirtyGroups;
		}
		var group, lists, groupData, batch;
		for (var groupId in groupMeshInstances) {
			if (!groupMeshInstances.hasOwnProperty(groupId)) continue;
			group = groupMeshInstances[groupId];
			groupData = this._batchGroups[groupId];
			if (!groupData) {
				continue;
			}
			lists = this.prepare(group, groupData.dynamic, groupData.maxAabbSize, groupData._ui || groupData._sprite);
			for (i = 0; i < lists.length; i++) {
				batch = this.create(lists[i], groupData.dynamic, parseInt(groupId, 10));
				if (!batch) continue;
				for (j = 0; j < groupData.layers.length; j++) {
					var layer = this.scene.layers.getLayerById(groupData.layers[j]);
					if (layer)
						layer.addMeshInstances(batch.model.meshInstances);
				}
			}
		}
	};
	function paramsIdentical(a, b) {
		if (a && !b) return false;
		if (!a && b) return false;
		a = a.data;
		b = b.data;
		if (a === b) return true;
		if (a instanceof Float32Array && b instanceof Float32Array) {
			if (a.length !== b.length) return false;
			for (var i = 0; i < a.length; i++) {
				if (a[i] !== b[i]) return false;
			}
			return true;
		}
		return false;
	}
	function equalParamSets(params1, params2) {
		var param;
		for (param in params1) {
			if (params1.hasOwnProperty(param) && !paramsIdentical(params1[param], params2[param]))
				return false;
		}
		for (param in params2) {
			if (params2.hasOwnProperty(param) && !paramsIdentical(params2[param], params1[param]))
				return false;
		}
		return true;
	}
	function equalLightLists(lightList1, lightList2) {
		var k;
		for (k = 0; k < lightList1.length; k++) {
			if (lightList2.indexOf(lightList1[k]) < 0)
				return false;
		}
		for (k = 0; k < lightList2.length; k++) {
			if (lightList1.indexOf(lightList2[k]) < 0)
				return false;
		}
		return  true;
	}
	var worldMatX = new Vec3();
	var worldMatY = new Vec3();
	var worldMatZ = new Vec3();
	function getScaleSign(mi) {
		var wt = mi.node.worldTransform;
		wt.getX(worldMatX);
		wt.getY(worldMatY);
		wt.getZ(worldMatZ);
		worldMatX.cross(worldMatX, worldMatY);
		return worldMatX.dot(worldMatZ) >= 0 ? 1 : -1;
	}
	BatchManager.prototype.prepare = function (meshInstances, dynamic, maxAabbSize, translucent) {
		if (meshInstances.length === 0) return [];
		if (maxAabbSize === undefined) maxAabbSize = Number.POSITIVE_INFINITY;
		var halfMaxAabbSize = maxAabbSize * 0.5;
		var maxInstanceCount = this.device.supportsBoneTextures ? 1024 : this.device.boneLimit;
		var maxNumVertices = this.device.extUintElement ? 0xffffffff : 0xffff;
		var material, layer, vertCount, params, lightList, defs, stencil, staticLights, scaleSign, drawOrder, indexed, vertexFormatBatchingHash;
		var aabb = new BoundingBox();
		var testAabb = new BoundingBox();
		var skipTranslucentAabb = null;
		var mi, sf;
		var lists = [];
		var i, j = 0;
		if (translucent) {
			meshInstances.sort(function (a, b) {
				return a.drawOrder - b.drawOrder;
			});
		}
		var meshInstancesLeftA = meshInstances;
		var meshInstancesLeftB;
		var skipMesh = translucent ? function (mi) {
			if (skipTranslucentAabb) {
				skipTranslucentAabb.add(mi.aabb);
			} else {
				skipTranslucentAabb = mi.aabb.clone();
			}
			meshInstancesLeftB.push(mi);
		} : function (mi) {
			meshInstancesLeftB.push(mi);
		};
		while (meshInstancesLeftA.length > 0) {
			lists[j] = [meshInstancesLeftA[0]];
			meshInstancesLeftB = [];
			material = meshInstancesLeftA[0].material;
			layer = meshInstancesLeftA[0].layer;
			defs = meshInstancesLeftA[0]._shaderDefs;
			params = meshInstancesLeftA[0].parameters;
			stencil = meshInstancesLeftA[0].stencilFront;
			lightList = meshInstancesLeftA[0]._staticLightList;
			vertCount = meshInstancesLeftA[0].mesh.vertexBuffer.getNumVertices();
			drawOrder = meshInstancesLeftA[0].drawOrder;
			aabb.copy(meshInstancesLeftA[0].aabb);
			scaleSign = getScaleSign(meshInstancesLeftA[0]);
			vertexFormatBatchingHash = meshInstancesLeftA[0].mesh.vertexBuffer.format.batchingHash;
			indexed = meshInstancesLeftA[0].mesh.primitive[0].indexed;
			skipTranslucentAabb = null;
			for (i = 1; i < meshInstancesLeftA.length; i++) {
				mi = meshInstancesLeftA[i];
				if (dynamic && lists[j].length >= maxInstanceCount) {
					meshInstancesLeftB = meshInstancesLeftB.concat(meshInstancesLeftA.slice(i));
					break;
				}
				if ((material !== mi.material) ||
					(layer !== mi.layer) ||
					(vertexFormatBatchingHash !== mi.mesh.vertexBuffer.format.batchingHash) ||
					(indexed !== mi.mesh.primitive[0].indexed) ||
					(defs !== mi._shaderDefs) ||
					(vertCount + mi.mesh.vertexBuffer.getNumVertices() > maxNumVertices)) {
					skipMesh(mi);
					continue;
				}
				testAabb.copy(aabb);
				testAabb.add(mi.aabb);
				if (testAabb.halfExtents.x > halfMaxAabbSize ||
					testAabb.halfExtents.y > halfMaxAabbSize ||
					testAabb.halfExtents.z > halfMaxAabbSize) {
					skipMesh(mi);
					continue;
				}
				if (stencil) {
					if (!(sf = mi.stencilFront) || stencil.func != sf.func || stencil.zpass != sf.zpass) {
						skipMesh(mi);
						continue;
					}
				}
				if (scaleSign != getScaleSign(mi)) {
					skipMesh(mi);
					continue;
				}
				if (!equalParamSets(params, mi.parameters)) {
					skipMesh(mi);
					continue;
				}
				staticLights = mi._staticLightList;
				if (lightList && staticLights) {
					if (!equalLightLists(lightList, staticLights)) {
						skipMesh(mi);
						continue;
					}
				} else if (lightList || staticLights) {
					skipMesh(mi);
					continue;
				}
				if (translucent && skipTranslucentAabb && skipTranslucentAabb.intersects(mi.aabb) && mi.drawOrder !== drawOrder) {
					skipMesh(mi);
					continue;
				}
				aabb.add(mi.aabb);
				vertCount += mi.mesh.vertexBuffer.getNumVertices();
				lists[j].push(mi);
			}
			j++;
			meshInstancesLeftA = meshInstancesLeftB;
		}
		return lists;
	};
	BatchManager.prototype.create = function (meshInstances, dynamic, batchGroupId) {
		if (!this._init) {
			var boneLimit = "#define BONE_LIMIT " + this.device.getBoneLimit() + "\n";
			this.transformVS = boneLimit + "#define DYNAMICBATCH\n" + shaderChunks.transformVS;
			this.skinTexVS = shaderChunks.skinBatchTexVS;
			this.skinConstVS = shaderChunks.skinBatchConstVS;
			this.vertexFormats = {};
			this._init = true;
		}
		var i, j;
		var streams = null, stream;
		var semantic;
		var material = null;
		var mesh, elems, numVerts;
		var batchNumVerts = 0;
		var batchNumIndices = 0;
		var batch = null;
		for (i = 0; i < meshInstances.length; i++) {
			if (meshInstances[i].visible) {
				mesh = meshInstances[i].mesh;
				numVerts = mesh.vertexBuffer.numVertices;
				batchNumVerts += numVerts;
				batchNumIndices += mesh.primitive[0].indexed ? mesh.primitive[0].count :
					(mesh.primitive[0].type == PRIMITIVE_TRIFAN && mesh.primitive[0].count === 4 ? 6 : 0);
				if (!streams) {
					material = meshInstances[i].material;
					streams = {};
					elems = mesh.vertexBuffer.format.elements;
					for (j = 0; j < elems.length; j++) {
						semantic = elems[j].name;
						streams[semantic] = {
							numComponents: elems[j].numComponents,
							dataType: elems[j].dataType,
							normalize: elems[j].normalize,
							count: 0
						};
					}
					if (dynamic) {
						streams[SEMANTIC_BLENDINDICES] = {
							numComponents: 1,
							dataType: TYPE_FLOAT32,
							normalize: false,
							count: 0
						};
					}
				}
			}
		}
		if (streams) {
			batch = new Batch(meshInstances, dynamic, batchGroupId);
			this._batchList.push(batch);
			var indexBase, numIndices, indexData;
			var verticesOffset = 0;
			var indexOffset = 0;
			var transform, vec = new Vec3();
			var indexArrayType = batchNumVerts <= 0xffff ? Uint16Array : Uint32Array;
			var indices = new indexArrayType(batchNumIndices);
			for (semantic in streams) {
				stream = streams[semantic];
				stream.typeArrayType = typedArrayTypes[stream.dataType];
				stream.elementByteSize = typedArrayTypesByteSize[stream.dataType];
				stream.buffer = new stream.typeArrayType(batchNumVerts * stream.numComponents);
			}
			for (i = 0; i < meshInstances.length; i++) {
				if (!meshInstances[i].visible)
					continue;
				mesh = meshInstances[i].mesh;
				numVerts = mesh.vertexBuffer.numVertices;
				if (!dynamic) {
					transform = meshInstances[i].node.getWorldTransform();
				}
				for (semantic in streams) {
					if (semantic !== SEMANTIC_BLENDINDICES) {
						stream = streams[semantic];
						var subarray = new stream.typeArrayType(stream.buffer.buffer, stream.elementByteSize * stream.count);
						var totalComponents = mesh.getVertexStream(semantic, subarray) * stream.numComponents;
						stream.count += totalComponents;
						if (!dynamic && stream.numComponents >= 3) {
							if (semantic == SEMANTIC_POSITION || semantic == SEMANTIC_NORMAL || semantic == SEMANTIC_TANGENT) {
								transform.transformFunction = semantic == SEMANTIC_POSITION ? Mat4.prototype.transformPoint : Mat4.prototype.transformVector;
								for (j = 0; j < totalComponents; j += stream.numComponents) {
									vec.set(subarray[j], subarray[j + 1], subarray[j + 2]);
									transform.transformFunction(vec, vec);
									subarray[j] = vec.x;
									subarray[j + 1] = vec.y;
									subarray[j + 2] = vec.z;
								}
							}
						}
					}
				}
				if (dynamic) {
					stream = streams[SEMANTIC_BLENDINDICES];
					for (j = 0; j < numVerts; j++)
						stream.buffer[stream.count++] = i;
				}
				if (mesh.primitive[0].indexed) {
					indexBase = mesh.primitive[0].base;
					numIndices = mesh.primitive[0].count;
					var srcFormat = mesh.indexBuffer[0].getFormat();
					indexData = new typedArrayIndexFormats[srcFormat](mesh.indexBuffer[0].storage);
				} else if (mesh.primitive[0].type == PRIMITIVE_TRIFAN && mesh.primitive[0].count === 4) {
					indexBase = 0;
					numIndices = 6;
					indexData = [0, 1, 3, 2, 3, 1];
				} else {
					numIndices = 0;
					continue;
				}
				for (j = 0; j < numIndices; j++) {
					indices[j + indexOffset] = indexData[indexBase + j] + verticesOffset;
				}
				indexOffset += numIndices;
				verticesOffset += numVerts;
			}
			mesh = new Mesh(this.device);
			for (semantic in streams) {
				stream = streams[semantic];
				mesh.setVertexStream(semantic, stream.buffer, stream.numComponents, undefined, stream.dataType, stream.normalize);
			}
			if (indices.length > 0)
				mesh.setIndices(indices);
			mesh.update(PRIMITIVE_TRIANGLES, false);
			if (dynamic) {
				material = material.clone();
				material.chunks.transformVS = this.transformVS;
				material.chunks.skinTexVS = this.skinTexVS;
				material.chunks.skinConstVS = this.skinConstVS;
				material.update();
			}
			var meshInstance = new MeshInstance(this.rootNode, mesh, material);
			meshInstance.castShadow = batch.origMeshInstances[0].castShadow;
			meshInstance.parameters = batch.origMeshInstances[0].parameters;
			meshInstance.isStatic = batch.origMeshInstances[0].isStatic;
			meshInstance.layer = batch.origMeshInstances[0].layer;
			meshInstance._staticLightList = batch.origMeshInstances[0]._staticLightList;
			meshInstance._shaderDefs = batch.origMeshInstances[0]._shaderDefs;
			meshInstance.cull = batch.origMeshInstances[0].cull;
			var batchGroup = this._batchGroups[batchGroupId];
			if (batchGroup && batchGroup._ui)
				meshInstance.cull = false;
			if (dynamic) {
				var nodes = [];
				for (i = 0; i < batch.origMeshInstances.length; i++) {
					nodes.push(batch.origMeshInstances[i].node);
				}
				meshInstance.skinInstance = new SkinBatchInstance(this.device, nodes, this.rootNode);
			}
			meshInstance._updateAabb = false;
			meshInstance.drawOrder = batch.origMeshInstances[0].drawOrder;
			meshInstance.stencilFront = batch.origMeshInstances[0].stencilFront;
			meshInstance.stencilBack = batch.origMeshInstances[0].stencilBack;
			meshInstance.flipFaces = getScaleSign(batch.origMeshInstances[0]) < 0;
			batch.meshInstance = meshInstance;
			this.update(batch);
			var newModel = new Model();
			newModel.meshInstances = [batch.meshInstance];
			newModel.castShadows = batch.origMeshInstances[0].castShadows;
			batch.model = newModel;
		}
		return batch;
	};
	BatchManager.prototype.update = function (batch) {
		batch._aabb.copy(batch.origMeshInstances[0].aabb);
		for (var i = 1; i < batch.origMeshInstances.length; i++) {
			batch._aabb.add(batch.origMeshInstances[i].aabb);
		}
		batch.meshInstance.aabb = batch._aabb;
		batch._aabb._radiusVer = -1;
		batch.meshInstance._aabbVer = 0;
	};
	BatchManager.prototype.updateAll = function () {
		if (this._dirtyGroups.length > 0) {
			this.generate(this._dirtyGroups);
		}
		for (var i = 0; i < this._batchList.length; i++) {
			if (!this._batchList[i].dynamic) continue;
			this.update(this._batchList[i]);
		}
	};
	BatchManager.prototype.clone = function (batch, clonedMeshInstances) {
		var batch2 = new Batch(clonedMeshInstances, batch.dynamic, batch.batchGroupId);
		this._batchList.push(batch2);
		var nodes = [];
		for (var i = 0; i < clonedMeshInstances.length; i++) {
			nodes.push(clonedMeshInstances[i].node);
		}
		batch2.meshInstance = new MeshInstance(batch.meshInstance.node, batch.meshInstance.mesh, batch.meshInstance.material);
		batch2.meshInstance._updateAabb = false;
		batch2.meshInstance.parameters = clonedMeshInstances[0].parameters;
		batch2.meshInstance.isStatic = clonedMeshInstances[0].isStatic;
		batch2.meshInstance.cull = clonedMeshInstances[0].cull;
		batch2.meshInstance.layer = clonedMeshInstances[0].layer;
		batch2.meshInstance._staticLightList = clonedMeshInstances[0]._staticLightList;
		if (batch.dynamic) {
			batch2.meshInstance.skinInstance = new SkinBatchInstance(this.device, nodes, this.rootNode);
		}
		batch2.meshInstance.castShadow = batch.meshInstance.castShadow;
		batch2.meshInstance._shader = batch.meshInstance._shader;
		var newModel = new Model();
		newModel.meshInstances = [batch2.meshInstance];
		newModel.castShadows = batch.origMeshInstances[0].castShadows;
		batch2.model = newModel;
		return batch2;
	};
	BatchManager.prototype.destroy = function (batch) {
		batch.refCounter = 0;
		if (!batch.model)
			return;
		var layers = this._batchGroups[batch.batchGroupId].layers;
		for (var i = 0; i < layers.length; i++) {
			var layer = this.scene.layers.getLayerById(layers[i]);
			if (layer)
				layer.removeMeshInstances(batch.model.meshInstances);
		}
		batch.model.destroy();
	};
	BatchManager.prototype.decrement = function (batch) {
		batch.refCounter--;
		if (batch.refCounter === 0) {
			this.destroy(batch);
		}
	};

	var _deviceCoord = new Vec3();
	var _far = new Vec3();
	var _farW = new Vec3();
	var _invViewProjMat = new Mat4();
	function Camera() {
		this._aspectRatio = 16 / 9;
		this._aspectRatioMode = ASPECT_AUTO;
		this._calculateProjection = null;
		this._calculateTransform = null;
		this._clearColor = new Color(0.75, 0.75, 0.75, 1);
		this._clearColorBuffer = true;
		this._clearDepth = 1;
		this._clearDepthBuffer = true;
		this._clearStencil = 0;
		this._clearStencilBuffer = true;
		this._cullingMask = 0xFFFFFFFF;
		this._cullFaces = true;
		this._farClip = 1000;
		this._flipFaces = false;
		this._fov = 45;
		this._frustumCulling = false;
		this._horizontalFov = false;
		this._layers = [LAYERID_WORLD, LAYERID_DEPTH, LAYERID_SKYBOX, LAYERID_UI, LAYERID_IMMEDIATE];
		this._nearClip = 0.1;
		this._node = null;
		this._orthoHeight = 10;
		this._projection = PROJECTION_PERSPECTIVE;
		this._rect = new Vec4(0, 0, 1, 1);
		this._renderTarget = null;
		this._scissorRect = new Vec4(0, 0, 1, 1);
		this._vrDisplay = null;
		this._projMat = new Mat4();
		this._projMatDirty = true;
		this._projMatSkybox = new Mat4();
		this._viewMat = new Mat4();
		this._viewMatDirty = true;
		this._viewProjMat = new Mat4();
		this._viewProjMatDirty = true;
		this.frustum = new Frustum();
	}
	Object.defineProperty(Camera.prototype, 'aspectRatio', {
		get: function () {
			return this._aspectRatio;
		},
		set: function (newValue) {
			if (this._aspectRatio !== newValue) {
				this._aspectRatio = newValue;
				this._projMatDirty = true;
			}
		}
	});
	Object.defineProperty(Camera.prototype, 'aspectRatioMode', {
		get: function () {
			return this._aspectRatioMode;
		},
		set: function (newValue) {
			if (this._aspectRatioMode !== newValue) {
				this._aspectRatioMode = newValue;
				this._projMatDirty = true;
			}
		}
	});
	Object.defineProperty(Camera.prototype, "calculateProjection", {
		get: function () {
			return this._calculateProjection;
		},
		set: function (newValue) {
			this._calculateProjection = newValue;
			this._projMatDirty = true;
		}
	});
	Object.defineProperty(Camera.prototype, "calculateTransform", {
		get: function () {
			return this._calculateTransform;
		},
		set: function (newValue) {
			this._calculateTransform = newValue;
		}
	});
	Object.defineProperty(Camera.prototype, 'clearColor', {
		get: function () {
			return this._clearColor;
		},
		set: function (newValue) {
			this._clearColor.copy(newValue);
		}
	});
	Object.defineProperty(Camera.prototype, 'clearColorBuffer', {
		get: function () {
			return this._clearColorBuffer;
		},
		set: function (newValue) {
			this._clearColorBuffer = newValue;
		}
	});
	Object.defineProperty(Camera.prototype, 'clearDepth', {
		get: function () {
			return this._clearDepth;
		},
		set: function (newValue) {
			this._clearDepth = newValue;
		}
	});
	Object.defineProperty(Camera.prototype, 'clearDepthBuffer', {
		get: function () {
			return this._clearDepthBuffer;
		},
		set: function (newValue) {
			this._clearDepthBuffer = newValue;
		}
	});
	Object.defineProperty(Camera.prototype, 'clearStencil', {
		get: function () {
			return this._clearStencil;
		},
		set: function (newValue) {
			this._clearStencil = newValue;
		}
	});
	Object.defineProperty(Camera.prototype, 'clearStencilBuffer', {
		get: function () {
			return this._clearStencilBuffer;
		},
		set: function (newValue) {
			this._clearStencilBuffer = newValue;
		}
	});
	Object.defineProperty(Camera.prototype, 'cullingMask', {
		get: function () {
			return this._cullingMask;
		},
		set: function (newValue) {
			this._cullingMask = newValue;
		}
	});
	Object.defineProperty(Camera.prototype, 'cullFaces', {
		get: function () {
			return this._cullFaces;
		},
		set: function (newValue) {
			this._cullFaces = newValue;
		}
	});
	Object.defineProperty(Camera.prototype, 'farClip', {
		get: function () {
			return this._farClip;
		},
		set: function (newValue) {
			if (this._farClip !== newValue) {
				this._farClip = newValue;
				this._projMatDirty = true;
			}
		}
	});
	Object.defineProperty(Camera.prototype, 'flipFaces', {
		get: function () {
			return this._flipFaces;
		},
		set: function (newValue) {
			this._flipFaces = newValue;
		}
	});
	Object.defineProperty(Camera.prototype, 'fov', {
		get: function () {
			return this._fov;
		},
		set: function (newValue) {
			if (this._fov !== newValue) {
				this._fov = newValue;
				this._projMatDirty = true;
			}
		}
	});
	Object.defineProperty(Camera.prototype, 'frustumCulling', {
		get: function () {
			return this._frustumCulling;
		},
		set: function (newValue) {
			this._frustumCulling = newValue;
		}
	});
	Object.defineProperty(Camera.prototype, 'horizontalFov', {
		get: function () {
			return this._horizontalFov;
		},
		set: function (newValue) {
			if (this._horizontalFov !== newValue) {
				this._horizontalFov = newValue;
				this._projMatDirty = true;
			}
		}
	});
	Object.defineProperty(Camera.prototype, 'layers', {
		get: function () {
			return this._layers;
		},
		set: function (newValue) {
			this._layers = newValue.slice(0);
		}
	});
	Object.defineProperty(Camera.prototype, 'nearClip', {
		get: function () {
			return this._nearClip;
		},
		set: function (newValue) {
			if (this._nearClip !== newValue) {
				this._nearClip = newValue;
				this._projMatDirty = true;
			}
		}
	});
	Object.defineProperty(Camera.prototype, 'node', {
		get: function () {
			return this._node;
		},
		set: function (newValue) {
			this._node = newValue;
		}
	});
	Object.defineProperty(Camera.prototype, 'orthoHeight', {
		get: function () {
			return this._orthoHeight;
		},
		set: function (newValue) {
			if (this._orthoHeight !== newValue) {
				this._orthoHeight = newValue;
				this._projMatDirty = true;
			}
		}
	});
	Object.defineProperty(Camera.prototype, 'projection', {
		get: function () {
			return this._projection;
		},
		set: function (newValue) {
			if (this._projection !== newValue) {
				this._projection = newValue;
				this._projMatDirty = true;
			}
		}
	});
	Object.defineProperty(Camera.prototype, 'projectionMatrix', {
		get: function () {
			this._evaluateProjectionMatrix();
			return this._projMat;
		}
	});
	Object.defineProperty(Camera.prototype, 'rect', {
		get: function () {
			return this._rect;
		},
		set: function (newValue) {
			this._rect.copy(newValue);
		}
	});
	Object.defineProperty(Camera.prototype, 'renderTarget', {
		get: function () {
			return this._renderTarget;
		},
		set: function (newValue) {
			this._renderTarget = newValue;
		}
	});
	Object.defineProperty(Camera.prototype, 'scissorRect', {
		get: function () {
			return this._scissorRect;
		},
		set: function (newValue) {
			this._scissorRect.copy(newValue);
		}
	});
	Object.defineProperty(Camera.prototype, 'viewMatrix', {
		get: function () {
			if (this._viewMatDirty) {
				var wtm = this._node.getWorldTransform();
				this._viewMat.copy(wtm).invert();
				this._viewMatDirty = false;
			}
			return this._viewMat;
		}
	});
	Object.defineProperty(Camera.prototype, 'vrDisplay', {
		get: function () {
			return this._vrDisplay;
		},
		set: function (newValue) {
			this._vrDisplay = newValue;
			if (newValue) {
				newValue._camera = this;
			}
		}
	});
	Object.assign(Camera.prototype, {
		clone: function () {
			return new this.constructor().copy(this);
		},
		copy: function (other) {
			this.aspectRatio = other.aspectRatio;
			this.aspectRatioMode = other.aspectRatioMode;
			this.calculateProjection = other.calculateProjection;
			this.calculateTransform = other.calculateTransform;
			this.clearColor = other.clearColor;
			this.clearColorBuffer = other.clearColorBuffer;
			this.clearDepth = other.clearDepth;
			this.clearDepthBuffer = other.clearDepthBuffer;
			this.clearStencil = other.clearStencil;
			this.clearStencilBuffer = other.clearStencilBuffer;
			this.cullFaces = other.cullFaces;
			this.cullingMask = other.cullingMask;
			this.farClip = other.farClip;
			this.flipFaces = other.flipFaces;
			this.fov = other.fov;
			this.frustumCulling = other.frustumCulling;
			this.horizontalFov = other.horizontalFov;
			this.layers = other.layers;
			this.nearClip = other.nearClip;
			this.orthoHeight = other.orthoHeight;
			this.projection = other.projection;
			this.rect = other.rect;
			this.renderTarget = other.renderTarget;
			this.scissorRect = other.scissorRect;
			this.vrDisplay = other.vrDisplay;
		},
		worldToScreen: function (worldCoord, cw, ch, screenCoord) {
			if (screenCoord === undefined) {
				screenCoord = new Vec3();
			}
			if (this._projMatDirty || this._viewMatDirty || this._viewProjMatDirty) {
				var projMat = this.projectionMatrix;
				var viewMat = this.viewMatrix;
				this._viewProjMat.mul2(projMat, viewMat);
				this._viewProjMatDirty = false;
			}
			this._viewProjMat.transformPoint(worldCoord, screenCoord);
			var vpm = this._viewProjMat.data;
			var w = worldCoord.x * vpm[3] +
					worldCoord.y * vpm[7] +
					worldCoord.z * vpm[11] +
							   1 * vpm[15];
			screenCoord.x = (screenCoord.x / w + 1) * 0.5 * cw;
			screenCoord.y = (1 - screenCoord.y / w) * 0.5 * ch;
			return screenCoord;
		},
		screenToWorld: function (x, y, z, cw, ch, worldCoord) {
			if (worldCoord === undefined) {
				worldCoord = new Vec3();
			}
			if (this._projMatDirty || this._viewMatDirty || this._viewProjMatDirty) {
				var projMat = this.projectionMatrix;
				var viewMat = this.viewMatrix;
				this._viewProjMat.mul2(projMat, viewMat);
				this._viewProjMatDirty = false;
			}
			_invViewProjMat.copy(this._viewProjMat).invert();
			if (this._projection === PROJECTION_PERSPECTIVE) {
				_far.set(x / cw * 2 - 1, (ch - y) / ch * 2 - 1, 1);
				_invViewProjMat.transformPoint(_far, _farW);
				var w = _far.x * _invViewProjMat.data[3] +
						_far.y * _invViewProjMat.data[7] +
						_far.z * _invViewProjMat.data[11] +
						_invViewProjMat.data[15];
				_farW.scale(1 / w);
				var alpha = z / this._farClip;
				worldCoord.lerp(this._node.getPosition(), _farW, alpha);
			} else {
				var range = this._farClip - this._nearClip;
				_deviceCoord.set(x / cw, (ch - y) / ch, z / range);
				_deviceCoord.scale(2);
				_deviceCoord.sub(Vec3.ONE);
				_invViewProjMat.transformPoint(_deviceCoord, worldCoord);
			}
			return worldCoord;
		},
		_evaluateProjectionMatrix: function () {
			if (this._projMatDirty) {
				if (this._projection === PROJECTION_PERSPECTIVE) {
					this._projMat.setPerspective(this._fov, this._aspectRatio, this._nearClip, this._farClip, this._horizontalFov);
					this._projMatSkybox.copy(this._projMat);
				} else {
					var y = this._orthoHeight;
					var x = y * this._aspectRatio;
					this._projMat.setOrtho(-x, x, -y, y, this._nearClip, this._farClip);
					this._projMatSkybox.setPerspective(this._fov, this._aspectRatio, this._nearClip, this._farClip);
				}
				this._projMatDirty = false;
			}
		},
		getProjectionMatrixSkybox: function () {
			this._evaluateProjectionMatrix();
			return this._projMatSkybox;
		}
	});

	var scaleCompensatePosTransform = new Mat4();
	var scaleCompensatePos = new Vec3();
	var scaleCompensateRot = new Quat();
	var scaleCompensateRot2 = new Quat();
	var scaleCompensateScale = new Vec3();
	var scaleCompensateScaleForParent = new Vec3();
	var tmpMat4$1 = new Mat4();
	var tmpQuat = new Quat();
	function GraphNode(name) {
		EventHandler.call(this);
		this.name = typeof name === "string" ? name : "Untitled";
		this.tags = new Tags(this);
		this._labels = {};
		this.localPosition = new Vec3(0, 0, 0);
		this.localRotation = new Quat(0, 0, 0, 1);
		this.localScale = new Vec3(1, 1, 1);
		this.localEulerAngles = new Vec3(0, 0, 0);
		this.position = new Vec3(0, 0, 0);
		this.rotation = new Quat(0, 0, 0, 1);
		this.eulerAngles = new Vec3(0, 0, 0);
		this._scale = null;
		this.localTransform = new Mat4();
		this._dirtyLocal = false;
		this._aabbVer = 0;
		this._frozen = false;
		this.worldTransform = new Mat4();
		this._dirtyWorld = false;
		this.normalMatrix = new Mat3();
		this._dirtyNormal = true;
		this._right = null;
		this._up = null;
		this._forward = null;
		this._parent = null;
		this._children = [];
		this._graphDepth = 0;
		this._enabled = true;
		this._enabledInHierarchy = false;
		this.scaleCompensation = false;
	}
	GraphNode.prototype = Object.create(EventHandler.prototype);
	GraphNode.prototype.constructor = GraphNode;
	Object.defineProperty(GraphNode.prototype, 'right', {
		get: function () {
			if (!this._right) {
				this._right = new Vec3();
			}
			return this.getWorldTransform().getX(this._right).normalize();
		}
	});
	Object.defineProperty(GraphNode.prototype, 'up', {
		get: function () {
			if (!this._up) {
				this._up = new Vec3();
			}
			return this.getWorldTransform().getY(this._up).normalize();
		}
	});
	Object.defineProperty(GraphNode.prototype, 'forward', {
		get: function () {
			if (!this._forward) {
				this._forward = new Vec3();
			}
			return this.getWorldTransform().getZ(this._forward).normalize().scale(-1);
		}
	});
	Object.defineProperty(GraphNode.prototype, 'enabled', {
		get: function () {
			return this._enabled && this._enabledInHierarchy;
		},
		set: function (enabled) {
			if (this._enabled !== enabled) {
				this._enabled = enabled;
				if (!this._parent || this._parent.enabled)
					this._notifyHierarchyStateChanged(this, enabled);
			}
		}
	});
	Object.defineProperty(GraphNode.prototype, 'parent', {
		get: function () {
			return this._parent;
		}
	});
	Object.defineProperty(GraphNode.prototype, 'path', {
		get: function () {
			var parent = this._parent;
			if (parent) {
				var path = this.name;
				while (parent && parent._parent) {
					path = parent.name + "/" + path;
					parent = parent._parent;
				}
				return path;
			}
			return '';
		}
	});
	Object.defineProperty(GraphNode.prototype, 'root', {
		get: function () {
			var parent = this._parent;
			if (!parent)
				return this;
			while (parent._parent)
				parent = parent._parent;
			return parent;
		}
	});
	Object.defineProperty(GraphNode.prototype, 'children', {
		get: function () {
			return this._children;
		}
	});
	Object.defineProperty(GraphNode.prototype, 'graphDepth', {
		get: function () {
			return this._graphDepth;
		}
	});
	Object.assign(GraphNode.prototype, {
		_notifyHierarchyStateChanged: function (node, enabled) {
			node._onHierarchyStateChanged(enabled);
			var c = node._children;
			for (var i = 0, len = c.length; i < len; i++) {
				if (c[i]._enabled)
					this._notifyHierarchyStateChanged(c[i], enabled);
			}
		},
		_onHierarchyStateChanged: function (enabled) {
			this._enabledInHierarchy = enabled;
			if (enabled && !this._frozen)
				this._unfreezeParentToRoot();
		},
		_cloneInternal: function (clone) {
			clone.name = this.name;
			var tags = this.tags._list;
			for (var i = 0; i < tags.length; i++)
				clone.tags.add(tags[i]);
			clone._labels = Object.assign({}, this._labels);
			clone.localPosition.copy(this.localPosition);
			clone.localRotation.copy(this.localRotation);
			clone.localScale.copy(this.localScale);
			clone.localEulerAngles.copy(this.localEulerAngles);
			clone.position.copy(this.position);
			clone.rotation.copy(this.rotation);
			clone.eulerAngles.copy(this.eulerAngles);
			clone.localTransform.copy(this.localTransform);
			clone._dirtyLocal = this._dirtyLocal;
			clone.worldTransform.copy(this.worldTransform);
			clone._dirtyWorld = this._dirtyWorld;
			clone._dirtyNormal = this._dirtyNormal;
			clone._aabbVer = this._aabbVer + 1;
			clone._enabled = this._enabled;
			clone.scaleCompensation = this.scaleCompensation;
			clone._enabledInHierarchy = false;
		},
		clone: function () {
			var clone = new GraphNode();
			this._cloneInternal(clone);
			return clone;
		},
		find: function (attr, value) {
			var result, results = [];
			var len = this._children.length;
			var i, descendants;
			if (attr instanceof Function) {
				var fn = attr;
				result = fn(this);
				if (result)
					results.push(this);
				for (i = 0; i < len; i++) {
					descendants = this._children[i].find(fn);
					if (descendants.length)
						results = results.concat(descendants);
				}
			} else {
				var testValue;
				if (this[attr]) {
					if (this[attr] instanceof Function) {
						testValue = this[attr]();
					} else {
						testValue = this[attr];
					}
					if (testValue === value)
						results.push(this);
				}
				for (i = 0; i < len; ++i) {
					descendants = this._children[i].find(attr, value);
					if (descendants.length)
						results = results.concat(descendants);
				}
			}
			return results;
		},
		findOne: function (attr, value) {
			var i;
			var len = this._children.length;
			var result = null;
			if (attr instanceof Function) {
				var fn = attr;
				result = fn(this);
				if (result)
					return this;
				for (i = 0; i < len; i++) {
					result = this._children[i].findOne(fn);
					if (result)
						return result;
				}
			} else {
				var testValue;
				if (this[attr]) {
					if (this[attr] instanceof Function) {
						testValue = this[attr]();
					} else {
						testValue = this[attr];
					}
					if (testValue === value) {
						return this;
					}
				}
				for (i = 0; i < len; i++) {
					result = this._children[i].findOne(attr, value);
					if (result !== null)
						return result;
				}
			}
			return null;
		},
		findByTag: function () {
			var tags = this.tags._processArguments(arguments);
			return this._findByTag(tags);
		},
		_findByTag: function (tags) {
			var result = [];
			var i, len = this._children.length;
			var descendants;
			for (i = 0; i < len; i++) {
				if (this._children[i].tags._has(tags))
					result.push(this._children[i]);
				descendants = this._children[i]._findByTag(tags);
				if (descendants.length)
					result = result.concat(descendants);
			}
			return result;
		},
		findByName: function (name) {
			if (this.name === name) return this;
			for (var i = 0; i < this._children.length; i++) {
				var found = this._children[i].findByName(name);
				if (found !== null) return found;
			}
			return null;
		},
		findByPath: function (path) {
			var parts = path.split('/');
			var currentParent = this;
			var result = null;
			for (var i = 0, imax = parts.length; i < imax && currentParent; i++) {
				var part = parts[i];
				result = null;
				var children = currentParent._children;
				for (var j = 0, jmax = children.length; j < jmax; j++) {
					if (children[j].name == part) {
						result = children[j];
						break;
					}
				}
				currentParent = result;
			}
			return result;
		},
		forEach: function (callback, thisArg) {
			callback.call(thisArg, this);
			var children = this._children;
			for (var i = 0; i < children.length; i++) {
				children[i].forEach(callback, thisArg);
			}
		},
		isDescendantOf: function (node) {
			var parent = this._parent;
			while (parent) {
				if (parent === node)
					return true;
				parent = parent._parent;
			}
			return false;
		},
		isAncestorOf: function (node) {
			return node.isDescendantOf(this);
		},
		getEulerAngles: function () {
			this.getWorldTransform().getEulerAngles(this.eulerAngles);
			return this.eulerAngles;
		},
		getLocalEulerAngles: function () {
			this.localRotation.getEulerAngles(this.localEulerAngles);
			return this.localEulerAngles;
		},
		getLocalPosition: function () {
			return this.localPosition;
		},
		getLocalRotation: function () {
			return this.localRotation;
		},
		getLocalScale: function () {
			return this.localScale;
		},
		getLocalTransform: function () {
			if (this._dirtyLocal) {
				this.localTransform.setTRS(this.localPosition, this.localRotation, this.localScale);
				this._dirtyLocal = false;
			}
			return this.localTransform;
		},
		getPosition: function () {
			this.getWorldTransform().getTranslation(this.position);
			return this.position;
		},
		getRotation: function () {
			this.rotation.setFromMat4(this.getWorldTransform());
			return this.rotation;
		},
		getScale: function () {
			if (!this._scale) {
				this._scale = new Vec3();
			}
			return this.getWorldTransform().getScale(this._scale);
		},
		getWorldTransform: function () {
			if (!this._dirtyLocal && !this._dirtyWorld)
				return this.worldTransform;
			if (this._parent)
				this._parent.getWorldTransform();
			this._sync();
			return this.worldTransform;
		},
		reparent: function (parent, index) {
			var current = this._parent;
			if (current)
				current.removeChild(this);
			if (parent) {
				if (index >= 0) {
					parent.insertChild(this, index);
				} else {
					parent.addChild(this);
				}
			}
		},
		setLocalEulerAngles: function (x, y, z) {
			if (x instanceof Vec3) {
				this.localRotation.setFromEulerAngles(x.x, x.y, x.z);
			} else {
				this.localRotation.setFromEulerAngles(x, y, z);
			}
			if (!this._dirtyLocal)
				this._dirtifyLocal();
		},
		setLocalPosition: function (x, y, z) {
			if (x instanceof Vec3) {
				this.localPosition.copy(x);
			} else {
				this.localPosition.set(x, y, z);
			}
			if (!this._dirtyLocal)
				this._dirtifyLocal();
		},
		setLocalRotation: function (x, y, z, w) {
			if (x instanceof Quat) {
				this.localRotation.copy(x);
			} else {
				this.localRotation.set(x, y, z, w);
			}
			if (!this._dirtyLocal)
				this._dirtifyLocal();
		},
		setLocalScale: function (x, y, z) {
			if (x instanceof Vec3) {
				this.localScale.copy(x);
			} else {
				this.localScale.set(x, y, z);
			}
			if (!this._dirtyLocal)
				this._dirtifyLocal();
		},
		_dirtifyLocal: function () {
			if (!this._dirtyLocal) {
				this._dirtyLocal = true;
				if (!this._dirtyWorld)
					this._dirtifyWorld();
			}
		},
		_unfreezeParentToRoot: function () {
			var p = this._parent;
			while (p) {
				p._frozen = false;
				p = p._parent;
			}
		},
		_dirtifyWorld: function () {
			if (!this._dirtyWorld)
				this._unfreezeParentToRoot();
			this._dirtifyWorldInternal();
		},
		_dirtifyWorldInternal: function () {
			if (!this._dirtyWorld) {
				this._frozen = false;
				this._dirtyWorld = true;
				for (var i = 0; i < this._children.length; i++) {
					if (!this._children[i]._dirtyWorld)
						this._children[i]._dirtifyWorldInternal();
				}
			}
			this._dirtyNormal = true;
			this._aabbVer++;
		},
		setPosition: function () {
			var position = new Vec3();
			var invParentWtm = new Mat4();
			return function (x, y, z) {
				if (x instanceof Vec3) {
					position.copy(x);
				} else {
					position.set(x, y, z);
				}
				if (this._parent === null) {
					this.localPosition.copy(position);
				} else {
					invParentWtm.copy(this._parent.getWorldTransform()).invert();
					invParentWtm.transformPoint(position, this.localPosition);
				}
				if (!this._dirtyLocal)
					this._dirtifyLocal();
			};
		}(),
		setRotation: function () {
			var rotation = new Quat();
			var invParentRot = new Quat();
			return function (x, y, z, w) {
				if (x instanceof Quat) {
					rotation.copy(x);
				} else {
					rotation.set(x, y, z, w);
				}
				if (this._parent === null) {
					this.localRotation.copy(rotation);
				} else {
					var parentRot = this._parent.getRotation();
					invParentRot.copy(parentRot).invert();
					this.localRotation.copy(invParentRot).mul(rotation);
				}
				if (!this._dirtyLocal)
					this._dirtifyLocal();
			};
		}(),
		setEulerAngles: function () {
			var invParentRot = new Quat();
			return function (x, y, z) {
				if (x instanceof Vec3) {
					this.localRotation.setFromEulerAngles(x.x, x.y, x.z);
				} else {
					this.localRotation.setFromEulerAngles(x, y, z);
				}
				if (this._parent !== null) {
					var parentRot = this._parent.getRotation();
					invParentRot.copy(parentRot).invert();
					this.localRotation.mul2(invParentRot, this.localRotation);
				}
				if (!this._dirtyLocal)
					this._dirtifyLocal();
			};
		}(),
		addChild: function (node) {
			if (node._parent !== null)
				throw new Error("GraphNode is already parented");
			this._children.push(node);
			this._onInsertChild(node);
		},
		addChildAndSaveTransform: function (node) {
			var wPos = node.getPosition();
			var wRot = node.getRotation();
			var current = node._parent;
			if (current)
				current.removeChild(node);
			node.setPosition(tmpMat4$1.copy(this.worldTransform).invert().transformPoint(wPos));
			node.setRotation(tmpQuat.copy(this.getRotation()).invert().mul(wRot));
			this._children.push(node);
			this._onInsertChild(node);
		},
		insertChild: function (node, index) {
			if (node._parent !== null)
				throw new Error("GraphNode is already parented");
			this._children.splice(index, 0, node);
			this._onInsertChild(node);
		},
		_onInsertChild: function (node) {
			node._parent = this;
			var enabledInHierarchy = (node._enabled && this.enabled);
			if (node._enabledInHierarchy !== enabledInHierarchy) {
				node._enabledInHierarchy = enabledInHierarchy;
				node._notifyHierarchyStateChanged(node, enabledInHierarchy);
			}
			node._updateGraphDepth();
			node._dirtifyWorld();
			if (this._frozen)
				node._unfreezeParentToRoot();
			if (node.fire) node.fire('insert', this);
			if (this.fire) this.fire('childinsert', node);
		},
		_updateGraphDepth: function () {
			if (this._parent) {
				this._graphDepth = this._parent._graphDepth + 1;
			} else {
				this._graphDepth = 0;
			}
			for (var i = 0, len = this._children.length; i < len; i++) {
				this._children[i]._updateGraphDepth();
			}
		},
		removeChild: function (child) {
			var i;
			var length = this._children.length;
			for (i = 0; i < length; ++i) {
				if (this._children[i] === child) {
					this._children.splice(i, 1);
					child._parent = null;
					if (child.fire) child.fire('remove', this);
					if (this.fire) this.fire('childremove', child);
					return;
				}
			}
		},
		_sync: function () {
			if (this._dirtyLocal) {
				this.localTransform.setTRS(this.localPosition, this.localRotation, this.localScale);
				this._dirtyLocal = false;
			}
			if (this._dirtyWorld) {
				if (this._parent === null) {
					this.worldTransform.copy(this.localTransform);
				} else {
					if (this.scaleCompensation) {
						var parentWorldScale;
						var parent = this._parent;
						var scale = this.localScale;
						var parentToUseScaleFrom = parent;
						if (parentToUseScaleFrom) {
							while (parentToUseScaleFrom && parentToUseScaleFrom.scaleCompensation) {
								parentToUseScaleFrom = parentToUseScaleFrom._parent;
							}
							if (parentToUseScaleFrom) {
								parentToUseScaleFrom = parentToUseScaleFrom._parent;
								if (parentToUseScaleFrom) {
									parentWorldScale = parentToUseScaleFrom.worldTransform.getScale();
									scaleCompensateScale.mul2(parentWorldScale, this.localScale);
									scale = scaleCompensateScale;
								}
							}
						}
						scaleCompensateRot2.setFromMat4(parent.worldTransform);
						scaleCompensateRot.mul2(scaleCompensateRot2, this.localRotation);
						var tmatrix = parent.worldTransform;
						if (parent.scaleCompensation) {
							scaleCompensateScaleForParent.mul2(parentWorldScale, parent.getLocalScale());
							scaleCompensatePosTransform.setTRS(parent.worldTransform.getTranslation(scaleCompensatePos),
															   scaleCompensateRot2,
															   scaleCompensateScaleForParent);
							tmatrix = scaleCompensatePosTransform;
						}
						tmatrix.transformPoint(this.localPosition, scaleCompensatePos);
						this.worldTransform.setTRS(scaleCompensatePos, scaleCompensateRot, scale);
					} else {
						this.worldTransform.mulAffine2(this._parent.worldTransform, this.localTransform);
					}
				}
				this._dirtyWorld = false;
			}
		},
		syncHierarchy: function () {
			if (!this._enabled)
				return;
			if (this._frozen)
				return;
			this._frozen = true;
			if (this._dirtyLocal || this._dirtyWorld) {
				this._sync();
			}
			var children = this._children;
			for (var i = 0, len = children.length; i < len; i++) {
				children[i].syncHierarchy();
			}
		},
		lookAt: function () {
			var matrix = new Mat4();
			var target = new Vec3();
			var up = new Vec3();
			var rotation = new Quat();
			return function (tx, ty, tz, ux, uy, uz) {
				if (tx instanceof Vec3) {
					target.copy(tx);
					if (ty instanceof Vec3) {
						up.copy(ty);
					} else {
						up.copy(Vec3.UP);
					}
				} else if (tz === undefined) {
					return;
				} else {
					target.set(tx, ty, tz);
					if (ux !== undefined) {
						up.set(ux, uy, uz);
					} else {
						up.copy(Vec3.UP);
					}
				}
				matrix.setLookAt(this.getPosition(), target, up);
				rotation.setFromMat4(matrix);
				this.setRotation(rotation);
			};
		}(),
		translate: function () {
			var translation = new Vec3();
			return function (x, y, z) {
				if (x instanceof Vec3) {
					translation.copy(x);
				} else {
					translation.set(x, y, z);
				}
				translation.add(this.getPosition());
				this.setPosition(translation);
			};
		}(),
		translateLocal: function () {
			var translation = new Vec3();
			return function (x, y, z) {
				if (x instanceof Vec3) {
					translation.copy(x);
				} else {
					translation.set(x, y, z);
				}
				this.localRotation.transformVector(translation, translation);
				this.localPosition.add(translation);
				if (!this._dirtyLocal)
					this._dirtifyLocal();
			};
		}(),
		rotate: function () {
			var quaternion = new Quat();
			var invParentRot = new Quat();
			return function (x, y, z) {
				if (x instanceof Vec3) {
					quaternion.setFromEulerAngles(x.x, x.y, x.z);
				} else {
					quaternion.setFromEulerAngles(x, y, z);
				}
				if (this._parent === null) {
					this.localRotation.mul2(quaternion, this.localRotation);
				} else {
					var rot = this.getRotation();
					var parentRot = this._parent.getRotation();
					invParentRot.copy(parentRot).invert();
					quaternion.mul2(invParentRot, quaternion);
					this.localRotation.mul2(quaternion, rot);
				}
				if (!this._dirtyLocal)
					this._dirtifyLocal();
			};
		}(),
		rotateLocal: function () {
			var quaternion = new Quat();
			return function (x, y, z) {
				if (x instanceof Vec3) {
					quaternion.setFromEulerAngles(x.x, x.y, x.z);
				} else {
					quaternion.setFromEulerAngles(x, y, z);
				}
				this.localRotation.mul(quaternion);
				if (!this._dirtyLocal)
					this._dirtifyLocal();
			};
		}()
	});

	var keyA, keyB, sortPos, sortDir;
	function sortManual(drawCallA, drawCallB) {
		return drawCallA.drawOrder - drawCallB.drawOrder;
	}
	function sortMaterialMesh(drawCallA, drawCallB) {
		keyA = drawCallA._key[SORTKEY_FORWARD];
		keyB = drawCallB._key[SORTKEY_FORWARD];
		if (keyA === keyB && drawCallA.mesh && drawCallB.mesh) {
			return drawCallB.mesh.id - drawCallA.mesh.id;
		}
		return keyB - keyA;
	}
	function sortBackToFront(drawCallA, drawCallB) {
		return drawCallB.zdist - drawCallA.zdist;
	}
	function sortFrontToBack(drawCallA, drawCallB) {
		return drawCallA.zdist - drawCallB.zdist;
	}
	var sortCallbacks = [null, sortManual, sortMaterialMesh, sortBackToFront, sortFrontToBack];
	function sortCameras(camA, camB) {
		return camA.priority - camB.priority;
	}
	function sortLights(lightA, lightB) {
		return lightB.key - lightA.key;
	}
	var layerCounter = 0;
	function VisibleInstanceList() {
		this.list = [];
		this.length = 0;
		this.done = false;
	}
	function InstanceList() {
		this.opaqueMeshInstances = [];
		this.transparentMeshInstances = [];
		this.shadowCasters = [];
		this.visibleOpaque = [];
		this.visibleTransparent = [];
	}
	InstanceList.prototype.clearVisibleLists = function (cameraPass) {
		if (this.visibleOpaque[cameraPass]) {
			this.visibleOpaque[cameraPass].length = 0;
			this.visibleOpaque[cameraPass].list.length = 0;
		}
		if (this.visibleTransparent[cameraPass]) {
			this.visibleTransparent[cameraPass].length = 0;
			this.visibleTransparent[cameraPass].list.length = 0;
		}
	};
	function Layer(options) {
		options = options || {};
		if (options.id !== undefined) {
			this.id = options.id;
			layerCounter = Math.max(this.id + 1, layerCounter);
		} else {
			this.id = layerCounter++;
		}
		this.name = options.name;
		this._enabled = options.enabled === undefined ? true : options.enabled;
		this._refCounter = this._enabled ? 1 : 0;
		this.opaqueSortMode = options.opaqueSortMode === undefined ? SORTMODE_MATERIALMESH : options.opaqueSortMode;
		this.transparentSortMode = options.transparentSortMode === undefined ? SORTMODE_BACK2FRONT : options.transparentSortMode;
		this.renderTarget = options.renderTarget;
		this.shaderPass = options.shaderPass === undefined ? SHADER_FORWARD : options.shaderPass;
		this.passThrough = options.passThrough === undefined ? false : options.passThrough;
		this.overrideClear = options.overrideClear === undefined ? false : options.overrideClear;
		this._clearColor = new Color(0, 0, 0, 1);
		if (options.clearColor) {
			this._clearColor.copy(options.clearColor);
		}
		this._clearColorBuffer = options.clearColorBuffer === undefined ? false : options.clearColorBuffer;
		this._clearDepthBuffer = options.clearDepthBuffer === undefined ? false : options.clearDepthBuffer;
		this._clearStencilBuffer = options.clearStencilBuffer === undefined ? false : options.clearStencilBuffer;
		this._clearOptions = {
			color: [this._clearColor.r, this._clearColor.g, this._clearColor.b, this._clearColor.a],
			depth: 1,
			stencil: 0,
			flags: (this._clearColorBuffer ? CLEARFLAG_COLOR : 0) | (this._clearDepthBuffer ? CLEARFLAG_DEPTH : 0) | (this._clearStencilBuffer ? CLEARFLAG_STENCIL : 0)
		};
		this.onPreCull = options.onPreCull;
		this.onPreRender = options.onPreRender;
		this.onPreRenderOpaque = options.onPreRenderOpaque;
		this.onPreRenderTransparent = options.onPreRenderTransparent;
		this.onPostCull = options.onPostCull;
		this.onPostRender = options.onPostRender;
		this.onPostRenderOpaque = options.onPostRenderOpaque;
		this.onPostRenderTransparent = options.onPostRenderTransparent;
		this.onDrawCall = options.onDrawCall;
		this.onEnable = options.onEnable;
		this.onDisable = options.onDisable;
		if (this._enabled && this.onEnable) {
			this.onEnable();
		}
		this.layerReference = options.layerReference;
		this.instances = options.layerReference ? options.layerReference.instances : new InstanceList();
		this.cullingMask = options.cullingMask ? options.cullingMask : 0xFFFFFFFF;
		this.opaqueMeshInstances = this.instances.opaqueMeshInstances;
		this.transparentMeshInstances = this.instances.transparentMeshInstances;
		this.shadowCasters = this.instances.shadowCasters;
		this.customSortCallback = null;
		this.customCalculateSortValues = null;
		this._lightComponents = [];
		this._lights = [];
		this._sortedLights = [[], [], []];
		this.cameras = [];
		this._dirty = false;
		this._dirtyLights = false;
		this._dirtyCameras = false;
		this._cameraHash = 0;
		this._lightHash = 0;
		this._staticLightHash = 0;
		this._needsStaticPrepare = true;
		this._staticPrepareDone = false;
		this._shaderVersion = -1;
		this._version = 0;
		this._lightCube = null;
	}
	Object.defineProperty(Layer.prototype, "enabled", {
		get: function () {
			return this._enabled;
		},
		set: function (val) {
			if (val !== this._enabled) {
				this._enabled = val;
				if (val) {
					this.incrementCounter();
					if (this.onEnable) this.onEnable();
				} else {
					this.decrementCounter();
					if (this.onDisable) this.onDisable();
				}
			}
		}
	});
	Object.defineProperty(Layer.prototype, "clearColor", {
		get: function () {
			return this._clearColor;
		},
		set: function (val) {
			this._clearColor.copy(val);
		}
	});
	Layer.prototype._updateClearFlags = function () {
		var flags = 0;
		if (this._clearColorBuffer)
			flags |= CLEARFLAG_COLOR;
		if (this._clearDepthBuffer)
			flags |= CLEARFLAG_DEPTH;
		if (this._clearStencilBuffer)
			flags |= CLEARFLAG_STENCIL;
		this._clearOptions.flags = flags;
	};
	Object.defineProperty(Layer.prototype, "clearColorBuffer", {
		get: function () {
			return this._clearColorBuffer;
		},
		set: function (val) {
			this._clearColorBuffer = val;
			this._updateClearFlags();
		}
	});
	Object.defineProperty(Layer.prototype, "clearDepthBuffer", {
		get: function () {
			return this._clearDepthBuffer;
		},
		set: function (val) {
			this._clearDepthBuffer = val;
			this._updateClearFlags();
		}
	});
	Object.defineProperty(Layer.prototype, "clearStencilBuffer", {
		get: function () {
			return this._clearStencilBuffer;
		},
		set: function (val) {
			this._clearStencilBuffer = val;
			this._updateClearFlags();
		}
	});
	Layer.prototype.incrementCounter = function () {
		if (this._refCounter === 0) {
			this._enabled = true;
			if (this.onEnable) this.onEnable();
		}
		this._refCounter++;
	};
	Layer.prototype.decrementCounter = function () {
		if (this._refCounter === 1) {
			this._enabled = false;
			if (this.onDisable) this.onDisable();
		} else if (this._refCounter === 0) {
			return;
		}
		this._refCounter--;
	};
	Layer.prototype.addMeshInstances = function (meshInstances, skipShadowCasters) {
		var sceneShaderVer = this._shaderVersion;
		var m, arr, mat;
		var casters = this.shadowCasters;
		for (var i = 0; i < meshInstances.length; i++) {
			m = meshInstances[i];
			mat = m.material;
			if (mat.blendType === BLEND_NONE) {
				arr = this.opaqueMeshInstances;
			} else {
				arr = this.transparentMeshInstances;
			}
			if (arr.indexOf(m) < 0) arr.push(m);
			if (!skipShadowCasters && m.castShadow && casters.indexOf(m) < 0) casters.push(m);
			if (!this.passThrough && sceneShaderVer >= 0 && mat._shaderVersion !== sceneShaderVer) {
				if (mat.updateShader !== Material.prototype.updateShader) {
					mat.clearVariants();
					mat.shader = null;
				}
				mat._shaderVersion = sceneShaderVer;
			}
		}
		if (!this.passThrough) this._dirty = true;
	};
	Layer.prototype.removeMeshInstances = function (meshInstances, skipShadowCasters) {
		var i, j, m, spliceOffset, spliceCount, len, drawCall;
		var opaque = this.opaqueMeshInstances;
		var transparent = this.transparentMeshInstances;
		var casters = this.shadowCasters;
		for (i = 0; i < meshInstances.length; i++) {
			m = meshInstances[i];
			spliceOffset = -1;
			spliceCount = 0;
			len = opaque.length;
			for (j = 0; j < len; j++) {
				drawCall = opaque[j];
				if (drawCall === m) {
					spliceOffset = j;
					spliceCount = 1;
					break;
				}
				if (drawCall._staticSource === m) {
					if (spliceOffset < 0) spliceOffset = j;
					spliceCount++;
				} else if (spliceOffset >= 0) {
					break;
				}
			}
			if (spliceOffset >= 0) opaque.splice(spliceOffset, spliceCount);
			spliceOffset = -1;
			spliceCount = 0;
			len = transparent.length;
			for (j = 0; j < len; j++) {
				drawCall = transparent[j];
				if (drawCall === m) {
					spliceOffset = j;
					spliceCount = 1;
					break;
				}
				if (drawCall._staticSource === m) {
					if (spliceOffset < 0) spliceOffset = j;
					spliceCount++;
				} else if (spliceOffset >= 0) {
					break;
				}
			}
			if (spliceOffset >= 0) transparent.splice(spliceOffset, spliceCount);
			if (skipShadowCasters) continue;
			j = casters.indexOf(m);
			if (j >= 0) casters.splice(j, 1);
		}
		this._dirty = true;
	};
	Layer.prototype.clearMeshInstances = function (skipShadowCasters) {
		if (this.opaqueMeshInstances.length === 0 && this.transparentMeshInstances.length === 0) {
			if (skipShadowCasters || this.shadowCasters.length === 0) return;
		}
		this.opaqueMeshInstances.length = 0;
		this.transparentMeshInstances.length = 0;
		if (!skipShadowCasters) this.shadowCasters.length = 0;
		if (!this.passThrough) this._dirty = true;
	};
	Layer.prototype.addLight = function (light) {
		if (this._lightComponents.indexOf(light) >= 0) return;
		this._lightComponents.push(light);
		this._lights.push(light.light);
		this._dirtyLights = true;
		this._generateLightHash();
	};
	Layer.prototype.removeLight = function (light) {
		var id = this._lightComponents.indexOf(light);
		if (id < 0) return;
		this._lightComponents.splice(id, 1);
		id = this._lights.indexOf(light.light);
		this._lights.splice(id, 1);
		this._dirtyLights = true;
		this._generateLightHash();
	};
	Layer.prototype.clearLights = function () {
		this._lightComponents.length = 0;
		this._lights.length = 0;
		this._dirtyLights = true;
	};
	Layer.prototype.addShadowCasters = function (meshInstances) {
		var m;
		var arr = this.shadowCasters;
		for (var i = 0; i < meshInstances.length; i++) {
			m = meshInstances[i];
			if (!m.castShadow) continue;
			if (arr.indexOf(m) < 0) arr.push(m);
		}
		this._dirtyLights = true;
	};
	Layer.prototype.removeShadowCasters = function (meshInstances) {
		var id;
		var arr = this.shadowCasters;
		for (var i = 0; i < meshInstances.length; i++) {
			id = arr.indexOf(meshInstances[i]);
			if (id >= 0) arr.splice(id, 1);
		}
		this._dirtyLights = true;
	};
	Layer.prototype._generateLightHash = function () {
		if (this._lights.length > 0) {
			this._lights.sort(sortLights);
			var str = "";
			var strStatic = "";
			for (var i = 0; i < this._lights.length; i++) {
				if (this._lights[i].isStatic) {
					strStatic += this._lights[i].key;
				} else {
					str += this._lights[i].key;
				}
			}
			if (str.length === 0) {
				this._lightHash = 0;
			} else {
				this._lightHash = hashCode(str);
			}
			if (strStatic.length === 0) {
				this._staticLightHash = 0;
			} else {
				this._staticLightHash = hashCode(strStatic);
			}
		} else {
			this._lightHash = 0;
			this._staticLightHash = 0;
		}
	};
	Layer.prototype._generateCameraHash = function () {
		if (this.cameras.length > 1) {
			this.cameras.sort(sortCameras);
			var str = "";
			for (var i = 0; i < this.cameras.length; i++) {
				str += this.cameras[i].entity.getGuid();
			}
			this._cameraHash = hashCode(str);
		} else {
			this._cameraHash = 0;
		}
		this._dirtyCameras = true;
	};
	Layer.prototype.addCamera = function (camera) {
		if (this.cameras.indexOf(camera) >= 0) return;
		this.cameras.push(camera);
		this._generateCameraHash();
	};
	Layer.prototype.removeCamera = function (camera) {
		var id = this.cameras.indexOf(camera);
		if (id < 0) return;
		this.cameras.splice(id, 1);
		this._generateCameraHash();
		this.instances.clearVisibleLists(id);
	};
	Layer.prototype.clearCameras = function () {
		this.cameras.length = 0;
		this._cameraHash = 0;
		this._dirtyCameras = true;
	};
	Layer.prototype._sortCameras = function () {
		this._generateCameraHash();
	};
	Layer.prototype._calculateSortDistances = function (drawCalls, drawCallsCount, camPos, camFwd) {
		var i, drawCall, meshPos;
		var tempx, tempy, tempz;
		for (i = 0; i < drawCallsCount; i++) {
			drawCall = drawCalls[i];
			if (drawCall.command) continue;
			if (drawCall.layer <= LAYER_FX) continue;
			if (drawCall.calculateSortDistance) {
				drawCall.zdist = drawCall.calculateSortDistance(drawCall, camPos, camFwd);
				continue;
			}
			meshPos = drawCall.aabb.center;
			tempx = meshPos.x - camPos.x;
			tempy = meshPos.y - camPos.y;
			tempz = meshPos.z - camPos.z;
			drawCall.zdist = tempx * camFwd.x + tempy * camFwd.y + tempz * camFwd.z;
		}
	};
	Layer.prototype._sortVisible = function (transparent, cameraNode, cameraPass) {
		var objects = this.instances;
		var sortMode = transparent ? this.transparentSortMode : this.opaqueSortMode;
		if (sortMode === SORTMODE_NONE) return;
		var visible = transparent ? objects.visibleTransparent[cameraPass] : objects.visibleOpaque[cameraPass];
		if (sortMode === SORTMODE_CUSTOM) {
			sortPos = cameraNode.getPosition();
			sortDir = cameraNode.forward;
			if (this.customCalculateSortValues) {
				this.customCalculateSortValues(visible.list, visible.length, sortPos, sortDir);
			}
			if (visible.list.length !== visible.length) {
				visible.list.length = visible.length;
			}
			if (this.customSortCallback) {
				visible.list.sort(this.customSortCallback);
			}
		} else {
			if (sortMode === SORTMODE_BACK2FRONT || sortMode === SORTMODE_FRONT2BACK) {
				sortPos = cameraNode.getPosition();
				sortDir = cameraNode.forward;
				this._calculateSortDistances(visible.list, visible.length, sortPos, sortDir);
			}
			if (visible.list.length !== visible.length) {
				visible.list.length = visible.length;
			}
			visible.list.sort(sortCallbacks[sortMode]);
		}
	};

	var scaleShift = new Mat4().mul2(
		new Mat4().setTranslate(0.5, 0.5, 0.5),
		new Mat4().setScale(0.5, 0.5, 0.5)
	);
	var opChanId = { r: 1, g: 2, b: 3, a: 4 };
	var pointLightRotations = [
		new Quat().setFromEulerAngles(0, 90, 180),
		new Quat().setFromEulerAngles(0, -90, 180),
		new Quat().setFromEulerAngles(90, 0, 0),
		new Quat().setFromEulerAngles(-90, 0, 0),
		new Quat().setFromEulerAngles(0, 180, 180),
		new Quat().setFromEulerAngles(0, 0, 180)
	];
	var numShadowModes = 5;
	var shadowMapCache = [{}, {}, {}, {}, {}];
	var directionalShadowEpsilon = 0.01;
	var pixelOffset = new Float32Array(2);
	var blurScissorRect = { x: 1, y: 1, z: 0, w: 0 };
	var shadowCamView = new Mat4();
	var shadowCamViewProj = new Mat4();
	var c2sc = new Mat4();
	var viewInvMat = new Mat4();
	var viewMat = new Mat4();
	var viewMat3 = new Mat3();
	var viewProjMat = new Mat4();
	var projMat;
	var viewInvL = new Mat4();
	var viewInvR = new Mat4();
	var viewL = new Mat4();
	var viewR = new Mat4();
	var viewPosL = new Vec3();
	var viewPosR = new Vec3();
	var projL, projR;
	var viewMat3L = new Mat4();
	var viewMat3R = new Mat4();
	var viewProjMatL = new Mat4();
	var viewProjMatR = new Mat4();
	var worldMatX$1 = new Vec3();
	var worldMatY$1 = new Vec3();
	var worldMatZ$1 = new Vec3();
	var frustumDiagonal = new Vec3();
	var tempSphere = { center: null, radius: 0 };
	var meshPos;
	var visibleSceneAabb = new BoundingBox();
	var boneTextureSize = [0, 0, 0, 0];
	var boneTexture, instancingData, modelMatrix, normalMatrix;
	var shadowMapCubeCache = {};
	var maxBlurSize = 25;
	var keyA$1, keyB$1;
	var _autoInstanceBuffer = null;
	var frustumPoints = [];
	for (var fp = 0; fp < 8; fp++) {
		frustumPoints.push(new Vec3());
	}
	function _getFrustumPoints(camera, farClip, points) {
		var nearClip = camera._nearClip;
		var fov = camera._fov * Math.PI / 180.0;
		var aspect = camera._aspectRatio;
		var projection = camera._projection;
		var x, y;
		if (projection === PROJECTION_PERSPECTIVE) {
			y = Math.tan(fov / 2.0) * nearClip;
		} else {
			y = camera._orthoHeight;
		}
		x = y * aspect;
		points[0].x = x;
		points[0].y = -y;
		points[0].z = -nearClip;
		points[1].x = x;
		points[1].y = y;
		points[1].z = -nearClip;
		points[2].x = -x;
		points[2].y = y;
		points[2].z = -nearClip;
		points[3].x = -x;
		points[3].y = -y;
		points[3].z = -nearClip;
		if (projection === PROJECTION_PERSPECTIVE) {
			y = Math.tan(fov / 2.0) * farClip;
			x = y * aspect;
		}
		points[4].x = x;
		points[4].y = -y;
		points[4].z = -farClip;
		points[5].x = x;
		points[5].y = y;
		points[5].z = -farClip;
		points[6].x = -x;
		points[6].y = y;
		points[6].z = -farClip;
		points[7].x = -x;
		points[7].y = -y;
		points[7].z = -farClip;
		return points;
	}
	var _sceneAABB_LS = [
		new Vec3(), new Vec3(), new Vec3(), new Vec3(),
		new Vec3(), new Vec3(), new Vec3(), new Vec3()
	];
	function _getZFromAABBSimple(w2sc, aabbMin, aabbMax, lcamMinX, lcamMaxX, lcamMinY, lcamMaxY) {
		_sceneAABB_LS[0].x = _sceneAABB_LS[1].x = _sceneAABB_LS[2].x = _sceneAABB_LS[3].x = aabbMin.x;
		_sceneAABB_LS[1].y = _sceneAABB_LS[3].y = _sceneAABB_LS[7].y = _sceneAABB_LS[5].y = aabbMin.y;
		_sceneAABB_LS[2].z = _sceneAABB_LS[3].z = _sceneAABB_LS[6].z = _sceneAABB_LS[7].z = aabbMin.z;
		_sceneAABB_LS[4].x = _sceneAABB_LS[5].x = _sceneAABB_LS[6].x = _sceneAABB_LS[7].x = aabbMax.x;
		_sceneAABB_LS[0].y = _sceneAABB_LS[2].y = _sceneAABB_LS[4].y = _sceneAABB_LS[6].y = aabbMax.y;
		_sceneAABB_LS[0].z = _sceneAABB_LS[1].z = _sceneAABB_LS[4].z = _sceneAABB_LS[5].z = aabbMax.z;
		var minz = 9999999999;
		var maxz = -9999999999;
		var z;
		for ( var i = 0; i < 8; ++i ) {
			w2sc.transformPoint( _sceneAABB_LS[i], _sceneAABB_LS[i] );
			z = _sceneAABB_LS[i].z;
			if (z < minz) minz = z;
			if (z > maxz) maxz = z;
		}
		return { min: minz, max: maxz };
	}
	function getShadowFormat(device, shadowType) {
		if (shadowType === SHADOW_VSM32) {
			return PIXELFORMAT_RGBA32F;
		} else if (shadowType === SHADOW_VSM16) {
			return PIXELFORMAT_RGBA16F;
		} else if (shadowType === SHADOW_PCF5) {
			return PIXELFORMAT_DEPTH;
		} else if (shadowType === SHADOW_PCF3 && device.webgl2) {
			return PIXELFORMAT_DEPTH;
		}
		return PIXELFORMAT_R8_G8_B8_A8;
	}
	function getShadowFiltering(device, shadowType) {
		if (shadowType === SHADOW_PCF3 && !device.webgl2) {
			return FILTER_NEAREST;
		} else if (shadowType === SHADOW_VSM32) {
			return device.extTextureFloatLinear ? FILTER_LINEAR : FILTER_NEAREST;
		} else if (shadowType === SHADOW_VSM16) {
			return device.extTextureHalfFloatLinear ? FILTER_LINEAR : FILTER_NEAREST;
		}
		return FILTER_LINEAR;
	}
	function createShadowMap(device, width, height, shadowType) {
		var format = getShadowFormat(device, shadowType);
		var filter = getShadowFiltering(device, shadowType);
		var shadowMap = new Texture(device, {
			format: format,
			width: width,
			height: height,
			mipmaps: false,
			minFilter: filter,
			magFilter: filter,
			addressU: ADDRESS_CLAMP_TO_EDGE,
			addressV: ADDRESS_CLAMP_TO_EDGE
		});
		shadowMap.name = 'shadowmap';
		if (shadowType === SHADOW_PCF5 || (shadowType === SHADOW_PCF3 && device.webgl2)) {
			shadowMap.compareOnRead = true;
			shadowMap.compareFunc = FUNC_LESS;
			return new RenderTarget({
				depthBuffer: shadowMap
			});
		}
		return new RenderTarget({
			colorBuffer: shadowMap,
			depth: true
		});
	}
	function createShadowCubeMap(device, size) {
		var cubemap = new Texture(device, {
			format: PIXELFORMAT_R8_G8_B8_A8,
			width: size,
			height: size,
			cubemap: true,
			mipmaps: false,
			minFilter: FILTER_NEAREST,
			magFilter: FILTER_NEAREST,
			addressU: ADDRESS_CLAMP_TO_EDGE,
			addressV: ADDRESS_CLAMP_TO_EDGE
		});
		cubemap.name = 'shadowcube';
		var targets = [];
		var target;
		for (var i = 0; i < 6; i++) {
			target = new RenderTarget({
				colorBuffer: cubemap,
				face: i,
				depth: true
			});
			targets.push(target);
		}
		return targets;
	}
	function gauss(x, sigma) {
		return Math.exp(-(x * x) / (2.0 * sigma * sigma));
	}
	function gaussWeights(kernelSize) {
		if (kernelSize > maxBlurSize) kernelSize = maxBlurSize;
		var sigma = (kernelSize - 1) / (2 * 3);
		var i, values, sum, halfWidth;
		halfWidth = (kernelSize - 1) * 0.5;
		values = new Array(kernelSize);
		sum = 0.0;
		for (i = 0; i < kernelSize; ++i) {
			values[i] = gauss(i - halfWidth, sigma);
			sum += values[i];
		}
		for (i = 0; i < kernelSize; ++i) {
			values[i] /= sum;
		}
		return values;
	}
	function createShadowCamera(device, shadowType, type) {
		var hwPcf = shadowType === SHADOW_PCF5 || (shadowType === SHADOW_PCF3 && device.webgl2);
		if (type === LIGHTTYPE_POINT) {
			hwPcf = false;
		}
		var shadowCam = new Camera();
		if (shadowType >= SHADOW_VSM8 && shadowType <= SHADOW_VSM32) {
			shadowCam.clearColor = new Color(0, 0, 0, 0);
		} else {
			shadowCam.clearColor = new Color(1, 1, 1, 1);
		}
		shadowCam.clearColorBuffer = !hwPcf;
		shadowCam.clearDepthBuffer = true;
		shadowCam.clearStencilBuffer = false;
		shadowCam.node = new GraphNode();
		return shadowCam;
	}
	function getShadowMapFromCache(device, res, mode, layer) {
		if (!layer) layer = 0;
		var id = layer * 10000 + res;
		var shadowBuffer = shadowMapCache[mode][id];
		if (!shadowBuffer) {
			shadowBuffer = createShadowMap(device, res, res, mode ? mode : SHADOW_PCF3);
			shadowMapCache[mode][id] = shadowBuffer;
		}
		return shadowBuffer;
	}
	function createShadowBuffer(device, light) {
		var shadowBuffer;
		if (light._type === LIGHTTYPE_POINT) {
			if (light._shadowType > SHADOW_PCF3) light._shadowType = SHADOW_PCF3;
			if (light._cacheShadowMap) {
				shadowBuffer = shadowMapCubeCache[light._shadowResolution];
				if (!shadowBuffer) {
					shadowBuffer = createShadowCubeMap(device, light._shadowResolution);
					shadowMapCubeCache[light._shadowResolution] = shadowBuffer;
				}
			} else {
				shadowBuffer = createShadowCubeMap(device, light._shadowResolution);
			}
			light._shadowCamera.renderTarget = shadowBuffer[0];
			light._shadowCubeMap = shadowBuffer;
		} else {
			if (light._cacheShadowMap) {
				shadowBuffer = getShadowMapFromCache(device, light._shadowResolution, light._shadowType);
			} else {
				shadowBuffer = createShadowMap(device, light._shadowResolution, light._shadowResolution, light._shadowType);
			}
			light._shadowCamera.renderTarget = shadowBuffer;
		}
		light._isCachedShadowMap = light._cacheShadowMap;
	}
	function getDepthKey(meshInstance) {
		var material = meshInstance.material;
		var x = meshInstance.skinInstance ? 10 : 0;
		var y = 0;
		if (material.opacityMap) {
			var opChan = material.opacityMapChannel;
			if (opChan) {
				y = opChanId[opChan];
			}
		}
		return x + y;
	}
	function ForwardRenderer(graphicsDevice) {
		this.device = graphicsDevice;
		var device = this.device;
		this._shadowDrawCalls = 0;
		this._forwardDrawCalls = 0;
		this._skinDrawCalls = 0;
		this._camerasRendered = 0;
		this._materialSwitches = 0;
		this._shadowMapUpdates = 0;
		this._shadowMapTime = 0;
		this._depthMapTime = 0;
		this._forwardTime = 0;
		this._cullTime = 0;
		this._sortTime = 0;
		this._skinTime = 0;
		this._morphTime = 0;
		this._instancingTime = 0;
		var library = device.getProgramLibrary();
		this.library = library;
		var scope = device.scope;
		this.projId = scope.resolve('matrix_projection');
		this.projSkyboxId = scope.resolve('matrix_projectionSkybox');
		this.viewId = scope.resolve('matrix_view');
		this.viewId3 = scope.resolve('matrix_view3');
		this.viewInvId = scope.resolve('matrix_viewInverse');
		this.viewProjId = scope.resolve('matrix_viewProjection');
		this.viewPos = new Float32Array(3);
		this.viewPosId = scope.resolve('view_position');
		this.nearClipId = scope.resolve('camera_near');
		this.farClipId = scope.resolve('camera_far');
		this.cameraParamsId = scope.resolve('camera_params');
		this.shadowMapLightRadiusId = scope.resolve('light_radius');
		this.fogColorId = scope.resolve('fog_color');
		this.fogStartId = scope.resolve('fog_start');
		this.fogEndId = scope.resolve('fog_end');
		this.fogDensityId = scope.resolve('fog_density');
		this.modelMatrixId = scope.resolve('matrix_model');
		this.normalMatrixId = scope.resolve('matrix_normal');
		this.poseMatrixId = scope.resolve('matrix_pose[0]');
		this.boneTextureId = scope.resolve('texture_poseMap');
		this.boneTextureSizeId = scope.resolve('texture_poseMapSize');
		this.morphWeightsA = scope.resolve('morph_weights_a');
		this.morphWeightsB = scope.resolve('morph_weights_b');
		this.morphPositionTex = scope.resolve('morphPositionTex');
		this.morphNormalTex = scope.resolve('morphNormalTex');
		this.morphTexParams = scope.resolve('morph_tex_params');
		this.alphaTestId = scope.resolve('alpha_ref');
		this.opacityMapId = scope.resolve('texture_opacityMap');
		this.ambientId = scope.resolve("light_globalAmbient");
		this.exposureId = scope.resolve("exposure");
		this.skyboxIntensityId = scope.resolve("skyboxIntensity");
		this.lightColorId = [];
		this.lightDir = [];
		this.lightDirId = [];
		this.lightShadowMapId = [];
		this.lightShadowMatrixId = [];
		this.lightShadowParamsId = [];
		this.lightShadowMatrixVsId = [];
		this.lightShadowParamsVsId = [];
		this.lightDirVs = [];
		this.lightDirVsId = [];
		this.lightRadiusId = [];
		this.lightPos = [];
		this.lightPosId = [];
		this.lightInAngleId = [];
		this.lightOutAngleId = [];
		this.lightPosVsId = [];
		this.lightCookieId = [];
		this.lightCookieIntId = [];
		this.lightCookieMatrixId = [];
		this.lightCookieOffsetId = [];
		this.depthMapId = scope.resolve('uDepthMap');
		this.screenSizeId = scope.resolve('uScreenSize');
		this._screenSize = new Float32Array(4);
		this.sourceId = scope.resolve("source");
		this.pixelOffsetId = scope.resolve("pixelOffset");
		this.weightId = scope.resolve("weight[0]");
		this.blurVsmShaderCode = [shaderChunks.blurVSMPS, "#define GAUSS\n" + shaderChunks.blurVSMPS];
		var packed = "#define PACKED\n";
		this.blurPackedVsmShaderCode = [packed + this.blurVsmShaderCode[0], packed + this.blurVsmShaderCode[1]];
		this.blurVsmShader = [{}, {}];
		this.blurPackedVsmShader = [{}, {}];
		this.blurVsmWeights = {};
		this.polygonOffsetId = scope.resolve("polygonOffset");
		this.polygonOffset = new Float32Array(2);
		this.fogColor = new Float32Array(3);
		this.ambientColor = new Float32Array(3);
		this.cameraParams = new Float32Array(4);
	}
	function mat3FromMat4(m3, m4) {
		m3.data[0] = m4.data[0];
		m3.data[1] = m4.data[1];
		m3.data[2] = m4.data[2];
		m3.data[3] = m4.data[4];
		m3.data[4] = m4.data[5];
		m3.data[5] = m4.data[6];
		m3.data[6] = m4.data[8];
		m3.data[7] = m4.data[9];
		m3.data[8] = m4.data[10];
	}
	Object.assign(ForwardRenderer.prototype, {
		sortCompare: function (drawCallA, drawCallB) {
			if (drawCallA.layer === drawCallB.layer) {
				if (drawCallA.drawOrder && drawCallB.drawOrder) {
					return drawCallA.drawOrder - drawCallB.drawOrder;
				} else if (drawCallA.zdist && drawCallB.zdist) {
					return drawCallB.zdist - drawCallA.zdist;
				} else if (drawCallA.zdist2 && drawCallB.zdist2) {
					return drawCallA.zdist2 - drawCallB.zdist2;
				}
			}
			return drawCallB._key[SORTKEY_FORWARD] - drawCallA._key[SORTKEY_FORWARD];
		},
		sortCompareMesh: function (drawCallA, drawCallB) {
			if (drawCallA.layer === drawCallB.layer) {
				if (drawCallA.drawOrder && drawCallB.drawOrder) {
					return drawCallA.drawOrder - drawCallB.drawOrder;
				} else if (drawCallA.zdist && drawCallB.zdist) {
					return drawCallB.zdist - drawCallA.zdist;
				}
			}
			keyA$1 = drawCallA._key[SORTKEY_FORWARD];
			keyB$1 = drawCallB._key[SORTKEY_FORWARD];
			if (keyA$1 === keyB$1 && drawCallA.mesh && drawCallB.mesh) {
				return drawCallB.mesh.id - drawCallA.mesh.id;
			}
			return keyB$1 - keyA$1;
		},
		depthSortCompare: function (drawCallA, drawCallB) {
			keyA$1 = drawCallA._key[SORTKEY_DEPTH];
			keyB$1 = drawCallB._key[SORTKEY_DEPTH];
			if (keyA$1 === keyB$1 && drawCallA.mesh && drawCallB.mesh) {
				return drawCallB.mesh.id - drawCallA.mesh.id;
			}
			return keyB$1 - keyA$1;
		},
		lightCompare: function (lightA, lightB) {
			return lightA.key - lightB.key;
		},
		_isVisible: function (camera, meshInstance) {
			if (!meshInstance.visible) return false;
			if (meshInstance.isVisibleFunc) {
				return meshInstance.isVisibleFunc(camera);
			}
			meshPos = meshInstance.aabb.center;
			if (meshInstance._aabb._radiusVer !== meshInstance._aabbVer) {
				meshInstance._aabb._radius = meshInstance._aabb.halfExtents.length();
				meshInstance._aabb._radiusVer = meshInstance._aabbVer;
			}
			tempSphere.radius = meshInstance._aabb._radius;
			tempSphere.center = meshPos;
			return camera.frustum.containsSphere(tempSphere);
		},
		getShadowCamera: function (device, light) {
			var shadowCam = light._shadowCamera;
			var shadowBuffer;
			if (shadowCam === null) {
				shadowCam = light._shadowCamera = createShadowCamera(device, light._shadowType, light._type);
				createShadowBuffer(device, light);
			} else {
				shadowBuffer = shadowCam.renderTarget;
				if ((shadowBuffer.width !== light._shadowResolution) || (shadowBuffer.height !== light._shadowResolution)) {
					createShadowBuffer(device, light);
				}
			}
			return shadowCam;
		},
		updateCameraFrustum: function (camera) {
			if (camera.vrDisplay && camera.vrDisplay.presenting) {
				projMat = camera.vrDisplay.combinedProj;
				var parent = camera._node.parent;
				if (parent) {
					viewMat.copy(parent.getWorldTransform()).mul(camera.vrDisplay.combinedViewInv).invert();
				} else {
					viewMat.copy(camera.vrDisplay.combinedView);
				}
				viewInvMat.copy(viewMat).invert();
				this.viewInvId.setValue(viewInvMat.data);
				viewProjMat.mul2(projMat, viewMat);
				camera.frustum.setFromMat4(viewProjMat);
			} else if (camera.xr && camera.xr.views.length) {
				var view = camera.xr.views[0];
				viewProjMat.mul2(view.projMat, view.viewOffMat);
				camera.frustum.setFromMat4(viewProjMat);
				return;
			}
			projMat = camera.projectionMatrix;
			if (camera.calculateProjection) {
				camera.calculateProjection(projMat, VIEW_CENTER);
			}
			if (camera.calculateTransform) {
				camera.calculateTransform(viewInvMat, VIEW_CENTER);
			} else {
				var pos = camera._node.getPosition();
				var rot = camera._node.getRotation();
				viewInvMat.setTRS(pos, rot, Vec3.ONE);
				this.viewInvId.setValue(viewInvMat.data);
			}
			viewMat.copy(viewInvMat).invert();
			viewProjMat.mul2(projMat, viewMat);
			camera.frustum.setFromMat4(viewProjMat);
		},
		setCamera: function (camera, target, clear, cullBorder) {
			var vrDisplay = camera.vrDisplay;
			var parent, transform;
			if (vrDisplay && vrDisplay.presenting) {
				projL = vrDisplay.leftProj;
				projR = vrDisplay.rightProj;
				projMat = vrDisplay.combinedProj;
				if (camera.calculateProjection) {
					camera.calculateProjection(projL, VIEW_LEFT);
					camera.calculateProjection(projR, VIEW_RIGHT);
					camera.calculateProjection(projMat, VIEW_CENTER);
				}
				if (camera.calculateTransform) {
					camera.calculateTransform(viewInvL, VIEW_LEFT);
					camera.calculateTransform(viewInvR, VIEW_RIGHT);
					camera.calculateTransform(viewInvMat, VIEW_CENTER);
					viewL.copy(viewInvL).invert();
					viewR.copy(viewInvR).invert();
					viewMat.copy(viewInvMat).invert();
				} else {
					parent = camera._node.parent;
					if (parent) {
						transform = parent.getWorldTransform();
						viewInvL.mul2(transform, vrDisplay.leftViewInv);
						viewInvR.mul2(transform, vrDisplay.rightViewInv);
						viewL.copy(viewInvL).invert();
						viewR.copy(viewInvR).invert();
						viewMat.copy(parent.getWorldTransform()).mul(vrDisplay.combinedViewInv).invert();
					} else {
						viewInvL.copy(vrDisplay.leftViewInv);
						viewInvR.copy(vrDisplay.rightViewInv);
						viewL.copy(vrDisplay.leftView);
						viewR.copy(vrDisplay.rightView);
						viewMat.copy(vrDisplay.combinedView);
					}
				}
				mat3FromMat4(viewMat3L, viewL);
				mat3FromMat4(viewMat3R, viewR);
				viewProjMatL.mul2(projL, viewL);
				viewProjMatR.mul2(projR, viewR);
				viewPosL.x = viewInvL.data[12];
				viewPosL.y = viewInvL.data[13];
				viewPosL.z = viewInvL.data[14];
				viewPosR.x = viewInvR.data[12];
				viewPosR.y = viewInvR.data[13];
				viewPosR.z = viewInvR.data[14];
				viewProjMat.mul2(projMat, viewMat);
				camera.frustum.setFromMat4(viewProjMat);
			} else if (camera.xr && camera.xr.session) {
				parent = camera._node.parent;
				if (parent) transform = parent.getWorldTransform();
				var views = camera.xr.views;
				for (var v = 0; v < views.length; v++) {
					var view = views[v];
					if (parent) {
						view.viewInvOffMat.mul2(transform, view.viewInvMat);
						view.viewOffMat.copy(view.viewInvOffMat).invert();
					} else {
						view.viewInvOffMat.copy(view.viewInvMat);
						view.viewOffMat.copy(view.viewMat);
					}
					mat3FromMat4(view.viewMat3, view.viewOffMat);
					view.projViewOffMat.mul2(view.projMat, view.viewOffMat);
					view.position[0] = view.viewInvOffMat.data[12];
					view.position[1] = view.viewInvOffMat.data[13];
					view.position[2] = view.viewInvOffMat.data[14];
					camera.frustum.setFromMat4(view.projViewOffMat);
				}
			} else {
				projMat = camera.projectionMatrix;
				if (camera.calculateProjection) {
					camera.calculateProjection(projMat, VIEW_CENTER);
				}
				this.projId.setValue(projMat.data);
				this.projSkyboxId.setValue(camera.getProjectionMatrixSkybox().data);
				if (camera.calculateTransform) {
					camera.calculateTransform(viewInvMat, VIEW_CENTER);
				} else {
					var pos = camera._node.getPosition();
					var rot = camera._node.getRotation();
					viewInvMat.setTRS(pos, rot, Vec3.ONE);
				}
				this.viewInvId.setValue(viewInvMat.data);
				viewMat.copy(viewInvMat).invert();
				this.viewId.setValue(viewMat.data);
				mat3FromMat4(viewMat3, viewMat);
				this.viewId3.setValue(viewMat3.data);
				viewProjMat.mul2(projMat, viewMat);
				this.viewProjId.setValue(viewProjMat.data);
				var cameraPos = camera._node.getPosition();
				this.viewPos[0] = cameraPos.x;
				this.viewPos[1] = cameraPos.y;
				this.viewPos[2] = cameraPos.z;
				this.viewPosId.setValue(this.viewPos);
				camera.frustum.setFromMat4(viewProjMat);
			}
			this.nearClipId.setValue(camera._nearClip);
			this.farClipId.setValue(camera._farClip);
			var n = camera._nearClip;
			var f = camera._farClip;
			this.cameraParams[0] = 1 / f;
			this.cameraParams[1] = f;
			this.cameraParams[2] = (1 - f / n) * 0.5;
			this.cameraParams[3] = (1 + f / n) * 0.5;
			this.cameraParamsId.setValue(this.cameraParams);
			this.clearView(camera, target, clear, false);
			var device = this.device;
			var pixelWidth = target ? target.width : device.width;
			var pixelHeight = target ? target.height : device.height;
			var scissorRect = camera.scissorRect;
			var x = Math.floor(scissorRect.x * pixelWidth);
			var y = Math.floor(scissorRect.y * pixelHeight);
			var w = Math.floor(scissorRect.z * pixelWidth);
			var h = Math.floor(scissorRect.w * pixelHeight);
			device.setScissor(x, y, w, h);
			if (cullBorder) device.setScissor(1, 1, pixelWidth - 2, pixelHeight - 2);
		},
		clearView: function (camera, target, clear, forceWrite, options) {
			var device = this.device;
			device.setRenderTarget(target);
			device.updateBegin();
			if (forceWrite) {
				device.setColorWrite(true, true, true, true);
				device.setDepthWrite(true);
			}
			var rect = camera.rect;
			var pixelWidth = target ? target.width : device.width;
			var pixelHeight = target ? target.height : device.height;
			var x = Math.floor(rect.x * pixelWidth);
			var y = Math.floor(rect.y * pixelHeight);
			var w = Math.floor(rect.z * pixelWidth);
			var h = Math.floor(rect.w * pixelHeight);
			device.setViewport(x, y, w, h);
			device.setScissor(x, y, w, h);
			if (clear) {
				device.clear(options ? options : {
					color: [camera._clearColor.r, camera._clearColor.g, camera._clearColor.b, camera._clearColor.a],
					depth: camera._clearDepth,
					flags: (camera._clearColorBuffer ? CLEARFLAG_COLOR : 0) |
						   (camera._clearDepthBuffer ? CLEARFLAG_DEPTH : 0) |
						   (camera._clearStencilBuffer ? CLEARFLAG_STENCIL : 0),
					stencil: camera._clearStencil
				});
			}
		},
		dispatchGlobalLights: function (scene) {
			var i;
			this.mainLight = -1;
			this.ambientColor[0] = scene.ambientLight.r;
			this.ambientColor[1] = scene.ambientLight.g;
			this.ambientColor[2] = scene.ambientLight.b;
			if (scene.gammaCorrection) {
				for (i = 0; i < 3; i++) {
					this.ambientColor[i] = Math.pow(this.ambientColor[i], 2.2);
				}
			}
			this.ambientId.setValue(this.ambientColor);
			this.exposureId.setValue(scene.exposure);
			if (scene.skyboxModel) this.skyboxIntensityId.setValue(scene.skyboxIntensity);
		},
		_resolveLight: function (scope, i) {
			var light = "light" + i;
			this.lightColorId[i] = scope.resolve(light + "_color");
			this.lightDir[i] = new Float32Array(3);
			this.lightDirId[i] = scope.resolve(light + "_direction");
			this.lightShadowMapId[i] = scope.resolve(light + "_shadowMap");
			this.lightShadowMatrixId[i] = scope.resolve(light + "_shadowMatrix");
			this.lightShadowParamsId[i] = scope.resolve(light + "_shadowParams");
			this.lightShadowMatrixVsId[i] = scope.resolve(light + "_shadowMatrixVS");
			this.lightShadowParamsVsId[i] = scope.resolve(light + "_shadowParamsVS");
			this.lightDirVs[i] = new Float32Array(3);
			this.lightDirVsId[i] = scope.resolve(light + "_directionVS");
			this.lightRadiusId[i] = scope.resolve(light + "_radius");
			this.lightPos[i] = new Float32Array(3);
			this.lightPosId[i] = scope.resolve(light + "_position");
			this.lightInAngleId[i] = scope.resolve(light + "_innerConeAngle");
			this.lightOutAngleId[i] = scope.resolve(light + "_outerConeAngle");
			this.lightPosVsId[i] = scope.resolve(light + "_positionVS");
			this.lightCookieId[i] = scope.resolve(light + "_cookie");
			this.lightCookieIntId[i] = scope.resolve(light + "_cookieIntensity");
			this.lightCookieMatrixId[i] = scope.resolve(light + "_cookieMatrix");
			this.lightCookieOffsetId[i] = scope.resolve(light + "_cookieOffset");
		},
		dispatchDirectLights: function (dirs, scene, mask) {
			var numDirs = dirs.length;
			var i;
			var directional, wtm;
			var cnt = 0;
			this.mainLight = -1;
			var scope = this.device.scope;
			for (i = 0; i < numDirs; i++) {
				if (!(dirs[i].mask & mask)) continue;
				directional = dirs[i];
				wtm = directional._node.getWorldTransform();
				if (!this.lightColorId[cnt]) {
					this._resolveLight(scope, cnt);
				}
				this.lightColorId[cnt].setValue(scene.gammaCorrection ? directional._linearFinalColor : directional._finalColor);
				wtm.getY(directional._direction).scale(-1);
				directional._direction.normalize();
				this.lightDir[cnt][0] = directional._direction.x;
				this.lightDir[cnt][1] = directional._direction.y;
				this.lightDir[cnt][2] = directional._direction.z;
				this.lightDirId[cnt].setValue(this.lightDir[cnt]);
				if (directional.castShadows) {
					var shadowMap = directional._isPcf && this.device.webgl2 ?
						directional._shadowCamera.renderTarget.depthBuffer :
						directional._shadowCamera.renderTarget.colorBuffer;
					var bias;
					if (directional._isVsm) {
						bias = -0.00001 * 20;
					} else {
						bias = (directional.shadowBias / directional._shadowCamera._farClip) * 100;
						if (!this.device.webgl2 && this.device.extStandardDerivatives) bias *= -100;
					}
					var normalBias = directional._isVsm ?
						directional.vsmBias / (directional._shadowCamera._farClip / 7.0) :
						directional._normalOffsetBias;
					this.lightShadowMapId[cnt].setValue(shadowMap);
					this.lightShadowMatrixId[cnt].setValue(directional._shadowMatrix.data);
					var params = directional._rendererParams;
					if (params.length !== 3) params.length = 3;
					params[0] = directional._shadowResolution;
					params[1] = normalBias;
					params[2] = bias;
					this.lightShadowParamsId[cnt].setValue(params);
					if (this.mainLight < 0) {
						this.lightShadowMatrixVsId[cnt].setValue(directional._shadowMatrix.data);
						this.lightShadowParamsVsId[cnt].setValue(params);
						directional._direction.normalize();
						this.lightDirVs[cnt][0] = directional._direction.x;
						this.lightDirVs[cnt][1] = directional._direction.y;
						this.lightDirVs[cnt][2] = directional._direction.z;
						this.lightDirVsId[cnt].setValue(this.lightDirVs[cnt]);
						this.mainLight = i;
					}
				}
				cnt++;
			}
			return cnt;
		},
		dispatchPointLight: function (scene, scope, point, cnt) {
			var wtm = point._node.getWorldTransform();
			if (!this.lightColorId[cnt]) {
				this._resolveLight(scope, cnt);
			}
			this.lightRadiusId[cnt].setValue(point.attenuationEnd);
			this.lightColorId[cnt].setValue(scene.gammaCorrection ? point._linearFinalColor : point._finalColor);
			wtm.getTranslation(point._position);
			this.lightPos[cnt][0] = point._position.x;
			this.lightPos[cnt][1] = point._position.y;
			this.lightPos[cnt][2] = point._position.z;
			this.lightPosId[cnt].setValue(this.lightPos[cnt]);
			if (point.castShadows) {
				var shadowMap = point._shadowCamera.renderTarget.colorBuffer;
				this.lightShadowMapId[cnt].setValue(shadowMap);
				var params = point._rendererParams;
				if (params.length !== 4) params.length = 4;
				params[0] = point._shadowResolution;
				params[1] = point._normalOffsetBias;
				params[2] = point.shadowBias;
				params[3] = 1.0 / point.attenuationEnd;
				this.lightShadowParamsId[cnt].setValue(params);
			}
			if (point._cookie) {
				this.lightCookieId[cnt].setValue(point._cookie);
				this.lightShadowMatrixId[cnt].setValue(wtm.data);
				this.lightCookieIntId[cnt].setValue(point.cookieIntensity);
			}
		},
		dispatchSpotLight: function (scene, scope, spot, cnt) {
			var wtm = spot._node.getWorldTransform();
			if (!this.lightColorId[cnt]) {
				this._resolveLight(scope, cnt);
			}
			this.lightInAngleId[cnt].setValue(spot._innerConeAngleCos);
			this.lightOutAngleId[cnt].setValue(spot._outerConeAngleCos);
			this.lightRadiusId[cnt].setValue(spot.attenuationEnd);
			this.lightColorId[cnt].setValue(scene.gammaCorrection ? spot._linearFinalColor : spot._finalColor);
			wtm.getTranslation(spot._position);
			this.lightPos[cnt][0] = spot._position.x;
			this.lightPos[cnt][1] = spot._position.y;
			this.lightPos[cnt][2] = spot._position.z;
			this.lightPosId[cnt].setValue(this.lightPos[cnt]);
			wtm.getY(spot._direction).scale(-1);
			spot._direction.normalize();
			this.lightDir[cnt][0] = spot._direction.x;
			this.lightDir[cnt][1] = spot._direction.y;
			this.lightDir[cnt][2] = spot._direction.z;
			this.lightDirId[cnt].setValue(this.lightDir[cnt]);
			if (spot.castShadows) {
				var bias;
				if (spot._isVsm) {
					bias = -0.00001 * 20;
				} else {
					bias = spot.shadowBias * 20;
					if (!this.device.webgl2 && this.device.extStandardDerivatives) bias *= -100;
				}
				var normalBias = spot._isVsm ?
					spot.vsmBias / (spot.attenuationEnd / 7.0) :
					spot._normalOffsetBias;
				var shadowMap = spot._isPcf && this.device.webgl2 ?
					spot._shadowCamera.renderTarget.depthBuffer :
					spot._shadowCamera.renderTarget.colorBuffer;
				this.lightShadowMapId[cnt].setValue(shadowMap);
				this.lightShadowMatrixId[cnt].setValue(spot._shadowMatrix.data);
				var params = spot._rendererParams;
				if (params.length !== 4) params.length = 4;
				params[0] = spot._shadowResolution;
				params[1] = normalBias;
				params[2] = bias;
				params[3] = 1.0 / spot.attenuationEnd;
				this.lightShadowParamsId[cnt].setValue(params);
			}
			if (spot._cookie) {
				this.lightCookieId[cnt].setValue(spot._cookie);
				if (!spot.castShadows) {
					var shadowCam = this.getShadowCamera(this.device, spot);
					var shadowCamNode = shadowCam._node;
					shadowCamNode.setPosition(spot._node.getPosition());
					shadowCamNode.setRotation(spot._node.getRotation());
					shadowCamNode.rotateLocal(-90, 0, 0);
					shadowCam.projection = PROJECTION_PERSPECTIVE;
					shadowCam.aspectRatio = 1;
					shadowCam.fov = spot._outerConeAngle * 2;
					shadowCamView.setTRS(shadowCamNode.getPosition(), shadowCamNode.getRotation(), Vec3.ONE).invert();
					shadowCamViewProj.mul2(shadowCam.projectionMatrix, shadowCamView);
					spot._shadowMatrix.mul2(scaleShift, shadowCamViewProj);
				}
				this.lightShadowMatrixId[cnt].setValue(spot._shadowMatrix.data);
				this.lightCookieIntId[cnt].setValue(spot.cookieIntensity);
				if (spot._cookieTransform) {
					spot._cookieTransformUniform[0] = spot._cookieTransform.x;
					spot._cookieTransformUniform[1] = spot._cookieTransform.y;
					spot._cookieTransformUniform[2] = spot._cookieTransform.z;
					spot._cookieTransformUniform[3] = spot._cookieTransform.w;
					this.lightCookieMatrixId[cnt].setValue(spot._cookieTransformUniform);
					spot._cookieOffsetUniform[0] = spot._cookieOffset.x;
					spot._cookieOffsetUniform[1] = spot._cookieOffset.y;
					this.lightCookieOffsetId[cnt].setValue(spot._cookieOffsetUniform);
				}
			}
		},
		dispatchLocalLights: function (sortedLights, scene, mask, usedDirLights, staticLightList) {
			var i;
			var point, spot;
			var pnts = sortedLights[LIGHTTYPE_POINT];
			var spts = sortedLights[LIGHTTYPE_SPOT];
			var numDirs = usedDirLights;
			var numPnts = pnts.length;
			var numSpts = spts.length;
			var cnt = numDirs;
			var scope = this.device.scope;
			for (i = 0; i < numPnts; i++) {
				point = pnts[i];
				if (!(point.mask & mask)) continue;
				if (point.isStatic) continue;
				this.dispatchPointLight(scene, scope, point, cnt);
				cnt++;
			}
			var staticId = 0;
			if (staticLightList) {
				point = staticLightList[staticId];
				while (point && point._type === LIGHTTYPE_POINT) {
					this.dispatchPointLight(scene, scope, point, cnt);
					cnt++;
					staticId++;
					point = staticLightList[staticId];
				}
			}
			for (i = 0; i < numSpts; i++) {
				spot = spts[i];
				if (!(spot.mask & mask)) continue;
				if (spot.isStatic) continue;
				this.dispatchSpotLight(scene, scope, spot, cnt);
				cnt++;
			}
			if (staticLightList) {
				spot = staticLightList[staticId];
				while (spot && spot._type === LIGHTTYPE_SPOT) {
					this.dispatchSpotLight(scene, scope, spot, cnt);
					cnt++;
					staticId++;
					spot = staticLightList[staticId];
				}
			}
		},
		cull: function (camera, drawCalls, visibleList) {
			var visibleLength = 0;
			var i, drawCall, visible;
			var drawCallsCount = drawCalls.length;
			var cullingMask = camera.cullingMask || 0xFFFFFFFF;
			if (!camera.frustumCulling) {
				for (i = 0; i < drawCallsCount; i++) {
					drawCall = drawCalls[i];
					if (!drawCall.visible && !drawCall.command) continue;
					if (drawCall.mask && (drawCall.mask & cullingMask) === 0) continue;
					visibleList[visibleLength] = drawCall;
					visibleLength++;
					drawCall.visibleThisFrame = true;
				}
				return visibleLength;
			}
			for (i = 0; i < drawCallsCount; i++) {
				drawCall = drawCalls[i];
				if (!drawCall.command) {
					if (!drawCall.visible) continue;
					visible = true;
					if (drawCall.mask && (drawCall.mask & cullingMask) === 0) continue;
					if (drawCall.cull) {
						visible = this._isVisible(camera, drawCall);
					}
					if (visible) {
						visibleList[visibleLength] = drawCall;
						visibleLength++;
						drawCall.visibleThisFrame = true;
					}
				} else {
					visibleList[visibleLength] = drawCall;
					visibleLength++;
					drawCall.visibleThisFrame = true;
				}
			}
			return visibleLength;
		},
		cullLights: function (camera, lights) {
			var i, light, type;
			for (i = 0; i < lights.length; i++) {
				light = lights[i];
				type = light._type;
				if (light.castShadows && light.enabled && light.shadowUpdateMode !== SHADOWUPDATE_NONE) {
					if (type !== LIGHTTYPE_DIRECTIONAL) {
						light.getBoundingSphere(tempSphere);
						if (!camera.frustum.containsSphere(tempSphere)) continue;
						light.visibleThisFrame = true;
					}
				}
			}
		},
		updateCpuSkinMatrices: function (drawCalls) {
			var drawCallsCount = drawCalls.length;
			if (drawCallsCount === 0) return;
			var i, skin;
			for (i = 0; i < drawCallsCount; i++) {
				skin = drawCalls[i].skinInstance;
				if (skin) {
					skin.updateMatrices(drawCalls[i].node);
					skin._dirty = true;
				}
			}
		},
		updateGpuSkinMatrices: function (drawCalls) {
			var i, skin;
			var drawCallsCount = drawCalls.length;
			for (i = 0; i < drawCallsCount; i++) {
				if (!drawCalls[i].visibleThisFrame) continue;
				skin = drawCalls[i].skinInstance;
				if (skin) {
					if (skin._dirty) {
						skin.updateMatrixPalette();
						skin._dirty = false;
					}
				}
			}
		},
		updateMorphing: function (drawCalls) {
			var i, morphInst;
			var drawCallsCount = drawCalls.length;
			for (i = 0; i < drawCallsCount; i++) {
				morphInst = drawCalls[i].morphInstance;
				if (morphInst && morphInst._dirty && drawCalls[i].visibleThisFrame) {
					morphInst.update();
				}
			}
		},
		setBaseConstants: function (device, material) {
			device.setCullMode(material.cull);
			if (material.opacityMap) {
				this.opacityMapId.setValue(material.opacityMap);
				this.alphaTestId.setValue(material.alphaTest);
			}
		},
		setSkinning: function (device, meshInstance, material) {
			if (meshInstance.skinInstance) {
				this._skinDrawCalls++;
				if (device.supportsBoneTextures) {
					boneTexture = meshInstance.skinInstance.boneTexture;
					this.boneTextureId.setValue(boneTexture);
					boneTextureSize[0] = boneTexture.width;
					boneTextureSize[1] = boneTexture.height;
					boneTextureSize[2] = 1.0 / boneTexture.width;
					boneTextureSize[3] = 1.0 / boneTexture.height;
					this.boneTextureSizeId.setValue(boneTextureSize);
				} else {
					this.poseMatrixId.setValue(meshInstance.skinInstance.matrixPalette);
				}
			}
		},
		drawInstance: function (device, meshInstance, mesh, style, normal) {
			instancingData = meshInstance.instancingData;
			if (instancingData) {
				if (instancingData.count > 0) {
					this._instancedDrawCalls++;
					device.setVertexBuffer(instancingData.vertexBuffer);
					device.draw(mesh.primitive[style], instancingData.count);
					if (instancingData.vertexBuffer === _autoInstanceBuffer) {
						this._removedByInstancing += instancingData.count;
						meshInstance.instancingData = null;
						return instancingData.count - 1;
					}
				}
			} else {
				modelMatrix = meshInstance.node.worldTransform;
				this.modelMatrixId.setValue(modelMatrix.data);
				if (normal) {
					normalMatrix = meshInstance.node.normalMatrix;
					if (meshInstance.node._dirtyNormal) {
						modelMatrix.invertTo3x3(normalMatrix);
						normalMatrix.transpose();
						meshInstance.node._dirtyNormal = false;
					}
					this.normalMatrixId.setValue(normalMatrix.data);
				}
				device.draw(mesh.primitive[style]);
			}
			return 0;
		},
		drawInstance2: function (device, meshInstance, mesh, style) {
			instancingData = meshInstance.instancingData;
			if (instancingData) {
				if (instancingData.count > 0) {
					this._instancedDrawCalls++;
					device.setVertexBuffer(instancingData.vertexBuffer);
					device.draw(mesh.primitive[style], instancingData.count);
					if (instancingData.vertexBuffer === _autoInstanceBuffer) {
						this._removedByInstancing += instancingData.count;
						meshInstance.instancingData = null;
						return instancingData.count - 1;
					}
				}
			} else {
				device.draw(mesh.primitive[style], undefined, true);
			}
			return 0;
		},
		renderShadows: function (lights, cameraPass) {
			var device = this.device;
			var i, j, light, shadowShader, type, shadowCam, shadowCamNode, pass, passes, shadowType, smode;
			var numInstances;
			var meshInstance, mesh, material;
			var style;
			var settings;
			var visibleList, visibleLength;
			var passFlag = 1 << SHADER_SHADOW;
			var paramName, parameter, parameters;
			for (i = 0; i < lights.length; i++) {
				light = lights[i];
				type = light._type;
				if (!light.castShadows || !light.enabled) continue;
				if (!light._shadowCamera) {
					this.getShadowCamera(device, light);
				}
				if (light.shadowUpdateMode !== SHADOWUPDATE_NONE && light.visibleThisFrame) {
					var cameraPos;
					shadowCam = this.getShadowCamera(device, light);
					shadowCamNode = shadowCam._node;
					pass = 0;
					passes = 1;
					if (type === LIGHTTYPE_DIRECTIONAL) {
						if (light._visibleLength[cameraPass] < 0) continue;
						settings = light._visibleCameraSettings[cameraPass];
						shadowCamNode.setPosition(settings.x, settings.y, settings.z);
						shadowCam.orthoHeight = settings.orthoHeight;
						shadowCam.farClip = settings.farClip;
						pass = cameraPass;
					} else if (type === LIGHTTYPE_SPOT) {
						cameraPos = shadowCamNode.getPosition();
						this.viewPos[0] = cameraPos.x;
						this.viewPos[1] = cameraPos.y;
						this.viewPos[2] = cameraPos.z;
						this.viewPosId.setValue(this.viewPos);
						this.shadowMapLightRadiusId.setValue(light.attenuationEnd);
					} else if (type === LIGHTTYPE_POINT) {
						cameraPos = shadowCamNode.getPosition();
						this.viewPos[0] = cameraPos.x;
						this.viewPos[1] = cameraPos.y;
						this.viewPos[2] = cameraPos.z;
						this.viewPosId.setValue(this.viewPos);
						this.shadowMapLightRadiusId.setValue(light.attenuationEnd);
						passes = 6;
					}
					if (type !== LIGHTTYPE_POINT) {
						shadowCamView.setTRS(shadowCamNode.getPosition(), shadowCamNode.getRotation(), Vec3.ONE).invert();
						shadowCamViewProj.mul2(shadowCam.projectionMatrix, shadowCamView);
						light._shadowMatrix.mul2(scaleShift, shadowCamViewProj);
					}
					if (device.webgl2) {
						if (type === LIGHTTYPE_POINT) {
							device.setDepthBias(false);
						} else {
							device.setDepthBias(true);
							device.setDepthBiasValues(light.shadowBias * -1000.0, light.shadowBias * -1000.0);
						}
					} else if (device.extStandardDerivatives) {
						if (type === LIGHTTYPE_POINT) {
							this.polygonOffset[0] = 0;
							this.polygonOffset[1] = 0;
							this.polygonOffsetId.setValue(this.polygonOffset);
						} else {
							this.polygonOffset[0] = light.shadowBias * -1000.0;
							this.polygonOffset[1] = light.shadowBias * -1000.0;
							this.polygonOffsetId.setValue(this.polygonOffset);
						}
					}
					if (light.shadowUpdateMode === SHADOWUPDATE_THISFRAME) light.shadowUpdateMode = SHADOWUPDATE_NONE;
					this._shadowMapUpdates += passes;
					device.setBlending(false);
					device.setDepthWrite(true);
					device.setDepthTest(true);
					if (light._isPcf && device.webgl2 && type !== LIGHTTYPE_POINT) {
						device.setColorWrite(false, false, false, false);
					} else {
						device.setColorWrite(true, true, true, true);
					}
					if (pass) {
						passes = pass + 1;
					} else {
						pass = 0;
					}
					while (pass < passes) {
						if (type === LIGHTTYPE_POINT) {
							shadowCamNode.setRotation(pointLightRotations[pass]);
							shadowCam.renderTarget = light._shadowCubeMap[pass];
						}
						this.setCamera(shadowCam, shadowCam.renderTarget, true, type !== LIGHTTYPE_POINT);
						visibleList = light._visibleList[pass];
						visibleLength = light._visibleLength[pass];
						shadowType = light._shadowType;
						smode = shadowType + type * numShadowModes;
						for (j = 0, numInstances = visibleLength; j < numInstances; j++) {
							meshInstance = visibleList[j];
							mesh = meshInstance.mesh;
							material = meshInstance.material;
							this.setBaseConstants(device, material);
							this.setSkinning(device, meshInstance, material);
							if (material.dirty) {
								material.updateUniforms();
								material.dirty = false;
							}
							if (material.chunks) {
								parameters = material.parameters;
								for (paramName in parameters) {
									parameter = parameters[paramName];
									if (parameter.passFlags & passFlag) {
										if (!parameter.scopeId) {
											parameter.scopeId = device.scope.resolve(paramName);
										}
										parameter.scopeId.setValue(parameter.data);
									}
								}
								this.setCullMode(true, false, meshInstance);
								parameters = meshInstance.parameters;
								for (paramName in parameters) {
									parameter = parameters[paramName];
									if (parameter.passFlags & passFlag) {
										if (!parameter.scopeId) {
											parameter.scopeId = device.scope.resolve(paramName);
										}
										parameter.scopeId.setValue(parameter.data);
									}
								}
							}
							shadowShader = meshInstance._shader[SHADER_SHADOW + smode];
							if (!shadowShader) {
								this.updateShader(meshInstance, meshInstance._shaderDefs, null, SHADER_SHADOW + smode);
								shadowShader = meshInstance._shader[SHADER_SHADOW + smode];
								meshInstance._key[SORTKEY_DEPTH] = getDepthKey(meshInstance);
							}
							device.setShader(shadowShader);
							style = meshInstance.renderStyle;
							this.setVertexBuffers(device, mesh);
							this.setMorphing(device, meshInstance.morphInstance);
							device.setIndexBuffer(mesh.indexBuffer[style]);
							j += this.drawInstance(device, meshInstance, mesh, style);
							this._shadowDrawCalls++;
						}
						pass++;
						if (type === LIGHTTYPE_DIRECTIONAL) light._visibleLength[cameraPass] = -1;
					}
					if (light._isVsm) {
						var filterSize = light._vsmBlurSize;
						if (filterSize > 1) {
							var origShadowMap = shadowCam.renderTarget;
							var tempRt = getShadowMapFromCache(device, light._shadowResolution, light._shadowType, 1);
							var isVsm8 = light._shadowType === SHADOW_VSM8;
							var blurMode = light.vsmBlurMode;
							var blurShader = (isVsm8 ? this.blurPackedVsmShader : this.blurVsmShader)[blurMode][filterSize];
							if (!blurShader) {
								this.blurVsmWeights[filterSize] = gaussWeights(filterSize);
								var blurVS = shaderChunks.fullscreenQuadVS;
								var blurFS = "#define SAMPLES " + filterSize + "\n";
								if (isVsm8) {
									blurFS += this.blurPackedVsmShaderCode[blurMode];
								} else {
									blurFS += this.blurVsmShaderCode[blurMode];
								}
								var blurShaderName = "blurVsm" + blurMode + "" + filterSize + "" + isVsm8;
								blurShader = createShaderFromCode(this.device, blurVS, blurFS, blurShaderName);
								if (isVsm8) {
									this.blurPackedVsmShader[blurMode][filterSize] = blurShader;
								} else {
									this.blurVsmShader[blurMode][filterSize] = blurShader;
								}
							}
							blurScissorRect.z = light._shadowResolution - 2;
							blurScissorRect.w = blurScissorRect.z;
							this.sourceId.setValue(origShadowMap.colorBuffer);
							pixelOffset[0] = 1 / light._shadowResolution;
							pixelOffset[1] = 0;
							this.pixelOffsetId.setValue(pixelOffset);
							if (blurMode === BLUR_GAUSSIAN) this.weightId.setValue(this.blurVsmWeights[filterSize]);
							drawQuadWithShader(device, tempRt, blurShader, null, blurScissorRect);
							this.sourceId.setValue(tempRt.colorBuffer);
							pixelOffset[1] = pixelOffset[0];
							pixelOffset[0] = 0;
							this.pixelOffsetId.setValue(pixelOffset);
							drawQuadWithShader(device, origShadowMap, blurShader, null, blurScissorRect);
						}
					}
				}
			}
			if (device.webgl2) {
				device.setDepthBias(false);
			} else if (device.extStandardDerivatives) {
				this.polygonOffset[0] = 0;
				this.polygonOffset[1] = 0;
				this.polygonOffsetId.setValue(this.polygonOffset);
			}
		},
		updateShader: function (meshInstance, objDefs, staticLightList, pass, sortedLights) {
			meshInstance.material._scene = this.scene;
			meshInstance.material.updateShader(this.device, this.scene, objDefs, staticLightList, pass, sortedLights);
			meshInstance._shader[pass] = meshInstance.material.shader;
		},
		setCullMode: function (cullFaces, flip, drawCall) {
			var material = drawCall.material;
			var mode = CULLFACE_NONE;
			if (cullFaces) {
				var flipFaces = 1;
				if (material.cull > CULLFACE_NONE && material.cull < CULLFACE_FRONTANDBACK) {
					if (drawCall.flipFaces)
						flipFaces *= -1;
					if (flip)
						flipFaces *= -1;
					var wt = drawCall.node.worldTransform;
					wt.getX(worldMatX$1);
					wt.getY(worldMatY$1);
					wt.getZ(worldMatZ$1);
					worldMatX$1.cross(worldMatX$1, worldMatY$1);
					if (worldMatX$1.dot(worldMatZ$1) < 0)
						flipFaces *= -1;
				}
				if (flipFaces < 0) {
					mode = material.cull === CULLFACE_FRONT ? CULLFACE_BACK : CULLFACE_FRONT;
				} else {
					mode = material.cull;
				}
			}
			this.device.setCullMode(mode);
		},
		setVertexBuffers: function (device, mesh) {
			device.setVertexBuffer(mesh.vertexBuffer);
		},
		setMorphing: function (device, morphInstance) {
			if (morphInstance) {
				if (morphInstance.morph.useTextureMorph) {
					device.setVertexBuffer(morphInstance.morph.vertexBufferIds);
					this.morphPositionTex.setValue(morphInstance.texturePositions);
					this.morphNormalTex.setValue(morphInstance.textureNormals);
					this.morphTexParams.setValue(morphInstance._textureParams);
				} else {
					var vb, semantic;
					for (var t = 0; t < morphInstance._activeVertexBuffers.length; t++) {
						vb = morphInstance._activeVertexBuffers[t];
						if (vb) {
							semantic = SEMANTIC_ATTR + (t + 8);
							vb.format.elements[0].name = semantic;
							vb.format.elements[0].scopeId = device.scope.resolve(semantic);
							vb.format.update();
							device.setVertexBuffer(vb);
						}
					}
					this.morphWeightsA.setValue(morphInstance._shaderMorphWeightsA);
					this.morphWeightsB.setValue(morphInstance._shaderMorphWeightsB);
				}
			}
		},
		renderForward: function (camera, drawCalls, drawCallsCount, sortedLights, pass, cullingMask, drawCallback, layer) {
			var device = this.device;
			var scene = this.scene;
			var vrDisplay = camera.vrDisplay;
			var passFlag = 1 << pass;
			var lightHash = layer ? layer._lightHash : 0;
			var i, drawCall, mesh, material, objDefs, variantKey, lightMask, style, usedDirLights;
			var prevMaterial = null, prevObjDefs, prevLightMask, prevStatic;
			var paramName, parameter, parameters;
			var stencilFront, stencilBack;
			var halfWidth = device.width * 0.5;
			for (i = 0; i < drawCallsCount; i++) {
				drawCall = drawCalls[i];
				if (cullingMask && drawCall.mask && !(cullingMask & drawCall.mask)) continue;
				if (drawCall.command) {
					drawCall.command();
				} else {
					mesh = drawCall.mesh;
					material = drawCall.material;
					objDefs = drawCall._shaderDefs;
					lightMask = drawCall.mask;
					this.setSkinning(device, drawCall, material);
					if (material && material === prevMaterial && objDefs !== prevObjDefs) {
						prevMaterial = null;
					}
					if (drawCall.isStatic || prevStatic) {
						prevMaterial = null;
					}
					if (material !== prevMaterial) {
						this._materialSwitches++;
						if (material.dirty) {
							material.updateUniforms();
							material.dirty = false;
						}
						if (!drawCall._shader[pass] || drawCall._shaderDefs !== objDefs || drawCall._lightHash !== lightHash) {
							if (!drawCall.isStatic) {
								variantKey = pass + "_" + objDefs + "_" + lightHash;
								drawCall._shader[pass] = material.variants[variantKey];
								if (!drawCall._shader[pass]) {
									this.updateShader(drawCall, objDefs, null, pass, sortedLights);
									material.variants[variantKey] = drawCall._shader[pass];
								}
							} else {
								this.updateShader(drawCall, objDefs, drawCall._staticLightList, pass, sortedLights);
							}
							drawCall._shaderDefs = objDefs;
							drawCall._lightHash = lightHash;
						}
						if (! drawCall._shader[pass].failed && ! device.setShader(drawCall._shader[pass])) {
							drawCall._shader[pass].failed = true;
						}
						parameters = material.parameters;
						for (paramName in parameters) {
							parameter = parameters[paramName];
							if (parameter.passFlags & passFlag) {
								if (!parameter.scopeId) {
									parameter.scopeId = device.scope.resolve(paramName);
								}
								parameter.scopeId.setValue(parameter.data);
							}
						}
						if (!prevMaterial || lightMask !== prevLightMask) {
							usedDirLights = this.dispatchDirectLights(sortedLights[LIGHTTYPE_DIRECTIONAL], scene, lightMask);
							this.dispatchLocalLights(sortedLights, scene, lightMask, usedDirLights, drawCall._staticLightList);
						}
						this.alphaTestId.setValue(material.alphaTest);
						device.setBlending(material.blend);
						if (material.blend) {
							if (material.separateAlphaBlend) {
								device.setBlendFunctionSeparate(material.blendSrc, material.blendDst, material.blendSrcAlpha, material.blendDstAlpha);
								device.setBlendEquationSeparate(material.blendEquation, material.blendAlphaEquation);
							} else {
								device.setBlendFunction(material.blendSrc, material.blendDst);
								device.setBlendEquation(material.blendEquation);
							}
						}
						device.setColorWrite(material.redWrite, material.greenWrite, material.blueWrite, material.alphaWrite);
						device.setDepthWrite(material.depthWrite);
						device.setDepthTest(material.depthTest);
						device.setAlphaToCoverage(material.alphaToCoverage);
						if (material.depthBias || material.slopeDepthBias) {
							device.setDepthBias(true);
							device.setDepthBiasValues(material.depthBias, material.slopeDepthBias);
						} else {
							device.setDepthBias(false);
						}
					}
					this.setCullMode(camera._cullFaces, camera._flipFaces, drawCall);
					stencilFront = drawCall.stencilFront || material.stencilFront;
					stencilBack = drawCall.stencilBack || material.stencilBack;
					if (stencilFront || stencilBack) {
						device.setStencilTest(true);
						if (stencilFront === stencilBack) {
							device.setStencilFunc(stencilFront.func, stencilFront.ref, stencilFront.readMask);
							device.setStencilOperation(stencilFront.fail, stencilFront.zfail, stencilFront.zpass, stencilFront.writeMask);
						} else {
							if (stencilFront) {
								device.setStencilFuncFront(stencilFront.func, stencilFront.ref, stencilFront.readMask);
								device.setStencilOperationFront(stencilFront.fail, stencilFront.zfail, stencilFront.zpass, stencilFront.writeMask);
							} else {
								device.setStencilFuncFront(FUNC_ALWAYS, 0, 0xFF);
								device.setStencilOperationFront(STENCILOP_KEEP, STENCILOP_KEEP, STENCILOP_KEEP, 0xFF);
							}
							if (stencilBack) {
								device.setStencilFuncBack(stencilBack.func, stencilBack.ref, stencilBack.readMask);
								device.setStencilOperationBack(stencilBack.fail, stencilBack.zfail, stencilBack.zpass, stencilBack.writeMask);
							} else {
								device.setStencilFuncBack(FUNC_ALWAYS, 0, 0xFF);
								device.setStencilOperationBack(STENCILOP_KEEP, STENCILOP_KEEP, STENCILOP_KEEP, 0xFF);
							}
						}
					} else {
						device.setStencilTest(false);
					}
					parameters = drawCall.parameters;
					for (paramName in parameters) {
						parameter = parameters[paramName];
						if (parameter.passFlags & passFlag) {
							if (!parameter.scopeId) {
								parameter.scopeId = device.scope.resolve(paramName);
							}
							parameter.scopeId.setValue(parameter.data);
						}
					}
					this.setVertexBuffers(device, mesh);
					this.setMorphing(device, drawCall.morphInstance);
					style = drawCall.renderStyle;
					device.setIndexBuffer(mesh.indexBuffer[style]);
					if (drawCallback) {
						drawCallback(drawCall, i);
					}
					if (vrDisplay && vrDisplay.presenting) {
						device.setViewport(0, 0, halfWidth, device.height);
						this.projId.setValue(projL.data);
						this.projSkyboxId.setValue(projL.data);
						this.viewInvId.setValue(viewInvL.data);
						this.viewId.setValue(viewL.data);
						this.viewId3.setValue(viewMat3L.data);
						this.viewProjId.setValue(viewProjMatL.data);
						this.viewPos[0] = viewPosL.x;
						this.viewPos[1] = viewPosL.y;
						this.viewPos[2] = viewPosL.z;
						this.viewPosId.setValue(this.viewPos);
						i += this.drawInstance(device, drawCall, mesh, style, true);
						this._forwardDrawCalls++;
						device.setViewport(halfWidth, 0, halfWidth, device.height);
						this.projId.setValue(projR.data);
						this.projSkyboxId.setValue(projR.data);
						this.viewInvId.setValue(viewInvR.data);
						this.viewId.setValue(viewR.data);
						this.viewId3.setValue(viewMat3R.data);
						this.viewProjId.setValue(viewProjMatR.data);
						this.viewPos[0] = viewPosR.x;
						this.viewPos[1] = viewPosR.y;
						this.viewPos[2] = viewPosR.z;
						this.viewPosId.setValue(this.viewPos);
						i += this.drawInstance2(device, drawCall, mesh, style);
						this._forwardDrawCalls++;
					} else if (camera.xr && camera.xr.session && camera.xr.views.length) {
						var views = camera.xr.views;
						for (var v = 0; v < views.length; v++) {
							var view = views[v];
							device.setViewport(view.viewport.x, view.viewport.y, view.viewport.z, view.viewport.w);
							this.projId.setValue(view.projMat.data);
							this.projSkyboxId.setValue(view.projMat.data);
							this.viewId.setValue(view.viewOffMat.data);
							this.viewInvId.setValue(view.viewInvOffMat.data);
							this.viewId3.setValue(view.viewMat3.data);
							this.viewProjId.setValue(view.projViewOffMat.data);
							this.viewPosId.setValue(view.position);
							if (v === 0) {
								i += this.drawInstance(device, drawCall, mesh, style, true);
							} else {
								i += this.drawInstance2(device, drawCall, mesh, style);
							}
							this._forwardDrawCalls++;
						}
					} else {
						i += this.drawInstance(device, drawCall, mesh, style, true);
						this._forwardDrawCalls++;
					}
					if (i < drawCallsCount - 1 && drawCalls[i + 1].material === material) {
						for (paramName in parameters) {
							parameter = material.parameters[paramName];
							if (parameter) {
								if (!parameter.scopeId) {
									parameter.scopeId = device.scope.resolve(paramName);
								}
								parameter.scopeId.setValue(parameter.data);
							}
						}
					}
					prevMaterial = material;
					prevObjDefs = objDefs;
					prevLightMask = lightMask;
					prevStatic = drawCall.isStatic;
				}
			}
			device.updateEnd();
		},
		setupInstancing: function (device) {
			if (device.enableAutoInstancing) {
				if (!_autoInstanceBuffer) {
					_autoInstanceBuffer = new VertexBuffer(device, VertexFormat.defaultInstancingFormat, device.autoInstancingMaxObjects, BUFFER_DYNAMIC);
				}
			}
		},
		revertStaticMeshes: function (meshInstances) {
			var i;
			var drawCalls = meshInstances;
			var drawCallsCount = drawCalls.length;
			var drawCall;
			var newDrawCalls = [];
			var prevStaticSource;
			for (i = 0; i < drawCallsCount; i++) {
				drawCall = drawCalls[i];
				if (drawCall._staticSource) {
					if (drawCall._staticSource !== prevStaticSource) {
						newDrawCalls.push(drawCall._staticSource);
						prevStaticSource = drawCall._staticSource;
					}
				} else {
					newDrawCalls.push(drawCall);
				}
			}
			meshInstances.length = newDrawCalls.length;
			for (i = 0; i < newDrawCalls.length; i++) {
				meshInstances[i] = newDrawCalls[i];
			}
		},
		prepareStaticMeshes: function (meshInstances, lights) {
			var i, j, k, v, s, index;
			var device = this.device;
			var scene = this.scene;
			var drawCalls = meshInstances;
			var drawCallsCount = drawCalls.length;
			var drawCall, light;
			var newDrawCalls = [];
			var mesh;
			var indices, verts, numTris, elems, vertSize, offsetP, baseIndex;
			var _x, _y, _z;
			var minx, miny, minz, maxx, maxy, maxz;
			var minv, maxv;
			var minVec = new Vec3();
			var maxVec = new Vec3();
			var localLightBounds = new BoundingBox();
			var invMatrix = new Mat4();
			var triLightComb = [];
			var triLightCombUsed;
			var indexBuffer, vertexBuffer;
			var combIndices, combIbName, combIb;
			var lightTypePass;
			var lightAabb = [];
			var aabb;
			var triBounds = [];
			var staticLights = [];
			var bit;
			var lht;
			for (i = 0; i < drawCallsCount; i++) {
				drawCall = drawCalls[i];
				if (!drawCall.isStatic) {
					newDrawCalls.push(drawCall);
				} else {
					aabb = drawCall.aabb;
					staticLights.length = 0;
					for (lightTypePass = LIGHTTYPE_POINT; lightTypePass <= LIGHTTYPE_SPOT; lightTypePass++) {
						for (j = 0; j < lights.length; j++) {
							light = lights[j];
							if (light._type !== lightTypePass) continue;
							if (light.enabled) {
								if (light.mask & drawCall.mask) {
									if (light.isStatic) {
										if (!lightAabb[j]) {
											lightAabb[j] = new BoundingBox();
											light._node.getWorldTransform();
											light.getBoundingSphere(tempSphere);
											lightAabb[j].center.copy(tempSphere.center);
											lightAabb[j].halfExtents.x = tempSphere.radius;
											lightAabb[j].halfExtents.y = tempSphere.radius;
											lightAabb[j].halfExtents.z = tempSphere.radius;
										}
										if (!lightAabb[j].intersects(aabb)) continue;
										staticLights.push(j);
									}
								}
							}
						}
					}
					if (staticLights.length === 0) {
						newDrawCalls.push(drawCall);
						continue;
					}
					mesh = drawCall.mesh;
					vertexBuffer = mesh.vertexBuffer;
					indexBuffer = mesh.indexBuffer[drawCall.renderStyle];
					indices = indexBuffer.bytesPerIndex === 2 ? new Uint16Array(indexBuffer.lock()) : new Uint32Array(indexBuffer.lock());
					numTris = mesh.primitive[drawCall.renderStyle].count / 3;
					baseIndex = mesh.primitive[drawCall.renderStyle].base;
					elems = vertexBuffer.format.elements;
					vertSize = vertexBuffer.format.size / 4;
					verts = new Float32Array(vertexBuffer.storage);
					for (k = 0; k < elems.length; k++) {
						if (elems[k].name === SEMANTIC_POSITION) {
							offsetP = elems[k].offset / 4;
						}
					}
					triLightComb.length = numTris;
					for (k = 0; k < numTris; k++) {
						triLightComb[k] = 0;
					}
					triLightCombUsed = false;
					triBounds.length = numTris * 6;
					for (k = 0; k < numTris; k++) {
						minx = Number.MAX_VALUE;
						miny = Number.MAX_VALUE;
						minz = Number.MAX_VALUE;
						maxx = -Number.MAX_VALUE;
						maxy = -Number.MAX_VALUE;
						maxz = -Number.MAX_VALUE;
						for (v = 0; v < 3; v++) {
							index = indices[k * 3 + v + baseIndex];
							index = index * vertSize + offsetP;
							_x = verts[index];
							_y = verts[index + 1];
							_z = verts[index + 2];
							if (_x < minx) minx = _x;
							if (_y < miny) miny = _y;
							if (_z < minz) minz = _z;
							if (_x > maxx) maxx = _x;
							if (_y > maxy) maxy = _y;
							if (_z > maxz) maxz = _z;
						}
						index = k * 6;
						triBounds[index] = minx;
						triBounds[index + 1] = miny;
						triBounds[index + 2] = minz;
						triBounds[index + 3] = maxx;
						triBounds[index + 4] = maxy;
						triBounds[index + 5] = maxz;
					}
					for (s = 0; s < staticLights.length; s++) {
						j = staticLights[s];
						light = lights[j];
						invMatrix.copy(drawCall.node.worldTransform).invert();
						localLightBounds.setFromTransformedAabb(lightAabb[j], invMatrix);
						minv = localLightBounds.getMin();
						maxv = localLightBounds.getMax();
						bit = 1 << s;
						for (k = 0; k < numTris; k++) {
							index = k * 6;
							if ((triBounds[index] <= maxv.x) && (triBounds[index + 3] >= minv.x) &&
								(triBounds[index + 1] <= maxv.y) && (triBounds[index + 4] >= minv.y) &&
								(triBounds[index + 2] <= maxv.z) && (triBounds[index + 5] >= minv.z)) {
								triLightComb[k] |= bit;
								triLightCombUsed = true;
							}
						}
					}
					if (triLightCombUsed) {
						combIndices = {};
						for (k = 0; k < numTris; k++) {
							j = k * 3 + baseIndex;
							combIbName = triLightComb[k];
							if (!combIndices[combIbName]) combIndices[combIbName] = [];
							combIb = combIndices[combIbName];
							combIb.push(indices[j]);
							combIb.push(indices[j + 1]);
							combIb.push(indices[j + 2]);
						}
						for (combIbName in combIndices) {
							combIb = combIndices[combIbName];
							var ib = new IndexBuffer(device, indexBuffer.format, combIb.length, indexBuffer.usage);
							var ib2 = ib.bytesPerIndex === 2 ? new Uint16Array(ib.lock()) : new Uint32Array(ib.lock());
							ib2.set(combIb);
							ib.unlock();
							minx = Number.MAX_VALUE;
							miny = Number.MAX_VALUE;
							minz = Number.MAX_VALUE;
							maxx = -Number.MAX_VALUE;
							maxy = -Number.MAX_VALUE;
							maxz = -Number.MAX_VALUE;
							for (k = 0; k < combIb.length; k++) {
								index = combIb[k];
								_x = verts[index * vertSize + offsetP];
								_y = verts[index * vertSize + offsetP + 1];
								_z = verts[index * vertSize + offsetP + 2];
								if (_x < minx) minx = _x;
								if (_y < miny) miny = _y;
								if (_z < minz) minz = _z;
								if (_x > maxx) maxx = _x;
								if (_y > maxy) maxy = _y;
								if (_z > maxz) maxz = _z;
							}
							minVec.set(minx, miny, minz);
							maxVec.set(maxx, maxy, maxz);
							var chunkAabb = new BoundingBox();
							chunkAabb.setMinMax(minVec, maxVec);
							var mesh2 = new Mesh(device);
							mesh2.vertexBuffer = vertexBuffer;
							mesh2.indexBuffer[0] = ib;
							mesh2.primitive[0].type = PRIMITIVE_TRIANGLES;
							mesh2.primitive[0].base = 0;
							mesh2.primitive[0].count = combIb.length;
							mesh2.primitive[0].indexed = true;
							mesh2.aabb = chunkAabb;
							var instance = new MeshInstance(drawCall.node, mesh2, drawCall.material);
							instance.isStatic = drawCall.isStatic;
							instance.visible = drawCall.visible;
							instance.layer = drawCall.layer;
							instance.castShadow = drawCall.castShadow;
							instance._receiveShadow = drawCall._receiveShadow;
							instance.cull = drawCall.cull;
							instance.pick = drawCall.pick;
							instance.mask = drawCall.mask;
							instance.parameters = drawCall.parameters;
							instance._shaderDefs = drawCall._shaderDefs;
							instance._staticSource = drawCall;
							if (drawCall._staticLightList) {
								instance._staticLightList = drawCall._staticLightList;
							} else {
								instance._staticLightList = [];
							}
							for (k = 0; k < staticLights.length; k++) {
								bit = 1 << k;
								if (combIbName & bit) {
									lht = lights[staticLights[k]];
									if (instance._staticLightList.indexOf(lht) < 0) {
										instance._staticLightList.push(lht);
									}
								}
							}
							instance._staticLightList.sort(this.lightCompare);
							newDrawCalls.push(instance);
						}
					} else {
						newDrawCalls.push(drawCall);
					}
				}
			}
			meshInstances.length = newDrawCalls.length;
			for (i = 0; i < newDrawCalls.length; i++) {
				meshInstances[i] = newDrawCalls[i];
			}
		},
		updateShaders: function (drawCalls) {
			var i;
			var materials = [];
			for (i = 0; i < drawCalls.length; i++) {
				var drawCall = drawCalls[i];
				if (drawCall.material !== undefined) {
					if (materials.indexOf(drawCall.material) === -1) {
						materials.push(drawCall.material);
					}
				}
			}
			for (i = 0; i < materials.length; i++) {
				var mat = materials[i];
				if (mat.updateShader !== Material.prototype.updateShader) {
					mat.clearVariants();
					mat.shader = null;
				}
			}
		},
		updateLitShaders: function (drawCalls) {
			for (var i = 0; i < drawCalls.length; i++) {
				var drawCall = drawCalls[i];
				if (drawCall.material !== undefined) {
					var mat = drawCall.material;
					if (mat.updateShader !== Material.prototype.updateShader) {
						if (mat.useLighting === false || (mat.emitter && !mat.emitter.lighting)) {
							continue;
						}
						mat.clearVariants();
						mat.shader = null;
					}
				}
			}
		},
		beginFrame: function (comp) {
			var scene = this.scene;
			var meshInstances = comp._meshInstances;
			var lights = comp._lights;
			if (scene.updateShaders) {
				this.updateShaders(meshInstances);
				scene.updateShaders = false;
				scene.updateLitShaders = false;
				scene._shaderVersion++;
			} else if (scene.updateLitShaders) {
				this.updateLitShaders(meshInstances);
				scene.updateLitShaders = false;
				scene._shaderVersion++;
			}
			this.updateCpuSkinMatrices(meshInstances);
			var i;
			var len = meshInstances.length;
			for (i = 0; i < len; i++) {
				meshInstances[i].visibleThisFrame = false;
			}
			len = lights.length;
			for (i = 0; i < len; i++) {
				lights[i].visibleThisFrame = lights[i]._type === LIGHTTYPE_DIRECTIONAL;
			}
		},
		beginLayers: function (comp) {
			var scene = this.scene;
			var len = comp.layerList.length;
			var layer;
			var i, j;
			var shaderVersion = this.scene._shaderVersion;
			for (i = 0; i < len; i++) {
				comp.layerList[i]._postRenderCounter = 0;
			}
			var transparent;
			for (i = 0; i < len; i++) {
				layer = comp.layerList[i];
				layer._shaderVersion = shaderVersion;
				layer._preRenderCalledForCameras = 0;
				layer._postRenderCalledForCameras = 0;
				transparent = comp.subLayerList[i];
				if (transparent) {
					layer._postRenderCounter |= 2;
				} else {
					layer._postRenderCounter |= 1;
				}
				layer._postRenderCounterMax = layer._postRenderCounter;
				for (j = 0; j < layer.cameras.length; j++) {
					if (!layer.instances.visibleOpaque[j]) layer.instances.visibleOpaque[j] = new VisibleInstanceList();
					if (!layer.instances.visibleTransparent[j]) layer.instances.visibleTransparent[j] = new VisibleInstanceList();
					layer.instances.visibleOpaque[j].done = false;
					layer.instances.visibleTransparent[j].done = false;
				}
				if (layer.cameras.length < layer.instances.visibleOpaque.length) {
					layer.instances.visibleOpaque.splice(layer.cameras.length, 1);
				}
				if (layer.cameras.length < layer.instances.visibleTransparent.length) {
					layer.instances.visibleTransparent.splice(layer.cameras.length, 1);
				}
				if (layer._needsStaticPrepare && layer._staticLightHash) {
					if (layer._staticPrepareDone) {
						this.revertStaticMeshes(layer.opaqueMeshInstances);
						this.revertStaticMeshes(layer.transparentMeshInstances);
					}
					this.prepareStaticMeshes(layer.opaqueMeshInstances, layer._lights);
					this.prepareStaticMeshes(layer.transparentMeshInstances, layer._lights);
					comp._dirty = true;
					scene.updateShaders = true;
					layer._needsStaticPrepare = false;
					layer._staticPrepareDone = true;
				}
			}
		},
		cullLocalShadowmap: function (light, drawCalls) {
			var i, type, shadowCam, shadowCamNode, passes, pass, numInstances, meshInstance, visibleList, vlen, visible;
			var lightNode;
			type = light._type;
			if (type === LIGHTTYPE_DIRECTIONAL) return;
			light.visibleThisFrame = true;
			shadowCam = this.getShadowCamera(this.device, light);
			shadowCam.projection = PROJECTION_PERSPECTIVE;
			shadowCam.nearClip = light.attenuationEnd / 1000;
			shadowCam.farClip = light.attenuationEnd;
			shadowCam.aspectRatio = 1;
			if (type === LIGHTTYPE_SPOT) {
				shadowCam.fov = light._outerConeAngle * 2;
				passes = 1;
			} else {
				shadowCam.fov = 90;
				passes = 6;
			}
			shadowCamNode = shadowCam._node;
			lightNode = light._node;
			shadowCamNode.setPosition(lightNode.getPosition());
			if (type === LIGHTTYPE_SPOT) {
				shadowCamNode.setRotation(lightNode.getRotation());
				shadowCamNode.rotateLocal(-90, 0, 0);
			}
			for (pass = 0; pass < passes; pass++) {
				if (type === LIGHTTYPE_POINT) {
					shadowCamNode.setRotation(pointLightRotations[pass]);
					shadowCam.renderTarget = light._shadowCubeMap[pass];
				}
				this.updateCameraFrustum(shadowCam);
				visibleList = light._visibleList[pass];
				if (!visibleList) {
					visibleList = light._visibleList[pass] = [];
				}
				light._visibleLength[pass] = 0;
				vlen = 0;
				for (i = 0, numInstances = drawCalls.length; i < numInstances; i++) {
					meshInstance = drawCalls[i];
					visible = true;
					if (meshInstance.cull) {
						visible = this._isVisible(shadowCam, meshInstance);
					}
					if (visible) {
						visibleList[vlen] = meshInstance;
						vlen++;
						meshInstance.visibleThisFrame = true;
					}
				}
				light._visibleLength[pass] = vlen;
				if (visibleList.length !== vlen) {
					visibleList.length = vlen;
				}
				visibleList.sort(this.depthSortCompare);
			}
		},
		cullDirectionalShadowmap: function (light, drawCalls, camera, pass) {
			var i, shadowCam, shadowCamNode, lightNode, frustumSize, vlen, visibleList;
			var unitPerTexel, delta, p;
			var minx, miny, minz, maxx, maxy, maxz, centerx, centery;
			var visible, numInstances;
			var meshInstance;
			var emptyAabb;
			var drawCallAabb;
			var device = this.device;
			light.visibleThisFrame = true;
			shadowCam = this.getShadowCamera(device, light);
			shadowCamNode = shadowCam._node;
			lightNode = light._node;
			shadowCamNode.setPosition(lightNode.getPosition());
			shadowCamNode.setRotation(lightNode.getRotation());
			shadowCamNode.rotateLocal(-90, 0, 0);
			_getFrustumPoints(camera, light.shadowDistance || camera._farClip, frustumPoints);
			frustumSize = frustumDiagonal.sub2( frustumPoints[0], frustumPoints[6] ).length();
			frustumSize = Math.max( frustumSize, frustumDiagonal.sub2( frustumPoints[4], frustumPoints[6] ).length() );
			shadowCamView.copy( shadowCamNode.getWorldTransform() ).invert();
			c2sc.copy( shadowCamView ).mul( camera._node.getWorldTransform() );
			for (i = 0; i < 8; i++) {
				c2sc.transformPoint(frustumPoints[i], frustumPoints[i]);
			}
			minx = miny = minz = 1000000;
			maxx = maxy = maxz = -1000000;
			for (i = 0; i < 8; i++) {
				p = frustumPoints[i];
				if (p.x < minx) minx = p.x;
				if (p.x > maxx) maxx = p.x;
				if (p.y < miny) miny = p.y;
				if (p.y > maxy) maxy = p.y;
				if (p.z < minz) minz = p.z;
				if (p.z > maxz) maxz = p.z;
			}
			unitPerTexel = frustumSize / light._shadowResolution;
			delta = (frustumSize - (maxx - minx)) * 0.5;
			minx = Math.floor( (minx - delta) / unitPerTexel ) * unitPerTexel;
			delta = (frustumSize - (maxy - miny)) * 0.5;
			miny = Math.floor( (miny - delta) / unitPerTexel ) * unitPerTexel;
			maxx = minx + frustumSize;
			maxy = miny + frustumSize;
			centerx = (maxx + minx) * 0.5;
			centery = (maxy + miny) * 0.5;
			shadowCamNode.translateLocal(centerx, centery, 100000);
			shadowCam.projection = PROJECTION_ORTHOGRAPHIC;
			shadowCam.nearClip = 0;
			shadowCam.farClip = 200000;
			shadowCam.aspectRatio = 1;
			shadowCam.orthoHeight = frustumSize * 0.5;
			this.updateCameraFrustum(shadowCam);
			emptyAabb = true;
			visibleList = light._visibleList[pass];
			if (!visibleList) {
				visibleList = light._visibleList[pass] = [];
			}
			vlen = light._visibleLength[pass] = 0;
			for (i = 0, numInstances = drawCalls.length; i < numInstances; i++) {
				meshInstance = drawCalls[i];
				visible = true;
				if (meshInstance.cull) {
					visible = this._isVisible(shadowCam, meshInstance);
				}
				if (visible) {
					visibleList[vlen] = meshInstance;
					vlen++;
					meshInstance.visibleThisFrame = true;
					drawCallAabb = meshInstance.aabb;
					if (emptyAabb) {
						visibleSceneAabb.copy(drawCallAabb);
						emptyAabb = false;
					} else {
						visibleSceneAabb.add(drawCallAabb);
					}
				}
			}
			light._visibleLength[pass] = vlen;
			if (visibleList.length !== vlen) {
				visibleList.length = vlen;
			}
			visibleList.sort(this.depthSortCompare);
			var z = _getZFromAABBSimple( shadowCamView, visibleSceneAabb.getMin(), visibleSceneAabb.getMax());
			maxz = z.max;
			if (z.min > minz) minz = z.min;
			shadowCamNode.setPosition(lightNode.getPosition());
			shadowCamNode.translateLocal(centerx, centery, maxz + directionalShadowEpsilon);
			shadowCam.farClip = maxz - minz;
			var settings = light._visibleCameraSettings[pass];
			if (!settings) {
				settings = light._visibleCameraSettings[pass] = {};
			}
			var lpos = shadowCamNode.getPosition();
			settings.x = lpos.x;
			settings.y = lpos.y;
			settings.z = lpos.z;
			settings.orthoHeight = shadowCam.orthoHeight;
			settings.farClip = shadowCam.farClip;
		},
		gpuUpdate: function (drawCalls) {
			this.updateGpuSkinMatrices(drawCalls);
			this.updateMorphing(drawCalls);
		},
		setSceneConstants: function () {
			var i;
			var device = this.device;
			var scene = this.scene;
			this.dispatchGlobalLights(scene);
			if (scene.fog !== FOG_NONE) {
				this.fogColor[0] = scene.fogColor.r;
				this.fogColor[1] = scene.fogColor.g;
				this.fogColor[2] = scene.fogColor.b;
				if (scene.gammaCorrection) {
					for (i = 0; i < 3; i++) {
						this.fogColor[i] = Math.pow(this.fogColor[i], 2.2);
					}
				}
				this.fogColorId.setValue(this.fogColor);
				if (scene.fog === FOG_LINEAR) {
					this.fogStartId.setValue(scene.fogStart);
					this.fogEndId.setValue(scene.fogEnd);
				} else {
					this.fogDensityId.setValue(scene.fogDensity);
				}
			}
			this._screenSize[0] = device.width;
			this._screenSize[1] = device.height;
			this._screenSize[2] = 1 / device.width;
			this._screenSize[3] = 1 / device.height;
			this.screenSizeId.setValue(this._screenSize);
		},
		renderComposition: function (comp) {
			var device = this.device;
			var camera;
			var renderedRt = comp._renderedRt;
			var renderedByCam = comp._renderedByCam;
			var renderedLayer = comp._renderedLayer;
			var i, layer, transparent, cameras, j, rt, k, processedThisCamera, processedThisCameraAndLayer, processedThisCameraAndRt;
			if (this.scene.updateSkybox) {
				this.scene._updateSkybox(device);
				this.scene.updateSkybox = false;
			}
			this.beginLayers(comp);
			var updated = comp._update();
			if (updated & COMPUPDATED_LIGHTS) {
				this.scene.updateLitShaders = true;
			}
			this.beginFrame(comp);
			this.setSceneConstants();
			var renderedLength = 0;
			var objects, drawCalls, visible;
			for (i = 0; i < comp.layerList.length; i++) {
				layer = comp.layerList[i];
				if (!layer.enabled || !comp.subLayerEnabled[i]) continue;
				transparent = comp.subLayerList[i];
				objects = layer.instances;
				cameras = layer.cameras;
				for (j = 0; j < cameras.length; j++) {
					camera = cameras[j];
					if (!camera) continue;
					camera.frameBegin(layer.renderTarget);
					drawCalls = transparent ? layer.transparentMeshInstances : layer.opaqueMeshInstances;
					processedThisCamera = false;
					processedThisCameraAndLayer = false;
					for (k = 0; k < renderedLength; k++) {
						if (renderedByCam[k] === camera) {
							processedThisCamera = true;
							if (renderedLayer[k] === layer) {
								processedThisCameraAndLayer = true;
								break;
							}
						}
					}
					if (!processedThisCamera) {
						this.updateCameraFrustum(camera.camera);
						this._camerasRendered++;
					}
					if (!processedThisCameraAndLayer) {
						this.cullLights(camera.camera, layer._lights);
					}
					if (!processedThisCamera || !processedThisCameraAndLayer) {
						renderedByCam[renderedLength] = camera;
						renderedLayer[renderedLength] = layer;
						renderedLength++;
					}
					visible = transparent ? objects.visibleTransparent[j] : objects.visibleOpaque[j];
					if (!visible.done) {
						if (layer.onPreCull) {
							layer.onPreCull(j);
						}
						visible.length = this.cull(camera.camera, drawCalls, visible.list);
						visible.done = true;
						if (layer.onPostCull) {
							layer.onPostCull(j);
						}
					}
					camera.frameEnd();
				}
			}
			var light, casters;
			for (i = 0; i < comp._lights.length; i++) {
				light = comp._lights[i];
				if (!light.visibleThisFrame) continue;
				if (light._type === LIGHTTYPE_DIRECTIONAL) continue;
				if (!light.castShadows || !light.enabled || light.shadowUpdateMode === SHADOWUPDATE_NONE) continue;
				casters = comp._lightShadowCasters[i];
				this.cullLocalShadowmap(light, casters);
			}
			renderedLength = 0;
			var globalLightCounter = -1;
			for (i = 0; i < comp._lights.length; i++) {
				light = comp._lights[i];
				if (light._type !== LIGHTTYPE_DIRECTIONAL) continue;
				globalLightCounter++;
				if (!light.castShadows || !light.enabled || light.shadowUpdateMode === SHADOWUPDATE_NONE) continue;
				casters = comp._lightShadowCasters[i];
				cameras = comp._globalLightCameras[globalLightCounter];
				for (j = 0; j < cameras.length; j++) {
					this.cullDirectionalShadowmap(light, casters, cameras[j].camera, comp._globalLightCameraIds[globalLightCounter][j]);
				}
			}
			this.gpuUpdate(comp._meshInstances);
			this.renderShadows(comp._sortedLights[LIGHTTYPE_SPOT]);
			this.renderShadows(comp._sortedLights[LIGHTTYPE_POINT]);
			renderedLength = 0;
			var cameraPass;
			for (i = 0; i < comp._renderList.length; i++) {
				layer = comp.layerList[comp._renderList[i]];
				if (!layer.enabled || !comp.subLayerEnabled[comp._renderList[i]]) continue;
				objects = layer.instances;
				transparent = comp.subLayerList[comp._renderList[i]];
				cameraPass = comp._renderListCamera[i];
				camera = layer.cameras[cameraPass];
				if (camera) camera.frameBegin(layer.renderTarget);
				if (!transparent && layer.onPreRenderOpaque) {
					layer.onPreRenderOpaque(cameraPass);
				} else if (transparent && layer.onPreRenderTransparent) {
					layer.onPreRenderTransparent(cameraPass);
				}
				if (!(layer._preRenderCalledForCameras & (1 << cameraPass))) {
					if (layer.onPreRender) layer.onPreRender(cameraPass);
					layer._preRenderCalledForCameras |= 1 << cameraPass;
					if (layer.overrideClear) {
						this.clearView(camera.camera, layer.renderTarget, true, true, layer._clearOptions);
					}
				}
				if (camera) {
					rt = layer.renderTarget;
					processedThisCameraAndRt = false;
					for (k = 0; k < renderedLength; k++) {
						if (renderedRt[k] === rt && renderedByCam[k] === camera) {
							processedThisCameraAndRt = true;
							break;
						}
					}
					if (!processedThisCameraAndRt) {
						if (!layer.overrideClear) this.clearView(camera.camera, layer.renderTarget, true, true);
						renderedRt[renderedLength] = rt;
						renderedByCam[renderedLength] = camera;
						renderedLength++;
					}
					this.renderShadows(layer._sortedLights[LIGHTTYPE_DIRECTIONAL], cameraPass);
					layer._sortVisible(transparent, camera.camera.node, cameraPass);
					visible = transparent ? objects.visibleTransparent[cameraPass] : objects.visibleOpaque[cameraPass];
					this.scene._activeCamera = camera.camera;
					this.setCamera(camera.camera, layer.renderTarget);
					this.renderForward(camera.camera,
									   visible.list,
									   visible.length,
									   layer._sortedLights,
									   layer.shaderPass,
									   layer.cullingMask,
									   layer.onDrawCall,
									   layer);
					device.setColorWrite(true, true, true, true);
					device.setStencilTest(false);
					device.setAlphaToCoverage(false);
					device.setDepthBias(false);
					camera.frameEnd();
				}
				if (!transparent && layer.onPostRenderOpaque) {
					layer.onPostRenderOpaque(cameraPass);
				} else if (transparent && layer.onPostRenderTransparent) {
					layer.onPostRenderTransparent(cameraPass);
				}
				if (layer.onPostRender && !(layer._postRenderCalledForCameras & (1 << cameraPass))) {
					layer._postRenderCounter &= ~(transparent ? 2 : 1);
					if (layer._postRenderCounter === 0) {
						layer.onPostRender(cameraPass);
						layer._postRenderCalledForCameras |= 1 << cameraPass;
						layer._postRenderCounter = layer._postRenderCounterMax;
					}
				}
			}
		}
	});

	function BasicMaterial() {
		Material.call(this);
		this.color = new Color(1, 1, 1, 1);
		this.colorUniform = new Float32Array(4);
		this.colorMap = null;
		this.vertexColors = false;
	}
	BasicMaterial.prototype = Object.create(Material.prototype);
	BasicMaterial.prototype.constructor = BasicMaterial;
	Object.assign(BasicMaterial.prototype, {
		clone: function () {
			var clone = new BasicMaterial();
			Material.prototype._cloneInternal.call(this, clone);
			clone.color.copy(this.color);
			clone.colorMap = this.colorMap;
			clone.vertexColors = this.vertexColors;
			return clone;
		},
		updateUniforms: function () {
			this.clearParameters();
			this.colorUniform[0] = this.color.r;
			this.colorUniform[1] = this.color.g;
			this.colorUniform[2] = this.color.b;
			this.colorUniform[3] = this.color.a;
			this.setParameter('uColor', this.colorUniform);
			if (this.colorMap) {
				this.setParameter('texture_diffuseMap', this.colorMap);
			}
		},
		updateShader: function (device, scene, objDefs, staticLightList, pass, sortedLights) {
			var options = {
				skin: !!this.meshInstances[0].skinInstance,
				vertexColors: this.vertexColors,
				diffuseMap: !!this.colorMap,
				pass: pass
			};
			var library = device.getProgramLibrary();
			this.shader = library.getProgram('basic', options);
		}
	});

	var identityGraphNode = new GraphNode();
	function ImmediateData(device) {
		this.lineVertexFormat = new VertexFormat(device, [
			{ semantic: SEMANTIC_POSITION, components: 3, type: TYPE_FLOAT32 },
			{ semantic: SEMANTIC_COLOR, components: 4, type: TYPE_UINT8, normalize: true }
		]);
		this.lineBatches = [];
		this.layers = [];
		this.layerToBatch = {};
		this.quadMesh = null;
		this.cubeLocalPos = null;
		this.cubeWorldPos = null;
		this.identityGraphNode = new GraphNode();
	}
	ImmediateData.prototype.addLayer = function (layer) {
		if (this.layers.indexOf(layer) < 0) {
			this.layers.push(layer);
		}
	};
	ImmediateData.prototype.getLayerIdx = function (layer) {
		return this.layerToBatch[layer.id];
	};
	ImmediateData.prototype.addLayerIdx = function (idx, layer) {
		this.layerToBatch[layer.id] = idx;
	};
	function LineBatch() {
		this.numLinesAllocated = 128;
		this.vb = null;
		this.vbRam = null;
		this.mesh = null;
		this.linesUsed = 0;
		this.material = null;
		this.meshInstance = null;
		this.layer = null;
	}
	Object.assign(LineBatch.prototype, {
		init: function (device, vertexFormat, layer, linesToAdd) {
			if (!this.mesh) {
				this.mesh = new Mesh(device);
				this.mesh.primitive[0].type = PRIMITIVE_LINES;
				this.mesh.primitive[0].base = 0;
				this.mesh.primitive[0].indexed = false;
				this.material = new BasicMaterial();
				this.material.vertexColors = true;
				this.material.blend = true;
				this.material.blendType = BLEND_NORMAL;
				this.material.update();
			}
			this.layer = layer;
			while ((this.linesUsed + linesToAdd) > this.numLinesAllocated) {
				if (this.vb) {
					this.vb.destroy();
					this.vb = null;
				}
				this.numLinesAllocated *= 2;
			}
			this.vertexFormat = vertexFormat;
			if (!this.vb) {
				this.vb = new VertexBuffer(device, vertexFormat, this.numLinesAllocated * 2, BUFFER_DYNAMIC);
				this.mesh.vertexBuffer = this.vb;
				this.vbRam = new DataView(this.vb.lock());
				if (!this.meshInstance) {
					identityGraphNode.worldTransform = Mat4.IDENTITY;
					identityGraphNode._dirtyWorld = identityGraphNode._dirtyNormal = false;
					this.meshInstance = new MeshInstance(identityGraphNode, this.mesh, this.material);
					this.meshInstance.cull = false;
				}
			}
		},
		addLines: function (position, color) {
			var multiColor = !!color.length;
			var offset = this.linesUsed * 2 * this.vertexFormat.size;
			var clr;
			for (var i = 0; i < position.length; i++) {
				this.vbRam.setFloat32(offset, position[i].x, true); offset += 4;
				this.vbRam.setFloat32(offset, position[i].y, true); offset += 4;
				this.vbRam.setFloat32(offset, position[i].z, true); offset += 4;
				clr = multiColor ? color[i] : color;
				this.vbRam.setUint8(offset, clr.r * 255); offset += 1;
				this.vbRam.setUint8(offset, clr.g * 255); offset += 1;
				this.vbRam.setUint8(offset, clr.b * 255); offset += 1;
				this.vbRam.setUint8(offset, clr.a * 255); offset += 1;
			}
			this.linesUsed += position.length / 2;
		},
		finalize: function (meshInstanceArray) {
			if (this.linesUsed > 0) {
				this.vb.setData(this.vbRam.buffer);
				this.mesh.primitive[0].count = this.linesUsed * 2;
				meshInstanceArray[0] = this.meshInstance;
				this.layer.addMeshInstances(meshInstanceArray, true);
				this.linesUsed = 0;
			}
		}
	});

	function LayerComposition() {
		EventHandler.call(this);
		this.layerList = [];
		this.subLayerList = [];
		this.subLayerEnabled = [];
		this._opaqueOrder = {};
		this._transparentOrder = {};
		this._dirty = false;
		this._dirtyBlend = false;
		this._dirtyLights = false;
		this._dirtyCameras = false;
		this._meshInstances = [];
		this._lights = [];
		this.cameras = [];
		this._sortedLights = [[], [], []];
		this._lightShadowCasters = [];
		this._globalLightCameras = [];
		this._globalLightCameraIds = [];
		this._renderedRt = [];
		this._renderedByCam = [];
		this._renderedLayer = [];
		this._renderList = [];
		this._renderListCamera = [];
	}
	LayerComposition.prototype = Object.create(EventHandler.prototype);
	LayerComposition.prototype.constructor = LayerComposition;
	LayerComposition.prototype._sortLights = function (target) {
		var light;
		var lights = target._lights;
		target._sortedLights[LIGHTTYPE_DIRECTIONAL].length = 0;
		target._sortedLights[LIGHTTYPE_POINT].length = 0;
		target._sortedLights[LIGHTTYPE_SPOT].length = 0;
		for (var i = 0; i < lights.length; i++) {
			light = lights[i];
			if (light.enabled) {
				target._sortedLights[light._type].push(light);
			}
		}
	};
	LayerComposition.prototype._update = function () {
		var i, j, k, l;
		var layer;
		var len = this.layerList.length;
		var result = 0;
		if (!this._dirty || !this._dirtyLights || !this._dirtyCameras) {
			for (i = 0; i < len; i++) {
				layer = this.layerList[i];
				if (layer._dirty) {
					this._dirty = true;
				}
				if (layer._dirtyLights) {
					this._dirtyLights = true;
				}
				if (layer._dirtyCameras) {
					this._dirtyCameras = true;
				}
			}
		}
		var arr;
		if (this._dirty) {
			result |= COMPUPDATED_INSTANCES;
			this._meshInstances.length = 0;
			var mi;
			for (i = 0; i < len; i++) {
				layer = this.layerList[i];
				if (layer.passThrough) continue;
				arr = layer.opaqueMeshInstances;
				for (j = 0; j < arr.length; j++) {
					mi = arr[j];
					if (this._meshInstances.indexOf(mi) < 0) {
						this._meshInstances.push(mi);
						if (mi.material && mi.material._dirtyBlend) {
							this._dirtyBlend = true;
							mi.material._dirtyBlend = false;
						}
					}
				}
				arr = layer.transparentMeshInstances;
				for (j = 0; j < arr.length; j++) {
					mi = arr[j];
					if (this._meshInstances.indexOf(mi) < 0) {
						this._meshInstances.push(mi);
						if (mi.material && mi.material._dirtyBlend) {
							this._dirtyBlend = true;
							mi.material._dirtyBlend = false;
						}
					}
				}
			}
			for (i = 0; i < len; i++) {
				this.layerList[i]._dirty = false;
				this.layerList[i]._version++;
			}
			this._dirty = false;
		}
		if (this._dirtyBlend) {
			result |= COMPUPDATED_BLEND;
			var opaqueOld, transparentOld, opaqueNew, transparentNew;
			for (i = 0; i < len; i++) {
				layer = this.layerList[i];
				if (layer.passThrough) continue;
				opaqueOld = layer.opaqueMeshInstances;
				transparentOld = layer.transparentMeshInstances;
				opaqueNew = [];
				transparentNew = [];
				for (j = 0; j < opaqueOld.length; j++) {
					if (opaqueOld[j].material && opaqueOld[j].material.blendType !== BLEND_NONE) {
						transparentNew.push(opaqueOld[j]);
					} else {
						opaqueNew.push(opaqueOld[j]);
					}
				}
				for (j = 0; j < transparentOld.length; j++) {
					if (transparentOld[j].material && transparentOld[j].material.blendType !== BLEND_NONE) {
						transparentNew.push(transparentOld[j]);
					} else {
						opaqueNew.push(transparentOld[j]);
					}
				}
				layer.opaqueMeshInstances.length = opaqueNew.length;
				for (j = 0; j < opaqueNew.length; j++) {
					layer.opaqueMeshInstances[j] = opaqueNew[j];
				}
				layer.transparentMeshInstances.length = transparentNew.length;
				for (j = 0; j < transparentNew.length; j++) {
					layer.transparentMeshInstances[j] = transparentNew[j];
				}
			}
			this._dirtyBlend = false;
		}
		var casters, lid, light;
		if (this._dirtyLights) {
			result |= COMPUPDATED_LIGHTS;
			this._lights.length = 0;
			this._lightShadowCasters.length = 0;
			for (i = 0; i < len; i++) {
				layer = this.layerList[i];
				arr = layer._lights;
				for (j = 0; j < arr.length; j++) {
					light = arr[j];
					lid = this._lights.indexOf(light);
					if (lid < 0) {
						this._lights.push(light);
						lid = this._lights.length - 1;
					}
					casters = this._lightShadowCasters[lid];
					if (!casters) {
						this._lightShadowCasters[lid] = casters = [];
					}
				}
			}
			this._sortLights(this);
			this._dirtyLights = false;
			for (i = 0; i < len; i++) {
				layer = this.layerList[i];
				this._sortLights(layer);
				layer._dirtyLights = false;
			}
		}
		if (result) {
			for (i = 0; i < len; i++) {
				layer = this.layerList[i];
				arr = layer._lights;
				for (j = 0; j < arr.length; j++) {
					light = arr[j];
					lid = this._lights.indexOf(light);
					casters = this._lightShadowCasters[lid];
					var meshInstances = layer.shadowCasters;
					for (k = 0; k < casters.length;) {
						if (this._meshInstances.indexOf(casters[k]) < 0) {
							casters[k] = casters[casters.length - 1];
							casters.length -= 1;
						} else {
							k++;
						}
					}
					for (k = 0; k < meshInstances.length; k++) {
						if (casters.indexOf(meshInstances[k]) < 0) casters.push(meshInstances[k]);
					}
				}
			}
		}
		if ((result & COMPUPDATED_LIGHTS) || this._dirtyCameras) {
			this._globalLightCameras.length = 0;
			var globalLights = this._sortedLights[LIGHTTYPE_DIRECTIONAL];
			for (l = 0; l < globalLights.length; l++) {
				light = globalLights[l];
				this._globalLightCameras[l] = [];
				for (i = 0; i < len; i++) {
					layer = this.layerList[i];
					if (layer._sortedLights[LIGHTTYPE_DIRECTIONAL].indexOf(light) < 0) continue;
					for (k = 0; k < layer.cameras.length; k++) {
						if (this._globalLightCameras[l].indexOf(layer.cameras[k]) >= 0) continue;
						this._globalLightCameras[l].push(layer.cameras[k]);
					}
				}
			}
		}
		var camera, index;
		if (this._dirtyCameras) {
			result |= COMPUPDATED_CAMERAS;
			this.cameras.length = 0;
			for (i = 0; i < len; i++) {
				layer = this.layerList[i];
				for (j = 0; j < layer.cameras.length; j++) {
					camera = layer.cameras[j];
					index = this.cameras.indexOf(camera);
					if (index < 0) {
						index = this.cameras.length;
						this.cameras.push(camera);
					}
				}
			}
			this._renderList.length = 0;
			this._renderListCamera.length = 0;
			var hash, hash2, groupLength, cam;
			var skipCount = 0;
			for (i = 0; i < len; i++) {
				if (skipCount) {
					skipCount--;
					continue;
				}
				layer = this.layerList[i];
				if (layer.cameras.length === 0 && !layer.isPostEffect) continue;
				hash = layer._cameraHash;
				if (hash === 0) {
					this._renderList.push(i);
					this._renderListCamera.push(0);
				} else {
					groupLength = 1;
					for (j = i + 1; j < len; j++) {
						hash2 = this.layerList[j]._cameraHash;
						if (hash !== hash2) {
							groupLength = (j - i) - 1;
							break;
						} else if (j === len - 1) {
							groupLength = j - i;
						}
					}
					if (groupLength === 1) {
						for (cam = 0; cam < layer.cameras.length; cam++) {
							this._renderList.push(i);
							this._renderListCamera.push(cam);
						}
					} else {
						cam = 0;
						for (cam = 0; cam < layer.cameras.length; cam++) {
							for (j = 0; j <= groupLength; j++) {
								this._renderList.push(i + j);
								this._renderListCamera.push(cam);
							}
						}
						skipCount = groupLength;
					}
				}
			}
			this._dirtyCameras = false;
			for (i = 0; i < len; i++) {
				this.layerList[i]._dirtyCameras = false;
			}
		}
		if ((result & COMPUPDATED_LIGHTS) || (result & COMPUPDATED_CAMERAS)) {
			this._globalLightCameraIds.length = 0;
			for (l = 0; l < this._globalLightCameras.length; l++) {
				arr = [];
				for (i = 0; i < this._globalLightCameras[l].length; i++) {
					index = this.cameras.indexOf( this._globalLightCameras[l][i] );
					if (index < 0) {
						continue;
					}
					arr.push(index);
				}
				this._globalLightCameraIds.push(arr);
			}
		}
		return result;
	};
	LayerComposition.prototype._isLayerAdded = function (layer) {
		if (this.layerList.indexOf(layer) >= 0) {
			return true;
		}
		return false;
	};
	LayerComposition.prototype._isSublayerAdded = function (layer, transparent) {
		for (var i = 0; i < this.layerList.length; i++) {
			if (this.layerList[i] === layer && this.subLayerList[i] === transparent) {
				return true;
			}
		}
		return false;
	};
	LayerComposition.prototype.push = function (layer) {
		if (this._isLayerAdded(layer)) return;
		this.layerList.push(layer);
		this.layerList.push(layer);
		this._opaqueOrder[layer.id] = this.subLayerList.push(false) - 1;
		this._transparentOrder[layer.id] = this.subLayerList.push(true) - 1;
		this.subLayerEnabled.push(true);
		this.subLayerEnabled.push(true);
		this._dirty = true;
		this._dirtyLights = true;
		this._dirtyCameras = true;
		this.fire("add", layer);
	};
	LayerComposition.prototype.insert = function (layer, index) {
		if (this._isLayerAdded(layer)) return;
		this.layerList.splice(index, 0,	layer,  layer);
		this.subLayerList.splice(index, 0, false,  true);
		var count = this.layerList.length;
		this._updateOpaqueOrder(index, count - 1);
		this._updateTransparentOrder(index, count - 1);
		this.subLayerEnabled.splice(index, 0, true,  true);
		this._dirty = true;
		this._dirtyLights = true;
		this._dirtyCameras = true;
		this.fire("add", layer);
	};
	LayerComposition.prototype.remove = function (layer) {
		var id = this.layerList.indexOf(layer);
		delete this._opaqueOrder[id];
		delete this._transparentOrder[id];
		while (id >= 0) {
			this.layerList.splice(id, 1);
			this.subLayerList.splice(id, 1);
			this.subLayerEnabled.splice(id, 1);
			id = this.layerList.indexOf(layer);
			this._dirty = true;
			this._dirtyLights = true;
			this._dirtyCameras = true;
			this.fire("remove", layer);
		}
		var count = this.layerList.length;
		this._updateOpaqueOrder(0, count - 1);
		this._updateTransparentOrder(0, count - 1);
	};
	LayerComposition.prototype.pushOpaque = function (layer) {
		if (this._isSublayerAdded(layer, false)) return;
		this.layerList.push(layer);
		this._opaqueOrder[layer.id] = this.subLayerList.push(false) - 1;
		this.subLayerEnabled.push(true);
		this._dirty = true;
		this._dirtyLights = true;
		this._dirtyCameras = true;
		this.fire("add", layer);
	};
	LayerComposition.prototype.insertOpaque = function (layer, index) {
		if (this._isSublayerAdded(layer, false)) return;
		this.layerList.splice(index, 0,	layer);
		this.subLayerList.splice(index, 0, false);
		var count = this.subLayerList.length;
		this._updateOpaqueOrder(index, count - 1);
		this.subLayerEnabled.splice(index, 0, true);
		this._dirty = true;
		this._dirtyLights = true;
		this._dirtyCameras = true;
		this.fire("add", layer);
	};
	LayerComposition.prototype.removeOpaque = function (layer) {
		for (var i = 0, len = this.layerList.length; i < len; i++) {
			if (this.layerList[i] === layer && !this.subLayerList[i]) {
				this.layerList.splice(i, 1);
				this.subLayerList.splice(i, 1);
				len--;
				this._updateOpaqueOrder(i, len - 1);
				this.subLayerEnabled.splice(i, 1);
				this._dirty = true;
				this._dirtyLights = true;
				this._dirtyCameras = true;
				if (this.layerList.indexOf(layer) < 0) {
					this.fire("remove", layer);
				}
				return;
			}
		}
	};
	LayerComposition.prototype.pushTransparent = function (layer) {
		if (this._isSublayerAdded(layer, true)) return;
		this.layerList.push(layer);
		this._transparentOrder[layer.id] = this.subLayerList.push(true) - 1;
		this.subLayerEnabled.push(true);
		this._dirty = true;
		this._dirtyLights = true;
		this._dirtyCameras = true;
		this.fire("add", layer);
	};
	LayerComposition.prototype.insertTransparent = function (layer, index) {
		if (this._isSublayerAdded(layer, true)) return;
		this.layerList.splice(index, 0,	layer);
		this.subLayerList.splice(index, 0, true);
		var count = this.subLayerList.length;
		this._updateTransparentOrder(index, count - 1);
		this.subLayerEnabled.splice(index, 0, true);
		this._dirty = true;
		this._dirtyLights = true;
		this._dirtyCameras = true;
		this.fire("add", layer);
	};
	LayerComposition.prototype.removeTransparent = function (layer) {
		for (var i = 0, len = this.layerList.length; i < len; i++) {
			if (this.layerList[i] === layer && this.subLayerList[i]) {
				this.layerList.splice(i, 1);
				this.subLayerList.splice(i, 1);
				len--;
				this._updateTransparentOrder(i, len - 1);
				this.subLayerEnabled.splice(i, 1);
				this._dirty = true;
				this._dirtyLights = true;
				this._dirtyCameras = true;
				if (this.layerList.indexOf(layer) < 0) {
					this.fire("remove", layer);
				}
				return;
			}
		}
	};
	LayerComposition.prototype._getSublayerIndex = function (layer, transparent) {
		var id = this.layerList.indexOf(layer);
		if (id < 0) return -1;
		if (this.subLayerList[id] !== transparent) {
			id = this.layerList.indexOf(layer, id + 1);
			if (id < 0) return -1;
			if (this.subLayerList[id] !== transparent) {
				return -1;
			}
		}
		return id;
	};
	LayerComposition.prototype.getOpaqueIndex = function (layer) {
		return this._getSublayerIndex(layer, false);
	};
	LayerComposition.prototype.getTransparentIndex = function (layer) {
		return this._getSublayerIndex(layer, true);
	};
	LayerComposition.prototype.getLayerById = function (id) {
		for (var i = 0; i < this.layerList.length; i++) {
			if (this.layerList[i].id === id) return this.layerList[i];
		}
		return null;
	};
	LayerComposition.prototype.getLayerByName = function (name) {
		for (var i = 0; i < this.layerList.length; i++) {
			if (this.layerList[i].name === name) return this.layerList[i];
		}
		return null;
	};
	LayerComposition.prototype._updateOpaqueOrder = function (startIndex, endIndex) {
		for (var i = startIndex; i <= endIndex; i++) {
			if (this.subLayerList[i] === false) {
				this._opaqueOrder[this.layerList[i].id] = i;
			}
		}
	};
	LayerComposition.prototype._updateTransparentOrder = function (startIndex, endIndex) {
		for (var i = startIndex; i <= endIndex; i++) {
			if (this.subLayerList[i] === true) {
				this._transparentOrder[this.layerList[i].id] = i;
			}
		}
	};
	LayerComposition.prototype._sortLayersDescending = function (layersA, layersB, order) {
		var i = 0;
		var len = 0;
		var id = 0;
		var topLayerA = -1;
		var topLayerB = -1;
		for (i = 0, len = layersA.length; i < len; i++) {
			id = layersA[i];
			if (order.hasOwnProperty(id)) {
				topLayerA = Math.max(topLayerA, order[id]);
			}
		}
		for (i = 0, len = layersB.length; i < len; i++) {
			id = layersB[i];
			if (order.hasOwnProperty(id)) {
				topLayerB = Math.max(topLayerB, order[id]);
			}
		}
		if (topLayerA === -1 && topLayerB !== -1) {
			return 1;
		} else if (topLayerB === -1 && topLayerA !== -1) {
			return -1;
		}
		return topLayerB - topLayerA;
	};
	LayerComposition.prototype.sortTransparentLayers = function (layersA, layersB) {
		return this._sortLayersDescending(layersA, layersB, this._transparentOrder);
	};
	LayerComposition.prototype.sortOpaqueLayers = function (layersA, layersB) {
		return this._sortLayersDescending(layersA, layersB, this._opaqueOrder);
	};

	var maxSize = 2048;
	var maskBaked = 2;
	var maskLightmap = 4;
	var sceneLightmaps = [];
	var sceneLightmapsNode = [];
	var lmCamera;
	var tempVec = new Vec3();
	var bounds = new BoundingBox();
	var lightBounds = new BoundingBox();
	var tempSphere$1 = {};
	var PASS_COLOR = 0;
	var PASS_DIR = 1;
	var passTexName = ["texture_lightMap", "texture_dirLightMap"];
	var passMaterial = [];
	function collectModels(node, nodes, nodesMeshInstances, allNodes) {
		if (!node.enabled) return;
		var i;
		if (node.model && node.model.model && node.model.enabled) {
			if (allNodes) allNodes.push(node);
			if (node.model.lightmapped) {
				if (nodes) {
					var hasUv1 = true;
					var meshInstances = node.model.model.meshInstances;
					for (i = 0; i < meshInstances.length; i++) {
						if (!meshInstances[i].mesh.vertexBuffer.format.hasUv1) {
							hasUv1 = false;
							break;
						}
					}
					if (hasUv1) {
						var j;
						var isInstance;
						var notInstancedMeshInstances = [];
						for (i = 0; i < meshInstances.length; i++) {
							isInstance = false;
							for (j = 0; j < meshInstances.length; j++) {
								if (i !== j) {
									if (meshInstances[i].mesh === meshInstances[j].mesh) {
										isInstance = true;
									}
								}
							}
							if (isInstance) {
								nodes.push(node);
								nodesMeshInstances.push([meshInstances[i]]);
							} else {
								notInstancedMeshInstances.push(meshInstances[i]);
							}
						}
						if (notInstancedMeshInstances.length > 0) {
							nodes.push(node);
							nodesMeshInstances.push(notInstancedMeshInstances);
						}
					}
				}
			}
		}
		for (i = 0; i < node._children.length; i++) {
			collectModels(node._children[i], nodes, nodesMeshInstances, allNodes);
		}
	}
	function Lightmapper(device, root, scene, renderer, assets) {
		this.device = device;
		this.root = root;
		this.scene = scene;
		this.renderer = renderer;
		this.assets = assets;
	}
	Object.assign(Lightmapper.prototype, {
		destroy: function () {
			this.device = null;
			this.root = null;
			this.scene = null;
			this.renderer = null;
			this.assets = null;
		},
		calculateLightmapSize: function (node) {
			var data, parent;
			var sizeMult = this.scene.lightmapSizeMultiplier || 16;
			var scale = tempVec;
			var area = { x: 1, y: 1, z: 1, uv: 1 };
			if (node.model.asset) {
				data = this.assets.get(node.model.asset).data;
				if (data.area) {
					area.x = data.area.x;
					area.y = data.area.y;
					area.z = data.area.z;
					area.uv = data.area.uv;
				}
			} else if (node.model._area) {
				data = node.model;
				if (data._area) {
					area.x = data._area.x;
					area.y = data._area.y;
					area.z = data._area.z;
					area.uv = data._area.uv;
				}
			}
			var areaMult = node.model.lightmapSizeMultiplier || 1;
			area.x *= areaMult;
			area.y *= areaMult;
			area.z *= areaMult;
			scale.copy(node.localScale);
			parent = node._parent;
			while (parent) {
				scale.mul(parent.localScale);
				parent = parent._parent;
			}
			scale.x = Math.abs(scale.x);
			scale.y = Math.abs(scale.y);
			scale.z = Math.abs(scale.z);
			var totalArea = area.x * scale.y * scale.z +
							area.y * scale.x * scale.z +
							area.z * scale.x * scale.y;
			totalArea /= area.uv;
			totalArea = Math.sqrt(totalArea);
			return Math.min(math.nextPowerOfTwo(totalArea * sizeMult), this.scene.lightmapMaxResolution || maxSize);
		},
		bake: function (nodes, mode) {
			var i, j;
			var device = this.device;
			var scene = this.scene;
			var passCount = 1;
			if (mode === undefined) mode = BAKE_COLORDIR;
			if (mode === BAKE_COLORDIR) passCount = 2;
			var pass;
			var allNodes = [];
			var nodesMeshInstances = [];
			if (!nodes) {
				for (i = 0; i < sceneLightmaps.length; i++) {
					for (j = 0; j < sceneLightmaps[i].length; j++) {
						sceneLightmaps[i][j].destroy();
					}
				}
				sceneLightmaps = [];
				sceneLightmapsNode = [];
				nodes = [];
				collectModels(this.root, nodes, nodesMeshInstances, allNodes);
			} else {
				var k;
				for (i = sceneLightmapsNode.length - 1; i >= 0; i--) {
					for (j = 0; j < nodes.length; j++) {
						if (sceneLightmapsNode[i] === nodes[j]) {
							for (k = 0; k < sceneLightmaps[i].length; k++) {
								sceneLightmaps[i][k].destroy();
							}
							sceneLightmaps.splice(i, 1);
							sceneLightmapsNode.splice(i, 1);
						}
					}
				}
				var _nodes = [];
				for (i = 0; i < nodes.length; i++) {
					collectModels(nodes[i], _nodes, nodesMeshInstances);
				}
				nodes = _nodes;
				collectModels(this.root, null, null, allNodes);
			}
			if (nodes.length === 0) {
				device.fire('lightmapper:end', {
					timestamp: now(),
					target: this
				});
				return;
			}
			var revertStatic = false;
			if (scene._needsStaticPrepare) {
				scene._needsStaticPrepare = false;
				revertStatic = true;
			}
			var lmaps = [[], []];
			var texPool = {};
			var size;
			var tex;
			var blackTex = new Texture(this.device, {
				width: 4,
				height: 4,
				format: PIXELFORMAT_R8_G8_B8_A8,
				type: TEXTURETYPE_RGBM
			});
			blackTex.name = 'lightmap';
			for (i = 0; i < nodes.length; i++) {
				size = this.calculateLightmapSize(nodes[i]);
				for (pass = 0; pass < passCount; pass++) {
					tex = new Texture(device, {
						width: size,
						height: size,
						format: PIXELFORMAT_R8_G8_B8_A8,
						mipmaps: false,
						type: (pass === PASS_COLOR) ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT,
						minFilter: FILTER_NEAREST,
						magFilter: FILTER_NEAREST
					});
					tex.name = 'lightmap';
					lmaps[pass].push(tex);
				}
				if (!texPool[size]) {
					var tex2 = new Texture(device, {
						width: size,
						height: size,
						format: PIXELFORMAT_R8_G8_B8_A8,
						mipmaps: false,
						type: TEXTURETYPE_RGBM,
						minFilter: FILTER_NEAREST,
						magFilter: FILTER_NEAREST
					});
					tex2.name = 'lightmap';
					var targ2 = new RenderTarget(device, tex2, {
						depth: false
					});
					texPool[size] = targ2;
				}
			}
			var activeComp = scene.layers;
			activeComp._update();
			var lights = [];
			var origMask = [];
			var origShadowMode = [];
			var origEnabled = [];
			var sceneLights = activeComp._lights;
			var mask;
			for (i = 0; i < sceneLights.length; i++) {
				if (sceneLights[i].enabled) {
					mask = sceneLights[i].mask;
					if ((mask & maskLightmap) !== 0) {
						origMask.push(mask);
						origShadowMode.push(sceneLights[i].shadowUpdateMode);
						sceneLights[i].mask = 0xFFFFFFFF;
						sceneLights[i].shadowUpdateMode =
							sceneLights[i]._type === LIGHTTYPE_DIRECTIONAL ? SHADOWUPDATE_REALTIME : SHADOWUPDATE_THISFRAME;
						lights.push(sceneLights[i]);
						sceneLights[i].isStatic = false;
					}
				}
				origEnabled.push(sceneLights[i].enabled);
				sceneLights[i].enabled = false;
			}
			var xformUv1 = "#define UV1LAYOUT\n" + shaderChunks.transformVS;
			var bakeLmEnd = shaderChunks.bakeLmEndPS;
			var dilate = shaderChunks.dilatePS;
			var dilateShader = createShaderFromCode(device, shaderChunks.fullscreenQuadVS, dilate, "lmDilate");
			var constantTexSource = device.scope.resolve("source");
			var constantPixelOffset = device.scope.resolve("pixelOffset");
			var constantBakeDir = device.scope.resolve("bakeDir");
			var pixelOffset = new Float32Array(2);
			var drawCalls = activeComp._meshInstances;
			for (i = 0; i < drawCalls.length; i++) {
				if (drawCalls[i].node) drawCalls[i].node.getWorldTransform();
			}
			var origFog = scene.fog;
			var origAmbientR = scene.ambientLight.r;
			var origAmbientG = scene.ambientLight.g;
			var origAmbientB = scene.ambientLight.b;
			scene.fog = FOG_NONE;
			scene.ambientLight.set(0, 0, 0);
			if (!lmCamera) {
				lmCamera = new Camera();
				lmCamera.clearColor = new Color(0, 0, 0, 0);
				lmCamera.clearColorBuffer = true;
				lmCamera.clearDepthBuffer = false;
				lmCamera.clearStencilBuffer = false;
				lmCamera.frustumCulling = false;
				lmCamera.node = new GraphNode();
			}
			var node;
			var lm, rcv, m;
			var origShaderDefs = [];
			origShaderDefs.length = sceneLightmapsNode.length;
			var shaderDefs;
			for (node = 0; node < allNodes.length; node++) {
				rcv = allNodes[node].model.model.meshInstances;
				shaderDefs = [];
				for (i = 0; i < rcv.length; i++) {
					shaderDefs.push(rcv[i]._shaderDefs);
					rcv[i]._shaderDefs &= ~(SHADERDEF_LM | SHADERDEF_DIRLM);
				}
				for (i = 0; i < sceneLightmapsNode.length; i++) {
					if (sceneLightmapsNode[i] === allNodes[node]) {
						origShaderDefs[i] = shaderDefs;
						break;
					}
				}
			}
			var origCastShadows = [];
			var casters = [];
			var meshes;
			for (node = 0; node < allNodes.length; node++) {
				origCastShadows[node] = allNodes[node].model.castShadows;
				allNodes[node].model.castShadows = allNodes[node].model.castShadowsLightmap;
				if (allNodes[node].model.castShadowsLightmap) {
					meshes = allNodes[node].model.meshInstances;
					for (i = 0; i < meshes.length; i++) {
						meshes[i].visibleThisFrame = true;
						casters.push(meshes[i]);
					}
				}
			}
			this.renderer.updateCpuSkinMatrices(casters);
			this.renderer.gpuUpdate(casters);
			var origMat = [];
			var nodeBounds = [];
			var nodeTarg = [[], []];
			var targ, targTmp, texTmp;
			var light, shadowCam;
			var nodeLightCount = [];
			nodeLightCount.length = nodes.length;
			var lmMaterial;
			for (pass = 0; pass < passCount; pass++) {
				if (!passMaterial[pass]) {
					lmMaterial = new StandardMaterial();
					lmMaterial.chunks.transformVS = xformUv1;
					if (pass === PASS_COLOR) {
						lmMaterial.chunks.endPS = bakeLmEnd;
						lmMaterial.ambient = new Color(0, 0, 0);
						lmMaterial.ambientTint = true;
						lmMaterial.lightMap = blackTex;
					} else {
						lmMaterial.chunks.basePS = shaderChunks.basePS + "\nuniform sampler2D texture_dirLightMap;\nuniform float bakeDir;\n";
						lmMaterial.chunks.endPS = shaderChunks.bakeDirLmEndPS;
					}
					lmMaterial.chunks.outputAlphaPS = "\n";
					lmMaterial.chunks.outputAlphaOpaquePS = "\n";
					lmMaterial.chunks.outputAlphaPremulPS = "\n";
					lmMaterial.cull = CULLFACE_NONE;
					lmMaterial.forceUv1 = true;
					lmMaterial.update();
					lmMaterial.updateShader(device, scene);
					lmMaterial.name = "lmMaterial" + pass;
					passMaterial[pass] = lmMaterial;
				}
			}
			for (node = 0; node < nodes.length; node++) {
				rcv = nodesMeshInstances[node];
				nodeLightCount[node] = 0;
				if (rcv.length > 0) {
					bounds.copy(rcv[0].aabb);
					for (i = 0; i < rcv.length; i++) {
						rcv[i].node.getWorldTransform();
						bounds.add(rcv[i].aabb);
					}
				}
				var nbounds = new BoundingBox();
				nbounds.copy(bounds);
				nodeBounds.push(nbounds);
				for (i = 0; i < rcv.length; i++) {
					m = rcv[i];
					m._shaderDefs &= ~(SHADERDEF_LM | SHADERDEF_DIRLM);
					m.mask = maskLightmap;
					m.deleteParameter("texture_lightMap");
					m.deleteParameter("texture_dirLightMap");
					m.setParameter("texture_lightMap", m.material.lightMap ? m.material.lightMap : blackTex);
					m.setParameter("texture_dirLightMap", blackTex);
				}
				for (pass = 0; pass < passCount; pass++) {
					lm = lmaps[pass][node];
					targ = new RenderTarget(device, lm, {
						depth: false
					});
					nodeTarg[pass].push(targ);
				}
			}
			for (j = 0; j < lights.length; j++)
				lights[j].enabled = false;
			var lightArray = [[], [], []];
			var shadersUpdatedOn1stPass = false;
			var shadowMapRendered;
			for (i = 0; i < lights.length; i++) {
				lights[i].enabled = true;
				shadowMapRendered = false;
				lights[i]._cacheShadowMap = true;
				if (lights[i]._type !== LIGHTTYPE_DIRECTIONAL) {
					lights[i]._node.getWorldTransform();
					lights[i].getBoundingSphere(tempSphere$1);
					lightBounds.center = tempSphere$1.center;
					lightBounds.halfExtents.x = tempSphere$1.radius;
					lightBounds.halfExtents.y = tempSphere$1.radius;
					lightBounds.halfExtents.z = tempSphere$1.radius;
				}
				if (lights[i]._type === LIGHTTYPE_SPOT) {
					light = lights[i];
					shadowCam = this.renderer.getShadowCamera(device, light);
					shadowCam._node.setPosition(light._node.getPosition());
					shadowCam._node.setRotation(light._node.getRotation());
					shadowCam._node.rotateLocal(-90, 0, 0);
					shadowCam.projection = PROJECTION_PERSPECTIVE;
					shadowCam.nearClip = light.attenuationEnd / 1000;
					shadowCam.farClip = light.attenuationEnd;
					shadowCam.aspectRatio = 1;
					shadowCam.fov = light._outerConeAngle * 2;
					this.renderer.updateCameraFrustum(shadowCam);
				}
				if (nodesMeshInstances.length > 0) {
					this.renderer.updateShaders(nodesMeshInstances[0]);
				}
				for (node = 0; node < nodes.length; node++) {
					rcv = nodesMeshInstances[node];
					bounds = nodeBounds[node];
					if (lights[i]._type === LIGHTTYPE_DIRECTIONAL) {
						tempVec.copy(bounds.center);
						tempVec.y += bounds.halfExtents.y;
						lmCamera.node.setPosition(tempVec);
						lmCamera.node.setEulerAngles(-90, 0, 0);
						var frustumSize = Math.max(bounds.halfExtents.x, bounds.halfExtents.z);
						lmCamera.projection = PROJECTION_ORTHOGRAPHIC;
						lmCamera.nearClip = 0;
						lmCamera.farClip = bounds.halfExtents.y * 2;
						lmCamera.aspectRatio = 1;
						lmCamera.orthoHeight = frustumSize;
					} else {
						if (!lightBounds.intersects(bounds)) {
							continue;
						}
					}
					if (lights[i]._type === LIGHTTYPE_SPOT) {
						var nodeVisible = false;
						for (j = 0; j < rcv.length; j++) {
							if (this.renderer._isVisible(shadowCam, rcv[j])) {
								nodeVisible = true;
								break;
							}
						}
						if (!nodeVisible) {
							continue;
						}
					}
					if (lights[i]._type === LIGHTTYPE_DIRECTIONAL) {
						lightArray[LIGHTTYPE_DIRECTIONAL][0] = lights[i];
						lightArray[LIGHTTYPE_POINT].length = 0;
						lightArray[LIGHTTYPE_SPOT].length = 0;
						if (!shadowMapRendered && lights[i].castShadows) {
							this.renderer.cullDirectionalShadowmap(lights[i], casters, lmCamera, 0);
							this.renderer.renderShadows(lightArray[LIGHTTYPE_DIRECTIONAL], 0);
							shadowMapRendered = true;
						}
					} else {
						lightArray[LIGHTTYPE_DIRECTIONAL].length = 0;
						if (lights[i]._type === LIGHTTYPE_POINT) {
							lightArray[LIGHTTYPE_POINT][0] = lights[i];
							lightArray[LIGHTTYPE_SPOT].length = 0;
							if (!shadowMapRendered && lights[i].castShadows) {
								this.renderer.cullLocalShadowmap(lights[i], casters);
								this.renderer.renderShadows(lightArray[LIGHTTYPE_POINT]);
								shadowMapRendered = true;
							}
						} else {
							lightArray[LIGHTTYPE_POINT].length = 0;
							lightArray[LIGHTTYPE_SPOT][0] = lights[i];
							if (!shadowMapRendered && lights[i].castShadows) {
								this.renderer.cullLocalShadowmap(lights[i], casters);
								this.renderer.renderShadows(lightArray[LIGHTTYPE_SPOT]);
								shadowMapRendered = true;
							}
						}
					}
					for (j = 0; j < rcv.length; j++) {
						origMat[j] = rcv[j].material;
					}
					for (pass = 0; pass < passCount; pass++) {
						lm = lmaps[pass][node];
						targ = nodeTarg[pass][node];
						targTmp = texPool[lm.width];
						texTmp = targTmp.colorBuffer;
						if (pass === 0) {
							shadersUpdatedOn1stPass = scene.updateShaders;
						} else if (shadersUpdatedOn1stPass) {
							scene.updateShaders = true;
						}
						for (j = 0; j < rcv.length; j++) {
							rcv[j].material = passMaterial[pass];
						}
						if (passCount > 1) {
							this.renderer.updateShaders(rcv);
						}
						this.renderer.setCamera(lmCamera, targTmp, true);
						if (pass === PASS_DIR) {
							constantBakeDir.setValue(lights[i].bakeDir ? 1 : 0);
						}
						this.renderer._forwardTime = 0;
						this.renderer._shadowMapTime = 0;
						this.renderer.renderForward(lmCamera,
													rcv, rcv.length,
													lightArray,
													SHADER_FORWARDHDR);
						lmaps[pass][node] = texTmp;
						nodeTarg[pass][node] = targTmp;
						texPool[lm.width] = targ;
						for (j = 0; j < rcv.length; j++) {
							m = rcv[j];
							m.setParameter(passTexName[pass], texTmp);
							m._shaderDefs |= SHADERDEF_LM;
						}
					}
					nodeLightCount[node]++;
					for (j = 0; j < rcv.length; j++) {
						rcv[j].material = origMat[j];
					}
				}
				lights[i].enabled = false;
				lights[i]._cacheShadowMap = false;
				if (lights[i]._isCachedShadowMap) {
					lights[i]._destroyShadowMap();
				}
			}
			var sceneLmaps;
			for (node = 0; node < nodes.length; node++) {
				rcv = nodesMeshInstances[node];
				sceneLmaps = [];
				for (pass = 0; pass < passCount; pass++) {
					lm = lmaps[pass][node];
					targ = nodeTarg[pass][node];
					targTmp = texPool[lm.width];
					texTmp = targTmp.colorBuffer;
					var numDilates2x = 4;
					pixelOffset[0] = 1 / lm.width;
					pixelOffset[1] = 1 / lm.height;
					constantPixelOffset.setValue(pixelOffset);
					for (i = 0; i < numDilates2x; i++) {
						constantTexSource.setValue(lm);
						drawQuadWithShader(device, targTmp, dilateShader);
						constantTexSource.setValue(texTmp);
						drawQuadWithShader(device, targ, dilateShader);
					}
					for (i = 0; i < rcv.length; i++) {
						m = rcv[i];
						m.mask = maskBaked;
						rcv[i].setParameter(passTexName[pass], lm);
						if (pass === PASS_DIR) rcv[i]._shaderDefs |= SHADERDEF_DIRLM;
					}
					sceneLmaps[pass] = lm;
					if (pass === passCount - 1) targ.destroy();
				}
				sceneLightmaps.push(sceneLmaps);
				sceneLightmapsNode.push(nodes[node]);
			}
			for (var key in texPool) {
				if (texPool.hasOwnProperty(key)) {
					texPool[key].colorBuffer.destroy();
					texPool[key].destroy();
				}
			}
			for (i = 0; i < sceneLightmaps.length; i++) {
				for (j = 0; j < sceneLightmaps[i].length; j++) {
					tex = sceneLightmaps[i][j];
					tex.minFilter = FILTER_LINEAR;
					tex.magFilter = FILTER_LINEAR;
				}
			}
			for (node = 0; node < allNodes.length; node++) {
				allNodes[node].model.castShadows = origCastShadows[node];
			}
			for (i = 0; i < origShaderDefs.length; i++) {
				if (origShaderDefs[i]) {
					rcv = sceneLightmapsNode[i].model.model.meshInstances;
					for (j = 0; j < rcv.length; j++) {
						rcv[j]._shaderDefs |= origShaderDefs[i][j] & (SHADERDEF_LM | SHADERDEF_DIRLM);
					}
				}
			}
			for (i = 0; i < lights.length; i++) {
				lights[i].mask = origMask[i];
				lights[i].shadowUpdateMode = origShadowMode[i];
			}
			for (i = 0; i < sceneLights.length; i++) {
				sceneLights[i].enabled = origEnabled[i];
			}
			scene.fog = origFog;
			scene.ambientLight.set(origAmbientR, origAmbientG, origAmbientB);
			if (revertStatic) {
				scene._needsStaticPrepare = true;
			}
		}
	});

	var nonUniformScale;
	var uniformScale = 1;
	var particleTexChannels = 4;
	var rotMat = new Mat4();
	var rotMatInv = new Mat4();
	var randomPosTformed = new Vec3();
	var randomPos = new Vec3();
	var rndFactor3Vec = new Vec3();
	var particlePosPrev = new Vec3();
	var velocityVec = new Vec3();
	var localVelocityVec = new Vec3();
	var velocityVec2 = new Vec3();
	var localVelocityVec2 = new Vec3();
	var radialVelocityVec = new Vec3();
	var particlePos = new Vec3();
	var particleFinalPos = new Vec3();
	var moveDirVec = new Vec3();
	var tmpVec3$1 = new Vec3();
	function frac(f) {
		return f - Math.floor(f);
	}
	function saturate(x) {
		return Math.max(Math.min(x, 1), 0);
	}
	function glMod(x, y) {
		return x - y * Math.floor(x / y);
	}
	function encodeFloatRGBA( v ) {
		var encX = frac(v);
		var encY = frac(255.0 * v);
		var encZ = frac(65025.0 * v);
		var encW = frac(160581375.0 * v);
		encX -= encY / 255.0;
		encY -= encZ / 255.0;
		encZ -= encW / 255.0;
		encW -= encW / 255.0;
		return [encX, encY, encZ, encW];
	}
	function encodeFloatRG( v ) {
		var encX = frac(v);
		var encY = frac(255.0 * v);
		encX -= encY / 255.0;
		encY -= encY / 255.0;
		return [encX, encY];
	}
	function ParticleCPUUpdater(emitter) {
		this._emitter = emitter;
	}
	ParticleCPUUpdater.prototype.calcSpawnPosition = function (particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, i) {
		var emitter = this._emitter;
		var rX = Math.random();
		var rY = Math.random();
		var rZ = Math.random();
		var rW = Math.random();
		if (emitter.useCpu) {
			particleTex[i * particleTexChannels + 0 + emitter.numParticlesPot * 2 * particleTexChannels] = rX;
			particleTex[i * particleTexChannels + 1 + emitter.numParticlesPot * 2 * particleTexChannels] = rY;
			particleTex[i * particleTexChannels + 2 + emitter.numParticlesPot * 2 * particleTexChannels] = rZ;
		}
		randomPos.x = rX - 0.5;
		randomPos.y = rY - 0.5;
		randomPos.z = rZ - 0.5;
		if (emitter.emitterShape === EMITTERSHAPE_BOX) {
			var max = Math.max(Math.abs(randomPos.x), Math.max(Math.abs(randomPos.y), Math.abs(randomPos.z)));
			var edgeX = max + (0.5 - max) * extentsInnerRatioUniform[0];
			var edgeY = max + (0.5 - max) * extentsInnerRatioUniform[1];
			var edgeZ = max + (0.5 - max) * extentsInnerRatioUniform[2];
			randomPos.x = edgeX * (max == Math.abs(randomPos.x) ? Math.sign(randomPos.x) : 2 * randomPos.x);
			randomPos.y = edgeY * (max == Math.abs(randomPos.y) ? Math.sign(randomPos.y) : 2 * randomPos.y);
			randomPos.z = edgeZ * (max == Math.abs(randomPos.z) ? Math.sign(randomPos.z) : 2 * randomPos.z);
			if (!emitter.localSpace)
				randomPosTformed.copy(emitterPos).add( spawnMatrix.transformPoint(randomPos) );
			else
				randomPosTformed.copy( spawnMatrix.transformPoint(randomPos) );
		} else {
			randomPos.normalize();
			var spawnBoundsSphereInnerRatio = (emitter.emitterRadius === 0) ? 0 : emitter.emitterRadiusInner / emitter.emitterRadius;
			var r = rW * (1.0 - spawnBoundsSphereInnerRatio) + spawnBoundsSphereInnerRatio;
			if (!emitter.localSpace)
				randomPosTformed.copy(emitterPos).add( randomPos.scale(r * emitter.emitterRadius) );
			else
				randomPosTformed.copy( randomPos.scale(r * emitter.emitterRadius) );
		}
		var particleRate, startSpawnTime;
		particleRate = math.lerp(emitter.rate, emitter.rate2, rX);
		startSpawnTime = -particleRate * i;
		if (emitter.pack8) {
			var packX = (randomPosTformed.x - emitter.worldBounds.center.x) / emitter.worldBoundsSize.x + 0.5;
			var packY = (randomPosTformed.y - emitter.worldBounds.center.y) / emitter.worldBoundsSize.y + 0.5;
			var packZ = (randomPosTformed.z - emitter.worldBounds.center.z) / emitter.worldBoundsSize.z + 0.5;
			var packA = math.lerp(emitter.startAngle * math.DEG_TO_RAD, emitter.startAngle2 * math.DEG_TO_RAD, rX);
			packA = (packA % (Math.PI * 2)) / (Math.PI * 2);
			var rg0 = encodeFloatRG(packX);
			particleTex[i * particleTexChannels] = rg0[0];
			particleTex[i * particleTexChannels + 1] = rg0[1];
			var ba0 = encodeFloatRG(packY);
			particleTex[i * particleTexChannels + 2] = ba0[0];
			particleTex[i * particleTexChannels + 3] = ba0[1];
			var rg1 = encodeFloatRG(packZ);
			particleTex[i * particleTexChannels + 0 + emitter.numParticlesPot * particleTexChannels] = rg1[0];
			particleTex[i * particleTexChannels + 1 + emitter.numParticlesPot * particleTexChannels] = rg1[1];
			var ba1 = encodeFloatRG(packA);
			particleTex[i * particleTexChannels + 2 + emitter.numParticlesPot * particleTexChannels] = ba1[0];
			particleTex[i * particleTexChannels + 3 + emitter.numParticlesPot * particleTexChannels] = ba1[1];
			var a2 = 1.0;
			particleTex[i * particleTexChannels + 3 + emitter.numParticlesPot * particleTexChannels * 2] = a2;
			var maxNegLife = Math.max(emitter.lifetime, (emitter.numParticles - 1.0) * (Math.max(emitter.rate, emitter.rate2)));
			var maxPosLife = emitter.lifetime + 1.0;
			startSpawnTime = (startSpawnTime + maxNegLife) / (maxNegLife + maxPosLife);
			var rgba3 = encodeFloatRGBA(startSpawnTime);
			particleTex[i * particleTexChannels + 0 + emitter.numParticlesPot * particleTexChannels * 3] = rgba3[0];
			particleTex[i * particleTexChannels + 1 + emitter.numParticlesPot * particleTexChannels * 3] = rgba3[1];
			particleTex[i * particleTexChannels + 2 + emitter.numParticlesPot * particleTexChannels * 3] = rgba3[2];
			particleTex[i * particleTexChannels + 3 + emitter.numParticlesPot * particleTexChannels * 3] = rgba3[3];
		} else {
			particleTex[i * particleTexChannels] =	 randomPosTformed.x;
			particleTex[i * particleTexChannels + 1] = randomPosTformed.y;
			particleTex[i * particleTexChannels + 2] = randomPosTformed.z;
			particleTex[i * particleTexChannels + 3] = math.lerp(emitter.startAngle * math.DEG_TO_RAD, emitter.startAngle2 * math.DEG_TO_RAD, rX);
			particleTex[i * particleTexChannels + 3 + emitter.numParticlesPot * particleTexChannels] = startSpawnTime;
		}
	};
	ParticleCPUUpdater.prototype.update = function (data, vbToSort, particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, delta, isOnStop) {
		var a, b, c, i, j;
		var emitter = this._emitter;
		if (emitter.meshInstance.node) {
			var fullMat = emitter.meshInstance.node.worldTransform;
			for (j = 0; j < 12; j++) {
				rotMat.data[j] = fullMat.data[j];
			}
			rotMatInv.copy(rotMat);
			rotMatInv.invert();
			nonUniformScale = emitter.meshInstance.node.localScale;
			uniformScale = Math.max(Math.max(nonUniformScale.x, nonUniformScale.y), nonUniformScale.z);
		}
		emitterPos = (emitter.meshInstance.node === null || emitter.localSpace) ? Vec3.ZERO : emitter.meshInstance.node.getPosition();
		var posCam = emitter.camera ? emitter.camera._node.getPosition() : Vec3.ZERO;
		var vertSize = !emitter.useMesh ? 15 : 17;
		var cf, cc;
		var rotSpeed, rotSpeed2, scale2, alpha, alpha2, radialSpeed, radialSpeed2;
		var precision1 = emitter.precision - 1;
		for (i = 0; i < emitter.numParticles; i++) {
			var id = Math.floor(emitter.vbCPU[i * emitter.numParticleVerts * (emitter.useMesh ? 6 : 4) + 3]);
			var rndFactor = particleTex[id * particleTexChannels + 0 + emitter.numParticlesPot * 2 * particleTexChannels];
			rndFactor3Vec.x = rndFactor;
			rndFactor3Vec.y = particleTex[id * particleTexChannels + 1 + emitter.numParticlesPot * 2 * particleTexChannels];
			rndFactor3Vec.z = particleTex[id * particleTexChannels + 2 + emitter.numParticlesPot * 2 * particleTexChannels];
			var particleRate = emitter.rate + (emitter.rate2 - emitter.rate) * rndFactor;
			var particleLifetime = emitter.lifetime;
			var life = particleTex[id * particleTexChannels + 3 + emitter.numParticlesPot * particleTexChannels] + delta;
			var nlife = saturate(life / particleLifetime);
			var scale = 0;
			var alphaDiv = 0;
			var angle = 0;
			var respawn = (life - delta) <= 0.0 || life >= particleLifetime;
			if (respawn) {
				this.calcSpawnPosition(particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, id);
			}
			var particleEnabled = life > 0.0 && life < particleLifetime;
			if (particleEnabled) {
				c = nlife * precision1;
				cf = Math.floor(c);
				cc = Math.ceil(c);
				c %= 1;
				a = emitter.qRotSpeed[cf];
				b = emitter.qRotSpeed[cc];
				rotSpeed = a + (b - a) * c;
				a = emitter.qRotSpeed2[cf];
				b = emitter.qRotSpeed2[cc];
				rotSpeed2 = a + (b - a) * c;
				a = emitter.qScale[cf];
				b = emitter.qScale[cc];
				scale = a + (b - a) * c;
				a = emitter.qScale2[cf];
				b = emitter.qScale2[cc];
				scale2 = a + (b - a) * c;
				a = emitter.qAlpha[cf];
				b = emitter.qAlpha[cc];
				alpha = a + (b - a) * c;
				a = emitter.qAlpha2[cf];
				b = emitter.qAlpha2[cc];
				alpha2 = a + (b - a) * c;
				a = emitter.qRadialSpeed[cf];
				b = emitter.qRadialSpeed[cc];
				radialSpeed = a + (b - a) * c;
				a = emitter.qRadialSpeed2[cf];
				b = emitter.qRadialSpeed2[cc];
				radialSpeed2 = a + (b - a) * c;
				radialSpeed += (radialSpeed2 - radialSpeed) * ((rndFactor * 100.0) % 1.0);
				particlePosPrev.x = particleTex[id * particleTexChannels];
				particlePosPrev.y = particleTex[id * particleTexChannels + 1];
				particlePosPrev.z = particleTex[id * particleTexChannels + 2];
				if (!emitter.localSpace)
					radialVelocityVec.copy(particlePosPrev).sub(emitterPos);
				else
					radialVelocityVec.copy(particlePosPrev);
				radialVelocityVec.normalize().scale(radialSpeed);
				cf *= 3;
				cc *= 3;
				a = emitter.qLocalVelocity[cf];
				b = emitter.qLocalVelocity[cc];
				localVelocityVec.x = a + (b - a) * c;
				a = emitter.qLocalVelocity[cf + 1];
				b = emitter.qLocalVelocity[cc + 1];
				localVelocityVec.y = a + (b - a) * c;
				a = emitter.qLocalVelocity[cf + 2];
				b = emitter.qLocalVelocity[cc + 2];
				localVelocityVec.z = a + (b - a) * c;
				a = emitter.qLocalVelocity2[cf];
				b = emitter.qLocalVelocity2[cc];
				localVelocityVec2.x = a + (b - a) * c;
				a = emitter.qLocalVelocity2[cf + 1];
				b = emitter.qLocalVelocity2[cc + 1];
				localVelocityVec2.y = a + (b - a) * c;
				a = emitter.qLocalVelocity2[cf + 2];
				b = emitter.qLocalVelocity2[cc + 2];
				localVelocityVec2.z = a + (b - a) * c;
				a = emitter.qVelocity[cf];
				b = emitter.qVelocity[cc];
				velocityVec.x = a + (b - a) * c;
				a = emitter.qVelocity[cf + 1];
				b = emitter.qVelocity[cc + 1];
				velocityVec.y = a + (b - a) * c;
				a = emitter.qVelocity[cf + 2];
				b = emitter.qVelocity[cc + 2];
				velocityVec.z = a + (b - a) * c;
				a = emitter.qVelocity2[cf];
				b = emitter.qVelocity2[cc];
				velocityVec2.x = a + (b - a) * c;
				a = emitter.qVelocity2[cf + 1];
				b = emitter.qVelocity2[cc + 1];
				velocityVec2.y = a + (b - a) * c;
				a = emitter.qVelocity2[cf + 2];
				b = emitter.qVelocity2[cc + 2];
				velocityVec2.z = a + (b - a) * c;
				localVelocityVec.x += (localVelocityVec2.x - localVelocityVec.x) * rndFactor3Vec.x;
				localVelocityVec.y += (localVelocityVec2.y - localVelocityVec.y) * rndFactor3Vec.y;
				localVelocityVec.z += (localVelocityVec2.z - localVelocityVec.z) * rndFactor3Vec.z;
				if (emitter.initialVelocity > 0) {
					if (emitter.emitterShape === EMITTERSHAPE_SPHERE) {
						randomPos.copy(rndFactor3Vec).scale(2).sub(Vec3.ONE).normalize();
						localVelocityVec.add(randomPos.scale(emitter.initialVelocity));
					} else {
						localVelocityVec.add(Vec3.FORWARD.scale(emitter.initialVelocity));
					}
				}
				velocityVec.x += (velocityVec2.x - velocityVec.x) * rndFactor3Vec.x;
				velocityVec.y += (velocityVec2.y - velocityVec.y) * rndFactor3Vec.y;
				velocityVec.z += (velocityVec2.z - velocityVec.z) * rndFactor3Vec.z;
				rotSpeed += (rotSpeed2 - rotSpeed) * rndFactor3Vec.y;
				scale = (scale + (scale2 - scale) * ((rndFactor * 10000.0) % 1.0)) * uniformScale;
				alphaDiv = (alpha2 - alpha) * ((rndFactor * 1000.0) % 1.0);
				if (emitter.meshInstance.node) {
					if (!emitter.localSpace) {
						rotMat.transformPoint(localVelocityVec, localVelocityVec);
					} else {
						localVelocityVec.x /= nonUniformScale.x;
						localVelocityVec.y /= nonUniformScale.y;
						localVelocityVec.z /= nonUniformScale.z;
					}
				}
				if (!emitter.localSpace) {
					localVelocityVec.add(velocityVec.mul(nonUniformScale));
					localVelocityVec.add(radialVelocityVec.mul(nonUniformScale));
				} else {
					rotMatInv.transformPoint(velocityVec, velocityVec);
					localVelocityVec.add(velocityVec).add(radialVelocityVec);
				}
				moveDirVec.copy(localVelocityVec);
				particlePos.copy(particlePosPrev).add(localVelocityVec.scale(delta));
				particleFinalPos.copy(particlePos);
				particleTex[id * particleTexChannels] =	  particleFinalPos.x;
				particleTex[id * particleTexChannels + 1] =  particleFinalPos.y;
				particleTex[id * particleTexChannels + 2] =  particleFinalPos.z;
				particleTex[id * particleTexChannels + 3] += rotSpeed * delta;
				if (emitter.wrap && emitter.wrapBounds) {
					if (!emitter.localSpace)
						particleFinalPos.sub(emitterPos);
					particleFinalPos.x = glMod(particleFinalPos.x, emitter.wrapBounds.x) - emitter.wrapBounds.x * 0.5;
					particleFinalPos.y = glMod(particleFinalPos.y, emitter.wrapBounds.y) - emitter.wrapBounds.y * 0.5;
					particleFinalPos.z = glMod(particleFinalPos.z, emitter.wrapBounds.z) - emitter.wrapBounds.z * 0.5;
					if (!emitter.localSpace)
						particleFinalPos.add(emitterPos);
				}
				if (emitter.sort > 0) {
					if (emitter.sort === 1) {
						tmpVec3$1.copy(particleFinalPos).sub(posCam);
						emitter.particleDistance[id] = -(tmpVec3$1.x * tmpVec3$1.x + tmpVec3$1.y * tmpVec3$1.y + tmpVec3$1.z * tmpVec3$1.z);
					} else if (emitter.sort === 2) {
						emitter.particleDistance[id] = life;
					} else if (emitter.sort === 3) {
						emitter.particleDistance[id] = -life;
					}
				}
			}
			if (isOnStop) {
				if (life < 0) {
					particleTex[id * particleTexChannels + 3 + emitter.numParticlesPot * 2 * particleTexChannels] = -1;
				}
			} else {
				if (life >= particleLifetime) {
					life -= Math.max(particleLifetime, (emitter.numParticles - 1) * particleRate);
					particleTex[id * particleTexChannels + 3 + emitter.numParticlesPot * 2 * particleTexChannels] = emitter.loop ? 1 : -1;
				}
				if (life < 0 && emitter.loop) {
					particleTex[id * particleTexChannels + 3 + emitter.numParticlesPot * 2 * particleTexChannels] = 1;
				}
			}
			if (particleTex[id * particleTexChannels + 3 + emitter.numParticlesPot * 2 * particleTexChannels] < 0)
				particleEnabled = false;
			particleTex[id * particleTexChannels + 3 + emitter.numParticlesPot * particleTexChannels] = life;
			for (var v = 0; v < emitter.numParticleVerts; v++) {
				var vbOffset = (i * emitter.numParticleVerts + v) * (emitter.useMesh ? 6 : 4);
				var quadX = emitter.vbCPU[vbOffset];
				var quadY = emitter.vbCPU[vbOffset + 1];
				var quadZ = emitter.vbCPU[vbOffset + 2];
				if (!particleEnabled) {
					quadX = quadY = quadZ = 0;
				}
				var w = i * emitter.numParticleVerts * vertSize + v * vertSize;
				data[w] = particleFinalPos.x;
				data[w + 1] = particleFinalPos.y;
				data[w + 2] = particleFinalPos.z;
				data[w + 3] = nlife;
				data[w + 4] = emitter.alignToMotion ? angle : particleTex[id * particleTexChannels + 3];
				data[w + 5] = scale;
				data[w + 6] = alphaDiv;
				data[w + 7] = moveDirVec.x;
				data[w + 8] = quadX;
				data[w + 9] = quadY;
				data[w + 10] = quadZ;
				data[w + 11] = moveDirVec.y;
				data[w + 12] = id;
				data[w + 13] = moveDirVec.z;
				data[w + 14] = emitter.vbCPU[vbOffset + 3];
				if (emitter.useMesh) {
					data[w + 15] = emitter.vbCPU[vbOffset + 4];
					data[w + 16] = emitter.vbCPU[vbOffset + 5];
				}
			}
		}
		if (emitter.sort > PARTICLESORT_NONE && emitter.camera) {
			var vbStride = emitter.useMesh ? 6 : 4;
			var particleDistance = emitter.particleDistance;
			for (i = 0; i < emitter.numParticles; i++) {
				vbToSort[i][0] = i;
				vbToSort[i][1] = particleDistance[Math.floor(emitter.vbCPU[i * emitter.numParticleVerts * vbStride + 3])];
			}
			emitter.vbOld.set(emitter.vbCPU);
			vbToSort.sort(function (p1, p2) {
				return p1[1] - p2[1];
			});
			for (i = 0; i < emitter.numParticles; i++) {
				var src = vbToSort[i][0] * emitter.numParticleVerts * vbStride;
				var dest = i * emitter.numParticleVerts * vbStride;
				for (j = 0; j < emitter.numParticleVerts * vbStride; j++) {
					emitter.vbCPU[dest + j] = emitter.vbOld[src + j];
				}
			}
		}
	};

	var spawnMatrix3 = new Mat3();
	var emitterMatrix3 = new Mat3();
	var emitterMatrix3Inv = new Mat3();
	function mat4ToMat3(mat4, mat3) {
		mat3.data[0] = mat4.data[0];
		mat3.data[1] = mat4.data[1];
		mat3.data[2] = mat4.data[2];
		mat3.data[3] = mat4.data[4];
		mat3.data[4] = mat4.data[5];
		mat3.data[5] = mat4.data[6];
		mat3.data[6] = mat4.data[8];
		mat3.data[7] = mat4.data[9];
		mat3.data[8] = mat4.data[10];
	}
	function ParticleGPUUpdater(emitter, gd) {
		this._emitter = emitter;
		this.frameRandomUniform = new Float32Array(3);
		this.emitterPosUniform = new Float32Array(3);
		this.emitterScaleUniform = new Float32Array([1, 1, 1]);
		this.worldBoundsMulUniform = new Float32Array(3);
		this.worldBoundsAddUniform = new Float32Array(3);
		this.inBoundsSizeUniform = new Float32Array(3);
		this.inBoundsCenterUniform = new Float32Array(3);
		this.constantParticleTexIN = gd.scope.resolve("particleTexIN");
		this.constantParticleTexOUT = gd.scope.resolve("particleTexOUT");
		this.constantEmitterPos = gd.scope.resolve("emitterPos");
		this.constantEmitterScale = gd.scope.resolve("emitterScale");
		this.constantSpawnBounds = gd.scope.resolve("spawnBounds");
		this.constantSpawnPosInnerRatio = gd.scope.resolve("spawnPosInnerRatio");
		this.constantSpawnBoundsSphere = gd.scope.resolve("spawnBoundsSphere");
		this.constantSpawnBoundsSphereInnerRatio = gd.scope.resolve("spawnBoundsSphereInnerRatio");
		this.constantInitialVelocity = gd.scope.resolve("initialVelocity");
		this.constantFrameRandom = gd.scope.resolve("frameRandom");
		this.constantDelta = gd.scope.resolve("delta");
		this.constantRate = gd.scope.resolve("rate");
		this.constantRateDiv = gd.scope.resolve("rateDiv");
		this.constantLifetime = gd.scope.resolve("lifetime");
		this.constantGraphSampleSize = gd.scope.resolve("graphSampleSize");
		this.constantGraphNumSamples = gd.scope.resolve("graphNumSamples");
		this.constantInternalTex0 = gd.scope.resolve("internalTex0");
		this.constantInternalTex1 = gd.scope.resolve("internalTex1");
		this.constantInternalTex2 = gd.scope.resolve("internalTex2");
		this.constantInternalTex3 = gd.scope.resolve("internalTex3");
		this.constantEmitterMatrix = gd.scope.resolve("emitterMatrix");
		this.constantEmitterMatrixInv = gd.scope.resolve("emitterMatrixInv");
		this.constantNumParticles = gd.scope.resolve("numParticles");
		this.constantNumParticlesPot = gd.scope.resolve("numParticlesPot");
		this.constantLocalVelocityDivMult = gd.scope.resolve("localVelocityDivMult");
		this.constantVelocityDivMult = gd.scope.resolve("velocityDivMult");
		this.constantRotSpeedDivMult = gd.scope.resolve("rotSpeedDivMult");
		this.constantSeed = gd.scope.resolve("seed");
		this.constantStartAngle = gd.scope.resolve("startAngle");
		this.constantStartAngle2 = gd.scope.resolve("startAngle2");
		this.constantOutBoundsMul = gd.scope.resolve("outBoundsMul");
		this.constantOutBoundsAdd = gd.scope.resolve("outBoundsAdd");
		this.constantInBoundsSize = gd.scope.resolve("inBoundsSize");
		this.constantInBoundsCenter = gd.scope.resolve("inBoundsCenter");
		this.constantMaxVel = gd.scope.resolve("maxVel");
		this.constantFaceTangent = gd.scope.resolve("faceTangent");
		this.constantFaceBinorm = gd.scope.resolve("faceBinorm");
	}
	ParticleGPUUpdater.prototype._setInputBounds = function () {
		this.inBoundsSizeUniform[0] = this._emitter.prevWorldBoundsSize.x;
		this.inBoundsSizeUniform[1] = this._emitter.prevWorldBoundsSize.y;
		this.inBoundsSizeUniform[2] = this._emitter.prevWorldBoundsSize.z;
		this.constantInBoundsSize.setValue(this.inBoundsSizeUniform);
		this.inBoundsCenterUniform[0] = this._emitter.prevWorldBoundsCenter.x;
		this.inBoundsCenterUniform[1] = this._emitter.prevWorldBoundsCenter.y;
		this.inBoundsCenterUniform[2] = this._emitter.prevWorldBoundsCenter.z;
		this.constantInBoundsCenter.setValue(this.inBoundsCenterUniform);
	};
	ParticleGPUUpdater.prototype.randomize = function () {
		this.frameRandomUniform[0] = Math.random();
		this.frameRandomUniform[1] = Math.random();
		this.frameRandomUniform[2] = Math.random();
	};
	ParticleGPUUpdater.prototype.update = function (device, spawnMatrix, extentsInnerRatioUniform, delta, isOnStop) {
		var emitter = this._emitter;
		device.setBlending(false);
		device.setColorWrite(true, true, true, true);
		device.setCullMode(CULLFACE_NONE);
		device.setDepthTest(false);
		device.setDepthWrite(false);
		this.randomize();
		this.constantGraphSampleSize.setValue(1.0 / emitter.precision);
		this.constantGraphNumSamples.setValue(emitter.precision);
		this.constantNumParticles.setValue(emitter.numParticles);
		this.constantNumParticlesPot.setValue(emitter.numParticlesPot);
		this.constantInternalTex0.setValue(emitter.internalTex0);
		this.constantInternalTex1.setValue(emitter.internalTex1);
		this.constantInternalTex2.setValue(emitter.internalTex2);
		this.constantInternalTex3.setValue(emitter.internalTex3);
		var node = emitter.meshInstance.node;
		var emitterScale = node === null ? Vec3.ONE : node.localScale;
		if (emitter.pack8) {
			this.worldBoundsMulUniform[0] = emitter.worldBoundsMul.x;
			this.worldBoundsMulUniform[1] = emitter.worldBoundsMul.y;
			this.worldBoundsMulUniform[2] = emitter.worldBoundsMul.z;
			this.constantOutBoundsMul.setValue(this.worldBoundsMulUniform);
			this.worldBoundsAddUniform[0] = emitter.worldBoundsAdd.x;
			this.worldBoundsAddUniform[1] = emitter.worldBoundsAdd.y;
			this.worldBoundsAddUniform[2] = emitter.worldBoundsAdd.z;
			this.constantOutBoundsAdd.setValue(this.worldBoundsAddUniform);
			this._setInputBounds();
			var maxVel = emitter.maxVel * Math.max(Math.max(emitterScale.x, emitterScale.y), emitterScale.z);
			maxVel = Math.max(maxVel, 1);
			this.constantMaxVel.setValue(maxVel);
		}
		var emitterPos = (node === null || emitter.localSpace) ? Vec3.ZERO : node.getPosition();
		var emitterMatrix = node === null ? Mat4.IDENTITY : node.getWorldTransform();
		if (emitter.emitterShape === EMITTERSHAPE_BOX) {
			mat4ToMat3(spawnMatrix, spawnMatrix3);
			this.constantSpawnBounds.setValue(spawnMatrix3.data);
			this.constantSpawnPosInnerRatio.setValue(extentsInnerRatioUniform);
		} else {
			this.constantSpawnBoundsSphere.setValue(emitter.emitterRadius);
			this.constantSpawnBoundsSphereInnerRatio.setValue((emitter.emitterRadius === 0) ? 0 : emitter.emitterRadiusInner / emitter.emitterRadius);
		}
		this.constantInitialVelocity.setValue(emitter.initialVelocity);
		mat4ToMat3(emitterMatrix, emitterMatrix3);
		emitterMatrix.invertTo3x3(emitterMatrix3Inv);
		this.emitterPosUniform[0] = emitterPos.x;
		this.emitterPosUniform[1] = emitterPos.y;
		this.emitterPosUniform[2] = emitterPos.z;
		this.constantEmitterPos.setValue(this.emitterPosUniform);
		this.constantFrameRandom.setValue(this.frameRandomUniform);
		this.constantDelta.setValue(delta);
		this.constantRate.setValue(emitter.rate);
		this.constantRateDiv.setValue(emitter.rate2 - emitter.rate);
		this.constantStartAngle.setValue(emitter.startAngle * math.DEG_TO_RAD);
		this.constantStartAngle2.setValue(emitter.startAngle2 * math.DEG_TO_RAD);
		this.constantSeed.setValue(emitter.seed);
		this.constantLifetime.setValue(emitter.lifetime);
		this.emitterScaleUniform[0] = emitterScale.x;
		this.emitterScaleUniform[1] = emitterScale.y;
		this.emitterScaleUniform[2] = emitterScale.z;
		this.constantEmitterScale.setValue(this.emitterScaleUniform);
		this.constantEmitterMatrix.setValue(emitterMatrix3.data);
		this.constantEmitterMatrixInv.setValue(emitterMatrix3Inv.data);
		this.constantLocalVelocityDivMult.setValue(emitter.localVelocityUMax);
		this.constantVelocityDivMult.setValue(emitter.velocityUMax);
		this.constantRotSpeedDivMult.setValue(emitter.rotSpeedUMax[0]);
		var texIN = emitter.swapTex ? emitter.particleTexOUT : emitter.particleTexIN;
		texIN = emitter.beenReset ? emitter.particleTexStart : texIN;
		var texOUT = emitter.swapTex ? emitter.particleTexIN : emitter.particleTexOUT;
		this.constantParticleTexIN.setValue(texIN);
		drawQuadWithShader(
			device,
			emitter.swapTex ? emitter.rtParticleTexIN : emitter.rtParticleTexOUT,
			!isOnStop ?
				(emitter.loop ? emitter.shaderParticleUpdateRespawn : emitter.shaderParticleUpdateNoRespawn) :
				emitter.shaderParticleUpdateOnStop);
		emitter.material.setParameter("particleTexOUT", texIN);
		emitter.material.setParameter("particleTexIN", texOUT);
		emitter.beenReset = false;
		emitter.swapTex = !emitter.swapTex;
		device.setDepthTest(true);
		device.setDepthWrite(true);
		emitter.prevWorldBoundsSize.copy(emitter.worldBoundsSize);
		emitter.prevWorldBoundsCenter.copy(emitter.worldBounds.center);
		if (emitter.pack8)
			this._setInputBounds();
	};

	var particleVerts = [
		[-1, -1],
		[1, -1],
		[1, 1],
		[-1, 1]
	];
	var _createTexture = function (device, width, height, pixelData, format, mult8Bit, filter) {
		if (!format) format = PIXELFORMAT_RGBA32F;
		var mipFilter = FILTER_NEAREST;
		if (filter && format === PIXELFORMAT_R8_G8_B8_A8)
			mipFilter = FILTER_LINEAR;
		var texture = new Texture(device, {
			width: width,
			height: height,
			format: format,
			cubemap: false,
			mipmaps: false,
			minFilter: mipFilter,
			magFilter: mipFilter,
			addressU: ADDRESS_CLAMP_TO_EDGE,
			addressV: ADDRESS_CLAMP_TO_EDGE
		});
		texture.name = "PSTexture";
		var pixels = texture.lock();
		if (format === PIXELFORMAT_R8_G8_B8_A8) {
			var temp = new Uint8Array(pixelData.length);
			for (var i = 0; i < pixelData.length; i++) {
				temp[i] = pixelData[i] * mult8Bit * 255;
			}
			pixelData = temp;
		}
		pixels.set(pixelData);
		texture.unlock();
		return texture;
	};
	function saturate$1(x) {
		return Math.max(Math.min(x, 1), 0);
	}
	var default0Curve = new Curve([0, 0, 1, 0]);
	var default1Curve = new Curve([0, 1, 1, 1]);
	var default0Curve3 = new CurveSet([0, 0, 1, 0], [0, 0, 1, 0], [0, 0, 1, 0]);
	var default1Curve3 = new CurveSet([0, 1, 1, 1], [0, 1, 1, 1], [0, 1, 1, 1]);
	var particleTexHeight = 2;
	var particleTexChannels$1 = 4;
	var extentsInnerRatioUniform = new Float32Array(3);
	var spawnMatrix = new Mat4();
	var tmpVec3$2 = new Vec3();
	var bMin = new Vec3();
	var bMax = new Vec3();
	var setPropertyTarget;
	var setPropertyOptions;
	function setProperty(pName, defaultVal) {
		if (setPropertyOptions[pName] !== undefined && setPropertyOptions[pName] !== null) {
			setPropertyTarget[pName] = setPropertyOptions[pName];
		} else {
			setPropertyTarget[pName] = defaultVal;
		}
	}
	function pack3NFloats(a, b, c) {
		var packed = ((a * 255) << 16) | ((b * 255) << 8) | (c * 255);
		return (packed) / (1 << 24);
	}
	function packTextureXYZ_NXYZ(qXYZ, qXYZ2) {
		var num = qXYZ.length / 3;
		var colors = new Array(num * 4);
		for (var i = 0; i < num; i++) {
			colors[i * 4] = qXYZ[i * 3];
			colors[i * 4 + 1] = qXYZ[i * 3 + 1];
			colors[i * 4 + 2] = qXYZ[i * 3 + 2];
			colors[i * 4 + 3] = pack3NFloats(qXYZ2[i * 3], qXYZ2[i * 3 + 1], qXYZ2[i * 3 + 2]);
		}
		return colors;
	}
	function packTextureRGBA(qRGB, qA) {
		var colors = new Array(qA.length * 4);
		for (var i = 0; i < qA.length; i++) {
			colors[i * 4] = qRGB[i * 3];
			colors[i * 4 + 1] = qRGB[i * 3 + 1];
			colors[i * 4 + 2] = qRGB[i * 3 + 2];
			colors[i * 4 + 3] = qA[i];
		}
		return colors;
	}
	function packTexture5Floats(qA, qB, qC, qD, qE) {
		var colors = new Array(qA.length * 4);
		for (var i = 0; i < qA.length; i++) {
			colors[i * 4] = qA[i];
			colors[i * 4 + 1] = qB[i];
			colors[i * 4 + 2] = 0;
			colors[i * 4 + 3] = pack3NFloats(qC[i], qD[i], qE[i]);
		}
		return colors;
	}
	function packTexture2Floats(qA, qB) {
		var colors = new Array(qA.length * 4);
		for (var i = 0; i < qA.length; i++) {
			colors[i * 4] = qA[i];
			colors[i * 4 + 1] = qB[i];
			colors[i * 4 + 2] = 0;
			colors[i * 4 + 3] = 0;
		}
		return colors;
	}
	var ParticleEmitter = function (graphicsDevice, options) {
		this.graphicsDevice = graphicsDevice;
		var gd = graphicsDevice;
		var precision = 32;
		this.precision = precision;
		this._addTimeTime = 0;
		if (!ParticleEmitter.DEFAULT_PARAM_TEXTURE) {
			var resolution = 16;
			var centerPoint = resolution * 0.5 + 0.5;
			var dtex = new Float32Array(resolution * resolution * 4);
			var x, y, xgrad, ygrad, p, c;
			for (y = 0; y < resolution; y++) {
				for (x = 0; x < resolution; x++) {
					xgrad = (x + 1) - centerPoint;
					ygrad = (y + 1) - centerPoint;
					c = saturate$1((1 - saturate$1(Math.sqrt(xgrad * xgrad + ygrad * ygrad) / resolution)) - 0.5);
					p = y * resolution + x;
					dtex[p * 4] =	 1;
					dtex[p * 4 + 1] = 1;
					dtex[p * 4 + 2] = 1;
					dtex[p * 4 + 3] = c;
				}
			}
			ParticleEmitter.DEFAULT_PARAM_TEXTURE = _createTexture(gd, resolution, resolution, dtex, PIXELFORMAT_R8_G8_B8_A8, 1.0, true);
			ParticleEmitter.DEFAULT_PARAM_TEXTURE.minFilter = FILTER_LINEAR;
			ParticleEmitter.DEFAULT_PARAM_TEXTURE.magFilter = FILTER_LINEAR;
		}
		setPropertyTarget = this;
		setPropertyOptions = options;
		setProperty("numParticles", 1);
		if (this.numParticles > graphicsDevice.maxTextureSize) {
			console.warn("WARNING: can't create more than " + graphicsDevice.maxTextureSize + " particles on this device.");
			this.numParticles = graphicsDevice.maxTextureSize;
		}
		setProperty("rate", 1);
		setProperty("rate2", this.rate);
		setProperty("lifetime", 50);
		setProperty("emitterExtents", new Vec3(0, 0, 0));
		setProperty("emitterExtentsInner", new Vec3(0, 0, 0));
		setProperty("emitterRadius", 0);
		setProperty("emitterRadiusInner", 0);
		setProperty("emitterShape", EMITTERSHAPE_BOX);
		setProperty("initialVelocity", 1);
		setProperty("wrap", false);
		setProperty("localSpace", false);
		setProperty("screenSpace", false);
		setProperty("wrapBounds", null);
		setProperty("colorMap", ParticleEmitter.DEFAULT_PARAM_TEXTURE);
		setProperty("normalMap", null);
		setProperty("loop", true);
		setProperty("preWarm", false);
		setProperty("sort", PARTICLESORT_NONE);
		setProperty("mode", PARTICLEMODE_GPU);
		setProperty("scene", null);
		setProperty("lighting", false);
		setProperty("halfLambert", false);
		setProperty("intensity", 1.0);
		setProperty("stretch", 0.0);
		setProperty("alignToMotion", false);
		setProperty("depthSoftening", 0);
		setProperty("mesh", null);
		setProperty("particleNormal", new Vec3(0, 1, 0));
		setProperty("orientation", PARTICLEORIENTATION_SCREEN);
		setProperty("depthWrite", false);
		setProperty("noFog", false);
		setProperty("blendType", BLEND_NORMAL);
		setProperty("node", null);
		setProperty("startAngle", 0);
		setProperty("startAngle2", this.startAngle);
		setProperty("animTilesX", 1);
		setProperty("animTilesY", 1);
		setProperty("animStartFrame", 0);
		setProperty("animNumFrames", 1);
		setProperty("animNumAnimations", 1);
		setProperty("animIndex", 0);
		setProperty("randomizeAnimIndex", false);
		setProperty("animSpeed", 1);
		setProperty("animLoop", true);
		this._gpuUpdater = new ParticleGPUUpdater(this, gd);
		this._cpuUpdater = new ParticleCPUUpdater(this);
		this.constantLightCube = gd.scope.resolve("lightCube[0]");
		this.emitterPosUniform = new Float32Array(3);
		this.wrapBoundsUniform = new Float32Array(3);
		this.emitterScaleUniform = new Float32Array([1, 1, 1]);
		setProperty("colorGraph", default1Curve3);
		setProperty("colorGraph2", this.colorGraph);
		setProperty("scaleGraph", default1Curve);
		setProperty("scaleGraph2", this.scaleGraph);
		setProperty("alphaGraph", default1Curve);
		setProperty("alphaGraph2", this.alphaGraph);
		setProperty("localVelocityGraph", default0Curve3);
		setProperty("localVelocityGraph2", this.localVelocityGraph);
		setProperty("velocityGraph", default0Curve3);
		setProperty("velocityGraph2", this.velocityGraph);
		setProperty("rotationSpeedGraph", default0Curve);
		setProperty("rotationSpeedGraph2", this.rotationSpeedGraph);
		setProperty("radialSpeedGraph", default0Curve);
		setProperty("radialSpeedGraph2", this.radialSpeedGraph);
		this.lightCube = new Float32Array(6 * 3);
		this.lightCubeDir = new Array(6);
		this.lightCubeDir[0] = new Vec3(-1, 0, 0);
		this.lightCubeDir[1] = new Vec3(1, 0, 0);
		this.lightCubeDir[2] = new Vec3(0, -1, 0);
		this.lightCubeDir[3] = new Vec3(0, 1, 0);
		this.lightCubeDir[4] = new Vec3(0, 0, -1);
		this.lightCubeDir[5] = new Vec3(0, 0, 1);
		this.animTilesParams = new Float32Array(2);
		this.animParams = new Float32Array(4);
		this.animIndexParams = new Float32Array(2);
		this.internalTex0 = null;
		this.internalTex1 = null;
		this.internalTex2 = null;
		this.colorParam = null;
		this.vbToSort = null;
		this.vbOld = null;
		this.particleDistance = null;
		this.camera = null;
		this.swapTex = false;
		this.useMesh = true;
		this.useCpu = false;
		this.pack8 = true;
		this.localBounds = new BoundingBox();
		this.worldBoundsNoTrail = new BoundingBox();
		this.worldBoundsTrail = [new BoundingBox(), new BoundingBox()];
		this.worldBounds = new BoundingBox();
		this.worldBoundsSize = new Vec3();
		this.prevWorldBoundsSize = new Vec3();
		this.prevWorldBoundsCenter = new Vec3();
		this.prevEmitterExtents = this.emitterExtents;
		this.prevEmitterRadius = this.emitterRadius;
		this.worldBoundsMul = new Vec3();
		this.worldBoundsAdd = new Vec3();
		this.timeToSwitchBounds = 0;
		this.shaderParticleUpdateRespawn = null;
		this.shaderParticleUpdateNoRespawn = null;
		this.shaderParticleUpdateOnStop = null;
		this.numParticleVerts = 0;
		this.numParticleIndices = 0;
		this.material = null;
		this.meshInstance = null;
		this.drawOrder = 0;
		this.seed = Math.random();
		this.fixedTimeStep = 1.0 / 60;
		this.maxSubSteps = 10;
		this.simTime = 0;
		this.simTimeTotal = 0;
		this.beenReset = false;
		this._layer = null;
		this.rebuild();
	};
	function calcEndTime(emitter) {
		var interval = (Math.max(emitter.rate, emitter.rate2) * emitter.numParticles + emitter.lifetime);
		return Date.now() + interval * 1000;
	}
	function subGraph(A, B) {
		var r = new Float32Array(A.length);
		for (var i = 0; i < A.length; i++) {
			r[i] = A[i] - B[i];
		}
		return r;
	}
	function maxUnsignedGraphValue(A, outUMax) {
		var i, j;
		var chans = outUMax.length;
		var values = A.length / chans;
		for (i = 0; i < values; i++) {
			for (j = 0; j < chans; j++) {
				var a = Math.abs(A[i * chans + j]);
				outUMax[j] = Math.max(outUMax[j], a);
			}
		}
	}
	function normalizeGraph(A, uMax) {
		var chans = uMax.length;
		var i, j;
		var values = A.length / chans;
		for (i = 0; i < values; i++) {
			for (j = 0; j < chans; j++) {
				A[i * chans + j] /= (uMax[j] === 0 ? 1 : uMax[j]);
				A[i * chans + j] *= 0.5;
				A[i * chans + j] += 0.5;
			}
		}
	}
	function divGraphFrom2Curves(curve1, curve2, outUMax) {
		var sub = subGraph(curve2, curve1);
		maxUnsignedGraphValue(sub, outUMax);
		normalizeGraph(sub, outUMax);
		return sub;
	}
	Object.assign(ParticleEmitter.prototype, {
		onChangeCamera: function () {
			this.regenShader();
			this.resetMaterial();
		},
		calculateBoundsMad: function () {
			this.worldBoundsMul.x = 1.0 / this.worldBoundsSize.x;
			this.worldBoundsMul.y = 1.0 / this.worldBoundsSize.y;
			this.worldBoundsMul.z = 1.0 / this.worldBoundsSize.z;
			this.worldBoundsAdd.copy(this.worldBounds.center).mul(this.worldBoundsMul).scale(-1);
			this.worldBoundsAdd.x += 0.5;
			this.worldBoundsAdd.y += 0.5;
			this.worldBoundsAdd.z += 0.5;
		},
		calculateWorldBounds: function () {
			if (!this.node) return;
			this.prevWorldBoundsSize.copy(this.worldBoundsSize);
			this.prevWorldBoundsCenter.copy(this.worldBounds.center);
			if (!this.useCpu) {
				var recalculateLocalBounds = false;
				if (this.emitterShape === EMITTERSHAPE_BOX) {
					recalculateLocalBounds = !this.emitterExtents.equals(this.prevEmitterExtents);
				} else {
					recalculateLocalBounds = !(this.emitterRadius === this.prevEmitterRadius);
				}
				if (recalculateLocalBounds) {
					this.calculateLocalBounds();
				}
			}
			var nodeWT = this.node.getWorldTransform();
			if (this.localSpace) {
				this.worldBoundsNoTrail.copy(this.localBounds);
			} else {
				this.worldBoundsNoTrail.setFromTransformedAabb(this.localBounds, nodeWT);
			}
			this.worldBoundsTrail[0].add(this.worldBoundsNoTrail);
			this.worldBoundsTrail[1].add(this.worldBoundsNoTrail);
			var now = this.simTimeTotal;
			if (now >= this.timeToSwitchBounds) {
				this.worldBoundsTrail[0].copy(this.worldBoundsTrail[1]);
				this.worldBoundsTrail[1].copy(this.worldBoundsNoTrail);
				this.timeToSwitchBounds = now + this.lifetime;
			}
			this.worldBounds.copy(this.worldBoundsTrail[0]);
			this.worldBoundsSize.copy(this.worldBounds.halfExtents).scale(2);
			if (this.localSpace) {
				this.meshInstance.aabb.setFromTransformedAabb(this.worldBounds, nodeWT);
				this.meshInstance.mesh.aabb.setFromTransformedAabb(this.worldBounds, nodeWT);
			} else {
				this.meshInstance.aabb.copy(this.worldBounds);
				this.meshInstance.mesh.aabb.copy(this.worldBounds);
			}
			this.meshInstance._aabbVer = 1 - this.meshInstance._aabbVer;
			if (this.pack8) this.calculateBoundsMad();
		},
		resetWorldBounds: function () {
			if (!this.node) return;
			this.worldBoundsNoTrail.setFromTransformedAabb(
				this.localBounds, this.localSpace ? Mat4.IDENTITY : this.node.getWorldTransform());
			this.worldBoundsTrail[0].copy(this.worldBoundsNoTrail);
			this.worldBoundsTrail[1].copy(this.worldBoundsNoTrail);
			this.worldBounds.copy(this.worldBoundsTrail[0]);
			this.worldBoundsSize.copy(this.worldBounds.halfExtents).scale(2);
			this.prevWorldBoundsSize.copy(this.worldBoundsSize);
			this.prevWorldBoundsCenter.copy(this.worldBounds.center);
			this.simTimeTotal = 0;
			this.timeToSwitchBounds = 0;
		},
		calculateLocalBounds: function () {
			var minx = Number.MAX_VALUE;
			var miny = Number.MAX_VALUE;
			var minz = Number.MAX_VALUE;
			var maxx = -Number.MAX_VALUE;
			var maxy = -Number.MAX_VALUE;
			var maxz = -Number.MAX_VALUE;
			var maxR = 0;
			var maxScale = 0;
			var stepWeight = this.lifetime / this.precision;
			var wVels = [this.qVelocity, this.qVelocity2];
			var lVels = [this.qLocalVelocity, this.qLocalVelocity2];
			var accumX = [0, 0];
			var accumY = [0, 0];
			var accumZ = [0, 0];
			var accumR = [0, 0];
			var accumW = [0, 0];
			var i, j;
			var index;
			var x, y, z;
			for (i = 0; i < this.precision + 1; i++) {
				index = Math.min(i, this.precision - 1);
				for (j = 0; j < 2; j++) {
					x = lVels[j][index * 3 + 0] * stepWeight + accumX[j];
					y = lVels[j][index * 3 + 1] * stepWeight + accumY[j];
					z = lVels[j][index * 3 + 2] * stepWeight + accumZ[j];
					minx = Math.min(x, minx);
					miny = Math.min(y, miny);
					minz = Math.min(z, minz);
					maxx = Math.max(x, maxx);
					maxy = Math.max(y, maxy);
					maxz = Math.max(z, maxz);
					accumX[j] = x;
					accumY[j] = y;
					accumZ[j] = z;
				}
				for (j = 0; j < 2; j++) {
					accumW[j] += stepWeight * Math.sqrt(
						wVels[j][index * 3 + 0] * wVels[j][index * 3 + 0] +
						wVels[j][index * 3 + 1] * wVels[j][index * 3 + 1] +
						wVels[j][index * 3 + 2] * wVels[j][index * 3 + 2]);
				}
				accumR[0] += this.qRadialSpeed[index] * stepWeight;
				accumR[1] += this.qRadialSpeed2[index] * stepWeight;
				maxR = Math.max(maxR, Math.max(Math.abs(accumR[0]), Math.abs(accumR[1])));
				maxScale = Math.max(maxScale, this.qScale[index]);
			}
			if (this.emitterShape === EMITTERSHAPE_BOX) {
				x = this.emitterExtents.x * 0.5;
				y = this.emitterExtents.y * 0.5;
				z = this.emitterExtents.z * 0.5;
			} else {
				x = this.emitterRadius;
				y = this.emitterRadius;
				z = this.emitterRadius;
			}
			var w = Math.max(accumW[0], accumW[1]);
			bMin.x = minx - maxScale - x - maxR - w;
			bMin.y = miny - maxScale - y - maxR - w;
			bMin.z = minz - maxScale - z - maxR - w;
			bMax.x = maxx + maxScale + x + maxR + w;
			bMax.y = maxy + maxScale + y + maxR + w;
			bMax.z = maxz + maxScale + z + maxR + w;
			this.localBounds.setMinMax(bMin, bMax);
		},
		rebuild: function () {
			var i;
			var gd = this.graphicsDevice;
			if (this.colorMap === null) this.colorMap = ParticleEmitter.DEFAULT_PARAM_TEXTURE;
			this.spawnBounds = this.emitterShape === EMITTERSHAPE_BOX ? this.emitterExtents : this.emitterRadius;
			this.useCpu = this.useCpu || this.sort > PARTICLESORT_NONE ||
			gd.maxVertexTextures <= 1 ||
			gd.fragmentUniformsCount < 64 ||
			gd.forceCpuParticles ||
			!gd.extTextureFloat;
			this._destroyResources();
			this.pack8 = (this.pack8 || !gd.textureFloatRenderable) && !this.useCpu;
			particleTexHeight = (this.useCpu || this.pack8) ? 4 : 2;
			this.useMesh = false;
			if (this.mesh) {
				var totalVertCount = this.numParticles * this.mesh.vertexBuffer.numVertices;
				if (totalVertCount > 65535) {
					console.warn("WARNING: particle system can't render mesh particles because numParticles * numVertices is more than 65k. Reverting to quad particles.");
				} else {
					this.useMesh = true;
				}
			}
			this.numParticlesPot = math.nextPowerOfTwo(this.numParticles);
			this.rebuildGraphs();
			this.calculateLocalBounds();
			this.resetWorldBounds();
			if (this.node) {
				this.worldBounds.setFromTransformedAabb(
					this.localBounds, this.localSpace ? Mat4.IDENTITY : this.node.getWorldTransform());
				this.worldBoundsTrail[0].copy(this.worldBounds);
				this.worldBoundsTrail[1].copy(this.worldBounds);
				this.worldBoundsSize.copy(this.worldBounds.halfExtents).scale(2);
				this.prevWorldBoundsSize.copy(this.worldBoundsSize);
				this.prevWorldBoundsCenter.copy(this.worldBounds.center);
				if (this.pack8) this.calculateBoundsMad();
			}
			this.vbToSort = new Array(this.numParticles);
			for (var iSort = 0; iSort < this.numParticles; iSort++) this.vbToSort[iSort] = [0, 0];
			this.particleDistance = new Float32Array(this.numParticles);
			this._gpuUpdater.randomize();
			this.particleTex = new Float32Array(this.numParticlesPot * particleTexHeight * particleTexChannels$1);
			var emitterPos = (this.node === null || this.localSpace) ? Vec3.ZERO : this.node.getPosition();
			if (this.emitterShape === EMITTERSHAPE_BOX) {
				if (this.node === null || this.localSpace){
					spawnMatrix.setTRS(Vec3.ZERO, Quat.IDENTITY, this.spawnBounds);
				} else {
					spawnMatrix.setTRS(Vec3.ZERO, this.node.getRotation(), tmpVec3$2.copy(this.spawnBounds).mul(this.node.localScale));
				}
				extentsInnerRatioUniform[0] = this.emitterExtents.x != 0 ? this.emitterExtentsInner.x / this.emitterExtents.x : 0;
				extentsInnerRatioUniform[1] = this.emitterExtents.y != 0 ? this.emitterExtentsInner.y / this.emitterExtents.y : 0;
				extentsInnerRatioUniform[2] = this.emitterExtents.z != 0 ? this.emitterExtentsInner.z / this.emitterExtents.z : 0;
			}
			for (i = 0; i < this.numParticles; i++) {
				this._cpuUpdater.calcSpawnPosition(this.particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, i);
				if (this.useCpu) this.particleTex[i * particleTexChannels$1 + 3 + this.numParticlesPot * 2 * particleTexChannels$1] = 1;
			}
			this.particleTexStart = new Float32Array(this.numParticlesPot * particleTexHeight * particleTexChannels$1);
			for (i = 0; i < this.particleTexStart.length; i++) this.particleTexStart[i] = this.particleTex[i];
			if (!this.useCpu) {
				if (this.pack8) {
					this.particleTexIN = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex, PIXELFORMAT_R8_G8_B8_A8, 1, false);
					this.particleTexOUT = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex, PIXELFORMAT_R8_G8_B8_A8, 1, false);
					this.particleTexStart = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTexStart, PIXELFORMAT_R8_G8_B8_A8, 1, false);
				} else {
					this.particleTexIN = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex);
					this.particleTexOUT = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex);
					this.particleTexStart = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTexStart);
				}
				this.rtParticleTexIN = new RenderTarget(gd, this.particleTexIN, {
					depth: false
				});
				this.rtParticleTexOUT = new RenderTarget(gd, this.particleTexOUT, {
					depth: false
				});
				this.swapTex = false;
			}
			var shaderCodeStart = (this.localSpace ? '#define LOCAL_SPACE\n' : '') + shaderChunks.particleUpdaterInitPS +
			(this.pack8 ? (shaderChunks.particleInputRgba8PS + shaderChunks.particleOutputRgba8PS) :
				(shaderChunks.particleInputFloatPS + shaderChunks.particleOutputFloatPS)) +
			(this.emitterShape === EMITTERSHAPE_BOX ? shaderChunks.particleUpdaterAABBPS : shaderChunks.particleUpdaterSpherePS) +
			shaderChunks.particleUpdaterStartPS;
			var shaderCodeRespawn = shaderCodeStart + shaderChunks.particleUpdaterRespawnPS + shaderChunks.particleUpdaterEndPS;
			var shaderCodeNoRespawn = shaderCodeStart + shaderChunks.particleUpdaterNoRespawnPS + shaderChunks.particleUpdaterEndPS;
			var shaderCodeOnStop = shaderCodeStart + shaderChunks.particleUpdaterOnStopPS + shaderChunks.particleUpdaterEndPS;
			var params = this.emitterShape + "" + this.pack8 + "" + this.localSpace;
			this.shaderParticleUpdateRespawn = createShaderFromCode(gd, shaderChunks.fullscreenQuadVS, shaderCodeRespawn, "fsQuad0" + params);
			this.shaderParticleUpdateNoRespawn = createShaderFromCode(gd, shaderChunks.fullscreenQuadVS, shaderCodeNoRespawn, "fsQuad1" + params);
			this.shaderParticleUpdateOnStop = createShaderFromCode(gd, shaderChunks.fullscreenQuadVS, shaderCodeOnStop, "fsQuad2" + params);
			this.numParticleVerts = this.useMesh ? this.mesh.vertexBuffer.numVertices : 4;
			this.numParticleIndices = this.useMesh ? this.mesh.indexBuffer[0].numIndices : 6;
			this._allocate(this.numParticles);
			var mesh = new Mesh(gd);
			mesh.vertexBuffer = this.vertexBuffer;
			mesh.indexBuffer[0] = this.indexBuffer;
			mesh.primitive[0].type = PRIMITIVE_TRIANGLES;
			mesh.primitive[0].base = 0;
			mesh.primitive[0].count = (this.numParticles * this.numParticleIndices);
			mesh.primitive[0].indexed = true;
			this.material = new Material();
			this.material.name = this.node.name;
			this.material.cull = CULLFACE_NONE;
			this.material.alphaWrite = false;
			this.material.blend = true;
			this.material.blendType = this.blendType;
			this.material.depthWrite = this.depthWrite;
			this.material.emitter = this;
			this.regenShader();
			this.resetMaterial();
			var wasVisible = this.meshInstance ? this.meshInstance.visible : true;
			this.meshInstance = new MeshInstance(this.node, mesh, this.material);
			this.meshInstance.pick = false;
			this.meshInstance.updateKey();
			this.meshInstance.cull = true;
			this.meshInstance._noDepthDrawGl1 = true;
			if (this.localSpace) {
				this.meshInstance.aabb.setFromTransformedAabb(this.worldBounds, this.node.getWorldTransform());
			} else {
				this.meshInstance.aabb.copy(this.worldBounds);
			}
			this.meshInstance._updateAabb = false;
			this.meshInstance.visible = wasVisible;
			this._initializeTextures();
			this.resetTime();
			this.addTime(0, false);
			if (this.preWarm) this.prewarm(this.lifetime);
		},
		_isAnimated: function () {
			return this.animNumFrames >= 1 &&
				   (this.animTilesX > 1 || this.animTilesY > 1) &&
				   (this.colorMap && this.colorMap !== ParticleEmitter.DEFAULT_PARAM_TEXTURE || this.normalMap);
		},
		rebuildGraphs: function () {
			var precision = this.precision;
			var gd = this.graphicsDevice;
			var i;
			this.qLocalVelocity = this.localVelocityGraph.quantize(precision);
			this.qVelocity = this.velocityGraph.quantize(precision);
			this.qColor =		 this.colorGraph.quantizeClamped(precision, 0, 1);
			this.qRotSpeed =	  this.rotationSpeedGraph.quantize(precision);
			this.qScale =		 this.scaleGraph.quantize(precision);
			this.qAlpha =		 this.alphaGraph.quantize(precision);
			this.qRadialSpeed =   this.radialSpeedGraph.quantize(precision);
			this.qLocalVelocity2 = this.localVelocityGraph2.quantize(precision);
			this.qVelocity2 =	  this.velocityGraph2.quantize(precision);
			this.qColor2 =		 this.colorGraph2.quantizeClamped(precision, 0, 1);
			this.qRotSpeed2 =	  this.rotationSpeedGraph2.quantize(precision);
			this.qScale2 =		 this.scaleGraph2.quantize(precision);
			this.qAlpha2 =		 this.alphaGraph2.quantize(precision);
			this.qRadialSpeed2 =   this.radialSpeedGraph2.quantize(precision);
			for (i = 0; i < precision; i++) {
				this.qRotSpeed[i] *= math.DEG_TO_RAD;
				this.qRotSpeed2[i] *= math.DEG_TO_RAD;
			}
			this.localVelocityUMax = new Float32Array(3);
			this.velocityUMax = new Float32Array(3);
			this.colorUMax = new Float32Array(3);
			this.rotSpeedUMax = [0];
			this.scaleUMax =	[0];
			this.alphaUMax =	[0];
			this.radialSpeedUMax = [0];
			this.qLocalVelocityDiv = divGraphFrom2Curves(this.qLocalVelocity, this.qLocalVelocity2, this.localVelocityUMax);
			this.qVelocityDiv =	  divGraphFrom2Curves(this.qVelocity, this.qVelocity2, this.velocityUMax);
			this.qColorDiv =		 divGraphFrom2Curves(this.qColor, this.qColor2, this.colorUMax);
			this.qRotSpeedDiv =	  divGraphFrom2Curves(this.qRotSpeed, this.qRotSpeed2, this.rotSpeedUMax);
			this.qScaleDiv =		 divGraphFrom2Curves(this.qScale, this.qScale2, this.scaleUMax);
			this.qAlphaDiv =		 divGraphFrom2Curves(this.qAlpha, this.qAlpha2, this.alphaUMax);
			this.qRadialSpeedDiv =   divGraphFrom2Curves(this.qRadialSpeed, this.qRadialSpeed2, this.radialSpeedUMax);
			if (this.pack8) {
				var umax = [0, 0, 0];
				maxUnsignedGraphValue(this.qVelocity, umax);
				var umax2 = [0, 0, 0];
				maxUnsignedGraphValue(this.qVelocity2, umax2);
				var lumax = [0, 0, 0];
				maxUnsignedGraphValue(this.qLocalVelocity, lumax);
				var lumax2 = [0, 0, 0];
				maxUnsignedGraphValue(this.qLocalVelocity2, lumax2);
				var rumax = [0];
				maxUnsignedGraphValue(this.qRadialSpeed, rumax);
				var rumax2 = [0];
				maxUnsignedGraphValue(this.qRadialSpeed2, rumax2);
				var maxVel = Math.max(umax[0], umax2[0]);
				maxVel = Math.max(maxVel, umax[1]);
				maxVel = Math.max(maxVel, umax2[1]);
				maxVel = Math.max(maxVel, umax[2]);
				maxVel = Math.max(maxVel, umax2[2]);
				var lmaxVel = Math.max(lumax[0], lumax2[0]);
				lmaxVel = Math.max(lmaxVel, lumax[1]);
				lmaxVel = Math.max(lmaxVel, lumax2[1]);
				lmaxVel = Math.max(lmaxVel, lumax[2]);
				lmaxVel = Math.max(lmaxVel, lumax2[2]);
				var maxRad = Math.max(rumax[0], rumax2[0]);
				this.maxVel = maxVel + lmaxVel + maxRad;
			}
			if (!this.useCpu) {
				this.internalTex0 = _createTexture(gd, precision, 1, packTextureXYZ_NXYZ(this.qLocalVelocity, this.qLocalVelocityDiv));
				this.internalTex1 = _createTexture(gd, precision, 1, packTextureXYZ_NXYZ(this.qVelocity, this.qVelocityDiv));
				this.internalTex2 = _createTexture(gd, precision, 1, packTexture5Floats(this.qRotSpeed, this.qScale, this.qScaleDiv, this.qRotSpeedDiv, this.qAlphaDiv));
				this.internalTex3 = _createTexture(gd, precision, 1, packTexture2Floats(this.qRadialSpeed, this.qRadialSpeedDiv));
			}
			this.colorParam = _createTexture(gd, precision, 1, packTextureRGBA(this.qColor, this.qAlpha), PIXELFORMAT_R8_G8_B8_A8, 1.0, true);
		},
		_initializeTextures: function () {
			if (this.colorMap) {
				this.material.setParameter('colorMap', this.colorMap);
				if (this.lighting && this.normalMap) {
					this.material.setParameter('normalMap', this.normalMap);
				}
			}
		},
		regenShader: function () {
			var programLib = this.graphicsDevice.getProgramLibrary();
			var hasNormal = (this.normalMap !== null);
			this.normalOption = 0;
			if (this.lighting) {
				this.normalOption = hasNormal ? 2 : 1;
			}
			this.material.updateShader = function () {
				if (this.emitter.scene) {
					if (this.emitter.camera != this.emitter.scene._activeCamera) {
						this.emitter.camera = this.emitter.scene._activeCamera;
						this.emitter.onChangeCamera();
					}
				}
				var inTools = this.emitter.inTools;
				var shader = programLib.getProgram("particle", {
					useCpu: this.emitter.useCpu,
					normal: this.emitter.normalOption,
					halflambert: this.emitter.halfLambert,
					stretch: this.emitter.stretch,
					alignToMotion: this.emitter.alignToMotion,
					soft: this.emitter.depthSoftening,
					mesh: this.emitter.useMesh,
					gamma: this.emitter.scene ? this.emitter.scene.gammaCorrection : 0,
					toneMap: this.emitter.scene ? this.emitter.scene.toneMapping : 0,
					fog: (this.emitter.scene && !this.emitter.noFog) ? this.emitter.scene.fog : "none",
					wrap: this.emitter.wrap && this.emitter.wrapBounds,
					localSpace: this.emitter.localSpace,
					screenSpace: inTools ? false : this.emitter.screenSpace,
					blend: this.blendType,
					animTex: this.emitter._isAnimated(),
					animTexLoop: this.emitter.animLoop,
					pack8: this.emitter.pack8,
					customFace: this.emitter.orientation != PARTICLEORIENTATION_SCREEN
				});
				this.shader = shader;
			};
			this.material.updateShader();
		},
		resetMaterial: function () {
			var material = this.material;
			material.setParameter('stretch', this.stretch);
			if (this._isAnimated()) {
				material.setParameter('animTexTilesParams', this.animTilesParams);
				material.setParameter('animTexParams', this.animParams);
				material.setParameter('animTexIndexParams', this.animIndexParams);
			}
			material.setParameter('colorMult', this.intensity);
			if (!this.useCpu) {
				material.setParameter('internalTex0', this.internalTex0);
				material.setParameter('internalTex1', this.internalTex1);
				material.setParameter('internalTex2', this.internalTex2);
				material.setParameter('internalTex3', this.internalTex3);
			}
			material.setParameter('colorParam', this.colorParam);
			material.setParameter('numParticles', this.numParticles);
			material.setParameter('numParticlesPot', this.numParticlesPot);
			material.setParameter('lifetime', this.lifetime);
			material.setParameter('rate', this.rate);
			material.setParameter('rateDiv', this.rate2 - this.rate);
			material.setParameter('seed', this.seed);
			material.setParameter('scaleDivMult', this.scaleUMax[0]);
			material.setParameter('alphaDivMult', this.alphaUMax[0]);
			material.setParameter('radialSpeedDivMult', this.radialSpeedUMax[0]);
			material.setParameter("graphNumSamples", this.precision);
			material.setParameter("graphSampleSize", 1.0 / this.precision);
			material.setParameter("emitterScale", new Float32Array([1, 1, 1]));
			if (this.pack8) {
				this._gpuUpdater._setInputBounds();
				material.setParameter("inBoundsSize", this._gpuUpdater.inBoundsSizeUniform);
				material.setParameter("inBoundsCenter", this._gpuUpdater.inBoundsCenterUniform);
				material.setParameter("maxVel", this.maxVel);
			}
			if (this.wrap && this.wrapBounds) {
				this.wrapBoundsUniform[0] = this.wrapBounds.x;
				this.wrapBoundsUniform[1] = this.wrapBounds.y;
				this.wrapBoundsUniform[2] = this.wrapBounds.z;
				material.setParameter('wrapBounds', this.wrapBoundsUniform);
			}
			if (this.colorMap) {
				material.setParameter('colorMap', this.colorMap);
			}
			if (this.lighting) {
				if (this.normalMap) {
					material.setParameter('normalMap', this.normalMap);
				}
			}
			if (this.depthSoftening > 0) {
				material.setParameter('softening', 1.0 / (this.depthSoftening * this.depthSoftening * 100));
			}
			if (this.stretch > 0.0) material.cull = CULLFACE_NONE;
			this._compParticleFaceParams();
		},
		_compParticleFaceParams: function () {
			var tangent, binormal;
			if (this.orientation == PARTICLEORIENTATION_SCREEN) {
				tangent = new Float32Array([1, 0, 0]);
				binormal = new Float32Array([0, 0, 1]);
			} else {
				var n;
				if (this.orientation == PARTICLEORIENTATION_WORLD) {
					n = this.particleNormal.normalize();
				} else {
					var emitterMat = this.node === null ?
						Mat4.IDENTITY : this.node.getWorldTransform();
					n = emitterMat.transformVector(this.particleNormal).normalize();
				}
				var t = new Vec3(1, 0, 0);
				if (Math.abs(t.dot(n)) == 1)
					t.set(0, 0, 1);
				var b = new Vec3().cross(n, t).normalize();
				t.cross(b, n).normalize();
				tangent = new Float32Array([t.x, t.y, t.z]);
				binormal = new Float32Array([b.x, b.y, b.z]);
			}
			this.material.setParameter("faceTangent", tangent);
			this.material.setParameter("faceBinorm", binormal);
		},
		_allocate: function (numParticles) {
			var psysVertCount = numParticles * this.numParticleVerts;
			var psysIndexCount = numParticles * this.numParticleIndices;
			var elements, particleFormat;
			var i;
			if ((this.vertexBuffer === undefined) || (this.vertexBuffer.getNumVertices() !== psysVertCount)) {
				if (!this.useCpu) {
					elements = [{
						semantic: SEMANTIC_ATTR0,
						components: 4,
						type: TYPE_FLOAT32
					}];
					if (this.useMesh) {
						elements.push({
							semantic: SEMANTIC_ATTR1,
							components: 2,
							type: TYPE_FLOAT32
						});
					}
					particleFormat = new VertexFormat(this.graphicsDevice, elements);
					this.vertexBuffer = new VertexBuffer(this.graphicsDevice, particleFormat, psysVertCount, BUFFER_DYNAMIC);
					this.indexBuffer = new IndexBuffer(this.graphicsDevice, INDEXFORMAT_UINT16, psysIndexCount);
				} else {
					elements = [{
						semantic: SEMANTIC_ATTR0,
						components: 4,
						type: TYPE_FLOAT32
					}, {
						semantic: SEMANTIC_ATTR1,
						components: 4,
						type: TYPE_FLOAT32
					}, {
						semantic: SEMANTIC_ATTR2,
						components: 4,
						type: TYPE_FLOAT32
					}, {
						semantic: SEMANTIC_ATTR3,
						components: 1,
						type: TYPE_FLOAT32
					}, {
						semantic: SEMANTIC_ATTR4,
						components: this.useMesh ? 4 : 2,
						type: TYPE_FLOAT32
					}];
					particleFormat = new VertexFormat(this.graphicsDevice, elements);
					this.vertexBuffer = new VertexBuffer(this.graphicsDevice, particleFormat, psysVertCount, BUFFER_DYNAMIC);
					this.indexBuffer = new IndexBuffer(this.graphicsDevice, INDEXFORMAT_UINT16, psysIndexCount);
				}
				var data = new Float32Array(this.vertexBuffer.lock());
				var meshData, stride, texCoordOffset;
				if (this.useMesh) {
					meshData = new Float32Array(this.mesh.vertexBuffer.lock());
					stride = meshData.length / this.mesh.vertexBuffer.numVertices;
					for (var elem = 0; elem < this.mesh.vertexBuffer.format.elements.length; elem++) {
						if (this.mesh.vertexBuffer.format.elements[elem].name === SEMANTIC_TEXCOORD0) {
							texCoordOffset = this.mesh.vertexBuffer.format.elements[elem].offset / 4;
							break;
						}
					}
				}
				var id;
				for (i = 0; i < psysVertCount; i++) {
					id = Math.floor(i / this.numParticleVerts);
					if (!this.useMesh) {
						var vertID = i % 4;
						data[i * 4] = particleVerts[vertID][0];
						data[i * 4 + 1] = particleVerts[vertID][1];
						data[i * 4 + 2] = 0;
						data[i * 4 + 3] = id;
					} else {
						var vert = i % this.numParticleVerts;
						data[i * 6] = meshData[vert * stride];
						data[i * 6 + 1] = meshData[vert * stride + 1];
						data[i * 6 + 2] = meshData[vert * stride + 2];
						data[i * 6 + 3] = id;
						data[i * 6 + 4] = meshData[vert * stride + texCoordOffset + 0];
						data[i * 6 + 5] = meshData[vert * stride + texCoordOffset + 1];
					}
				}
				if (this.useCpu) {
					this.vbCPU = new Float32Array(data);
					this.vbOld = new Float32Array(this.vbCPU.length);
				}
				this.vertexBuffer.unlock();
				if (this.useMesh) {
					this.mesh.vertexBuffer.unlock();
				}
				var dst = 0;
				var indices = new Uint16Array(this.indexBuffer.lock());
				if (this.useMesh) meshData = new Uint16Array(this.mesh.indexBuffer[0].lock());
				for (i = 0; i < numParticles; i++) {
					if (!this.useMesh) {
						var baseIndex = i * 4;
						indices[dst++] = baseIndex;
						indices[dst++] = baseIndex + 1;
						indices[dst++] = baseIndex + 2;
						indices[dst++] = baseIndex;
						indices[dst++] = baseIndex + 2;
						indices[dst++] = baseIndex + 3;
					} else {
						for (var j = 0; j < this.numParticleIndices; j++) {
							indices[i * this.numParticleIndices + j] = meshData[j] + i * this.numParticleVerts;
						}
					}
				}
				this.indexBuffer.unlock();
				if (this.useMesh) this.mesh.indexBuffer[0].unlock();
			}
		},
		reset: function () {
			this.beenReset = true;
			this.seed = Math.random();
			this.material.setParameter('seed', this.seed);
			if (this.useCpu) {
				for (var i = 0; i < this.particleTexStart.length; i++) {
					this.particleTex[i] = this.particleTexStart[i];
				}
			} else {
				this._initializeTextures();
			}
			this.resetWorldBounds();
			this.resetTime();
			var origLoop =  this.loop;
			this.loop = true;
			this.addTime(0, false);
			this.loop = origLoop;
			if (this.preWarm) {
				this.prewarm(this.lifetime);
			}
		},
		prewarm: function (time) {
			var lifetimeFraction = time / this.lifetime;
			var iterations = Math.min(Math.floor(lifetimeFraction * this.precision), this.precision);
			var stepDelta = time / iterations;
			for (var i = 0; i < iterations; i++) {
				this.addTime(stepDelta, false);
			}
		},
		resetTime: function () {
			this.endTime = calcEndTime(this);
		},
		finishFrame: function () {
			if (this.useCpu) this.vertexBuffer.unlock();
		},
		addTime: function (delta, isOnStop) {
			var device = this.graphicsDevice;
			this.simTimeTotal += delta;
			this.calculateWorldBounds();
			if (this._isAnimated()) {
				var tilesParams = this.animTilesParams;
				tilesParams[0] = 1.0 / this.animTilesX;
				tilesParams[1] = 1.0 / this.animTilesY;
				var params = this.animParams;
				params[0] = this.animStartFrame;
				params[1] = this.animNumFrames * this.animSpeed;
				params[2] = this.animNumFrames - 1;
				params[3] = this.animNumAnimations - 1;
				var animIndexParams = this.animIndexParams;
				animIndexParams[0] = this.animIndex;
				animIndexParams[1] = this.randomizeAnimIndex;
			}
			if (this.scene) {
				if (this.camera != this.scene._activeCamera) {
					this.camera = this.scene._activeCamera;
					this.onChangeCamera();
				}
			}
			if (this.emitterShape === EMITTERSHAPE_BOX) {
				extentsInnerRatioUniform[0] = this.emitterExtents.x != 0 ? this.emitterExtentsInner.x / this.emitterExtents.x : 0;
				extentsInnerRatioUniform[1] = this.emitterExtents.y != 0 ? this.emitterExtentsInner.y / this.emitterExtents.y : 0;
				extentsInnerRatioUniform[2] = this.emitterExtents.z != 0 ? this.emitterExtentsInner.z / this.emitterExtents.z : 0;
				if (this.meshInstance.node === null){
					spawnMatrix.setTRS(Vec3.ZERO, Quat.IDENTITY, this.emitterExtents);
				} else {
					spawnMatrix.setTRS(Vec3.ZERO, this.meshInstance.node.getRotation(), tmpVec3$2.copy(this.emitterExtents).mul(this.meshInstance.node.localScale));
				}
			}
			var emitterPos;
			var emitterScale = this.meshInstance.node === null ? Vec3.ONE : this.meshInstance.node.localScale;
			this.emitterScaleUniform[0] = emitterScale.x;
			this.emitterScaleUniform[1] = emitterScale.y;
			this.emitterScaleUniform[2] = emitterScale.z;
			this.material.setParameter("emitterScale", this.emitterScaleUniform);
			if (this.localSpace && this.meshInstance.node) {
				emitterPos = this.meshInstance.node.getPosition();
				this.emitterPosUniform[0] = emitterPos.x;
				this.emitterPosUniform[1] = emitterPos.y;
				this.emitterPosUniform[2] = emitterPos.z;
				this.material.setParameter("emitterPos", this.emitterPosUniform);
			}
			this._compParticleFaceParams();
			if (!this.useCpu) {
				this._gpuUpdater.update(device, spawnMatrix, extentsInnerRatioUniform, delta, isOnStop);
			} else {
				var data = new Float32Array(this.vertexBuffer.lock());
				this._cpuUpdater.update(data, this.vbToSort, this.particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, delta, isOnStop);
			}
			if (!this.loop) {
				if (Date.now() > this.endTime) {
					if (this.onFinished) this.onFinished();
					this.meshInstance.visible = false;
				}
			}
			if (this.meshInstance) {
				this.meshInstance.drawOrder = this.drawOrder;
			}
		},
		_destroyResources: function () {
			if (this.particleTexIN) {
				this.particleTexIN.destroy();
				this.particleTexIN = null;
			}
			if (this.particleTexOUT) {
				this.particleTexOUT.destroy();
				this.particleTexOUT = null;
			}
			if (this.particleTexStart && this.particleTexStart.destroy) {
				this.particleTexStart.destroy();
				this.particleTexStart = null;
			}
			if (this.rtParticleTexIN) {
				this.rtParticleTexIN.destroy();
				this.rtParticleTexIN = null;
			}
			if (this.rtParticleTexOUT) {
				this.rtParticleTexOUT.destroy();
				this.rtParticleTexOUT = null;
			}
			if (this.internalTex0) {
				this.internalTex0.destroy();
				this.internalTex0 = null;
			}
			if (this.internalTex1) {
				this.internalTex1.destroy();
				this.internalTex1 = null;
			}
			if (this.internalTex2) {
				this.internalTex2.destroy();
				this.internalTex2 = null;
			}
			if (this.internalTex3) {
				this.internalTex3.destroy();
				this.internalTex3 = null;
			}
			if (this.colorParam) {
				this.colorParam.destroy();
				this.colorParam = null;
			}
			if (this.vertexBuffer) {
				this.vertexBuffer.destroy();
				this.vertexBuffer = undefined;
			}
			if (this.indexBuffer) {
				this.indexBuffer.destroy();
				this.indexBuffer = undefined;
			}
			if (this.material) {
				this.material.destroy();
				this.material = null;
			}
		},
		destroy: function () {
			this.camera = null;
			this._destroyResources();
		}
	});

	var primitiveUv1Padding = 4.0 / 64;
	var primitiveUv1PaddingScale = 1.0 - primitiveUv1Padding * 2;
	function calculateNormals(positions, indices) {
		var triangleCount = indices.length / 3;
		var vertexCount   = positions.length / 3;
		var i1, i2, i3;
		var i;
		var p1 = new Vec3();
		var p2 = new Vec3();
		var p3 = new Vec3();
		var p1p2 = new Vec3();
		var p1p3 = new Vec3();
		var faceNormal = new Vec3();
		var normals = [];
		for (i = 0; i < positions.length; i++) {
			normals[i] = 0;
		}
		for (i = 0; i < triangleCount; i++) {
			i1 = indices[i * 3];
			i2 = indices[i * 3 + 1];
			i3 = indices[i * 3 + 2];
			p1.set(positions[i1 * 3], positions[i1 * 3 + 1], positions[i1 * 3 + 2]);
			p2.set(positions[i2 * 3], positions[i2 * 3 + 1], positions[i2 * 3 + 2]);
			p3.set(positions[i3 * 3], positions[i3 * 3 + 1], positions[i3 * 3 + 2]);
			p1p2.sub2(p2, p1);
			p1p3.sub2(p3, p1);
			faceNormal.cross(p1p2, p1p3).normalize();
			normals[i1 * 3]	 += faceNormal.x;
			normals[i1 * 3 + 1] += faceNormal.y;
			normals[i1 * 3 + 2] += faceNormal.z;
			normals[i2 * 3]	 += faceNormal.x;
			normals[i2 * 3 + 1] += faceNormal.y;
			normals[i2 * 3 + 2] += faceNormal.z;
			normals[i3 * 3]	 += faceNormal.x;
			normals[i3 * 3 + 1] += faceNormal.y;
			normals[i3 * 3 + 2] += faceNormal.z;
		}
		for (i = 0; i < vertexCount; i++) {
			var nx = normals[i * 3];
			var ny = normals[i * 3 + 1];
			var nz = normals[i * 3 + 2];
			var invLen = 1 / Math.sqrt(nx * nx + ny * ny + nz * nz);
			normals[i * 3] *= invLen;
			normals[i * 3 + 1] *= invLen;
			normals[i * 3 + 2] *= invLen;
		}
		return normals;
	}
	function calculateTangents(positions, normals, uvs, indices) {
		var triangleCount = indices.length / 3;
		var vertexCount   = positions.length / 3;
		var i1, i2, i3;
		var x1, x2, y1, y2, z1, z2, s1, s2, t1, t2, r;
		var sdir = new Vec3();
		var tdir = new Vec3();
		var v1   = new Vec3();
		var v2   = new Vec3();
		var v3   = new Vec3();
		var w1   = new Vec2();
		var w2   = new Vec2();
		var w3   = new Vec2();
		var i;
		var tan1 = new Float32Array(vertexCount * 3);
		var tan2 = new Float32Array(vertexCount * 3);
		var tangents = [];
		var area = 0.0;
		for (i = 0; i < triangleCount; i++) {
			i1 = indices[i * 3];
			i2 = indices[i * 3 + 1];
			i3 = indices[i * 3 + 2];
			v1.set(positions[i1 * 3], positions[i1 * 3 + 1], positions[i1 * 3 + 2]);
			v2.set(positions[i2 * 3], positions[i2 * 3 + 1], positions[i2 * 3 + 2]);
			v3.set(positions[i3 * 3], positions[i3 * 3 + 1], positions[i3 * 3 + 2]);
			w1.set(uvs[i1 * 2], uvs[i1 * 2 + 1]);
			w2.set(uvs[i2 * 2], uvs[i2 * 2 + 1]);
			w3.set(uvs[i3 * 2], uvs[i3 * 2 + 1]);
			x1 = v2.x - v1.x;
			x2 = v3.x - v1.x;
			y1 = v2.y - v1.y;
			y2 = v3.y - v1.y;
			z1 = v2.z - v1.z;
			z2 = v3.z - v1.z;
			s1 = w2.x - w1.x;
			s2 = w3.x - w1.x;
			t1 = w2.y - w1.y;
			t2 = w3.y - w1.y;
			area = s1 * t2 - s2 * t1;
			if (area == 0.0) {
				sdir.set(0.0, 1.0, 0.0);
				tdir.set(1.0, 0.0, 0.0);
			} else {
				r = 1.0 / area;
				sdir.set((t2 * x1 - t1 * x2) * r,
						 (t2 * y1 - t1 * y2) * r,
						 (t2 * z1 - t1 * z2) * r);
				tdir.set((s1 * x2 - s2 * x1) * r,
						 (s1 * y2 - s2 * y1) * r,
						 (s1 * z2 - s2 * z1) * r);
			}
			tan1[i1 * 3 + 0] += sdir.x;
			tan1[i1 * 3 + 1] += sdir.y;
			tan1[i1 * 3 + 2] += sdir.z;
			tan1[i2 * 3 + 0] += sdir.x;
			tan1[i2 * 3 + 1] += sdir.y;
			tan1[i2 * 3 + 2] += sdir.z;
			tan1[i3 * 3 + 0] += sdir.x;
			tan1[i3 * 3 + 1] += sdir.y;
			tan1[i3 * 3 + 2] += sdir.z;
			tan2[i1 * 3 + 0] += tdir.x;
			tan2[i1 * 3 + 1] += tdir.y;
			tan2[i1 * 3 + 2] += tdir.z;
			tan2[i2 * 3 + 0] += tdir.x;
			tan2[i2 * 3 + 1] += tdir.y;
			tan2[i2 * 3 + 2] += tdir.z;
			tan2[i3 * 3 + 0] += tdir.x;
			tan2[i3 * 3 + 1] += tdir.y;
			tan2[i3 * 3 + 2] += tdir.z;
		}
		t1 = new Vec3();
		t2 = new Vec3();
		var n = new Vec3();
		var temp = new Vec3();
		for (i = 0; i < vertexCount; i++) {
			n.set(normals[i * 3], normals[i * 3 + 1], normals[i * 3 + 2]);
			t1.set(tan1[i * 3], tan1[i * 3 + 1], tan1[i * 3 + 2]);
			t2.set(tan2[i * 3], tan2[i * 3 + 1], tan2[i * 3 + 2]);
			var ndott = n.dot(t1);
			temp.copy(n).scale(ndott);
			temp.sub2(t1, temp).normalize();
			tangents[i * 4]	 = temp.x;
			tangents[i * 4 + 1] = temp.y;
			tangents[i * 4 + 2] = temp.z;
			temp.cross(n, t1);
			tangents[i * 4 + 3] = (temp.dot(t2) < 0.0) ? -1.0 : 1.0;
		}
		return tangents;
	}
	function createMesh(device, positions, opts) {
		var normals	  = opts && opts.normals !== undefined ? opts.normals : null;
		var tangents	 = opts && opts.tangents !== undefined ? opts.tangents : null;
		var colors	   = opts && opts.colors !== undefined ? opts.colors : null;
		var uvs		  = opts && opts.uvs !== undefined ? opts.uvs : null;
		var uvs1		 = opts && opts.uvs1 !== undefined ? opts.uvs1 : null;
		var indices	  = opts && opts.indices !== undefined ? opts.indices : null;
		var blendIndices = opts && opts.blendIndices !== undefined ? opts.blendIndices : null;
		var blendWeights = opts && opts.blendWeights !== undefined ? opts.blendWeights : null;
		var vertexDesc = [
			{ semantic: SEMANTIC_POSITION, components: 3, type: TYPE_FLOAT32 }
		];
		if (normals !== null) {
			vertexDesc.push({ semantic: SEMANTIC_NORMAL, components: 3, type: TYPE_FLOAT32 });
		}
		if (tangents !== null) {
			vertexDesc.push({ semantic: SEMANTIC_TANGENT, components: 4, type: TYPE_FLOAT32 });
		}
		if (colors !== null) {
			vertexDesc.push({ semantic: SEMANTIC_COLOR, components: 4, type: TYPE_UINT8, normalize: true });
		}
		if (uvs !== null) {
			vertexDesc.push({ semantic: SEMANTIC_TEXCOORD0, components: 2, type: TYPE_FLOAT32 });
		}
		if (uvs1 !== null) {
			vertexDesc.push({ semantic: SEMANTIC_TEXCOORD1, components: 2, type: TYPE_FLOAT32 });
		}
		if (blendIndices !== null) {
			vertexDesc.push({ semantic: SEMANTIC_BLENDINDICES, components: 2, type: TYPE_UINT8 });
		}
		if (blendWeights !== null) {
			vertexDesc.push({ semantic: SEMANTIC_BLENDWEIGHT, components: 2, type: TYPE_FLOAT32 });
		}
		var vertexFormat = new VertexFormat(device, vertexDesc);
		var numVertices  = positions.length / 3;
		var vertexBuffer = new VertexBuffer(device, vertexFormat, numVertices);
		var iterator = new VertexIterator(vertexBuffer);
		for (var i = 0; i < numVertices; i++) {
			iterator.element[SEMANTIC_POSITION].set(positions[i * 3], positions[i * 3 + 1], positions[i * 3 + 2]);
			if (normals !== null) {
				iterator.element[SEMANTIC_NORMAL].set(normals[i * 3], normals[i * 3 + 1], normals[i * 3 + 2]);
			}
			if (tangents !== null) {
				iterator.element[SEMANTIC_TANGENT].set(tangents[i * 4], tangents[i * 4 + 1], tangents[i * 4 + 2], tangents[i * 4 + 3]);
			}
			if (colors !== null) {
				iterator.element[SEMANTIC_COLOR].set(colors[i * 4], colors[i * 4 + 1], colors[i * 4 + 2], colors[i * 4 + 3]);
			}
			if (uvs !== null) {
				iterator.element[SEMANTIC_TEXCOORD0].set(uvs[i * 2], uvs[i * 2 + 1]);
			}
			if (uvs1 !== null) {
				iterator.element[SEMANTIC_TEXCOORD1].set(uvs1[i * 2], uvs1[i * 2 + 1]);
			}
			if (blendIndices !== null) {
				iterator.element[SEMANTIC_BLENDINDICES].set(blendIndices[i * 2], blendIndices[i * 2 + 1]);
			}
			if (blendWeights !== null) {
				iterator.element[SEMANTIC_BLENDWEIGHT].set(blendWeights[i * 2], blendWeights[i * 2 + 1]);
			}
			iterator.next();
		}
		iterator.end();
		var indexBuffer = null;
		var indexed = (indices !== null);
		if (indexed) {
			indexBuffer = new IndexBuffer(device, INDEXFORMAT_UINT16, indices.length);
			var dst = new Uint16Array(indexBuffer.lock());
			dst.set(indices);
			indexBuffer.unlock();
		}
		var aabb = new BoundingBox();
		aabb.compute(positions);
		var mesh = new Mesh(device);
		mesh.vertexBuffer = vertexBuffer;
		mesh.indexBuffer[0] = indexBuffer;
		mesh.primitive[0].type = PRIMITIVE_TRIANGLES;
		mesh.primitive[0].base = 0;
		mesh.primitive[0].count = indexed ? indices.length : numVertices;
		mesh.primitive[0].indexed = indexed;
		mesh.aabb = aabb;
		return mesh;
	}
	function createTorus(device, opts) {
		var rc = opts && opts.tubeRadius !== undefined ? opts.tubeRadius : 0.2;
		var rt = opts && opts.ringRadius !== undefined ? opts.ringRadius : 0.3;
		var segments = opts && opts.segments !== undefined ? opts.segments : 30;
		var sides = opts && opts.sides !== undefined ? opts.sides : 20;
		var calculateTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;
		var i, j;
		var x, y, z, nx, ny, nz, u, v;
		var positions = [];
		var normals = [];
		var uvs = [];
		var indices = [];
		for (i = 0; i <= sides; i++) {
			for (j = 0; j <= segments; j++) {
				x  = Math.cos(2.0 * Math.PI * j / segments) * (rt + rc * Math.cos(2.0 * Math.PI * i / sides));
				y  = Math.sin(2.0 * Math.PI * i / sides) * rc;
				z  = Math.sin(2.0 * Math.PI * j / segments) * (rt + rc * Math.cos(2.0 * Math.PI * i / sides));
				nx = Math.cos(2.0 * Math.PI * j / segments) * Math.cos(2.0 * Math.PI * i / sides);
				ny = Math.sin(2.0 * Math.PI * i / sides);
				nz = Math.sin(2.0 * Math.PI * j / segments) * Math.cos(2.0 * Math.PI * i / sides);
				u = i / sides;
				v = 1.0 - j / segments;
				positions.push(x, y, z);
				normals.push(nx, ny, nz);
				uvs.push(u, v);
				if ((i < sides) && (j < segments)) {
					var first, second, third, fourth;
					first   = ((i))	 * (segments + 1) + ((j));
					second  = ((i + 1)) * (segments + 1) + ((j));
					third   = ((i))	 * (segments + 1) + ((j + 1));
					fourth  = ((i + 1)) * (segments + 1) + ((j + 1));
					indices.push(first, second, third);
					indices.push(second, fourth, third);
				}
			}
		}
		var options = {
			normals: normals,
			uvs: uvs,
			indices: indices
		};
		if (calculateTangents) {
			options.tangents = calculateTangents(positions, normals, uvs, indices);
		}
		return createMesh(device, positions, options);
	}
	function _createConeData(baseRadius, peakRadius, height, heightSegments, capSegments, roundedCaps) {
		var i, j;
		var x, y, z, u, v;
		var pos = new Vec3();
		var bottomToTop = new Vec3();
		var norm = new Vec3();
		var top, bottom, tangent;
		var positions = [];
		var normals = [];
		var uvs = [];
		var uvs1 = [];
		var indices = [];
		var theta, cosTheta, sinTheta;
		var phi, sinPhi, cosPhi;
		var first, second, third, fourth;
		var offset;
		if (height > 0) {
			for (i = 0; i <= heightSegments; i++) {
				for (j = 0; j <= capSegments; j++) {
					theta = (j / capSegments) * 2.0 * Math.PI - Math.PI;
					sinTheta = Math.sin(theta);
					cosTheta = Math.cos(theta);
					bottom = new Vec3(sinTheta * baseRadius, -height / 2.0, cosTheta * baseRadius);
					top	= new Vec3(sinTheta * peakRadius,  height / 2.0, cosTheta * peakRadius);
					pos.lerp(bottom, top, i / heightSegments);
					bottomToTop.sub2(top, bottom).normalize();
					tangent = new Vec3(cosTheta, 0.0, -sinTheta);
					norm.cross(tangent, bottomToTop).normalize();
					positions.push(pos.x, pos.y, pos.z);
					normals.push(norm.x, norm.y, norm.z);
					u = j / capSegments;
					v = i / heightSegments;
					uvs.push(u, v);
					var _v = v;
					v = u;
					u = _v;
					u /= 3;
					u = u * primitiveUv1PaddingScale + primitiveUv1Padding;
					v = v * primitiveUv1PaddingScale + primitiveUv1Padding;
					uvs1.push(u, v);
					if ((i < heightSegments) && (j < capSegments)) {
						first   = ((i))	 * (capSegments + 1) + ((j));
						second  = ((i))	 * (capSegments + 1) + ((j + 1));
						third   = ((i + 1)) * (capSegments + 1) + ((j));
						fourth  = ((i + 1)) * (capSegments + 1) + ((j + 1));
						indices.push(first, second, third);
						indices.push(second, fourth, third);
					}
				}
			}
		}
		if (roundedCaps) {
			var lat, lon;
			var latitudeBands = Math.floor(capSegments / 2);
			var longitudeBands = capSegments;
			var capOffset = height / 2;
			for (lat = 0; lat <= latitudeBands; lat++) {
				theta = (lat * Math.PI * 0.5) / latitudeBands;
				sinTheta = Math.sin(theta);
				cosTheta = Math.cos(theta);
				for (lon = 0; lon <= longitudeBands; lon++) {
					phi = lon * 2 * Math.PI / longitudeBands - Math.PI / 2.0;
					sinPhi = Math.sin(phi);
					cosPhi = Math.cos(phi);
					x = cosPhi * sinTheta;
					y = cosTheta;
					z = sinPhi * sinTheta;
					u = 1.0 - lon / longitudeBands;
					v = 1.0 - lat / latitudeBands;
					positions.push(x * peakRadius, y * peakRadius + capOffset, z * peakRadius);
					normals.push(x, y, z);
					uvs.push(u, v);
					u /= 3;
					v /= 3;
					u = u * primitiveUv1PaddingScale + primitiveUv1Padding;
					v = v * primitiveUv1PaddingScale + primitiveUv1Padding;
					u += 1.0 / 3;
					uvs1.push(u, v);
				}
			}
			offset = (heightSegments + 1) * (capSegments + 1);
			for (lat = 0; lat < latitudeBands; ++lat) {
				for (lon = 0; lon < longitudeBands; ++lon) {
					first  = (lat * (longitudeBands + 1)) + lon;
					second = first + longitudeBands + 1;
					indices.push(offset + first + 1, offset + second, offset + first);
					indices.push(offset + first + 1, offset + second + 1, offset + second);
				}
			}
			for (lat = 0; lat <= latitudeBands; lat++) {
				theta = Math.PI * 0.5 + (lat * Math.PI * 0.5) / latitudeBands;
				sinTheta = Math.sin(theta);
				cosTheta = Math.cos(theta);
				for (lon = 0; lon <= longitudeBands; lon++) {
					phi = lon * 2 * Math.PI / longitudeBands - Math.PI / 2.0;
					sinPhi = Math.sin(phi);
					cosPhi = Math.cos(phi);
					x = cosPhi * sinTheta;
					y = cosTheta;
					z = sinPhi * sinTheta;
					u = 1.0 - lon / longitudeBands;
					v = 1.0 - lat / latitudeBands;
					positions.push(x * peakRadius, y * peakRadius - capOffset, z * peakRadius);
					normals.push(x, y, z);
					uvs.push(u, v);
					u /= 3;
					v /= 3;
					u = u * primitiveUv1PaddingScale + primitiveUv1Padding;
					v = v * primitiveUv1PaddingScale + primitiveUv1Padding;
					u += 2.0 / 3;
					uvs1.push(u, v);
				}
			}
			offset = (heightSegments + 1) * (capSegments + 1) + (longitudeBands + 1) * (latitudeBands + 1);
			for (lat = 0; lat < latitudeBands; ++lat) {
				for (lon = 0; lon < longitudeBands; ++lon) {
					first  = (lat * (longitudeBands + 1)) + lon;
					second = first + longitudeBands + 1;
					indices.push(offset + first + 1, offset + second, offset + first);
					indices.push(offset + first + 1, offset + second + 1, offset + second);
				}
			}
		} else {
			offset = (heightSegments + 1) * (capSegments + 1);
			if (baseRadius > 0.0) {
				for (i = 0; i < capSegments; i++) {
					theta = (i / capSegments) * 2.0 * Math.PI;
					x = Math.sin(theta);
					y = -height / 2.0;
					z = Math.cos(theta);
					u = 1.0 - (x + 1.0) / 2.0;
					v = (z + 1.0) / 2.0;
					positions.push(x * baseRadius, y, z * baseRadius);
					normals.push(0.0, -1.0, 0.0);
					uvs.push(u, v);
					u /= 3;
					v /= 3;
					u = u * primitiveUv1PaddingScale + primitiveUv1Padding;
					v = v * primitiveUv1PaddingScale + primitiveUv1Padding;
					u += 1.0 / 3;
					uvs1.push(u, v);
					if (i > 1) {
						indices.push(offset, offset + i, offset + i - 1);
					}
				}
			}
			offset += capSegments;
			if (peakRadius > 0.0) {
				for (i = 0; i < capSegments; i++) {
					theta = (i / capSegments) * 2.0 * Math.PI;
					x = Math.sin(theta);
					y = height / 2.0;
					z = Math.cos(theta);
					u = 1.0 - (x + 1.0) / 2.0;
					v = (z + 1.0) / 2.0;
					positions.push(x * peakRadius, y, z * peakRadius);
					normals.push(0.0, 1.0, 0.0);
					uvs.push(u, v);
					u /= 3;
					v /= 3;
					u = u * primitiveUv1PaddingScale + primitiveUv1Padding;
					v = v * primitiveUv1PaddingScale + primitiveUv1Padding;
					u += 2.0 / 3;
					uvs1.push(u, v);
					if (i > 1) {
						indices.push(offset, offset + i - 1, offset + i);
					}
				}
			}
		}
		return {
			positions: positions,
			normals: normals,
			uvs: uvs,
			uvs1: uvs1,
			indices: indices
		};
	}
	function createCylinder(device, opts) {
		var radius = opts && (opts.radius || opts.baseRadius);
		radius = radius !== undefined ? radius : 0.5;
		var height = opts && opts.height !== undefined ? opts.height : 1.0;
		var heightSegments = opts && opts.heightSegments !== undefined ? opts.heightSegments : 5;
		var capSegments = opts && opts.capSegments !== undefined ? opts.capSegments : 20;
		var calculateTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;
		var options = _createConeData(radius, radius, height, heightSegments, capSegments, false);
		if (calculateTangents) {
			options.tangents = calculateTangents(options.positions, options.normals, options.uvs, options.indices);
		}
		return createMesh(device, options.positions, options);
	}
	function createCapsule(device, opts) {
		var radius = opts && opts.radius !== undefined ? opts.radius : 0.3;
		var height = opts && opts.height !== undefined ? opts.height : 1.0;
		var heightSegments = opts && opts.heightSegments !== undefined ? opts.heightSegments : 1;
		var sides = opts && opts.sides !== undefined ? opts.sides : 20;
		var calculateTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;
		var options = _createConeData(radius, radius, height - 2 * radius, heightSegments, sides, true);
		if (calculateTangents) {
			options.tangents = calculateTangents(options.positions, options.normals, options.uvs, options.indices);
		}
		return createMesh(device, options.positions, options);
	}
	function createCone(device, opts) {
		var baseRadius = opts && opts.baseRadius !== undefined ? opts.baseRadius : 0.5;
		var peakRadius = opts && opts.peakRadius !== undefined ? opts.peakRadius : 0.0;
		var height = opts && opts.height !== undefined ? opts.height : 1.0;
		var heightSegments = opts && opts.heightSegments !== undefined ? opts.heightSegments : 5;
		var capSegments = opts && opts.capSegments !== undefined ? opts.capSegments : 18;
		var calculateTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;
		var options = _createConeData(baseRadius, peakRadius, height, heightSegments, capSegments, false);
		if (calculateTangents) {
			options.tangents = calculateTangents(options.positions, options.normals, options.uvs, options.indices);
		}
		return createMesh(device, options.positions, options);
	}
	function createSphere(device, opts) {
		var radius = opts && opts.radius !== undefined ? opts.radius : 0.5;
		var latitudeBands = opts && opts.latitudeBands !== undefined ? opts.latitudeBands : 16;
		var longitudeBands = opts && opts.longitudeBands !== undefined ? opts.longitudeBands : 16;
		var calculateTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;
		var lon, lat;
		var theta, sinTheta, cosTheta, phi, sinPhi, cosPhi;
		var first, second;
		var x, y, z, u, v;
		var positions = [];
		var normals = [];
		var uvs = [];
		var indices = [];
		for (lat = 0; lat <= latitudeBands; lat++) {
			theta = lat * Math.PI / latitudeBands;
			sinTheta = Math.sin(theta);
			cosTheta = Math.cos(theta);
			for (lon = 0; lon <= longitudeBands; lon++) {
				phi = lon * 2 * Math.PI / longitudeBands - Math.PI / 2.0;
				sinPhi = Math.sin(phi);
				cosPhi = Math.cos(phi);
				x = cosPhi * sinTheta;
				y = cosTheta;
				z = sinPhi * sinTheta;
				u = 1.0 - lon / longitudeBands;
				v = 1.0 - lat / latitudeBands;
				positions.push(x * radius, y * radius, z * radius);
				normals.push(x, y, z);
				uvs.push(u, v);
			}
		}
		for (lat = 0; lat < latitudeBands; ++lat) {
			for (lon = 0; lon < longitudeBands; ++lon) {
				first  = (lat * (longitudeBands + 1)) + lon;
				second = first + longitudeBands + 1;
				indices.push(first + 1, second, first);
				indices.push(first + 1, second + 1, second);
			}
		}
		var options = {
			normals: normals,
			uvs: uvs,
			uvs1: uvs,
			indices: indices
		};
		if (calculateTangents) {
			options.tangents = calculateTangents(positions, normals, uvs, indices);
		}
		return createMesh(device, positions, options);
	}
	function createPlane(device, opts) {
		var he = opts && opts.halfExtents !== undefined ? opts.halfExtents : new Vec2(0.5, 0.5);
		var ws = opts && opts.widthSegments !== undefined ? opts.widthSegments : 5;
		var ls = opts && opts.lengthSegments !== undefined ? opts.lengthSegments : 5;
		var calculateTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;
		var i, j;
		var x, y, z, u, v;
		var positions = [];
		var normals = [];
		var uvs = [];
		var indices = [];
		var vcounter = 0;
		for (i = 0; i <= ws; i++) {
			for (j = 0; j <= ls; j++) {
				x = -he.x + 2.0 * he.x * i / ws;
				y = 0.0;
				z = -(-he.y + 2.0 * he.y * j / ls);
				u = i / ws;
				v = j / ls;
				positions.push(x, y, z);
				normals.push(0.0, 1.0, 0.0);
				uvs.push(u, v);
				if ((i < ws) && (j < ls)) {
					indices.push(vcounter + ls + 1, vcounter + 1, vcounter);
					indices.push(vcounter + ls + 1, vcounter + ls + 2, vcounter + 1);
				}
				vcounter++;
			}
		}
		var options = {
			normals: normals,
			uvs: uvs,
			uvs1: uvs,
			indices: indices
		};
		if (calculateTangents) {
			options.tangents = calculateTangents(positions, normals, uvs, indices);
		}
		return createMesh(device, positions, options);
	}
	function createBox(device, opts) {
		var he = opts && opts.halfExtents !== undefined ? opts.halfExtents : new Vec3(0.5, 0.5, 0.5);
		var ws = opts && opts.widthSegments !== undefined ? opts.widthSegments : 1;
		var ls = opts && opts.lengthSegments !== undefined ? opts.lengthSegments : 1;
		var hs = opts && opts.heightSegments !== undefined ? opts.heightSegments : 1;
		var calculateTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;
		var corners = [
			new Vec3(-he.x, -he.y,  he.z),
			new Vec3( he.x, -he.y,  he.z),
			new Vec3( he.x,  he.y,  he.z),
			new Vec3(-he.x,  he.y,  he.z),
			new Vec3( he.x, -he.y, -he.z),
			new Vec3(-he.x, -he.y, -he.z),
			new Vec3(-he.x,  he.y, -he.z),
			new Vec3( he.x,  he.y, -he.z)
		];
		var faceAxes = [
			[0, 1, 3],
			[4, 5, 7],
			[3, 2, 6],
			[1, 0, 4],
			[1, 4, 2],
			[5, 0, 6]
		];
		var faceNormals = [
			[0,  0,  1],
			[0,  0, -1],
			[0,  1,  0],
			[0, -1,  0],
			[1,  0,  0],
			[-1,  0,  0]
		];
		var sides = {
			FRONT: 0,
			BACK: 1,
			TOP: 2,
			BOTTOM: 3,
			RIGHT: 4,
			LEFT: 5
		};
		var positions = [];
		var normals = [];
		var uvs = [];
		var uvs1 = [];
		var indices = [];
		var vcounter = 0;
		var generateFace = function (side, uSegments, vSegments) {
			var u, v;
			var i, j;
			for (i = 0; i <= uSegments; i++) {
				for (j = 0; j <= vSegments; j++) {
					var temp1 = new Vec3();
					var temp2 = new Vec3();
					var temp3 = new Vec3();
					var r = new Vec3();
					temp1.lerp(corners[faceAxes[side][0]], corners[faceAxes[side][1]], i / uSegments);
					temp2.lerp(corners[faceAxes[side][0]], corners[faceAxes[side][2]], j / vSegments);
					temp3.sub2(temp2, corners[faceAxes[side][0]]);
					r.add2(temp1, temp3);
					u = i / uSegments;
					v = j / vSegments;
					positions.push(r.x, r.y, r.z);
					normals.push(faceNormals[side][0], faceNormals[side][1], faceNormals[side][2]);
					uvs.push(u, v);
					u /= 3;
					v /= 3;
					u = u * primitiveUv1PaddingScale + primitiveUv1Padding;
					v = v * primitiveUv1PaddingScale + primitiveUv1Padding;
					u += (side % 3) / 3;
					v += Math.floor(side / 3) / 3;
					uvs1.push(u, v);
					if ((i < uSegments) && (j < vSegments)) {
						indices.push(vcounter + vSegments + 1, vcounter + 1, vcounter);
						indices.push(vcounter + vSegments + 1, vcounter + vSegments + 2, vcounter + 1);
					}
					vcounter++;
				}
			}
		};
		generateFace(sides.FRONT, ws, hs);
		generateFace(sides.BACK, ws, hs);
		generateFace(sides.TOP, ws, ls);
		generateFace(sides.BOTTOM, ws, ls);
		generateFace(sides.RIGHT, ls, hs);
		generateFace(sides.LEFT, ls, hs);
		var options = {
			normals: normals,
			uvs: uvs,
			uvs1: uvs1,
			indices: indices
		};
		if (calculateTangents) {
			options.tangents = calculateTangents(positions, normals, uvs, indices);
		}
		return createMesh(device, positions, options);
	}

	function Scene() {
		EventHandler.call(this);
		this.root = null;
		this._gravity = new Vec3(0, -9.8, 0);
		this._layers = null;
		this._fog = FOG_NONE;
		this.fogColor = new Color(0, 0, 0);
		this.fogStart = 1;
		this.fogEnd = 1000;
		this.fogDensity = 0;
		this.ambientLight = new Color(0, 0, 0);
		this._gammaCorrection = GAMMA_NONE;
		this._toneMapping = 0;
		this.exposure = 1.0;
		this._skyboxPrefiltered = [null, null, null, null, null, null];
		this._firstUpdateSkybox = true;
		this._skyboxCubeMap = null;
		this.skyboxModel = null;
		this._skyboxIntensity = 1;
		this._skyboxMip = 0;
		this.lightmapSizeMultiplier = 1;
		this.lightmapMaxResolution = 2048;
		this.lightmapMode = BAKE_COLORDIR;
		this._stats = {
			meshInstances: 0,
			lights: 0,
			dynamicLights: 0,
			bakedLights: 0,
			lastStaticPrepareFullTime: 0,
			lastStaticPrepareSearchTime: 0,
			lastStaticPrepareWriteTime: 0,
			lastStaticPrepareTriAabbTime: 0,
			lastStaticPrepareCombineTime: 0,
			updateShadersTime: 0
		};
		this.updateShaders = true;
		this.updateSkybox = true;
		this._shaderVersion = 0;
		this._statsUpdated = false;
		this._models = [];
		this.defaultMaterial = new StandardMaterial();
		this.defaultMaterial.name = "Default Material";
		this.defaultMaterial.shadingModel = SPECULAR_BLINN;
	}
	Scene.prototype = Object.create(EventHandler.prototype);
	Scene.prototype.constructor = Scene;
	Scene.prototype.destroy = function () {
		this.root = null;
		this.defaultMaterial.destroy();
		this.defaultMaterial = null;
		this.off();
	};
	Object.defineProperty(Scene.prototype, 'fog', {
		get: function () {
			return this._fog;
		},
		set: function (type) {
			if (type !== this._fog) {
				this._fog = type;
				this.updateShaders = true;
			}
		}
	});
	Object.defineProperty(Scene.prototype, 'gammaCorrection', {
		get: function () {
			return this._gammaCorrection;
		},
		set: function (value) {
			if (value !== this._gammaCorrection) {
				this._gammaCorrection = value;
				this.updateShaders = true;
			}
		}
	});
	Object.defineProperty(Scene.prototype, 'toneMapping', {
		get: function () {
			return this._toneMapping;
		},
		set: function (value) {
			if (value !== this._toneMapping) {
				this._toneMapping = value;
				this.updateShaders = true;
			}
		}
	});
	Object.defineProperty(Scene.prototype, 'skybox', {
		get: function () {
			return this._skyboxCubeMap;
		},
		set: function (value) {
			this._skyboxCubeMap = value;
			this._resetSkyboxModel();
			this.updateShaders = true;
		}
	});
	Object.defineProperty(Scene.prototype, 'skyboxIntensity', {
		get: function () {
			return this._skyboxIntensity;
		},
		set: function (value) {
			this._skyboxIntensity = value;
			this._resetSkyboxModel();
			this.updateShaders = true;
		}
	});
	Object.defineProperty(Scene.prototype, 'skyboxMip', {
		get: function () {
			return this._skyboxMip;
		},
		set: function (value) {
			this._skyboxMip = value;
			this._resetSkyboxModel();
			this.updateShaders = true;
		}
	});
	Object.defineProperty(Scene.prototype, 'skyboxPrefiltered128', {
		get: function () {
			return this._skyboxPrefiltered[0];
		},
		set: function (value) {
			if (this._skyboxPrefiltered[0] === value)
				return;
			this._skyboxPrefiltered[0] = value;
			this.updateShaders = true;
		}
	});
	Object.defineProperty(Scene.prototype, 'skyboxPrefiltered64', {
		get: function () {
			return this._skyboxPrefiltered[1];
		},
		set: function (value) {
			if (this._skyboxPrefiltered[1] === value)
				return;
			this._skyboxPrefiltered[1] = value;
			this.updateShaders = true;
		}
	});
	Object.defineProperty(Scene.prototype, 'skyboxPrefiltered32', {
		get: function () {
			return this._skyboxPrefiltered[2];
		},
		set: function (value) {
			if (this._skyboxPrefiltered[2] === value)
				return;
			this._skyboxPrefiltered[2] = value;
			this.updateShaders = true;
		}
	});
	Object.defineProperty(Scene.prototype, 'skyboxPrefiltered16', {
		get: function () {
			return this._skyboxPrefiltered[3];
		},
		set: function (value) {
			if (this._skyboxPrefiltered[3] === value)
				return;
			this._skyboxPrefiltered[3] = value;
			this.updateShaders = true;
		}
	});
	Object.defineProperty(Scene.prototype, 'skyboxPrefiltered8', {
		get: function () {
			return this._skyboxPrefiltered[4];
		},
		set: function (value) {
			if (this._skyboxPrefiltered[4] === value)
				return;
			this._skyboxPrefiltered[4] = value;
			this.updateShaders = true;
		}
	});
	Object.defineProperty(Scene.prototype, 'skyboxPrefiltered4', {
		get: function () {
			return this._skyboxPrefiltered[5];
		},
		set: function (value) {
			if (this._skyboxPrefiltered[5] === value)
				return;
			this._skyboxPrefiltered[5] = value;
			this.updateShaders = true;
		}
	});
	Object.defineProperty(Scene.prototype, 'drawCalls', {
		get: function () {
			var drawCalls = this.layers._meshInstances;
			if (!drawCalls.length) {
				this.layers._update();
				drawCalls = this.layers._meshInstances;
			}
			return drawCalls;
		},
		set: function (value) {
		}
	});
	Object.defineProperty(Scene.prototype, 'layers', {
		get: function () {
			return this._layers;
		},
		set: function (layers) {
			var prev = this._layers;
			this._layers = layers;
			this.fire("set:layers", prev, layers);
		}
	});
	Scene.prototype.applySettings = function (settings) {
		this._gravity.set(settings.physics.gravity[0], settings.physics.gravity[1], settings.physics.gravity[2]);
		this.ambientLight.set(settings.render.global_ambient[0], settings.render.global_ambient[1], settings.render.global_ambient[2]);
		this._fog = settings.render.fog;
		this.fogColor.set(settings.render.fog_color[0], settings.render.fog_color[1], settings.render.fog_color[2]);
		this.fogStart = settings.render.fog_start;
		this.fogEnd = settings.render.fog_end;
		this.fogDensity = settings.render.fog_density;
		this._gammaCorrection = settings.render.gamma_correction;
		this._toneMapping = settings.render.tonemapping;
		this.lightmapSizeMultiplier = settings.render.lightmapSizeMultiplier;
		this.lightmapMaxResolution = settings.render.lightmapMaxResolution;
		this.lightmapMode = settings.render.lightmapMode;
		this.exposure = settings.render.exposure;
		this._skyboxIntensity = settings.render.skyboxIntensity === undefined ? 1 : settings.render.skyboxIntensity;
		this._skyboxMip = settings.render.skyboxMip === undefined ? 0 : settings.render.skyboxMip;
		this._resetSkyboxModel();
		this.updateShaders = true;
	};
	Scene.prototype._updateSkybox = function (device) {
		if (!this.skyboxModel) {
			var skyboxMapping = [0, 1, 3, 4, 5, 6];
			var usedTex =
				this._skyboxMip ?
					this._skyboxPrefiltered[skyboxMapping[this._skyboxMip]] || this._skyboxPrefiltered[0] || this._skyboxCubeMap :
					this._skyboxCubeMap || this._skyboxPrefiltered[0];
			if (!usedTex) {
				return;
			}
			var material = new Material();
			var scene = this;
			material.updateShader = function (dev, sc, defs, staticLightList, pass) {
				var library = device.getProgramLibrary();
				var shader = library.getProgram('skybox', {
					rgbm: usedTex.type === TEXTURETYPE_RGBM,
					hdr: (usedTex.type === TEXTURETYPE_RGBM || usedTex.format === PIXELFORMAT_RGBA32F),
					useIntensity: scene.skyboxIntensity !== 1,
					mip: usedTex.fixCubemapSeams ? scene.skyboxMip : 0,
					fixSeams: usedTex.fixCubemapSeams,
					gamma: (pass === SHADER_FORWARDHDR ? (scene.gammaCorrection ? GAMMA_SRGBHDR : GAMMA_NONE) : scene.gammaCorrection),
					toneMapping: (pass === SHADER_FORWARDHDR ? TONEMAP_LINEAR : scene.toneMapping)
				});
				this.shader = shader;
			};
			material.updateShader();
			material.setParameter("texture_cubeMap", usedTex);
			material.cull = CULLFACE_FRONT;
			material.depthWrite = false;
			var skyLayer = this.layers.getLayerById(LAYERID_SKYBOX);
			if (skyLayer) {
				var node = new GraphNode();
				var mesh = createBox(device);
				var meshInstance = new MeshInstance(node, mesh, material);
				meshInstance.cull = false;
				meshInstance._noDepthDrawGl1 = true;
				var model = new Model();
				model.graph = node;
				model.meshInstances = [meshInstance];
				this.skyboxModel = model;
				skyLayer.addMeshInstances(model.meshInstances);
				this.skyLayer = skyLayer;
				if (this._firstUpdateSkybox) {
					skyLayer.enabled = true;
					this._firstUpdateSkybox = false;
				}
				this.fire("set:skybox", usedTex);
			}
		}
	};
	Scene.prototype._resetSkyboxModel = function () {
		if (this.skyboxModel) {
			this.skyLayer.removeMeshInstances(this.skyboxModel.meshInstances);
			this.skyboxModel.destroy();
		}
		this.skyboxModel = null;
		this.updateSkybox = true;
	};
	Scene.prototype.setSkybox = function (cubemaps) {
		var i;
		if (!cubemaps)
			cubemaps = [null, null, null, null, null, null, null];
		var different = false;
		if (this._skyboxCubeMap !== cubemaps[0])
			different = true;
		if (!different) {
			for (i = 0; i < 6 && !different; i++) {
				if (this._skyboxPrefiltered[i] !== cubemaps[i + 1])
					different = true;
			}
		}
		if (!different)
			return;
		for (i = 0; i < 6; i++)
			this._skyboxPrefiltered[i] = cubemaps[i + 1];
		this.skybox = cubemaps[0];
	};
	Scene.prototype.destroy = function () {
		this.skybox = null;
	};
	Scene.prototype.addModel = function (model) {
		if (this.containsModel(model)) return;
		var layer = this.layers.getLayerById(LAYERID_WORLD);
		if (!layer) return;
		layer.addMeshInstances(model.meshInstances);
		this._models.push(model);
	};
	Scene.prototype.addShadowCaster = function (model) {
		var layer = this.layers.getLayerById(LAYERID_WORLD);
		if (!layer) return;
		layer.addShadowCasters(model.meshInstances);
	};
	Scene.prototype.removeModel = function (model) {
		var index = this._models.indexOf(model);
		if (index !== -1) {
			var layer = this.layers.getLayerById(LAYERID_WORLD);
			if (!layer) return;
			layer.removeMeshInstances(model.meshInstances);
			this._models.splice(index, 1);
		}
	};
	Scene.prototype.removeShadowCasters = function (model) {
		var layer = this.layers.getLayerById(LAYERID_WORLD);
		if (!layer) return;
		layer.removeShadowCasters(model.meshInstances);
	};
	Scene.prototype.containsModel = function (model) {
		return this._models.indexOf(model) >= 0;
	};
	Scene.prototype.getModels = function (model) {
		return this._models;
	};

	function hasAudio() {
		return (typeof Audio !== 'undefined');
	}
	function hasAudioContext() {
		return !!(typeof AudioContext !== 'undefined' || typeof webkitAudioContext !== 'undefined');
	}

	var Channel;
	if (hasAudioContext()) {
		Channel = function (manager, sound, options) {
			options = options || {};
			this.volume = (options.volume === undefined) ? 1 : options.volume;
			this.loop = (options.loop === undefined) ? false : options.loop;
			this.pitch = (options.pitch === undefined ? 1 : options.pitch);
			this.sound = sound;
			this.paused = false;
			this.suspended = false;
			this.startTime = 0;
			this.startOffset = 0;
			this.manager = manager;
			this.source = null;
			var context = manager.context;
			this.gain = context.createGain();
		};
		Object.assign(Channel.prototype, {
			play: function () {
				if (this.source) {
					throw new Error('Call stop() before calling play()');
				}
				this._createSource();
				if (!this.source) {
					return;
				}
				this.startTime = this.manager.context.currentTime;
				this.source.start(0, this.startOffset % this.source.buffer.duration);
				this.setVolume(this.volume);
				this.setLoop(this.loop);
				this.setPitch(this.pitch);
				this.manager.on('volumechange', this.onManagerVolumeChange, this);
				this.manager.on('suspend', this.onManagerSuspend, this);
				this.manager.on('resume', this.onManagerResume, this);
				if (this.manager.suspended)
					this.onManagerSuspend();
			},
			pause: function () {
				if (this.source) {
					this.paused = true;
					this.startOffset += this.manager.context.currentTime - this.startTime;
					this.source.stop(0);
					this.source = null;
				}
			},
			unpause: function () {
				if (this.source || !this.paused) {
					console.warn('Call pause() before unpausing.');
					return;
				}
				this._createSource();
				if (!this.source) {
					return;
				}
				this.startTime = this.manager.context.currentTime;
				this.source.start(0, this.startOffset % this.source.buffer.duration);
				this.setVolume(this.volume);
				this.setLoop(this.loop);
				this.setPitch(this.pitch);
				this.paused = false;
			},
			stop: function () {
				if (this.source) {
					this.source.stop(0);
					this.source = null;
				}
				this.manager.off('volumechange', this.onManagerVolumeChange, this);
				this.manager.off('suspend', this.onManagerSuspend, this);
				this.manager.off('resume', this.onManagerResume, this);
			},
			setLoop: function (loop) {
				this.loop = loop;
				if (this.source) {
					this.source.loop = loop;
				}
			},
			setVolume: function (volume) {
				volume = math.clamp(volume, 0, 1);
				this.volume = volume;
				if (this.gain) {
					this.gain.gain.value = volume * this.manager.volume;
				}
			},
			setPitch: function (pitch) {
				this.pitch = pitch;
				if (this.source) {
					this.source.playbackRate.value = pitch;
				}
			},
			isPlaying: function () {
				return (!this.paused && (this.source.playbackState === this.source.PLAYING_STATE));
			},
			getDuration: function () {
				return this.source ? this.source.buffer.duration : 0;
			},
			_createSource: function () {
				var context = this.manager.context;
				if (this.sound.buffer) {
					this.source = context.createBufferSource();
					this.source.buffer = this.sound.buffer;
					this.source.connect(this.gain);
					this.gain.connect(context.destination);
					if (!this.loop) {
						this.source.onended = this.pause.bind(this);
					}
				}
			}
		});
	} else if (hasAudio()) {
		Channel = function (manager, sound, options) {
			this.volume = options.volume || 1;
			this.loop = options.loop || false;
			this.sound = sound;
			this.pitch = options.pitch !== undefined ? options.pitch : 1;
			this.paused = false;
			this.suspended = false;
			this.manager = manager;
			if (sound.audio) {
				this.source = sound.audio.cloneNode(false);
				this.source.pause();
			}
		};
		Object.assign(Channel.prototype, {
			play: function () {
				if (this.source) {
					this.paused = false;
					this.setVolume(this.volume);
					this.setLoop(this.loop);
					this.setPitch(this.pitch);
					this.source.play();
				}
				this.manager.on('volumechange', this.onManagerVolumeChange, this);
				this.manager.on('suspend', this.onManagerSuspend, this);
				this.manager.on('resume', this.onManagerResume, this);
				if (this.manager.suspended)
					this.onManagerSuspend();
			},
			pause: function () {
				if (this.source) {
					this.paused = true;
					this.source.pause();
				}
			},
			unpause: function () {
				if (this.source) {
					this.paused = false;
					this.source.play();
				}
			},
			stop: function () {
				if (this.source) {
					this.source.pause();
				}
				this.manager.off('volumechange', this.onManagerVolumeChange, this);
				this.manager.off('suspend', this.onManagerSuspend, this);
				this.manager.off('resume', this.onManagerResume, this);
			},
			setVolume: function (volume) {
				volume = math.clamp(volume, 0, 1);
				this.volume = volume;
				if (this.source) {
					this.source.volume = volume * this.manager.volume;
				}
			},
			setLoop: function (loop) {
				this.loop = loop;
				if (this.source) {
					this.source.loop = loop;
				}
			},
			setPitch: function (pitch) {
				this.pitch = pitch;
				if (this.source) {
					this.source.playbackRate = pitch;
				}
			},
			getDuration: function () {
				return this.source && !isNaN(this.source.duration) ? this.source.duration : 0;
			},
			isPlaying: function () {
				return !this.source.paused;
			}
		});
	} else {
		Channel = function () {
		};
	}
	Object.assign(Channel.prototype, {
		getVolume: function () {
			return this.volume;
		},
		getLoop: function () {
			return this.loop;
		},
		getPitch: function () {
			return this.pitch;
		},
		onManagerVolumeChange: function () {
			this.setVolume(this.getVolume());
		},
		onManagerSuspend: function () {
			if (this.isPlaying() && !this.suspended) {
				this.suspended = true;
				this.pause();
			}
		},
		onManagerResume: function () {
			if (this.suspended) {
				this.suspended = false;
				this.unpause();
			}
		}
	});

	var DISTANCE_LINEAR = 'linear';
	var DISTANCE_INVERSE = 'inverse';
	var DISTANCE_EXPONENTIAL = 'exponential';

	var MAX_DISTANCE = 10000;
	var Channel3d;
	if (hasAudioContext()) {
		Channel3d = function (manager, sound, options) {
			Channel.call(this, manager, sound, options);
			this.position = new Vec3();
			this.velocity = new Vec3();
			var context = manager.context;
			this.panner = context.createPanner();
		};
		Channel3d.prototype = Object.create(Channel.prototype);
		Channel3d.prototype.constructor = Channel3d;
		Object.assign(Channel3d.prototype, {
			getPosition: function () {
				return this.position;
			},
			setPosition: function (position) {
				this.position.copy(position);
				this.panner.setPosition(position.x, position.y, position.z);
			},
			getVelocity: function () {
				return this.velocity;
			},
			setVelocity: function (velocity) {
				this.velocity.copy(velocity);
				this.panner.setVelocity(velocity.x, velocity.y, velocity.z);
			},
			getMaxDistance: function () {
				return this.panner.maxDistance;
			},
			setMaxDistance: function (max) {
				this.panner.maxDistance = max;
			},
			getMinDistance: function () {
				return this.panner.refDistance;
			},
			setMinDistance: function (min) {
				this.panner.refDistance = min;
			},
			getRollOffFactor: function () {
				return this.panner.rolloffFactor;
			},
			setRollOffFactor: function (factor) {
				this.panner.rolloffFactor = factor;
			},
			getDistanceModel: function () {
				return this.pannel.distanceModel;
			},
			setDistanceModel: function (distanceModel) {
				this.panner.distanceModel = distanceModel;
			},
			_createSource: function () {
				var context = this.manager.context;
				this.source = context.createBufferSource();
				this.source.buffer = this.sound.buffer;
				this.source.connect(this.panner);
				this.panner.connect(this.gain);
				this.gain.connect(context.destination);
				if (!this.loop) {
					this.source.onended = this.pause.bind(this);
				}
			}
		});
	} else if (hasAudio()) {
		var offset = new Vec3();
		var fallOff = function (posOne, posTwo, refDistance, maxDistance, rolloffFactor, distanceModel) {
			offset = offset.sub2(posOne, posTwo);
			var distance = offset.length();
			if (distance < refDistance) {
				return 1;
			} else if (distance > maxDistance) {
				return 0;
			}
			var result = 0;
			if (distanceModel === DISTANCE_LINEAR) {
				result = 1 - rolloffFactor * (distance - refDistance) / (maxDistance - refDistance);
			} else if (distanceModel === DISTANCE_INVERSE) {
				result = refDistance / (refDistance + rolloffFactor * (distance - refDistance));
			} else if (distanceModel === DISTANCE_EXPONENTIAL) {
				result = Math.pow(distance / refDistance, -rolloffFactor);
			}
			return math.clamp(result, 0, 1);
		};
		Channel3d = function (manager, sound) {
			Channel.call(this, manager, sound);
			this.position = new Vec3();
			this.velocity = new Vec3();
			this.maxDistance = MAX_DISTANCE;
			this.minDistance = 1;
			this.rollOffFactor = 1;
			this.distanceModel = DISTANCE_INVERSE;
		};
		Channel3d.prototype = Object.create(Channel.prototype);
		Channel3d.prototype.constructor = Channel3d;
		Object.assign(Channel3d.prototype, {
			getPosition: function () {
				return this.position;
			},
			setPosition: function (position) {
				this.position.copy(position);
				if (this.source) {
					var listener = this.manager.listener;
					var lpos = listener.getPosition();
					var factor = fallOff(lpos, this.position, this.minDistance, this.maxDistance, this.rollOffFactor, this.distanceModel);
					var v = this.getVolume();
					this.source.volume = v * factor;
				}
			},
			getVelocity: function () {
				return this.velocity;
			},
			setVelocity: function (velocity) {
				this.velocity.copy(velocity);
			},
			getMaxDistance: function () {
				return this.maxDistance;
			},
			setMaxDistance: function (max) {
				this.maxDistance = max;
			},
			getMinDistance: function () {
				return this.minDistance;
			},
			setMinDistance: function (min) {
				this.minDistance = min;
			},
			getRollOffFactor: function () {
				return this.rollOffFactor;
			},
			setRollOffFactor: function (factor) {
				this.rollOffFactor = factor;
			},
			getDistanceModel: function () {
				return this.distanceModel;
			},
			setDistanceModel: function (distanceModel) {
				this.distanceModel = distanceModel;
			}
		});
	} else {
		Channel3d = function () { };
	}

	function Listener(manager) {
		this.position = new Vec3();
		this.velocity = new Vec3();
		this.orientation = new Mat4();
		if (hasAudioContext()) {
			this.listener = manager.context.listener;
		}
	}
	Object.assign(Listener.prototype, {
		getPosition: function () {
			return this.position;
		},
		setPosition: function (position) {
			this.position.copy(position);
			if (this.listener) {
				this.listener.setPosition(position.x, position.y, position.z);
			}
		},
		getVelocity: function () {
			return this.velocity;
		},
		setVelocity: function (velocity) {
			this.velocity.copy(velocity);
			if (this.listener) {
				this.listener.setPosition(velocity.x, velocity.y, velocity.z);
			}
		},
		setOrientation: function (orientation) {
			this.orientation.copy(orientation);
			if (this.listener) {
				this.listener.setOrientation(-orientation.data[8], -orientation.data[9], -orientation.data[10],
											 orientation.data[4], orientation.data[5], orientation.data[6]);
			}
		},
		getOrientation: function () {
			return this.orientation;
		}
	});

	function SoundManager(options) {
		EventHandler.call(this);
		if (hasAudioContext() || options.forceWebAudioApi) {
			if (typeof AudioContext !== 'undefined') {
				this.context = new AudioContext();
			} else if (typeof webkitAudioContext !== 'undefined') {
				this.context = new webkitAudioContext();
			}
			if (this.context) {
				var context = this.context;
				this.resumeContext = function () {
					this.context.resume();
					window.removeEventListener('mousedown', this.resumeContext);
					window.removeEventListener('touchend', this.resumeContext);
				}.bind(this);
				window.addEventListener('mousedown', this.resumeContext);
				window.addEventListener('touchend', this.resumeContext);
				if (platform.ios) {
					var unlock = function () {
						var buffer = context.createBuffer(1, 1, 44100);
						var source = context.createBufferSource();
						source.buffer = buffer;
						source.connect(context.destination);
						source.start(0);
						source.disconnect();
						window.removeEventListener('touchend', unlock);
					};
					window.addEventListener('touchend', unlock);
				}
			}
		} else {
			console.warn('No support for 3D audio found');
		}
		if (!hasAudio())
			console.warn('No support for 2D audio found');
		this.listener = new Listener(this);
		this._volume = 1;
		this.suspended = false;
	}
	SoundManager.prototype = Object.create(EventHandler.prototype);
	SoundManager.prototype.constructor = SoundManager;
	Object.assign(SoundManager.prototype, {
		suspend: function  () {
			this.suspended = true;
			this.fire('suspend');
		},
		resume: function () {
			this.suspended = false;
			this.fire('resume');
		},
		destroy: function () {
			window.removeEventListener('mousedown', this.resumeContext);
			window.removeEventListener('touchend', this.resumeContext);
			this.fire('destroy');
			if (this.context && this.context.close) {
				this.context.close();
				this.context = null;
			}
		},
		playSound: function (sound, options) {
			options = options || {};
			var channel = null;
			if (Channel) {
				channel = new Channel(this, sound, options);
				channel.play();
			}
			return channel;
		},
		playSound3d: function (sound, position, options) {
			options = options || {};
			var channel = null;
			if (Channel3d) {
				channel = new Channel3d(this, sound, options);
				channel.setPosition(position);
				if (options.volume) {
					channel.setVolume(options.volume);
				}
				if (options.loop) {
					channel.setLoop(options.loop);
				}
				if (options.maxDistance) {
					channel.setMaxDistance(options.maxDistance);
				}
				if (options.minDistance) {
					channel.setMinDistance(options.minDistance);
				}
				if (options.rollOffFactor) {
					channel.setRollOffFactor(options.rollOffFactor);
				}
				if (options.distanceModel) {
					channel.setDistanceModel(options.distanceModel);
				}
				channel.play();
			}
			return channel;
		}
	});
	Object.defineProperty(SoundManager.prototype, 'volume', {
		get: function () {
			return this._volume;
		},
		set: function (volume) {
			volume = math.clamp(volume, 0, 1);
			this._volume = volume;
			this.fire('volumechange', volume);
		}
	});

	function Key(time, position, rotation, scale) {
		this.time = time;
		this.position = position;
		this.rotation = rotation;
		this.scale = scale;
	}
	function Node() {
		this._name = "";
		this._keys = [];
	}
	function Animation() {
		this.name = '';
		this.duration = 0;
		this._nodes = [];
		this._nodeDict = {};
	}
	Animation.prototype.getDuration = function () {
		return this.duration;
	};
	Animation.prototype.getName = function () {
		return this.name;
	};
	Animation.prototype.getNode = function (name) {
		return this._nodeDict[name];
	};
	Object.defineProperty(Animation.prototype, 'nodes', {
		get: function () {
			return this._nodes;
		}
	});
	Animation.prototype.getNodes = function () {
		return this._nodes;
	};
	Animation.prototype.setDuration = function (duration) {
		this.duration = duration;
	};
	Animation.prototype.setName = function (name) {
		this.name = name;
	};
	Animation.prototype.addNode = function (node) {
		this._nodes.push(node);
		this._nodeDict[node._name] = node;
	};

	function MorphTarget(options) {
		if (arguments.length === 2) {
			options = arguments[1];
		}
		this.options = options;
		this.name = options.name;
		this.defaultWeight = options.defaultWeight || 0;
		this.aabb = options.aabb;
		if (!this.aabb) {
			this.aabb = new BoundingBox();
			if (options.deltaPositions)
				this.aabb.compute(options.deltaPositions);
		}
		this.deltaPositions = options.deltaPositions;
	}
	Object.defineProperties(MorphTarget.prototype, {
		'morphPositions': {
			get: function () {
				return !!this._vertexBufferPositions || !!this.texturePositions;
			}
		},
		'morphNormals': {
			get: function () {
				return !!this._vertexBufferNormals || !!this.textureNormals;
			}
		}
	});
	Object.assign(MorphTarget.prototype, {
		_postInit: function () {
			this.options = null;
		},
		_initVertexBuffers: function (graphicsDevice) {
			var options = this.options;
			this._vertexBufferPositions = this._createVertexBuffer(graphicsDevice, options.deltaPositions, options.deltaPositionsType);
			this._vertexBufferNormals = this._createVertexBuffer(graphicsDevice, options.deltaNormals, options.deltaNormalsType);
			if (this._vertexBufferPositions) {
				this.deltaPositions = this._vertexBufferPositions.lock();
			}
		},
		_createVertexBuffer: function (device, data, dataType) {
			if (data) {
				var formatDesc = [{ semantic: SEMANTIC_ATTR0, components: 3, type: dataType || TYPE_FLOAT32 }];
				return new VertexBuffer(device, new VertexFormat(device, formatDesc), data.length / 3, BUFFER_STATIC, data);
			}
			return null;
		},
		_setTexture: function (name, texture) {
			this[name] = texture;
		},
		destroy: function () {
			if (this._vertexBufferPositions) {
				this._vertexBufferPositions.destroy();
				this._vertexBufferPositions = null;
			}
			if (this._vertexBufferNormals) {
				this._vertexBufferNormals.destroy();
				this._vertexBufferNormals = null;
			}
			if (this.texturePositions) {
				this.texturePositions.destroy();
				this.texturePositions = null;
			}
			if (this.textureNormals) {
				this.textureNormals.destroy();
				this.textureNormals = null;
			}
		}
	});

	var INTERPOLATION_STEP = 0;
	var INTERPOLATION_LINEAR = 1;
	var INTERPOLATION_CUBIC = 2;

	function AnimPropertyLocator() {}
	Object.assign(AnimPropertyLocator.prototype, {
		encode: function (locator) {
			return AnimBinder.joinPath([
				AnimBinder.joinPath(locator[0]),
				locator[1],
				AnimBinder.joinPath(locator[2])
			], '/');
		},
		decode: function (locator) {
			var locatorSections = AnimBinder.splitPath(locator, '/');
			return [
				AnimBinder.splitPath(locatorSections[0]),
				locatorSections[1],
				AnimBinder.splitPath(locatorSections[2])
			];
		}
	});

	function Entity(name, app) {
		GraphNode.call(this, name);
		if (name instanceof Application) app = name;
		this._batchHandle = null;
		this.c = {};
		this._app = app;
		if (!app) {
			this._app = Application.getApplication();
			if (!this._app) {
				throw new Error("Couldn't find current application");
			}
		}
		this._guid = null;
		this._destroying = false;
	}
	Entity.prototype = Object.create(GraphNode.prototype);
	Entity.prototype.constructor = Entity;
	Entity.prototype.addComponent = function (type, data) {
		var system = this._app.systems[type];
		if (!system) {
			return null;
		}
		if (this.c[type]) {
			return null;
		}
		return system.addComponent(this, data);
	};
	Entity.prototype.removeComponent = function (type) {
		var system = this._app.systems[type];
		if (!system) {
			return;
		}
		if (!this.c[type]) {
			return;
		}
		system.removeComponent(this);
	};
	Entity.prototype.findComponent = function (type) {
		var entity = this.findOne(function (node) {
			return node.c && node.c[type];
		});
		return entity && entity.c[type];
	};
	Entity.prototype.findComponents = function (type) {
		var entities = this.find(function (node) {
			return node.c && node.c[type];
		});
		return entities.map(function (entity) {
			return entity.c[type];
		});
	};
	Entity.prototype.getGuid = function () {
		if (! this._guid) {
			this.setGuid(guid.create());
		}
		return this._guid;
	};
	Entity.prototype.setGuid = function (guid) {
		var index = this._app._entityIndex;
		if (this._guid) {
			delete index[this._guid];
		}
		this._guid = guid;
		index[this._guid] = this;
	};
	Entity.prototype._notifyHierarchyStateChanged = function (node, enabled) {
		var enableFirst = false;
		if (node === this && this._app._enableList.length === 0)
			enableFirst = true;
		node._beingEnabled = true;
		node._onHierarchyStateChanged(enabled);
		if (node._onHierarchyStatePostChanged)
			this._app._enableList.push(node);
		var i, len;
		var c = node._children;
		for (i = 0, len = c.length; i < len; i++) {
			if (c[i]._enabled)
				this._notifyHierarchyStateChanged(c[i], enabled);
		}
		node._beingEnabled = false;
		if (enableFirst) {
			for (i = 0; i < this._app._enableList.length; i++) {
				this._app._enableList[i]._onHierarchyStatePostChanged();
			}
			this._app._enableList.length = 0;
		}
	};
	Entity.prototype._onHierarchyStateChanged = function (enabled) {
		GraphNode.prototype._onHierarchyStateChanged.call(this, enabled);
		var component;
		var components = this.c;
		for (var type in components) {
			if (components.hasOwnProperty(type)) {
				component = components[type];
				if (component.enabled) {
					if (enabled) {
						component.onEnable();
					} else {
						component.onDisable();
					}
				}
			}
		}
	};
	Entity.prototype._onHierarchyStatePostChanged = function () {
		var components = this.c;
		for (var type in components) {
			if (components.hasOwnProperty(type))
				components[type].onPostStateChange();
		}
	};
	Entity.prototype.findByGuid = function (guid) {
		if (this._guid === guid) return this;
		var e = this._app._entityIndex[guid];
		if (e && (e === this || e.isDescendantOf(this))) {
			return e;
		}
		return null;
	};
	Entity.prototype.destroy = function () {
		var name;
		this._destroying = true;
		for (name in this.c) {
			this.c[name].enabled = false;
		}
		for (name in this.c) {
			this.c[name].system.removeComponent(this);
		}
		if (this._parent)
			this._parent.removeChild(this);
		var children = this._children;
		var child = children.shift();
		while (child) {
			if (child instanceof Entity) {
				child.destroy();
			}
			child._parent = null;
			child = children.shift();
		}
		this.fire('destroy', this);
		this.off();
		if (this._guid) {
			delete this._app._entityIndex[this._guid];
		}
		this._destroying = false;
	};
	Entity.prototype.clone = function () {
		var duplicatedIdsMap = {};
		var clone = this._cloneRecursively(duplicatedIdsMap);
		duplicatedIdsMap[this.getGuid()] = clone;
		resolveDuplicatedEntityReferenceProperties(this, this, clone, duplicatedIdsMap);
		return clone;
	};
	Entity.prototype._cloneRecursively = function (duplicatedIdsMap) {
		var clone = new Entity(this._app);
		GraphNode.prototype._cloneInternal.call(this, clone);
		for (var type in this.c) {
			var component = this.c[type];
			component.system.cloneComponent(this, clone);
		}
		var i;
		for (i = 0; i < this._children.length; i++) {
			var oldChild = this._children[i];
			if (oldChild instanceof Entity) {
				var newChild = oldChild._cloneRecursively(duplicatedIdsMap);
				clone.addChild(newChild);
				duplicatedIdsMap[oldChild.getGuid()] = newChild;
			}
		}
		return clone;
	};
	function resolveDuplicatedEntityReferenceProperties(oldSubtreeRoot, oldEntity, newEntity, duplicatedIdsMap) {
		var i, len;
		if (oldEntity instanceof Entity) {
			var components = oldEntity.c;
			for (var componentName in components) {
				var component = components[componentName];
				var entityProperties = component.system.getPropertiesOfType('entity');
				for (i = 0, len = entityProperties.length; i < len; i++) {
					var propertyDescriptor = entityProperties[i];
					var propertyName = propertyDescriptor.name;
					var oldEntityReferenceId = component[propertyName];
					var entityIsWithinOldSubtree = !!oldSubtreeRoot.findByGuid(oldEntityReferenceId);
					if (entityIsWithinOldSubtree) {
						var newEntityReferenceId = duplicatedIdsMap[oldEntityReferenceId].getGuid();
						if (newEntityReferenceId) {
							newEntity.c[componentName][propertyName] = newEntityReferenceId;
						} else {
							console.warn('Could not find corresponding entity id when resolving duplicated entity references');
						}
					}
				}
			}
			if (components.script && ! newEntity._app.useLegacyScriptAttributeCloning) {
				newEntity.script.resolveDuplicatedEntityReferenceProperties(components.script, duplicatedIdsMap);
			}
			var _old = oldEntity.children.filter(function (e) {
				return (e instanceof Entity);
			});
			var _new = newEntity.children.filter(function (e) {
				return (e instanceof Entity);
			});
			for (i = 0, len = _old.length; i < len; i++) {
				resolveDuplicatedEntityReferenceProperties(oldSubtreeRoot, _old[i], _new[i], duplicatedIdsMap);
			}
		}
	}

	function AnimData(components, data) {
		this._components = components;
		this._data = data;
	}
	Object.defineProperties(AnimData.prototype, {
		components: {
			get: function () {
				return this._components;
			}
		},
		data: {
			get: function () {
				return this._data;
			}
		}
	});
	function AnimCache() {
		this._left = Infinity;
		this._right = -Infinity;
		this._len = 0;
		this._recip = 0;
		this._p0 = 0;
		this._p1 = 0;
		this._t = 0;
		this._hermite = {
			valid: false,
			p0: 0,
			m0: 0,
			p1: 0,
			m1: 0
		};
	}
	Object.assign(AnimCache.prototype, {
		update: function (time, input) {
			if (time < this._left || time >= this._right) {
				var len = input.length;
				if (!len) {
					this._left = -Infinity;
					this._right = Infinity;
					this._len = 0;
					this._recip = 0;
					this._p0 = this._p1 = 0;
				} else {
					if (time < input[0]) {
						this._left = -Infinity;
						this._right = input[0];
						this._len = 0;
						this._recip = 0;
						this._p0 = this._p1 = 0;
					} else if (time >= input[len - 1]) {
						this._left = input[len - 1];
						this._right = Infinity;
						this._len = 0;
						this._recip = 0;
						this._p0 = this._p1 = len - 1;
					} else {
						var index = this._findKey(time, input);
						this._left = input[index];
						this._right = input[index + 1];
						this._len = this._right - this._left;
						var diff = 1.0 / this._len;
						this._recip = (isFinite(diff) ? diff : 0);
						this._p0 = index;
						this._p1 = index + 1;
					}
				}
			}
			this._t = (this._recip === 0) ? 0 : ((time - this._left) * this._recip);
			this._hermite.valid = false;
		},
		_findKey: function (time, input) {
			var index = 0;
			while (time >= input[index + 1]) {
				index++;
			}
			return index;
		},
		eval: function (result, interpolation, output) {
			var data = output._data;
			var comp = output._components;
			var idx0 = this._p0 * comp;
			var i;
			if (interpolation === INTERPOLATION_STEP) {
				for (i = 0; i < comp; ++i) {
					result[i] = data[idx0 + i];
				}
			} else {
				var t = this._t;
				var idx1 = this._p1 * comp;
				switch (interpolation) {
					case INTERPOLATION_LINEAR:
						for (i = 0; i < comp; ++i) {
							result[i] = math.lerp(data[idx0 + i], data[idx1 + i], t);
						}
						break;
					case INTERPOLATION_CUBIC:
						var hermite = this._hermite;
						if (!hermite.valid) {
							var t2 = t * t;
							var twot = t + t;
							var omt = 1 - t;
							var omt2 = omt * omt;
							hermite.valid = true;
							hermite.p0 = (1 + twot) * omt2;
							hermite.m0 = t * omt2;
							hermite.p1 = t2 * (3 - twot);
							hermite.m1 = t2 * (t - 1);
						}
						var p0 = (this._p0 * 3 + 1) * comp;
						var m0 = (this._p0 * 3 + 2) * comp;
						var p1 = (this._p1 * 3 + 1) * comp;
						var m1 = (this._p1 * 3 + 0) * comp;
						for (i = 0; i < comp; ++i) {
							result[i] = hermite.p0 * data[p0 + i] +
										hermite.m0 * data[m0 + i] * this._len +
										hermite.p1 * data[p1 + i] +
										hermite.m1 * data[m1 + i] * this._len;
						}
						break;
				}
			}
		}
	});
	function AnimCurve(paths, input, output, interpolation) {
		this._paths = paths;
		this._input = input;
		this._output = output;
		this._interpolation = interpolation;
	}
	Object.defineProperties(AnimCurve.prototype, {
		paths: {
			get: function () {
				return this._paths;
			}
		},
		input: {
			get: function () {
				return this._input;
			}
		},
		output: {
			get: function () {
				return this._output;
			}
		},
		interpolation: {
			get: function () {
				return this._interpolation;
			}
		}
	});
	function AnimTrack(name, duration, inputs, outputs, curves) {
		this._name = name;
		this._duration = duration;
		this._inputs = inputs;
		this._outputs = outputs;
		this._curves = curves;
	}
	Object.defineProperties(AnimTrack.prototype, {
		name: {
			get: function () {
				return this._name;
			}
		},
		duration: {
			get: function () {
				return this._duration;
			}
		},
		inputs: {
			get: function () {
				return this._inputs;
			}
		},
		outputs: {
			get: function () {
				return this._outputs;
			}
		},
		curves: {
			get: function () {
				return this._curves;
			}
		}
	});
	Object.assign(AnimTrack.prototype, {
		eval: function (time, snapshot) {
			snapshot._time = time;
			var inputs = this._inputs;
			var outputs = this._outputs;
			var curves = this._curves;
			var cache = snapshot._cache;
			var results = snapshot._results;
			var i;
			for (i = 0; i < inputs.length; ++i) {
				cache[i].update(time, inputs[i]._data);
			}
			for (i = 0; i < curves.length; ++i) {
				var curve = curves[i];
				var output = outputs[curve._output];
				var result = results[i];
				cache[curve._input].eval(result, curve._interpolation, output);
			}
		}
	});
	function AnimSnapshot(animTrack) {
		this._name = animTrack.name + 'Snapshot';
		this._time = -1;
		this._cache = [];
		this._results = [];
		var i;
		for (i = 0; i < animTrack._inputs.length; ++i) {
			this._cache[i] = new AnimCache();
		}
		var curves = animTrack._curves;
		var outputs = animTrack._outputs;
		for (i = 0; i < curves.length; ++i) {
			var curve = curves[i];
			var output = outputs[curve._output];
			var storage = [];
			for (var j = 0; j < output._components; ++j) {
				storage[j] = 0;
			}
			this._results[i] = storage;
		}
	}
	function AnimClip(track, time, speed, playing, loop) {
		this._name = track.name;
		this._track = track;
		this._snapshot = new AnimSnapshot(track);
		this._playing = playing;
		this._time = time;
		this._speed = speed;
		this._loop = loop;
		this._blendWeight = 1.0;
		this._blendOrder = 0.0;
	}
	Object.defineProperties(AnimClip.prototype, {
		name: {
			get: function () {
				return this._name;
			},
			set: function (name) {
				this._name = name;
			}
		},
		track: {
			get: function () {
				return this._track;
			}
		},
		snapshot: {
			get: function () {
				return this._snapshot;
			}
		},
		time: {
			get: function () {
				return this._time;
			},
			set: function (time) {
				this._time = time;
			}
		},
		speed: {
			get: function () {
				return this._speed;
			},
			set: function (speed) {
				this._speed = speed;
			}
		},
		loop: {
			get: function () {
				return this._loop;
			},
			set: function (loop) {
				this._loop = loop;
			}
		},
		blendWeight: {
			get: function () {
				return this._blendWeight;
			},
			set: function (blendWeight) {
				this._blendWeight = blendWeight;
			}
		},
		blendOrder: {
			get: function () {
				return this._blendOrder;
			},
			set: function (blendOrder) {
				this._blendOrder = blendOrder;
			}
		}
	});
	Object.assign(AnimClip.prototype, {
		_update: function (deltaTime) {
			if (this._playing) {
				var time = this._time;
				var duration = this._track.duration;
				var speed = this._speed;
				var loop = this._loop;
				time += speed * deltaTime;
				if (speed >= 0) {
					if (time > duration) {
						if (loop) {
							time = (time % duration) || 0;
						} else {
							time = this._track.duration;
							this.pause();
						}
					}
				} else {
					if (time < 0) {
						if (loop) {
							time = duration + ((time % duration) || 0);
						} else {
							time = 0;
							this.pause();
						}
					}
				}
				this._time = time;
			}
			if (this._time != this._snapshot._time) {
				this._track.eval(this._time, this._snapshot);
			}
		},
		play: function () {
			this._playing = true;
			this._time = 0;
		},
		stop: function () {
			this._playing = false;
			this._time = 0;
		},
		pause: function () {
			this._playing = false;
		},
		resume: function () {
			this._playing = true;
		},
		reset: function () {
			this._time = 0;
		}
	});
	function AnimTarget(func, type, components) {
		this._func = func;
		this._type = type;
		this._components = components;
	}
	Object.defineProperties(AnimTarget.prototype, {
		func: {
			get: function () {
				return this._func;
			}
		},
		type: {
			get: function () {
				return this._type;
			}
		},
		components: {
			get: function () {
				return this._components;
			}
		}
	});
	function AnimBinder() {}
	AnimBinder.joinPath = function (pathSegments, character) {
		character = character || '.';
		var escape = function (string) {
			return string.replace(/\\/g, '\\\\').replace(new RegExp('\\' + character, 'g'), '\\' + character);
		};
		return pathSegments.map(escape).join(character);
	};
	AnimBinder.splitPath = function (path, character) {
		character = character || '.';
		var result = [];
		var curr = "";
		var i = 0;
		while (i < path.length) {
			var c = path[i++];
			if (c === '\\' && i < path.length) {
				c = path[i++];
				if (c === '\\' || c === character) {
					curr += c;
				} else {
					curr += '\\' + c;
				}
			} else if (c === character) {
				result.push(curr);
				curr = '';
			} else {
				curr += c;
			}
		}
		if (curr.length > 0) {
			result.push(curr);
		}
		return result;
	};
	Object.assign(AnimBinder.prototype, {
		resolve: function (path) {
			return null;
		},
		unresolve: function (path) {
		},
		update: function (deltaTime) {
		}
	});
	function DefaultAnimBinder(graph) {
		var nodes = { };
		var flatten = function (node) {
			nodes[node.name] = {
				node: node,
				count: 0
			};
			for (var i = 0; i < node.children.length; ++i) {
				flatten(node.children[i]);
			}
		};
		flatten(graph);
		this.nodes = nodes;
		this.activeNodes = [];
		this.handlers = {
			'localPosition': function (node) {
				var object = node.localPosition;
				var func = function (value) {
					object.set.apply(object, value);
				};
				return new AnimTarget(func, 'vector', 3);
			},
			'localRotation': function (node) {
				var object = node.localRotation;
				var func = function (value) {
					object.set.apply(object, value);
				};
				return new AnimTarget(func, 'quaternion', 4);
			},
			'localScale': function (node) {
				var object = node.localScale;
				var func = function (value) {
					object.set.apply(object, value);
				};
				return new AnimTarget(func, 'vector', 3);
			},
			'weights': function (node) {
				var object = node;
				while (object && object.constructor !== Entity) {
					object = object.parent;
				}
				if (!object ||
					!object.model ||
					!object.model.model ||
					!object.model.model.morphInstances) {
					return null;
				}
				var meshInstances = object.model.meshInstances;
				var morphInstance;
				for (var i = 0; i < meshInstances.length; ++i) {
					if (meshInstances[i].node.name === node.name) {
						morphInstance = meshInstances[i].morphInstance;
						break;
					}
				}
				if (!morphInstance) {
					return null;
				}
				var func = function (value) {
					for (var i = 0; i < value.length; ++i) {
						morphInstance.setWeight(i, value[i]);
					}
				};
				return new AnimTarget(func, 'vector', morphInstance.morph._targets.length);
			},
			'materialTexture': function (node, textureName) {
				var object = node;
				while (object && object.constructor !== Entity) {
					object = object.parent;
				}
				if (!object ||
					!object.model ||
					!object.model.model) {
					return null;
				}
				var meshInstances = object.model.meshInstances;
				var meshInstance;
				for (var i = 0; i < meshInstances.length; ++i) {
					if (meshInstances[i].node.name === node.name) {
						meshInstance = meshInstances[i];
						break;
					}
				}
				if (!meshInstance) {
					return null;
				}
				var func = function (value) {
					var textureAsset = this.animComponent.system.app.assets.get(value[0]);
					if (textureAsset && textureAsset.resource && textureAsset.type === 'texture') {
						meshInstance.material[textureName] = textureAsset.resource;
						meshInstance.material.update();
					}
				}.bind(this);
				return new AnimTarget(func, 'vector', 1);
			}.bind(this)
		};
		this.propertyLocator = new AnimPropertyLocator();
	}
	Object.assign(DefaultAnimBinder.prototype, {
		resolve: function (path) {
			var pathSections = this.propertyLocator.decode(path);
			var node = this.nodes[pathSections[0][0] || ""];
			if (!node) {
				return null;
			}
			var handler = this.handlers[pathSections[2][0]];
			if (!handler) {
				return null;
			}
			var target = handler(node.node);
			if (!target) {
				return null;
			}
			if (node.count === 0) {
				this.activeNodes.push(node.node);
			}
			node.count++;
			return target;
		},
		unresolve: function (path) {
			var pathSections = this.propertyLocator.decode(path);
			if (pathSections[1] !== 'graph')
				return;
			var node = this.nodes[pathSections[0][0]];
			node.count--;
			if (node.count === 0) {
				var activeNodes = this.activeNodes;
				var i = activeNodes.indexOf(node.node);
				var len = activeNodes.length;
				if (i < len - 1) {
					activeNodes[i] = activeNodes[len - 1];
				}
				activeNodes.pop();
			}
		},
		update: function (deltaTime) {
			var activeNodes = this.activeNodes;
			for (var i = 0; i < activeNodes.length; ++i) {
				activeNodes[i]._dirtifyLocal();
			}
		}
	});
	function AnimEvaluator(binder) {
		this._binder = binder;
		this._clips = [];
		this._inputs = [];
		this._outputs = [];
		this._targets = {};
	}
	Object.defineProperties(AnimEvaluator.prototype, {
		'clips': {
			get: function () {
				return this._clips;
			}
		}
	});
	AnimEvaluator._dot = function (a, b) {
		var len  = a.length;
		var result = 0;
		for (var i = 0; i < len; ++i) {
			result += a[i] * b[i];
		}
		return result;
	};
	AnimEvaluator._normalize = function (a) {
		var l = AnimEvaluator._dot(a, a);
		if (l > 0) {
			l = 1.0 / Math.sqrt(l);
			var len = a.length;
			for (var i = 0; i < len; ++i) {
				a[i] *= l;
			}
		}
	};
	AnimEvaluator._set = function (a, b, type) {
		var len  = a.length;
		var i;
		if (type === 'quaternion') {
			var l = AnimEvaluator._dot(b, b);
			if (l > 0) {
				l = 1.0 / Math.sqrt(l);
			}
			for (i = 0; i < len; ++i) {
				a[i] = b[i] * l;
			}
		} else {
			for (i = 0; i < len; ++i) {
				a[i] = b[i];
			}
		}
	};
	AnimEvaluator._blendVec = function (a, b, t) {
		var it = 1.0 - t;
		var len = a.length;
		for (var i = 0; i < len; ++i) {
			a[i] = a[i] * it + b[i] * t;
		}
	};
	AnimEvaluator._blendQuat = function (a, b, t) {
		var len = a.length;
		var it = 1.0 - t;
		if (AnimEvaluator._dot(a, b) < 0) {
			t = -t;
		}
		for (var i = 0; i < len; ++i) {
			a[i] = a[i] * it + b[i] * t;
		}
		AnimEvaluator._normalize(a);
	};
	AnimEvaluator._blend = function (a, b, t, type) {
		if (type === 'quaternion') {
			AnimEvaluator._blendQuat(a, b, t);
		} else {
			AnimEvaluator._blendVec(a, b, t);
		}
	};
	AnimEvaluator._stableSort = function (a, lessFunc) {
		var len = a.length;
		for (var i = 0; i < len - 1; ++i) {
			for (var j = i + 1; j < len; ++j) {
				if (lessFunc(a[j], a[i])) {
					var tmp = a[i];
					a[i] = a[j];
					a[j] = tmp;
				}
			}
		}
	};
	Object.assign(AnimEvaluator.prototype, {
		addClip: function (clip) {
			var targets = this._targets;
			var curves = clip.track.curves;
			var snapshot = clip.snapshot;
			var inputs = [];
			var outputs = [];
			for (var i = 0; i < curves.length; ++i) {
				var curve = curves[i];
				var paths = curve.paths;
				for (var j = 0; j < paths.length; ++j) {
					var path = paths[j];
					var target = targets[path];
					if (!target) {
						var resolved = this._binder.resolve(path);
						if (resolved) {
							target = {
								target: resolved,
								value: [],
								curves: 0,
								blendCounter: 0
							};
							for (var k = 0; k < target.target.components; ++k) {
								target.value.push(0);
							}
							targets[path] = target;
						}
					}
					if (target) {
						target.curves++;
						inputs.push(snapshot._results[i]);
						outputs.push(target);
					}
				}
			}
			this._clips.push(clip);
			this._inputs.push(inputs);
			this._outputs.push(outputs);
		},
		removeClip: function (index) {
			var targets = this._targets;
			var clips = this._clips;
			var clip = clips[index];
			var curves = clip.track.curves;
			for (var i = 0; i < curves.length; ++i) {
				var curve = curves[i];
				var paths = curve.paths;
				for (var j = 0; j < paths.length; ++j) {
					var path = paths[j];
					var target = targets[path];
					if (target) {
						target.curves--;
						if (target.curves === 0) {
							this._binder.unresolve(path);
							delete targets[path];
						}
					}
				}
			}
			clips.splice(index, 1);
			this._inputs.splice(index, 1);
			this._outputs.splice(index, 1);
		},
		removeClips: function () {
			while (this._clips.length > 0) {
				this.removeClip(0);
			}
		},
		findClip: function (name) {
			var clips = this._clips;
			for (var i = 0; i < clips.length; ++i) {
				var clip = clips[i];
				if (clip.name === name) {
					return clip;
				}
			}
			return null;
		},
		update: function (deltaTime) {
			var clips = this._clips;
			var order = clips.map(function (c, i) {
				return i;
			});
			AnimEvaluator._stableSort(order, function (a, b) {
				return clips[a].blendOrder < clips[b].blendOrder;
			});
			var i, j;
			for (i = 0; i < clips.length; ++i) {
				var index = order[i];
				var clip = clips[index];
				var inputs = this._inputs[index];
				var outputs = this._outputs[index];
				var blendWeight = clip.blendWeight;
				if (blendWeight > 0.0) {
					clip._update(deltaTime);
				}
				var input;
				var output;
				var value;
				if (blendWeight >= 1.0) {
					for (j = 0; j < inputs.length; ++j) {
						input = inputs[j];
						output = outputs[j];
						value = output.value;
						AnimEvaluator._set(value, input, output.target.type);
						output.blendCounter++;
					}
				} else if (blendWeight > 0.0) {
					for (j = 0; j < inputs.length; ++j) {
						input = inputs[j];
						output = outputs[j];
						value = output.value;
						if (output.blendCounter === 0) {
							AnimEvaluator._set(value, input, output.target.type);
						} else {
							AnimEvaluator._blend(value, input, blendWeight, output.target.type);
						}
						output.blendCounter++;
					}
				}
			}
			var targets = this._targets;
			for (var path in targets) {
				if (targets.hasOwnProperty(path)) {
					var target = targets[path];
					target.target.func(target.value);
					target.blendCounter = 0;
				}
			}
			this._binder.update(deltaTime);
		}
	});

	function I18nParser() {}
	I18nParser.prototype._validate = function (data) {
		if (!data.header) {
			throw new Error('pc.I18n#addData: Missing "header" field');
		}
		if (!data.header.version) {
			throw new Error('pc.I18n#addData: Missing "header.version" field');
		}
		if (data.header.version !== 1) {
			throw new Error('pc.I18n#addData: Invalid "header.version" field');
		}
		if (!data.data) {
			throw new Error('pc.I18n#addData: Missing "data" field');
		} else if (!Array.isArray(data.data)) {
			throw new Error('pc.I18n#addData: "data" field must be an array');
		}
		for (var i = 0, len = data.data.length; i < len; i++) {
			var entry = data.data[i];
			if (!entry.info) {
				throw new Error('pc.I18n#addData: missing "data[' + i + '].info" field');
			}
			if (!entry.info.locale) {
				throw new Error('pc.I18n#addData: missing "data[' + i + '].info.locale" field');
			}
			if (typeof entry.info.locale !== 'string') {
				throw new Error('pc.I18n#addData: "data[' + i + '].info.locale" must be a string');
			}
			if (!entry.messages) {
				throw new Error('pc.I18n#addData: missing "data[' + i + '].messages" field');
			}
		}
	};
	I18nParser.prototype.parse = function (data) {
		return data.data;
	};

	var PLURALS = {};
	var definePluralFn = function (locales, fn) {
		for (var i = 0, len = locales.length; i < len; i++) {
			PLURALS[locales[i]] = fn;
		}
	};
	var getLang = function (locale) {
		var idx = locale.indexOf('-');
		if (idx !== -1) {
			return locale.substring(0, idx);
		}
		return locale;
	};
	var replaceLang = function (locale, desiredLang) {
		var idx = locale.indexOf('-');
		if (idx !== -1) {
			return desiredLang + locale.substring(idx);
		}
		return desiredLang;
	};
	var DEFAULT_LOCALE = 'en-US';
	var DEFAULT_LOCALE_FALLBACKS = {
		'en': 'en-US',
		'es': 'en-ES',
		'zh': 'zh-CN',
		'zh-HK': 'zh-TW',
		'zh-TW': 'zh-HK',
		'zh-MO': 'zh-HK',
		'fr': 'fr-FR',
		'de': 'de-DE',
		'it': 'it-IT',
		'ru': 'ru-RU',
		'ja': 'ja-JP'
	};
	definePluralFn([
		'ja',
		'ko',
		'th',
		'vi',
		'zh',
		'id'
	], function (n) {
		return 0;
	});
	definePluralFn([
		'fa',
		'hi'
	], function (n) {
		if (n >= 0 && n <= 1) {
			return 0;
		}
		return 1;
	});
	definePluralFn([
		'fr',
		'pt'
	], function (n) {
		if (n >= 0 && n < 2) {
			return 0;
		}
		return 1;
	});
	definePluralFn([
		'da'
	], function (n) {
		if (n === 1 || !Number.isInteger(n) && n >= 0 && n <= 1) {
			return 0;
		}
		return 1;
	});
	definePluralFn([
		'de',
		'en',
		'it',
		'el',
		'es',
		'tr',
		'fi',
		'sv',
		'nb',
		'no',
		'ur'
	], function (n) {
		if (n === 1)  {
			return 0;
		}
		return 1;
	});
	definePluralFn([
		'ru',
		'uk'
	], function (n) {
		if (Number.isInteger(n)) {
			var mod10 = n % 10;
			var mod100 = n % 100;
			if (mod10 === 1 && mod100 !== 11) {
				return 0;
			} else if (mod10 >= 2 && mod10 <= 4 && (mod100 < 12 || mod100 > 14)) {
				return 1;
			} else if (mod10 === 0 || mod10 >= 5 && mod10 <= 9 || mod100 >= 11 && mod100 <= 14) {
				return 2;
			}
		}
		return 3;
	});
	definePluralFn([
		'pl'
	], function (n) {
		if (Number.isInteger(n)) {
			if (n === 1) {
				return 0;
			}
			var mod10 = n % 10;
			var mod100 = n % 100;
			if (mod10 >= 2 && mod10 <= 4 && (mod100 < 12 || mod100 > 14)) {
				return 1;
			} else if (mod10 >= 0 && mod10 <= 1 || mod10 >= 5 && mod10 <= 9 || mod100 >= 12 && mod100 <= 14) {
				return 2;
			}
		}
		return 3;
	});
	definePluralFn([
		'ar'
	], function (n) {
		if (n === 0)  {
			return 0;
		} else if (n === 1) {
			return 1;
		} else if (n === 2) {
			return 2;
		}
		if (Number.isInteger(n)) {
			var mod100 = n % 100;
			if (mod100 >= 3 && mod100 <= 10) {
				return 3;
			} else if (mod100 >= 11 && mod100 <= 99) {
				return 4;
			}
		}
		return 5;
	});
	var DEFAULT_PLURAL_FN = PLURALS[getLang(DEFAULT_LOCALE)];
	var getPluralFn = function (lang) {
		return PLURALS[lang] || DEFAULT_PLURAL_FN;
	};
	function I18n(app) {
		EventHandler.call(this);
		this.locale = DEFAULT_LOCALE;
		this._translations = {};
		this._availableLangs = {};
		this._app = app;
		this._assets = [];
		this._parser = new I18nParser();
	}
	I18n.prototype = Object.create(EventHandler.prototype);
	I18n.prototype.constructor = I18n;
	I18n.findAvailableLocale = function (desiredLocale, availableLocales) {
		if (availableLocales[desiredLocale]) {
			return desiredLocale;
		}
		var fallback = DEFAULT_LOCALE_FALLBACKS[desiredLocale];
		if (fallback && availableLocales[fallback]) {
			return fallback;
		}
		var lang = getLang(desiredLocale);
		fallback = DEFAULT_LOCALE_FALLBACKS[lang];
		if (availableLocales[fallback]) {
			return fallback;
		}
		if (availableLocales[lang]) {
			return lang;
		}
		return DEFAULT_LOCALE;
	};
	I18n.prototype.getText = function (key, locale) {
		var result = key;
		var lang;
		if (!locale) {
			locale = this._locale;
			lang = this._lang;
		}
		var translations = this._translations[locale];
		if (!translations) {
			if (!lang) {
				lang = getLang(locale);
			}
			locale = this._findFallbackLocale(locale, lang);
			translations = this._translations[locale];
		}
		if (translations && translations.hasOwnProperty(key)) {
			result = translations[key];
			if (Array.isArray(result)) {
				result = result[0];
			}
			if (result === null || result === undefined) {
				result = key;
			}
		}
		return result;
	};
	I18n.prototype.getPluralText = function (key, n, locale) {
		var result = key;
		var pluralFn;
		var lang;
		if (!locale) {
			locale = this._locale;
			lang = this._lang;
			pluralFn = this._pluralFn;
		} else {
			lang = getLang(locale);
			pluralFn = getPluralFn(lang);
		}
		var translations = this._translations[locale];
		if (!translations) {
			locale = this._findFallbackLocale(locale, lang);
			lang = getLang(locale);
			pluralFn = getPluralFn(lang);
			translations = this._translations[locale];
		}
		if (translations && translations[key] && pluralFn) {
			var index = pluralFn(n);
			result = translations[key][index];
			if (result === null || result === undefined) {
				result = key;
			}
		}
		return result;
	};
	I18n.prototype.addData = function (data) {
		var parsed;
		try {
			parsed = this._parser.parse(data);
		} catch (err) {
			console.error(err);
			return;
		}
		for (var i = 0, len = parsed.length; i < len; i++) {
			var entry = parsed[i];
			var locale = entry.info.locale;
			var messages = entry.messages;
			if (!this._translations[locale]) {
				this._translations[locale] = {};
				var lang = getLang(locale);
				if (!this._availableLangs[lang]) {
					this._availableLangs[lang] = locale;
				}
			}
			Object.assign(this._translations[locale], messages);
			this.fire('data:add', locale, messages);
		}
	};
	I18n.prototype.removeData = function (data) {
		var parsed;
		var key;
		try {
			parsed = this._parser.parse(data);
		} catch (err) {
			console.error(err);
			return;
		}
		for (var i = 0, len = parsed.length; i < len; i++) {
			var entry = parsed[i];
			var locale = entry.info.locale;
			var translations = this._translations[locale];
			if (!translations) continue;
			var messages = entry.messages;
			for (key in messages) {
				delete translations[key];
			}
			var hasAny = false;
			for (key in translations) {
				hasAny = true;
				break;
			}
			if (!hasAny) {
				delete this._translations[locale];
				delete this._availableLangs[getLang(locale)];
			}
			this.fire('data:remove', locale, messages);
		}
	};
	I18n.prototype.destroy = function () {
		this._translations = null;
		this._availableLangs = null;
		this._assets = null;
		this._parser = null;
		this.off();
	};
	Object.defineProperty(I18n.prototype, 'locale', {
		get: function () {
			return this._locale;
		},
		set: function (value) {
			if (this._locale === value) {
				return;
			}
			var lang = getLang(value);
			if (lang === 'in') {
				lang = 'id';
				value = replaceLang(value, lang);
				if (this._locale === value) {
					return;
				}
			}
			var old = this._locale;
			this._locale = value;
			this._lang = lang;
			this._pluralFn = getPluralFn(this._lang);
			this.fire('set:locale', value, old);
		}
	});
	Object.defineProperty(I18n.prototype, 'assets', {
		get: function () {
			return this._assets;
		},
		set: function (value) {
			var i;
			var len;
			var id;
			var asset;
			var index = {};
			for (i = 0, len = value.length; i < len; i++) {
				id = value[i] instanceof Asset ? value[i].id : value[i];
				index[id] = true;
			}
			i = this._assets.length;
			while (i--) {
				id = this._assets[i];
				if (!index[id]) {
					this._app.assets.off('add:' + id, this._onAssetAdd, this);
					asset = this._app.assets.get(id);
					if (asset) {
						this._onAssetRemove(asset);
					}
					this._assets.splice(i, 1);
				}
			}
			for (id in index) {
				id = parseInt(id, 10);
				if (this._assets.indexOf(id) !== -1) continue;
				this._assets.push(id);
				asset = this._app.assets.get(id);
				if (!asset) {
					this._app.assets.once('add:' + id, this._onAssetAdd, this);
				} else {
					this._onAssetAdd(asset);
				}
			}
		}
	});
	I18n.prototype._findFallbackLocale = function (locale, lang) {
		var result = DEFAULT_LOCALE_FALLBACKS[locale];
		if (result && this._translations[result]) {
			return result;
		}
		result = DEFAULT_LOCALE_FALLBACKS[lang];
		if (result && this._translations[result]) {
			return result;
		}
		result = this._availableLangs[lang];
		if (result && this._translations[result]) {
			return result;
		}
		return DEFAULT_LOCALE;
	};
	I18n.prototype._onAssetAdd = function (asset) {
		asset.on('load', this._onAssetLoad, this);
		asset.on('change', this._onAssetChange, this);
		asset.on('remove', this._onAssetRemove, this);
		asset.on('unload', this._onAssetUnload, this);
		if (asset.resource) {
			this._onAssetLoad(asset);
		}
	};
	I18n.prototype._onAssetLoad = function (asset) {
		this.addData(asset.resource);
	};
	I18n.prototype._onAssetChange = function (asset) {
		if (asset.resource) {
			this.addData(asset.resource);
		}
	};
	I18n.prototype._onAssetRemove = function (asset) {
		asset.off('load', this._onAssetLoad, this);
		asset.off('change', this._onAssetChange, this);
		asset.off('remove', this._onAssetRemove, this);
		asset.off('unload', this._onAssetUnload, this);
		if (asset.resource) {
			this.removeData(asset.resource);
		}
		this._app.assets.once('add:' + asset.id, this._onAssetAdd, this);
	};
	I18n.prototype._onAssetUnload = function (asset) {
		if (asset.resource) {
			this.removeData(asset.resource);
		}
	};

	var ABSOLUTE_URL = new RegExp(
		'^' +
		'\\s*' +
		'(?:' +
			'(?:' +
				'[a-z]+[a-z0-9\\-\\+\\.]*' +
				':' +
			')?' +
			'//' +
			'|' +
			'data:' +
			'|blob:' +
		')',
		'i'
	);
	var ASSET_ANIMATION = 'animation';
	var ASSET_AUDIO = 'audio';
	var ASSET_IMAGE = 'image';
	var ASSET_JSON = 'json';
	var ASSET_MODEL = 'model';
	var ASSET_MATERIAL = 'material';
	var ASSET_TEXT = 'text';
	var ASSET_TEXTURE = 'texture';
	var ASSET_CUBEMAP = 'cubemap';
	var ASSET_SHADER = 'shader';
	var ASSET_CSS = 'css';
	var ASSET_HTML = 'html';
	var ASSET_SCRIPT = 'script';
	var ASSET_CONTAINER = 'container';

	var properties = [];
	function AssetVariants(asset) {
		this.asset = asset;
	}
	var defineVariantProperty = function (name) {
		var field = '_' + name;
		properties.push(field);
		Object.defineProperty(AssetVariants.prototype, name, {
			get: function () {
				return this[field] || null;
			},
			set: function (value) {
				var fieldAsBool = !!this[field];
				var valueAsBool = !!value;
				if (fieldAsBool !== valueAsBool || (this[field] && value && this[field].hash !== value.hash)) {
					if (value) {
						this[field] = {
							url: value.url,
							filename: value.filename,
							size: value.size,
							hash: value.hash,
							opt: value.opt || 0
						};
					} else {
						this[field] = null;
					}
					if (this.asset.file) {
						this.asset.fire('change', this.asset, 'file', this.asset._file, this.asset._file);
						this.asset.reload();
					}
				}
			}
		});
	};
	defineVariantProperty('dxt');
	defineVariantProperty('pvr');
	defineVariantProperty('etc1');
	defineVariantProperty('etc2');
	defineVariantProperty('basis');
	AssetVariants.prototype.clear = function () {
		for (var i = 0; i < properties.length; i++)
			this[properties[i]] = null;
	};

	var assetIdCounter = -1;
	var VARIANT_SUPPORT = {
		pvr: 'extCompressedTexturePVRTC',
		dxt: 'extCompressedTextureS3TC',
		etc2: 'extCompressedTextureETC',
		etc1: 'extCompressedTextureETC1',
		basis: 'canvas'
	};
	var VARIANT_DEFAULT_PRIORITY = ['pvr', 'dxt', 'etc2', 'etc1', 'basis'];
	function Asset(name, type, file, data, options) {
		EventHandler.call(this);
		this._id = assetIdCounter--;
		this.name = name || '';
		this.type = type;
		this.tags = new Tags(this);
		this._preload = false;
		this.variants = new AssetVariants(this);
		this._file = null;
		this._data = data || { };
		this.options = options || { };
		this._resources = [];
		this._i18n = {};
		this.loaded = false;
		this.loading = false;
		this.registry = null;
		if (file) this.file = file;
	}
	Asset.prototype = Object.create(EventHandler.prototype);
	Asset.prototype.constructor = Asset;
	Object.assign(Asset.prototype, {
		getFileUrl: function () {
			var file = this.getPreferredFile();
			if (!file || !file.url)
				return null;
			var url = file.url;
			if (this.registry && this.registry.prefix && !ABSOLUTE_URL.test(url))
				url = this.registry.prefix + url;
			if (this.type !== 'script' && file.hash) {
				var separator = url.indexOf('?') !== -1 ? '&' : '?';
				url += separator + 't=' + file.hash;
			}
			return url;
		},
		getPreferredFile: function () {
			if (!this.file)
				return null;
			if (this.type === 'texture' || this.type === 'textureatlas' || this.type === 'bundle') {
				var app = this.registry._loader._app;
				var device = app.graphicsDevice;
				for (var i = 0, len = VARIANT_DEFAULT_PRIORITY.length; i < len; i++) {
					var variant = VARIANT_DEFAULT_PRIORITY[i];
					if (! device[VARIANT_SUPPORT[variant]]) continue;
					if (this.file.variants[variant]) {
						return this.file.variants[variant];
					}
					if (app.enableBundles) {
						var bundles = app.bundles.listBundlesForAsset(this);
						if (! bundles) continue;
						for (var j = 0, len2 = bundles.length; j < len2; j++) {
							if (bundles[j].file && bundles[j].file.variants && bundles[j].file.variants[variant]) {
								return this.file;
							}
						}
					}
				}
			}
			return this.file;
		},
		getAbsoluteUrl: function (relativePath) {
			var base = path.getDirectory(this.file.url);
			return path.join(base, relativePath);
		},
		getLocalizedAssetId: function (locale) {
			locale = I18n.findAvailableLocale(locale, this._i18n);
			return this._i18n[locale] || null;
		},
		addLocalizedAssetId: function (locale, assetId) {
			this._i18n[locale] = assetId;
			this.fire('add:localized', locale, assetId);
		},
		removeLocalizedAssetId: function (locale) {
			var assetId = this._i18n[locale];
			if (assetId) {
				delete this._i18n[locale];
				this.fire('remove:localized', locale, assetId);
			}
		},
		ready: function (callback, scope) {
			scope = scope || this;
			if (this.resource) {
				callback.call(scope, this);
			} else {
				this.once("load", function (asset) {
					callback.call(scope, asset);
				});
			}
		},
		reload: function () {
			if (this.loaded) {
				this.loaded = false;
				this.registry.load(this);
			}
		},
		unload: function () {
			if (!this.loaded && this._resources.length === 0)
				return;
			this.fire('unload', this);
			this.registry.fire('unload:' + this.id, this);
			var old = this._resources;
			this.resources = [];
			this.loaded = false;
			if (this.file) {
				this.registry._loader.clearCache(this.getFileUrl(), this.type);
			}
			for (var i = 0; i < old.length; ++i) {
				var resource = old[i];
				if (resource && resource.destroy) {
					resource.destroy();
				}
			}
		}
	});
	Object.defineProperty(Asset.prototype, 'id', {
		get: function () {
			return this._id;
		},
		set: function (value) {
			this._id = value;
		}
	});
	Object.defineProperty(Asset.prototype, 'file', {
		get: function () {
			return this._file;
		},
		set: function (value) {
			var key;
			var valueAsBool = !!value;
			var fileAsBool = !!this._file;
			if (valueAsBool !== fileAsBool || (value && this._file && value.hash !== this._file)) {
				if (value) {
					if (!this._file)
						this._file = { };
					this._file.url = value.url;
					this._file.filename = value.filename;
					this._file.hash = value.hash;
					this._file.size = value.size;
					this._file.variants = this.variants;
					this._file.contents = value.contents;
					if (value.hasOwnProperty('variants')) {
						this.variants.clear();
						if (value.variants) {
							for (key in value.variants) {
								if (!value.variants[key])
									continue;
								this.variants[key] = value.variants[key];
							}
						}
					}
					this.fire('change', this, 'file', this._file, this._file);
					this.reload();
				} else {
					this._file = null;
					this.variants.clear();
				}
			} else if (value && this._file && value.hasOwnProperty('variants')) {
				this.variants.clear();
				if (value.variants) {
					for (key in value.variants) {
						if (!value.variants[key])
							continue;
						this.variants[key] = value.variants[key];
					}
				}
			}
		}
	});
	Object.defineProperty(Asset.prototype, 'data', {
		get: function () {
			return this._data;
		},
		set: function (value) {
			var old = this._data;
			this._data = value;
			if (value !== old) {
				this.fire('change', this, 'data', value, old);
				if (this.loaded)
					this.registry._loader.patch(this, this.registry);
			}
		}
	});
	Object.defineProperty(Asset.prototype, 'resource', {
		get: function () {
			return this._resources[0];
		},
		set: function (value) {
			var _old = this._resources[0];
			this._resources[0] = value;
			this.fire('change', this, 'resource', value, _old);
		}
	});
	Object.defineProperty(Asset.prototype, 'resources', {
		get: function () {
			return this._resources;
		},
		set: function (value) {
			var _old = this._resources;
			this._resources = value;
			this.fire('change', this, 'resources', value, _old);
		}
	});
	Object.defineProperty(Asset.prototype, 'preload', {
		get: function () {
			return this._preload;
		},
		set: function (value) {
			value = !!value;
			if (this._preload === value)
				return;
			this._preload = value;
			if (this._preload && !this.loaded && !this.loading && this.registry)
				this.registry.load(this);
		}
	});
	Object.defineProperty(Asset.prototype, 'loadFaces', {
		get: function () {
			return this._loadFaces;
		},
		set: function (value) {
			value = !!value;
			if (!this.hasOwnProperty('_loadFaces') || value !== this._loadFaces) {
				this._loadFaces = value;
				if (this.loaded)
					this.registry._loader.patch(this, this.registry);
			}
		}
	});

	var isDataURI = function (uri) {
		return /^data:.*,.*$/i.test(uri);
	};
	var getDataURIMimeType = function (uri) {
		return uri.substring(uri.indexOf(":") + 1, uri.indexOf(";"));
	};
	var getNumComponents = function (accessorType) {
		switch (accessorType) {
			case 'SCALAR': return 1;
			case 'VEC2': return 2;
			case 'VEC3': return 3;
			case 'VEC4': return 4;
			case 'MAT2': return 4;
			case 'MAT3': return 9;
			case 'MAT4': return 16;
			default: return 3;
		}
	};
	var getComponentType = function (componentType) {
		switch (componentType) {
			case 5120: return TYPE_INT8;
			case 5121: return TYPE_UINT8;
			case 5122: return TYPE_INT16;
			case 5123: return TYPE_UINT16;
			case 5124: return TYPE_INT32;
			case 5125: return TYPE_UINT32;
			case 5126: return TYPE_FLOAT32;
			default: return 0;
		}
	};
	var getComponentSizeInBytes = function (componentType) {
		switch (componentType) {
			case 5120: return 1;
			case 5121: return 1;
			case 5122: return 2;
			case 5123: return 2;
			case 5124: return 4;
			case 5125: return 4;
			case 5126: return 4;
			default: return 0;
		}
	};
	var getComponentDataType = function (componentType) {
		switch (componentType) {
			case 5120: return Int8Array;
			case 5121: return Uint8Array;
			case 5122: return Int16Array;
			case 5123: return Uint16Array;
			case 5124: return Int32Array;
			case 5125: return Uint32Array;
			case 5126: return Float32Array;
			default: return null;
		}
	};
	var gltfToEngineSemanticMap = {
		'POSITION': SEMANTIC_POSITION,
		'NORMAL': SEMANTIC_NORMAL,
		'TANGENT': SEMANTIC_TANGENT,
		'COLOR_0': SEMANTIC_COLOR,
		'JOINTS_0': SEMANTIC_BLENDINDICES,
		'WEIGHTS_0': SEMANTIC_BLENDWEIGHT,
		'TEXCOORD_0': SEMANTIC_TEXCOORD0,
		'TEXCOORD_1': SEMANTIC_TEXCOORD1
	};
	var getAccessorData = function (gltfAccessor, bufferViews) {
		var numComponents = getNumComponents(gltfAccessor.type);
		var dataType = getComponentDataType(gltfAccessor.componentType);
		if (!dataType) {
			return null;
		}
		var result;
		if (gltfAccessor.sparse) {
			var sparse = gltfAccessor.sparse;
			var indicesAccessor = {
				count: sparse.count,
				type: "SCALAR"
			};
			var indices = getAccessorData(Object.assign(indicesAccessor, sparse.indices), bufferViews);
			var valuesAccessor = {
				count: sparse.count,
				type: gltfAccessor.scalar,
				componentType: gltfAccessor.componentType
			};
			var values = getAccessorData(Object.assign(valuesAccessor, sparse.values), bufferViews);
			if (gltfAccessor.hasOwnProperty('bufferView')) {
				var baseAccessor = {
					bufferView: gltfAccessor.bufferView,
					byteOffset: gltfAccessor.byteOffset,
					componentType: gltfAccessor.componentType,
					count: gltfAccessor.count,
					type: gltfAccessor.type
				};
				result = getAccessorData(baseAccessor, bufferViews).slice();
			} else {
				result = new dataType(gltfAccessor.count * numComponents);
			}
			for (var i = 0; i < sparse.count; ++i) {
				var targetIndex = indices[i];
				for (var j = 0; j < numComponents; ++j) {
					result[targetIndex * numComponents + j] = values[i * numComponents + j];
				}
			}
		} else {
			var bufferView = bufferViews[gltfAccessor.bufferView];
			result = new dataType(bufferView.buffer,
								  bufferView.byteOffset + (gltfAccessor.hasOwnProperty('byteOffset') ? gltfAccessor.byteOffset : 0),
								  gltfAccessor.count * numComponents);
		}
		return result;
	};
	var getPrimitiveType = function (primitive) {
		if (!primitive.hasOwnProperty('mode')) {
			return PRIMITIVE_TRIANGLES;
		}
		switch (primitive.mode) {
			case 0: return PRIMITIVE_POINTS;
			case 1: return PRIMITIVE_LINES;
			case 2: return PRIMITIVE_LINELOOP;
			case 3: return PRIMITIVE_LINESTRIP;
			case 4: return PRIMITIVE_TRIANGLES;
			case 5: return PRIMITIVE_TRISTRIP;
			case 6: return PRIMITIVE_TRIFAN;
			default: return PRIMITIVE_TRIANGLES;
		}
	};
	var generateIndices = function (numVertices) {
		var dummyIndices = new Uint16Array(numVertices);
		for (var i = 0; i < numVertices; i++) {
			dummyIndices[i] = i;
		}
		return dummyIndices;
	};
	var generateNormals = function (sourceDesc, indices) {
		var p = sourceDesc[SEMANTIC_POSITION];
		if (!p || p.components !== 3) {
			return;
		}
		var positions;
		if (p.size !== p.stride) {
			var srcStride = p.stride / typedArrayTypesByteSize[p.type];
			var src = new typedArrayTypes[p.type](p.buffer, p.offset, p.count * srcStride);
			positions = new typedArrayTypes[p.type](p.count * 3);
			for (var i = 0; i < p.count; ++i) {
				positions[i * 3 + 0] = src[i * srcStride + 0];
				positions[i * 3 + 1] = src[i * srcStride + 1];
				positions[i * 3 + 2] = src[i * srcStride + 2];
			}
		} else {
			positions = new typedArrayTypes[p.type](p.buffer, p.offset, p.count * 3);
		}
		var numVertices = p.count;
		if (!indices) {
			indices = generateIndices(numVertices);
		}
		var normalsTemp = calculateNormals(positions, indices);
		var normals = new Float32Array(normalsTemp.length);
		normals.set(normalsTemp);
		sourceDesc[SEMANTIC_NORMAL] = {
			buffer: normals.buffer,
			size: 12,
			offset: 0,
			stride: 12,
			count: numVertices,
			components: 3,
			type: TYPE_FLOAT32
		};
	};
	var flipTexCoordVs = function (vertexBuffer) {
		var i, j;
		var floatOffsets = [];
		var shortOffsets = [];
		var byteOffsets = [];
		for (i = 0; i < vertexBuffer.format.elements.length; ++i) {
			var element = vertexBuffer.format.elements[i];
			if (element.name === SEMANTIC_TEXCOORD0 ||
				element.name === SEMANTIC_TEXCOORD1) {
				switch (element.dataType) {
					case TYPE_FLOAT32:
						floatOffsets.push({ offset: element.offset / 4 + 1, stride: element.stride / 4 });
						break;
					case TYPE_UINT16:
						shortOffsets.push({ offset: element.offset / 2 + 1, stride: element.stride / 2 });
						break;
					case TYPE_UINT8:
						byteOffsets.push({ offset: element.offset + 1, stride: element.stride });
						break;
				}
			}
		}
		var flip = function (offsets, type, one) {
			var typedArray = new type(vertexBuffer.storage);
			for (i = 0; i < offsets.length; ++i) {
				var index = offsets[i].offset;
				var stride = offsets[i].stride;
				for (j = 0; j < vertexBuffer.numVertices; ++j) {
					typedArray[index] = one - typedArray[index];
					index += stride;
				}
			}
		};
		if (floatOffsets.length > 0) {
			flip(floatOffsets, Float32Array, 1.0);
		}
		if (shortOffsets.length > 0) {
			flip(shortOffsets, Uint16Array, 65535);
		}
		if (byteOffsets.length > 0) {
			flip(byteOffsets, Uint8Array, 255);
		}
	};
	var cloneTexture = function (texture) {
		var shallowCopyLevels = function (texture) {
			var result = [];
			for (var mip = 0; mip < texture._levels.length; ++mip) {
				var level = [];
				if (texture.cubemap) {
					for (var face = 0; face < 6; ++face) {
						level.push(texture._levels[mip][face]);
					}
				} else {
					level = texture._levels[mip];
				}
				result.push(level);
			}
			return result;
		};
		var result = new pc.Texture(texture.device, texture);
		result._levels = shallowCopyLevels(texture);
		return result;
	};
	var cloneTextureAsset = function (src) {
		var result = new pc.Asset(src.name + '_clone',
								  src.type,
								  src.file,
								  src.data,
								  src.options);
		result.loaded = true;
		result.resource = cloneTexture(src.resource);
		src.registry.add(result);
		return result;
	};
	var createVertexBufferInternal = function (device, sourceDesc, disableFlipV) {
		var positionDesc = sourceDesc[SEMANTIC_POSITION];
		var numVertices = positionDesc.count;
		var vertexDesc = [];
		for (var semantic in sourceDesc) {
			if (sourceDesc.hasOwnProperty(semantic)) {
				vertexDesc.push({
					semantic: semantic,
					components: sourceDesc[semantic].components,
					type: sourceDesc[semantic].type,
					normalize: !!sourceDesc[semantic].normalize
				});
			}
		}
		var elementOrder = [
			SEMANTIC_POSITION,
			SEMANTIC_NORMAL,
			SEMANTIC_TANGENT,
			SEMANTIC_COLOR,
			SEMANTIC_BLENDINDICES,
			SEMANTIC_BLENDWEIGHT,
			SEMANTIC_TEXCOORD0,
			SEMANTIC_TEXCOORD1
		];
		vertexDesc.sort(function (lhs, rhs) {
			var lhsOrder = elementOrder.indexOf(lhs.semantic);
			var rhsOrder = elementOrder.indexOf(rhs.semantic);
			return (lhsOrder < rhsOrder) ? -1 : (rhsOrder < lhsOrder ? 1 : 0);
		});
		var i, j, k;
		var source, target, sourceOffset;
		var vertexFormat = new VertexFormat(device, vertexDesc);
		var isCorrectlyInterleaved = true;
		for (i = 0; i < vertexFormat.elements.length; ++i) {
			target = vertexFormat.elements[i];
			source = sourceDesc[target.name];
			sourceOffset = source.offset - positionDesc.offset;
			if ((source.buffer !== positionDesc.buffer) ||
				(source.stride !== target.stride) ||
				(source.size !== target.size) ||
				(sourceOffset !== target.offset)) {
				isCorrectlyInterleaved = false;
				break;
			}
		}
		var vertexBuffer = new VertexBuffer(device,
											vertexFormat,
											numVertices,
											BUFFER_STATIC);
		var vertexData = vertexBuffer.lock();
		var targetArray = new Uint32Array(vertexData);
		var sourceArray;
		if (isCorrectlyInterleaved) {
			sourceArray = new Uint32Array(positionDesc.buffer,
										  positionDesc.offset,
										  numVertices * vertexBuffer.format.size / 4);
			targetArray.set(sourceArray);
		} else {
			var targetStride, sourceStride;
			for (i = 0; i < vertexBuffer.format.elements.length; ++i) {
				target = vertexBuffer.format.elements[i];
				targetStride = target.stride / 4;
				source = sourceDesc[target.name];
				sourceArray = new Uint32Array(source.buffer, source.offset, source.count * source.stride / 4);
				sourceStride = source.stride / 4;
				var src = 0;
				var dst = target.offset / 4;
				var kend = Math.floor((source.size + 3) / 4);
				for (j = 0; j < numVertices; ++j) {
					for (k = 0; k < kend; ++k) {
						targetArray[dst + k] = sourceArray[src + k];
					}
					src += sourceStride;
					dst += targetStride;
				}
			}
		}
		if (!disableFlipV) {
			flipTexCoordVs(vertexBuffer);
		}
		vertexBuffer.unlock();
		return vertexBuffer;
	};
	var createVertexBuffer = function (device, attributes, indices, accessors, bufferViews, disableFlipV) {
		var sourceDesc = {};
		for (var attrib in attributes) {
			if (attributes.hasOwnProperty(attrib) && gltfToEngineSemanticMap.hasOwnProperty(attrib)) {
				var accessor = accessors[attributes[attrib]];
				var accessorData = getAccessorData(accessor, bufferViews);
				var bufferView = bufferViews[accessor.bufferView];
				var semantic = gltfToEngineSemanticMap[attrib];
				var size = getNumComponents(accessor.type) * getComponentSizeInBytes(accessor.componentType);
				var stride = bufferView.hasOwnProperty('byteStride') ? bufferView.byteStride : size;
				sourceDesc[semantic] = {
					buffer: accessorData.buffer,
					size: size,
					offset: accessorData.byteOffset,
					stride: stride,
					count: accessor.count,
					components: getNumComponents(accessor.type),
					type: getComponentType(accessor.componentType),
					normalize: accessor.normalized
				};
			}
		}
		if (!sourceDesc.hasOwnProperty(SEMANTIC_NORMAL)) {
			generateNormals(sourceDesc, indices);
		}
		return createVertexBufferInternal(device, sourceDesc, disableFlipV);
	};
	var createVertexBufferDraco = function (device, outputGeometry, extDraco, decoder, decoderModule, indices, disableFlipV) {
		var numPoints = outputGeometry.num_points();
		var extractDracoAttributeInfo = function (uniqueId) {
			var attribute = decoder.GetAttributeByUniqueId(outputGeometry, uniqueId);
			var numValues = numPoints * attribute.num_components();
			var dracoFormat = attribute.data_type();
			var ptr, values, componentSizeInBytes, storageType;
			switch (dracoFormat) {
				case decoderModule.DT_UINT8:
					storageType = TYPE_UINT8;
					componentSizeInBytes = 1;
					ptr = decoderModule._malloc(numValues * componentSizeInBytes);
					decoder.GetAttributeDataArrayForAllPoints(outputGeometry, attribute, decoderModule.DT_UINT8, numValues * componentSizeInBytes, ptr);
					values = new Uint8Array(decoderModule.HEAPU8.buffer, ptr, numValues).slice();
					break;
				case decoderModule.DT_UINT16:
					storageType = TYPE_UINT16;
					componentSizeInBytes = 2;
					ptr = decoderModule._malloc(numValues * componentSizeInBytes);
					decoder.GetAttributeDataArrayForAllPoints(outputGeometry, attribute, decoderModule.DT_UINT16, numValues * componentSizeInBytes, ptr);
					values = new Uint16Array(decoderModule.HEAPU16.buffer, ptr, numValues).slice();
					break;
				case decoderModule.DT_FLOAT32:
				default:
					storageType = TYPE_FLOAT32;
					componentSizeInBytes = 4;
					ptr = decoderModule._malloc(numValues * componentSizeInBytes);
					decoder.GetAttributeDataArrayForAllPoints(outputGeometry, attribute, decoderModule.DT_FLOAT32, numValues * componentSizeInBytes, ptr);
					values = new Float32Array(decoderModule.HEAPF32.buffer, ptr, numValues).slice();
					break;
			}
			decoderModule._free(ptr);
			return {
				values: values,
				numComponents: attribute.num_components(),
				componentSizeInBytes: componentSizeInBytes,
				storageType: storageType,
				normalized: attribute.normalized()
			};
		};
		var sourceDesc = {};
		var attributes = extDraco.attributes;
		for (var attrib in attributes) {
			if (attributes.hasOwnProperty(attrib) && gltfToEngineSemanticMap.hasOwnProperty(attrib)) {
				var semantic = gltfToEngineSemanticMap[attrib];
				var attributeInfo = extractDracoAttributeInfo(attributes[attrib]);
				var size = attributeInfo.numComponents * attributeInfo.componentSizeInBytes;
				sourceDesc[semantic] = {
					values: attributeInfo.values,
					buffer: attributeInfo.values.buffer,
					size: size,
					offset: 0,
					stride: size,
					count: numPoints,
					components: attributeInfo.numComponents,
					type: attributeInfo.storageType,
					normalize: attributeInfo.normalized
				};
			}
		}
		if (!sourceDesc.hasOwnProperty(SEMANTIC_NORMAL)) {
			generateNormals(sourceDesc, indices);
		}
		return createVertexBufferInternal(device, sourceDesc, disableFlipV);
	};
	var createSkin = function (device, gltfSkin, accessors, bufferViews, nodes) {
		var i, j, bindMatrix;
		var joints = gltfSkin.joints;
		var numJoints = joints.length;
		var ibp = [];
		if (gltfSkin.hasOwnProperty('inverseBindMatrices')) {
			var inverseBindMatrices = gltfSkin.inverseBindMatrices;
			var ibmData = getAccessorData(accessors[inverseBindMatrices], bufferViews);
			var ibmValues = [];
			for (i = 0; i < numJoints; i++) {
				for (j = 0; j < 16; j++) {
					ibmValues[j] = ibmData[i * 16 + j];
				}
				bindMatrix = new Mat4();
				bindMatrix.set(ibmValues);
				ibp.push(bindMatrix);
			}
		} else {
			for (i = 0; i < numJoints; i++) {
				bindMatrix = new Mat4();
				ibp.push(bindMatrix);
			}
		}
		var boneNames = [];
		for (i = 0; i < numJoints; i++) {
			boneNames[i] = nodes[joints[i]].name;
		}
		var skeleton = gltfSkin.skeleton;
		var skin = new Skin(device, ibp, boneNames);
		skin.skeleton = nodes[skeleton];
		skin.bones = [];
		for (i = 0; i < joints.length; i++) {
			skin.bones[i] = nodes[joints[i]];
		}
		return skin;
	};
	var tempMat = new Mat4();
	var tempVec$1 = new Vec3();
	var createMesh$1 = function (device, gltfMesh, accessors, bufferViews, callback, disableFlipV) {
		var meshes = [];
		gltfMesh.primitives.forEach(function (primitive) {
			var primitiveType, vertexBuffer, numIndices;
			var indices = null;
			var mesh = new Mesh(device);
			var canUseMorph = true;
			if (primitive.hasOwnProperty('extensions')) {
				var extensions = primitive.extensions;
				if (extensions.hasOwnProperty('KHR_draco_mesh_compression')) {
					var decoderModule = window.DracoDecoderModule;
					if (decoderModule) {
						var extDraco = extensions.KHR_draco_mesh_compression;
						if (extDraco.hasOwnProperty('attributes')) {
							var uint8Buffer = bufferViews[extDraco.bufferView];
							var buffer = new decoderModule.DecoderBuffer();
							buffer.Init(uint8Buffer, uint8Buffer.length);
							var decoder = new decoderModule.Decoder();
							var geometryType = decoder.GetEncodedGeometryType(buffer);
							var outputGeometry, status;
							switch (geometryType) {
								case decoderModule.POINT_CLOUD:
									primitiveType = PRIMITIVE_POINTS;
									outputGeometry = new decoderModule.PointCloud();
									status = decoder.DecodeBufferToPointCloud(buffer, outputGeometry);
									break;
								case decoderModule.TRIANGULAR_MESH:
									primitiveType = PRIMITIVE_TRIANGLES;
									outputGeometry = new decoderModule.Mesh();
									status = decoder.DecodeBufferToMesh(buffer, outputGeometry);
									break;
								case decoderModule.INVALID_GEOMETRY_TYPE:
							}
							if (!status || !status.ok() || outputGeometry.ptr == 0) {
								callback("Failed to decode draco compressed asset: " +
								(status ? status.error_msg() : ('Mesh asset - invalid draco compressed geometry type: ' + geometryType) ));
								return;
							}
							var numFaces = outputGeometry.num_faces();
							if (geometryType == decoderModule.TRIANGULAR_MESH) {
								var bit32 = outputGeometry.num_points() > 65535;
								numIndices = numFaces * 3;
								var dataSize = numIndices * (bit32 ? 4 : 2);
								var ptr = decoderModule._malloc(dataSize);
								if (bit32) {
									decoder.GetTrianglesUInt32Array(outputGeometry, dataSize, ptr);
									indices = new Uint32Array(decoderModule.HEAPU32.buffer, ptr, numIndices).slice();
								} else {
									decoder.GetTrianglesUInt16Array(outputGeometry, dataSize, ptr);
									indices = new Uint16Array(decoderModule.HEAPU16.buffer, ptr, numIndices).slice();
								}
								decoderModule._free( ptr );
							}
							vertexBuffer = createVertexBufferDraco(device, outputGeometry, extDraco, decoder, decoderModule, indices, disableFlipV);
							decoderModule.destroy(outputGeometry);
							decoderModule.destroy(decoder);
							decoderModule.destroy(buffer);
							canUseMorph = false;
						}
					}
				}
			}
			if (!vertexBuffer) {
				indices = primitive.hasOwnProperty('indices') ? getAccessorData(accessors[primitive.indices], bufferViews) : null;
				vertexBuffer = createVertexBuffer(device, primitive.attributes, indices, accessors, bufferViews, disableFlipV);
				primitiveType = getPrimitiveType(primitive);
			}
			mesh.vertexBuffer = vertexBuffer;
			mesh.primitive[0].type = primitiveType;
			mesh.primitive[0].base = 0;
			mesh.primitive[0].indexed = (indices !== null);
			if (indices !== null) {
				var indexFormat;
				if (indices instanceof Uint8Array) {
					indexFormat = INDEXFORMAT_UINT8;
				} else if (indices instanceof Uint16Array) {
					indexFormat = INDEXFORMAT_UINT16;
				} else {
					indexFormat = INDEXFORMAT_UINT32;
				}
				if (indexFormat === INDEXFORMAT_UINT32 && !device.extUintElement) {
					indexFormat = INDEXFORMAT_UINT16;
					indices = new Uint16Array(indices);
				}
				var indexBuffer = new IndexBuffer(device, indexFormat, indices.length, BUFFER_STATIC, indices);
				mesh.indexBuffer[0] = indexBuffer;
				mesh.primitive[0].count = indices.length;
			} else {
				mesh.primitive[0].count = vertexBuffer.numVertices;
			}
			mesh.materialIndex = primitive.material;
			var accessor = accessors[primitive.attributes.POSITION];
			var min = accessor.min;
			var max = accessor.max;
			var aabb = new BoundingBox(
				new Vec3((max[0] + min[0]) / 2, (max[1] + min[1]) / 2, (max[2] + min[2]) / 2),
				new Vec3((max[0] - min[0]) / 2, (max[1] - min[1]) / 2, (max[2] - min[2]) / 2)
			);
			mesh.aabb = aabb;
			if (canUseMorph && primitive.hasOwnProperty('targets')) {
				var targets = [];
				primitive.targets.forEach(function (target, index) {
					var options = {};
					if (target.hasOwnProperty('POSITION')) {
						accessor = accessors[target.POSITION];
						options.deltaPositions = getAccessorData(accessor, bufferViews);
						options.deltaPositionsType = getComponentType(accessor.componentType);
						if (accessor.hasOwnProperty('min') && accessor.hasOwnProperty('max')) {
							options.aabb = new BoundingBox();
							options.aabb.setMinMax(new Vec3(accessor.min), new Vec3(accessor.max));
						}
					}
					if (target.hasOwnProperty('NORMAL')) {
						accessor = accessors[target.NORMAL];
						options.deltaNormals = getAccessorData(accessor, bufferViews);
						options.deltaNormalsType = getComponentType(accessor.componentType);
					}
					if (gltfMesh.hasOwnProperty('extras') &&
						gltfMesh.extras.hasOwnProperty('targetNames')) {
						options.name = gltfMesh.extras.targetNames[index];
					} else {
						options.name = targets.length.toString(10);
					}
					targets.push(new MorphTarget(device, options));
				});
				mesh.morph = new Morph(targets);
				if (gltfMesh.hasOwnProperty('weights')) {
					for (var i = 0; i < gltfMesh.weights.length; ++i) {
						targets[i].defaultWeight = gltfMesh.weights[i];
					}
				}
			}
			meshes.push(mesh);
		});
		return meshes;
	};
	var createMaterial = function (gltfMaterial, textures, disableFlipV) {
		var glossChunk = [
			"#ifdef MAPFLOAT",
			"uniform float material_shininess;",
			"#endif",
			"",
			"#ifdef MAPTEXTURE",
			"uniform sampler2D texture_glossMap;",
			"#endif",
			"",
			"void getGlossiness() {",
			"	dGlossiness = 1.0;",
			"",
			"#ifdef MAPFLOAT",
			"	dGlossiness *= material_shininess;",
			"#endif",
			"",
			"#ifdef MAPTEXTURE",
			"	dGlossiness *= texture2D(texture_glossMap, $UV).$CH;",
			"#endif",
			"",
			"#ifdef MAPVERTEX",
			"	dGlossiness *= saturate(vVertexColor.$VC);",
			"#endif",
			"",
			"	dGlossiness = 1.0 - dGlossiness;",
			"",
			"	dGlossiness += 0.0000001;",
			"}"
		].join('\n');
		var specularChunk = [
			"#ifdef MAPCOLOR",
			"uniform vec3 material_specular;",
			"#endif",
			"",
			"#ifdef MAPTEXTURE",
			"uniform sampler2D texture_specularMap;",
			"#endif",
			"",
			"void getSpecularity() {",
			"	dSpecularity = vec3(1.0);",
			"",
			"	#ifdef MAPCOLOR",
			"		dSpecularity *= material_specular;",
			"	#endif",
			"",
			"	#ifdef MAPTEXTURE",
			"		vec3 srgb = texture2D(texture_specularMap, $UV).$CH;",
			"		dSpecularity *= vec3(pow(srgb.r, 2.2), pow(srgb.g, 2.2), pow(srgb.b, 2.2));",
			"	#endif",
			"",
			"	#ifdef MAPVERTEX",
			"		dSpecularity *= saturate(vVertexColor.$VC);",
			"	#endif",
			"}"
		].join('\n');
		var uvONE = [1, 1];
		var uvZERO = [0, 0];
		var extractTextureTransform = function (source, material, maps) {
			var map;
			var texCoord = source.texCoord;
			if (texCoord) {
				for (map = 0; map < maps.length; ++map) {
					material[maps[map] + 'MapUv'] = texCoord;
				}
			}
			var scale = uvONE;
			var offset = uvZERO;
			var extensions = source.extensions;
			if (extensions) {
				var textureTransformData = extensions.KHR_texture_transform;
				if (textureTransformData) {
					if (textureTransformData.scale) {
						scale = textureTransformData.scale;
					}
					if (textureTransformData.offset) {
						offset = textureTransformData.offset;
					}
				}
			}
			for (map = 0; map < maps.length; ++map) {
				material[maps[map] + 'MapTiling'] = new Vec2(scale[0], scale[1]);
				material[maps[map] + 'MapOffset'] = new Vec2(offset[0], disableFlipV ? offset[1] : 1.0 - scale[1] - offset[1]);
			}
		};
		var material = new StandardMaterial();
		material.occludeSpecular = true;
		material.diffuseTint = true;
		material.diffuseVertexColor = true;
		material.specularTint = true;
		material.specularVertexColor = true;
		if (gltfMaterial.hasOwnProperty('name')) {
			material.name = gltfMaterial.name;
		}
		var color, texture;
		if (gltfMaterial.hasOwnProperty('extensions') &&
			gltfMaterial.extensions.hasOwnProperty('KHR_materials_pbrSpecularGlossiness')) {
			var specData = gltfMaterial.extensions.KHR_materials_pbrSpecularGlossiness;
			if (specData.hasOwnProperty('diffuseFactor')) {
				color = specData.diffuseFactor;
				material.diffuse.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));
				material.opacity = (color[3] != null) ? color[3] : 1;
			} else {
				material.diffuse.set(1, 1, 1);
				material.opacity = 1;
			}
			if (specData.hasOwnProperty('diffuseTexture')) {
				var diffuseTexture = specData.diffuseTexture;
				texture = textures[diffuseTexture.index];
				material.diffuseMap = texture;
				material.diffuseMapChannel = 'rgb';
				material.opacityMap = texture;
				material.opacityMapChannel = 'a';
				extractTextureTransform(diffuseTexture, material, ['diffuse', 'opacity']);
			}
			material.useMetalness = false;
			if (specData.hasOwnProperty('specularFactor')) {
				color = specData.specularFactor;
				material.specular.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));
			} else {
				material.specular.set(1, 1, 1);
			}
			if (specData.hasOwnProperty('glossinessFactor')) {
				material.shininess = 100 * specData.glossinessFactor;
			} else {
				material.shininess = 100;
			}
			if (specData.hasOwnProperty('specularGlossinessTexture')) {
				var specularGlossinessTexture = specData.specularGlossinessTexture;
				material.specularMap = material.glossMap = textures[specularGlossinessTexture.index];
				material.specularMapChannel = 'rgb';
				material.glossMapChannel = 'a';
				extractTextureTransform(specularGlossinessTexture, material, ['gloss', 'metalness']);
			}
			material.chunks.specularPS = specularChunk;
		} else if (gltfMaterial.hasOwnProperty('pbrMetallicRoughness')) {
			var pbrData = gltfMaterial.pbrMetallicRoughness;
			if (pbrData.hasOwnProperty('baseColorFactor')) {
				color = pbrData.baseColorFactor;
				material.diffuse.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));
				material.opacity = color[3];
			} else {
				material.diffuse.set(1, 1, 1);
				material.opacity = 1;
			}
			if (pbrData.hasOwnProperty('baseColorTexture')) {
				var baseColorTexture = pbrData.baseColorTexture;
				texture = textures[baseColorTexture.index];
				material.diffuseMap = texture;
				material.diffuseMapChannel = 'rgb';
				material.opacityMap = texture;
				material.opacityMapChannel = 'a';
				extractTextureTransform(baseColorTexture, material, ['diffuse', 'opacity']);
			}
			material.useMetalness = true;
			if (pbrData.hasOwnProperty('metallicFactor')) {
				material.metalness = pbrData.metallicFactor;
			} else {
				material.metalness = 1;
			}
			if (pbrData.hasOwnProperty('roughnessFactor')) {
				material.shininess = 100 * pbrData.roughnessFactor;
			} else {
				material.shininess = 100;
			}
			if (pbrData.hasOwnProperty('metallicRoughnessTexture')) {
				var metallicRoughnessTexture = pbrData.metallicRoughnessTexture;
				material.metalnessMap = material.glossMap = textures[metallicRoughnessTexture.index];
				material.metalnessMapChannel = 'b';
				material.glossMapChannel = 'g';
				extractTextureTransform(metallicRoughnessTexture, material, ['gloss', 'metalness']);
			}
			material.chunks.glossPS = glossChunk;
		}
		if (gltfMaterial.hasOwnProperty('normalTexture')) {
			var normalTexture = gltfMaterial.normalTexture;
			material.normalMap = textures[normalTexture.index];
			extractTextureTransform(normalTexture, material, ['normal']);
			if (normalTexture.hasOwnProperty('scale')) {
				material.bumpiness = normalTexture.scale;
			}
		}
		if (gltfMaterial.hasOwnProperty('occlusionTexture')) {
			var occlusionTexture = gltfMaterial.occlusionTexture;
			material.aoMap = textures[occlusionTexture.index];
			material.aoMapChannel = 'r';
			extractTextureTransform(occlusionTexture, material, ['ao']);
		}
		if (gltfMaterial.hasOwnProperty('emissiveFactor')) {
			color = gltfMaterial.emissiveFactor;
			material.emissive.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));
			material.emissiveTint = true;
		} else {
			material.emissive.set(0, 0, 0);
			material.emissiveTint = false;
		}
		if (gltfMaterial.hasOwnProperty('emissiveTexture')) {
			var emissiveTexture = gltfMaterial.emissiveTexture;
			material.emissiveMap = textures[emissiveTexture.index];
			extractTextureTransform(emissiveTexture, material, ['emissive']);
		}
		if (gltfMaterial.hasOwnProperty('alphaMode')) {
			switch (gltfMaterial.alphaMode) {
				case 'MASK':
					material.blendType = BLEND_NONE;
					if (gltfMaterial.hasOwnProperty('alphaCutoff')) {
						material.alphaTest = gltfMaterial.alphaCutoff;
					} else {
						material.alphaTest = 0.5;
					}
					break;
				case 'BLEND':
					material.blendType = BLEND_NORMAL;
					break;
				default:
				case 'OPAQUE':
					material.blendType = BLEND_NONE;
					break;
			}
		} else {
			material.blendType = BLEND_NONE;
		}
		if (gltfMaterial.hasOwnProperty('doubleSided')) {
			material.twoSidedLighting = gltfMaterial.doubleSided;
			material.cull = gltfMaterial.doubleSided ? CULLFACE_NONE : CULLFACE_BACK;
		} else {
			material.twoSidedLighting = false;
			material.cull = CULLFACE_BACK;
		}
		if (gltfMaterial.hasOwnProperty('extensions') &&
			gltfMaterial.extensions.hasOwnProperty('KHR_materials_unlit')) {
			material.useLighting = false;
			material.emissive.copy(material.diffuse);
			material.emissiveTint = material.diffuseTint;
			material.emissiveMap = material.diffuseMap;
			material.emissiveMapUv = material.diffuseMapUv;
			material.emissiveMapTiling.copy(material.diffuseMapTiling);
			material.emissiveMapOffset.copy(material.diffuseMapOffset);
			material.emissiveMapChannel = material.diffuseMapChannel;
			material.emissiveVertexColor = material.diffuseVertexColor;
			material.emissiveVertexColorChannel = material.diffuseVertexColorChannel;
			material.diffuse.set(0, 0, 0);
			material.diffuseTint = false;
			material.diffuseMap = null;
			material.diffuseVertexColor = false;
		}
		material.update();
		return material;
	};
	var createAnimation = function (gltfAnimation, animationIndex, gltfAccessors, bufferViews, nodes) {
		var createAnimData = function (gltfAccessor) {
			var data = getAccessorData(gltfAccessor, bufferViews);
			return new AnimData(getNumComponents(gltfAccessor.type), new data.constructor(data));
		};
		var interpMap = {
			"STEP": INTERPOLATION_STEP,
			"LINEAR": INTERPOLATION_LINEAR,
			"CUBICSPLINE": INTERPOLATION_CUBIC
		};
		var inputMap = { };
		var inputs = [];
		var outputMap = { };
		var outputs = [];
		var curves = [];
		var i;
		for (i = 0; i < gltfAnimation.samplers.length; ++i) {
			var sampler = gltfAnimation.samplers[i];
			if (!inputMap.hasOwnProperty(sampler.input)) {
				inputMap[sampler.input] = inputs.length;
				inputs.push(createAnimData(gltfAccessors[sampler.input]));
			}
			if (!outputMap.hasOwnProperty(sampler.output)) {
				outputMap[sampler.output] = outputs.length;
				outputs.push(createAnimData(gltfAccessors[sampler.output]));
			}
			var interpolation =
				sampler.hasOwnProperty('interpolation') &&
				interpMap.hasOwnProperty(sampler.interpolation) ?
					interpMap[sampler.interpolation] : INTERPOLATION_LINEAR;
			curves.push(new AnimCurve(
				[],
				inputMap[sampler.input],
				outputMap[sampler.output],
				interpolation));
		}
		var quatArrays = [];
		var propertyLocator = new AnimPropertyLocator();
		var transformSchema = {
			'translation': 'localPosition',
			'rotation': 'localRotation',
			'scale': 'localScale',
			'weights': 'weights'
		};
		for (i = 0; i < gltfAnimation.channels.length; ++i) {
			var channel = gltfAnimation.channels[i];
			var target = channel.target;
			var curve = curves[channel.sampler];
			curve._paths.push(propertyLocator.encode([[nodes[target.node].name], 'graph', [transformSchema[target.path]]]));
			if (target.path.startsWith('rotation') && curve.interpolation !== INTERPOLATION_CUBIC) {
				quatArrays.push(curve.output);
			} else if (target.path.startsWith('weights')) {
				outputs[curve.output]._components = outputs[curve.output].data.length / inputs[curve.input].data.length;
			}
		}
		quatArrays.sort();
		var prevIndex = null;
		var data;
		for (i = 0; i < quatArrays.length; ++i) {
			var index = quatArrays[i];
			if (i === 0 || index !== prevIndex) {
				data = outputs[index];
				if (data.components === 4) {
					var d = data.data;
					var len = d.length - 4;
					for (var j = 0; j < len; j += 4) {
						var dp = d[j + 0] * d[j + 4] +
								 d[j + 1] * d[j + 5] +
								 d[j + 2] * d[j + 6] +
								 d[j + 3] * d[j + 7];
						if (dp < 0) {
							d[j + 4] *= -1;
							d[j + 5] *= -1;
							d[j + 6] *= -1;
							d[j + 7] *= -1;
						}
					}
				}
				prevIndex = index;
			}
		}
		var duration = 0;
		for (i = 0; i < inputs.length; i++) {
			data  = inputs[i]._data;
			duration = Math.max(duration, data.length === 0 ? 0 : data[data.length - 1]);
		}
		return new AnimTrack(
			gltfAnimation.hasOwnProperty('name') ? gltfAnimation.name : ("animation_" + animationIndex),
			duration,
			inputs,
			outputs,
			curves);
	};
	var createNode = function (gltfNode, nodeIndex) {
		var entity = new GraphNode();
		if (gltfNode.hasOwnProperty('name') && gltfNode.name.length > 0) {
			entity.name = gltfNode.name;
		} else {
			entity.name = "node_" + nodeIndex;
		}
		if (gltfNode.hasOwnProperty('matrix')) {
			tempMat.data.set(gltfNode.matrix);
			tempMat.getTranslation(tempVec$1);
			entity.setLocalPosition(tempVec$1);
			tempMat.getEulerAngles(tempVec$1);
			entity.setLocalEulerAngles(tempVec$1);
			tempMat.getScale(tempVec$1);
			entity.setLocalScale(tempVec$1);
		}
		if (gltfNode.hasOwnProperty('rotation')) {
			var r = gltfNode.rotation;
			entity.setLocalRotation(r[0], r[1], r[2], r[3]);
		}
		if (gltfNode.hasOwnProperty('translation')) {
			var t = gltfNode.translation;
			entity.setLocalPosition(t[0], t[1], t[2]);
		}
		if (gltfNode.hasOwnProperty('scale')) {
			var s = gltfNode.scale;
			entity.setLocalScale(s[0], s[1], s[2]);
		}
		return entity;
	};
	var createSkins = function (device, gltf, nodes, bufferViews) {
		if (!gltf.hasOwnProperty('skins') || gltf.skins.length === 0) {
			return [];
		}
		return gltf.skins.map(function (gltfSkin) {
			return createSkin(device, gltfSkin, gltf.accessors, bufferViews, nodes);
		});
	};
	var createMeshes = function (device, gltf, bufferViews, callback, disableFlipV) {
		if (!gltf.hasOwnProperty('meshes') || gltf.meshes.length === 0 ||
			!gltf.hasOwnProperty('accessors') || gltf.accessors.length === 0 ||
			!gltf.hasOwnProperty('bufferViews') || gltf.bufferViews.length === 0) {
			return [];
		}
		return gltf.meshes.map(function (gltfMesh) {
			return createMesh$1(device, gltfMesh, gltf.accessors, bufferViews, callback, disableFlipV);
		});
	};
	var createMaterials = function (gltf, textures, options, disableFlipV) {
		if (!gltf.hasOwnProperty('materials') || gltf.materials.length === 0) {
			return [];
		}
		var preprocess = options && options.material && options.material.preprocess;
		var process = options && options.material && options.material.process || createMaterial;
		var postprocess = options && options.material && options.material.postprocess;
		return gltf.materials.map(function (gltfMaterial) {
			if (preprocess) {
				preprocess(gltfMaterial);
			}
			var material = process(gltfMaterial, textures, disableFlipV);
			if (postprocess) {
				postprocess(gltfMaterial, material);
			}
			return material;
		});
	};
	var createAnimations = function (gltf, nodes, bufferViews, options) {
		if (!gltf.hasOwnProperty('animations') || gltf.animations.length === 0) {
			return [];
		}
		var preprocess = options && options.animation && options.animation.preprocess;
		var postprocess = options && options.animation && options.animation.postprocess;
		return gltf.animations.map(function (gltfAnimation, index) {
			if (preprocess) {
				preprocess(gltfAnimation);
			}
			var animation = createAnimation(gltfAnimation, index, gltf.accessors, bufferViews, nodes);
			if (postprocess) {
				postprocess(gltfAnimation, animation);
			}
			return animation;
		});
	};
	var createNodes = function (gltf, options) {
		if (!gltf.hasOwnProperty('nodes') || gltf.nodes.length === 0) {
			return [];
		}
		var preprocess = options && options.node && options.node.preprocess;
		var process = options && options.node && options.node.process || createNode;
		var postprocess = options && options.node && options.node.postprocess;
		var nodes = gltf.nodes.map(function (gltfNode, index) {
			if (preprocess) {
				preprocess(gltfNode);
			}
			var node = process(gltfNode, index);
			if (postprocess) {
				postprocess(gltfNode, node);
			}
			return node;
		});
		for (var i = 0; i < gltf.nodes.length; ++i) {
			var gltfNode = gltf.nodes[i];
			if (gltfNode.hasOwnProperty('children')) {
				for (var j = 0; j < gltfNode.children.length; ++j) {
					var parent = nodes[i];
					var child = nodes[gltfNode.children[j]];
					if (!child.parent) {
						parent.addChild(child);
					}
				}
			}
		}
		return nodes;
	};
	var createScenes = function (gltf, nodes) {
		var scenes = [];
		var count = gltf.scenes.length;
		if (count === 1 && gltf.scenes[0].nodes.length === 1) {
			var nodeIndex = gltf.scenes[0].nodes[0];
			scenes.push(nodes[nodeIndex]);
		} else {
			for (var i = 0; i < count; i++) {
				var scene = gltf.scenes[i];
				var sceneRoot = new GraphNode(scene.name);
				for (var n = 0; n < scene.nodes.length; n++) {
					var childNode = nodes[scene.nodes[n]];
					sceneRoot.addChild(childNode);
				}
				scenes.push(sceneRoot);
			}
		}
		return scenes;
	};
	var createResources = function (device, gltf, bufferViews, textureAssets, options, callback) {
		var preprocess = options && options.global && options.global.preprocess;
		var postprocess = options && options.global && options.global.postprocess;
		if (preprocess) {
			preprocess(gltf);
		}
		var disableFlipV = gltf.asset && gltf.asset.generator === 'PlayCanvas';
		var nodes = createNodes(gltf, options);
		var scenes = createScenes(gltf, nodes);
		var animations = createAnimations(gltf, nodes, bufferViews, options);
		var materials = createMaterials(gltf, textureAssets.map(function (textureAsset) {
			return textureAsset.resource;
		}), options, disableFlipV);
		var meshes = createMeshes(device, gltf, bufferViews, callback, disableFlipV);
		var skins = createSkins(device, gltf, nodes, bufferViews);
		var result = {
			'gltf': gltf,
			'nodes': nodes,
			'scenes': scenes,
			'animations': animations,
			'textures': textureAssets,
			'materials': materials,
			'meshes': meshes,
			'skins': skins
		};
		if (postprocess) {
			postprocess(gltf, result);
		}
		callback(null, result);
	};
	var applySampler = function (texture, gltfSampler) {
		var defaultSampler = {
			magFilter: 9729,
			minFilter: 9987,
			wrapS: 10497,
			wrapT: 10497
		};
		var getFilter = function (filter) {
			switch (filter) {
				case 9728: return FILTER_NEAREST;
				case 9729: return FILTER_LINEAR;
				case 9984: return FILTER_NEAREST_MIPMAP_NEAREST;
				case 9985: return FILTER_LINEAR_MIPMAP_NEAREST;
				case 9986: return FILTER_NEAREST_MIPMAP_LINEAR;
				case 9987: return FILTER_LINEAR_MIPMAP_LINEAR;
				default:   return FILTER_LINEAR;
			}
		};
		var getWrap = function (wrap) {
			switch (wrap) {
				case 33071: return ADDRESS_CLAMP_TO_EDGE;
				case 33648: return ADDRESS_MIRRORED_REPEAT;
				case 10497: return ADDRESS_REPEAT;
				default:	return ADDRESS_REPEAT;
			}
		};
		if (texture) {
			gltfSampler = gltfSampler || defaultSampler;
			texture.minFilter = getFilter(gltfSampler.minFilter);
			texture.magFilter = getFilter(gltfSampler.magFilter);
			texture.addressU = getWrap(gltfSampler.wrapS);
			texture.addressV = getWrap(gltfSampler.wrapT);
		}
	};
	var loadImageAsync = function (gltfImage, index, bufferViews, urlBase, registry, options, callback) {
		var preprocess = options && options.image && options.image.preprocess;
		var processAsync = (options && options.image && options.image.processAsync) || function (gltfImage, callback) {
			callback(null, null);
		};
		var postprocess = options && options.image && options.image.postprocess;
		var onLoad = function (textureAsset) {
			if (postprocess) {
				postprocess(gltfImage, textureAsset);
			}
			callback(null, textureAsset);
		};
		var loadTexture = function (url, mimeType, crossOrigin, isBlobUrl) {
			var mimeTypeFileExtensions = {
				'image/png': 'png',
				'image/jpeg': 'jpg',
				'image/basis': 'basis',
				'image/ktx': 'ktx',
				'image/vnd-ms.dds': 'dds'
			};
			var file = { url: url };
			if (mimeType) {
				var extension = mimeTypeFileExtensions[mimeType];
				if (extension) {
					file.filename = 'glb-texture-' + index + '.' + extension;
				}
			}
			var asset = new Asset('texture_' + index, 'texture',  file, null, { crossOrigin: crossOrigin });
			asset.on('load', function () {
				if (isBlobUrl) {
					URL.revokeObjectURL(url);
				}
				onLoad(asset);
			});
			asset.on('error', function (err, asset) {
				callback(err);
			});
			registry.add(asset);
			registry.load(asset);
		};
		if (preprocess) {
			preprocess(gltfImage);
		}
		processAsync(gltfImage, function (err, textureAsset) {
			if (err) {
				callback(err);
			} else if (textureAsset) {
				onLoad(textureAsset);
			} else {
				if (gltfImage.hasOwnProperty('uri')) {
					if (isDataURI(gltfImage.uri)) {
						loadTexture(gltfImage.uri, getDataURIMimeType(gltfImage.uri));
					} else {
						loadTexture(path.join(urlBase, gltfImage.uri), null, "anonymous");
					}
				} else if (gltfImage.hasOwnProperty('bufferView') && gltfImage.hasOwnProperty('mimeType')) {
					var blob = new Blob([bufferViews[gltfImage.bufferView]], { type: gltfImage.mimeType });
					loadTexture(URL.createObjectURL(blob), gltfImage.mimeType, null, true);
				} else {
					callback("Invalid image found in gltf (neither uri or bufferView found). index=" + index);
				}
			}
		});
	};
	var loadTexturesAsync = function (gltf, bufferViews, urlBase, registry, options, callback) {
		if (!gltf.hasOwnProperty('images') || gltf.images.length === 0 ||
			!gltf.hasOwnProperty('textures') || gltf.textures.length === 0) {
			callback(null, []);
			return;
		}
		var preprocess = options && options.texture && options.texture.preprocess;
		var processAsync = (options && options.texture && options.texture.processAsync) || function (gltfTexture, gltfImages, callback) {
			callback(null, null);
		};
		var postprocess = options && options.texture && options.texture.postprocess;
		var assets = [];
		var textures = [];
		var remaining = gltf.textures.length;
		var onLoad = function (textureIndex, imageIndex) {
			if (!textures[imageIndex]) {
				textures[imageIndex] = [];
			}
			textures[imageIndex].push(textureIndex);
			if (--remaining === 0) {
				var result = [];
				textures.forEach(function (textureList, imageIndex) {
					textureList.forEach(function (textureIndex, index) {
						var textureAsset = (index === 0) ? assets[imageIndex] : cloneTextureAsset(assets[imageIndex]);
						applySampler(textureAsset.resource, (gltf.samplers || [])[gltf.textures[textureIndex].sampler]);
						result[textureIndex] = textureAsset;
						if (postprocess) {
							postprocess(gltf.textures[index], textureAsset);
						}
					});
				});
				callback(null, result);
			}
		};
		for (var i = 0; i < gltf.textures.length; ++i) {
			var gltfTexture = gltf.textures[i];
			if (preprocess) {
				preprocess(gltfTexture);
			}
			processAsync(gltfTexture, gltf.images, function (i, gltfTexture, err, gltfImageIndex) {
				if (err) {
					callback(err);
				} else {
					if (gltfImageIndex === undefined || gltfImageIndex === null) {
						gltfImageIndex = gltfTexture.source;
					}
					if (assets[gltfImageIndex]) {
						onLoad(i, gltfImageIndex);
					} else {
						var gltfImage = gltf.images[gltfImageIndex];
						loadImageAsync(gltfImage, i, bufferViews, urlBase, registry, options, function (err, textureAsset) {
							if (err) {
								callback(err);
							} else {
								assets[gltfImageIndex] = textureAsset;
								onLoad(i, gltfImageIndex);
							}
						});
					}
				}
			}.bind(null, i, gltfTexture));
		}
	};
	var loadBuffersAsync = function (gltf, binaryChunk, urlBase, options, callback) {
		var result = [];
		if (gltf.buffers === null || gltf.buffers.length === 0) {
			callback(null, result);
			return;
		}
		var preprocess = options && options.buffer && options.buffer.preprocess;
		var processAsync = (options && options.buffer && options.buffer.processAsync) || function (gltfBuffer, callback) {
			callback(null, null);
		};
		var postprocess = options && options.buffer && options.buffer.postprocess;
		var remaining = gltf.buffers.length;
		var onLoad = function (index, buffer) {
			result[index] = buffer;
			if (postprocess) {
				postprocess(gltf.buffers[index], buffer);
			}
			if (--remaining === 0) {
				callback(null, result);
			}
		};
		for (var i = 0; i < gltf.buffers.length; ++i) {
			var gltfBuffer = gltf.buffers[i];
			if (preprocess) {
				preprocess(gltfBuffer);
			}
			processAsync(gltfBuffer, function (i, gltfBuffer, err, arrayBuffer) {
				if (err) {
					callback(err);
				} else if (arrayBuffer) {
					onLoad(i, new Uint8Array(arrayBuffer));
				} else {
					if (gltfBuffer.hasOwnProperty('uri')) {
						if (isDataURI(gltfBuffer.uri)) {
							var byteString = atob(gltfBuffer.uri.split(',')[1]);
							var binaryArray = new Uint8Array(byteString.length);
							for (var j = 0; j < byteString.length; j++) {
								binaryArray[j] = byteString.charCodeAt(j);
							}
							onLoad(i, binaryArray);
						} else {
							http.get(
								path.join(urlBase, gltfBuffer.uri),
								{ cache: true, responseType: 'arraybuffer', retry: false },
								function (i, err, result) {
									if (err) {
										callback(err);
									} else {
										onLoad(i, new Uint8Array(result));
									}
								}.bind(null, i)
							);
						}
					} else {
						onLoad(i, binaryChunk);
					}
				}
			}.bind(null, i, gltfBuffer));
		}
	};
	var parseGltf = function (gltfChunk, callback) {
		var decodeBinaryUtf8 = function (array) {
			if (typeof TextDecoder !== 'undefined') {
				return new TextDecoder().decode(array);
			}
			var str = "";
			for (var i = 0; i < array.length; i++) {
				str += String.fromCharCode(array[i]);
			}
			return decodeURIComponent(escape(str));
		};
		var gltf = JSON.parse(decodeBinaryUtf8(gltfChunk));
		if (gltf.asset && gltf.asset.version && parseFloat(gltf.asset.version) < 2) {
			callback("Invalid gltf version. Expected version 2.0 or above but found version '" + gltf.asset.version + "'.");
			return;
		}
		callback(null, gltf);
	};
	var parseGlb = function (glbData, callback) {
		var data = new DataView(glbData);
		var magic = data.getUint32(0, true);
		var version = data.getUint32(4, true);
		var length = data.getUint32(8, true);
		if (magic !== 0x46546C67) {
			callback("Invalid magic number found in glb header. Expected 0x46546C67, found 0x" + magic.toString(16));
			return;
		}
		if (version !== 2) {
			callback("Invalid version number found in glb header. Expected 2, found " + version);
			return;
		}
		if (length <= 0 || length > glbData.byteLength) {
			callback("Invalid length found in glb header. Found " + length);
			return;
		}
		var chunks = [];
		var offset = 12;
		while (offset < length) {
			var chunkLength = data.getUint32(offset, true);
			if (offset + chunkLength + 8 > glbData.byteLength) {
				throw new Error("Invalid chunk length found in glb. Found " + chunkLength);
			}
			var chunkType = data.getUint32(offset + 4, true);
			var chunkData = new Uint8Array(glbData, offset + 8, chunkLength);
			chunks.push( { length: chunkLength, type: chunkType, data: chunkData } );
			offset += chunkLength + 8;
		}
		if (chunks.length !== 1 && chunks.length !== 2) {
			callback("Invalid number of chunks found in glb file.");
			return;
		}
		if (chunks[0].type !== 0x4E4F534A) {
			callback("Invalid chunk type found in glb file. Expected 0x4E4F534A, found 0x" + chunks[0].type.toString(16));
			return;
		}
		if (chunks.length > 1 && chunks[1].type !== 0x004E4942) {
			callback("Invalid chunk type found in glb file. Expected 0x004E4942, found 0x" + chunks[1].type.toString(16));
			return;
		}
		callback(null, {
			gltfChunk: chunks[0].data,
			binaryChunk: chunks.length === 2 ? chunks[1].data : null
		});
	};
	var parseChunk = function (filename, data, callback) {
		if (filename && filename.toLowerCase().endsWith('.glb')) {
			parseGlb(data, callback);
		} else {
			callback(null, {
				gltfChunk: data,
				binaryChunk: null
			});
		}
	};
	var parseBufferViewsAsync = function (gltf, buffers, options, callback) {
		var result = [];
		var preprocess = options && options.bufferView && options.bufferView.preprocess;
		var processAsync = (options && options.bufferView && options.bufferView.processAsync) || function (gltfBufferView, buffers, callback) {
			callback(null, null);
		};
		var postprocess = options && options.bufferView && options.bufferView.postprocess;
		var remaining = gltf.bufferViews.length;
		var onLoad = function (index, bufferView) {
			var gltfBufferView = gltf.bufferViews[index];
			if (gltfBufferView.hasOwnProperty('byteStride')) {
				bufferView.byteStride = gltfBufferView.byteStride;
			}
			result[index] = bufferView;
			if (postprocess) {
				postprocess(gltfBufferView, bufferView);
			}
			if (--remaining === 0) {
				callback(null, result);
			}
		};
		for (var i = 0; i < gltf.bufferViews.length; ++i) {
			var gltfBufferView = gltf.bufferViews[i];
			if (preprocess) {
				preprocess(gltfBufferView);
			}
			processAsync(gltfBufferView, buffers, function (i, gltfBufferView, err, result) {
				if (err) {
					callback(err);
				} else if (result) {
					onLoad(i, result);
				} else {
					var buffer = buffers[gltfBufferView.buffer];
					var typedArray = new Uint8Array(buffer.buffer,
													buffer.byteOffset + (gltfBufferView.hasOwnProperty('byteOffset') ? gltfBufferView.byteOffset : 0),
													gltfBufferView.byteLength);
					onLoad(i, typedArray);
				}
			}.bind(null, i, gltfBufferView));
		}
	};
	function GlbParser() {}
	GlbParser.parseAsync = function (filename, urlBase, data, device, registry, options, callback) {
		parseChunk(filename, data, function (err, chunks) {
			if (err) {
				callback(err);
				return;
			}
			parseGltf(chunks.gltfChunk, function (err, gltf) {
				if (err) {
					callback(err);
					return;
				}
				loadBuffersAsync(gltf, chunks.binaryChunk, urlBase, options, function (err, buffers) {
					if (err) {
						callback(err);
						return;
					}
					parseBufferViewsAsync(gltf, buffers, options, function (err, bufferViews) {
						if (err) {
							callback(err);
							return;
						}
						loadTexturesAsync(gltf, bufferViews, urlBase, registry, options, function (err, textureAssets) {
							if (err) {
								callback(err);
								return;
							}
							createResources(device, gltf, bufferViews, textureAssets, options, callback);
						});
					});
				});
			});
		});
	};
	GlbParser.parse = function (filename, data, device, options) {
		var result = null;
		options = options || { };
		parseChunk(filename, data, function (err, chunks) {
			if (err) {
				console.error(err);
			} else {
				parseGltf(chunks.gltfChunk, function (err, gltf) {
					if (err) {
						console.error(err);
					} else {
						parseBufferViewsAsync(gltf, [chunks.binaryChunk], options, function (err, bufferViews) {
							if (err) {
								console.error(err);
							} else {
								createResources(device, gltf, bufferViews, [], options, function (err, result_) {
									if (err) {
										console.error(err);
									} else {
										result = result_;
									}
								});
							}
						});
					}
				});
			}
		});
		return result;
	};
	GlbParser.createModel = function (glb, defaultMaterial) {
		var createMeshInstance = function (model, mesh, skins, skinInstances, materials, node, gltfNode) {
			var material = (mesh.materialIndex === undefined) ? defaultMaterial : materials[mesh.materialIndex];
			var meshInstance = new MeshInstance(node, mesh, material);
			if (mesh.morph) {
				var morphInstance = new MorphInstance(mesh.morph);
				if (mesh.weights) {
					for (var wi = 0; wi < mesh.weights.length; wi++) {
						morphInstance.setWeight(wi, mesh.weights[wi]);
					}
				}
				meshInstance.morphInstance = morphInstance;
				model.morphInstances.push(morphInstance);
			}
			if (gltfNode.hasOwnProperty('skin')) {
				var skinIndex = gltfNode.skin;
				var skin = skins[skinIndex];
				mesh.skin = skin;
				var skinInstance = skinInstances[skinIndex];
				meshInstance.skinInstance = skinInstance;
				model.skinInstances.push(skinInstance);
			}
			model.meshInstances.push(meshInstance);
		};
		var model = new Model();
		var s, skinInstances = [];
		for (s = 0; s < glb.skins.length; s++) {
			var skinInstance = new SkinInstance(glb.skins[s]);
			skinInstance.bones = glb.skins[s].bones;
			skinInstances.push(skinInstance);
		}
		if (glb.scenes.length === 1) {
			model.graph = glb.scenes[0];
		} else {
			model.graph = new GraphNode('SceneGroup');
			for (s = 0; s < glb.scenes.length; s++) {
				model.graph.addChild(glb.scenes[s]);
			}
		}
		for (var i = 0; i < glb.nodes.length; i++) {
			var node = glb.nodes[i];
			if (node.root === model.graph) {
				var gltfNode = glb.gltf.nodes[i];
				if (gltfNode.hasOwnProperty('mesh')) {
					var meshGroup = glb.meshes[gltfNode.mesh];
					for (var mi = 0; mi < meshGroup.length; mi++) {
						createMeshInstance(model, meshGroup[mi], glb.skins, skinInstances, glb.materials, node, gltfNode);
					}
				}
			}
		}
		return model;
	};

	function AnimationHandler() {
		this.retryRequests = false;
	}
	Object.assign(AnimationHandler.prototype, {
		load: function (url, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			var options = {
				retry: this.retryRequests
			};
			if (url.load.startsWith('blob:')) {
				if (path.getExtension(url.original).toLowerCase() === '.glb') {
					options.responseType = Http.ResponseType.ARRAY_BUFFER;
				} else {
					options.responseType = Http.ResponseType.JSON;
				}
			}
			http.get(url.load, options, function (err, response) {
				if (err) {
					callback("Error loading animation resource: " + url.original + " [" + err + "]");
				} else {
					callback(null, response);
				}
			});
		},
		open: function (url, data) {
			if (path.getExtension(url).toLowerCase() === '.glb') {
				var glb = GlbParser.parse("filename.glb", data, null);
				if (!glb) {
					return null;
				}
				return glb.animations;
			}
			return this["_parseAnimationV" + data.animation.version](data);
		},
		_parseAnimationV3: function (data) {
			var animData = data.animation;
			var anim = new Animation();
			anim.setName(animData.name);
			anim.duration = animData.duration;
			for (var i = 0; i < animData.nodes.length; i++) {
				var node = new Node();
				var n = animData.nodes[i];
				node._name = n.name;
				for (var j = 0; j < n.keys.length; j++) {
					var k = n.keys[j];
					var t = k.time;
					var p = k.pos;
					var r = k.rot;
					var s = k.scale;
					var pos = new Vec3(p[0], p[1], p[2]);
					var rot = new Quat().setFromEulerAngles(r[0], r[1], r[2]);
					var scl = new Vec3(s[0], s[1], s[2]);
					var key = new Key(t, pos, rot, scl);
					node._keys.push(key);
				}
				anim.addNode(node);
			}
			return anim;
		},
		_parseAnimationV4: function (data) {
			var animData = data.animation;
			var anim = new Animation();
			anim.setName(animData.name);
			anim.duration = animData.duration;
			for (var i = 0; i < animData.nodes.length; i++) {
				var node = new Node();
				var n = animData.nodes[i];
				node._name = n.name;
				var defPos = n.defaults.p;
				var defRot = n.defaults.r;
				var defScl = n.defaults.s;
				for (var j = 0; j < n.keys.length; j++) {
					var k = n.keys[j];
					var t = k.t;
					var p = defPos ? defPos : k.p;
					var r = defRot ? defRot : k.r;
					var s = defScl ? defScl : k.s;
					var pos = new Vec3(p[0], p[1], p[2]);
					var rot = new Quat().setFromEulerAngles(r[0], r[1], r[2]);
					var scl = new Vec3(s[0], s[1], s[2]);
					var key = new Key(t, pos, rot, scl);
					node._keys.push(key);
				}
				anim.addNode(node);
			}
			return anim;
		}
	});

	function AnimClipHandler() {
		this.retryRequests = false;
	}
	Object.assign(AnimClipHandler.prototype, {
		load: function (url, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			var options = {
				retry: this.retryRequests
			};
			if (url.load.startsWith('blob:')) {
				options.responseType = Http.ResponseType.JSON;
			}
			http.get(url.load, options, function (err, response) {
				if (err) {
					callback("Error loading animation clip resource: " + url.original + " [" + err + "]");
				} else {
					callback(null, response);
				}
			});
		},
		open: function (url, data) {
			var name = data.name;
			var duration = data.duration;
			var inputs = data.inputs.map(function (input) {
				return new AnimData(1, input);
			});
			var outputs = data.outputs.map(function (output) {
				return new AnimData(output.components, output.data);
			});
			var curves = data.curves.map(function (curve) {
				return new AnimCurve(
					[curve.path],
					curve.inputIndex,
					curve.outputIndex,
					curve.interpolation
				);
			});
			return new AnimTrack(
				name,
				duration,
				inputs,
				outputs,
				curves
			);
		}
	});

	function AnimStateGraph(data) {
		this._layers = [];
		this._parameters = {};
		var i;
		if (!Array.isArray(data.layers)) {
			for (var layerId in data.layers) {
				var dataLayer = data.layers[layerId];
				var layer = {
					name: dataLayer.name,
					states: [],
					transitions: []
				};
				for (i = 0; i < dataLayer.states.length; i++) {
					layer.states.push(data.states[dataLayer.states[i]]);
				}
				for (i = 0; i < dataLayer.transitions.length; i++) {
					var dataLayerTransition = data.transitions[dataLayer.transitions[i]];
					if (dataLayerTransition.conditions && !Array.isArray(dataLayerTransition.conditions)) {
						var conditionKeys = Object.keys(dataLayerTransition.conditions);
						var conditions = [];
						for (var j = 0; j < conditionKeys.length; j++) {
							var condition = dataLayerTransition.conditions[conditionKeys[j]];
							if (condition.parameterName) {
								conditions.push(condition);
							}
						}
						dataLayerTransition.conditions = conditions;
					}
					if (Number.isInteger(dataLayerTransition.from)) {
						dataLayerTransition.from = data.states[dataLayerTransition.from].name;
					}
					if (Number.isInteger(dataLayerTransition.to)) {
						dataLayerTransition.to = data.states[dataLayerTransition.to].name;
					}
					layer.transitions.push(dataLayerTransition);
				}
				this._layers.push(layer);
			}
		} else {
			this._layers = data.layers;
		}
		for (var paramId in data.parameters) {
			var param = data.parameters[paramId];
			this._parameters[param.name] = { type: param.type, value: param.value };
		}
	}
	Object.defineProperties(AnimStateGraph.prototype, {
		parameters: {
			get: function () {
				return Object.assign({}, this._parameters);
			}
		},
		layers: {
			get: function () {
				return this._layers;
			}
		}
	});

	function AnimStateGraphHandler() {
		this.retryRequests = false;
	}
	Object.assign(AnimStateGraphHandler.prototype, {
		load: function (url, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			var options = {
				retry: this.retryRequests
			};
			if (url.load.startsWith('blob:')) {
				options.responseType = Http.ResponseType.JSON;
			}
			http.get(url.load, options, function (err, response) {
				if (err) {
					callback("Error loading animation state graph resource: " + url.original + " [" + err + "]");
				} else {
					callback(null, response);
				}
			});
		},
		open: function (url, data) {
			return new AnimStateGraph(data);
		}
	});

	function Sound(resource) {
		if (resource instanceof Audio) {
			this.audio = resource;
		} else {
			this.buffer = resource;
		}
	}
	Object.defineProperty(Sound.prototype, 'duration', {
		get: function () {
			var duration = 0;
			if (this.buffer) {
				duration = this.buffer.duration;
			} else if (this.audio) {
				duration = this.audio.duration;
			}
			return duration || 0;
		}
	});

	var ie = (function () {
		if (typeof window === 'undefined') {
			return false;
		}
		var ua = window.navigator.userAgent;
		var msie = ua.indexOf('MSIE ');
		if (msie > 0) {
			return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);
		}
		var trident = ua.indexOf('Trident/');
		if (trident > 0) {
			var rv = ua.indexOf('rv:');
			return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);
		}
		return false;
	})();
	function AudioHandler(manager) {
		this.manager = manager;
		this.retryRequests = false;
	}
	Object.assign(AudioHandler.prototype, {
		_isSupported: function (url) {
			var toMIME = {
				'.ogg': 'audio/ogg',
				'.mp3': 'audio/mpeg',
				'.wav': 'audio/x-wav',
				'.mp4a': 'audio/mp4',
				'.m4a': 'audio/mp4',
				'.mp4': 'audio/mp4',
				'.aac': 'audio/aac'
			};
			var ext = path.getExtension(url);
			if (toMIME[ext]) {
				return true;
			}
			return false;
		},
		load: function (url, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			var success = function (resource) {
				callback(null, new Sound(resource));
			};
			var error = function (err) {
				var msg = 'Error loading audio url: ' + url.original;
				if (err) {
					msg += ': ' + (err.message || err);
				}
				console.warn(msg);
				callback(msg);
			};
			if (this._createSound) {
				if (!this._isSupported(url.original)) {
					error("Audio format for " + url.original + " not supported");
					return;
				}
				this._createSound(url.load, success, error);
			} else {
				error(null);
			}
		},
		open: function (url, data) {
			return data;
		}
	});
	if (hasAudioContext()) {
		AudioHandler.prototype._createSound = function (url, success, error) {
			var manager = this.manager;
			if (!manager.context) {
				error('Audio manager has no audio context');
				return;
			}
			var options = {
				retry: this.retryRequests
			};
			if (url.startsWith('blob:')) {
				options.responseType = Http.ResponseType.ARRAY_BUFFER;
			}
			http.get(url, options, function (err, response) {
				if (err) {
					error(err);
					return;
				}
				manager.context.decodeAudioData(response, success, error);
			});
		};
	} else if (hasAudio()) {
		AudioHandler.prototype._createSound = function (url, success, error) {
			var audio = null;
			try {
				audio = new Audio();
			} catch (e) {
				error("No support for Audio element");
				return;
			}
			if (ie) {
				document.body.appendChild(audio);
			}
			var onReady = function () {
				audio.removeEventListener('canplaythrough', onReady);
				if (ie) {
					document.body.removeChild(audio);
				}
				success(audio);
			};
			audio.onerror = function () {
				audio.onerror = null;
				if (ie) {
					document.body.removeChild(audio);
				}
				error();
			};
			audio.addEventListener('canplaythrough', onReady);
			audio.src = url;
		};
	}

	function BinaryHandler() {
		this.retryRequests = false;
	}
	Object.assign(BinaryHandler.prototype, {
		load: function (url, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			http.get(url.load, {
				responseType: Http.ResponseType.ARRAY_BUFFER,
				retry: this.retryRequests
			}, function (err, response) {
				if (!err) {
					callback(null, response);
				} else {
					callback("Error loading binary resource: " + url.original + " [" + err + "]");
				}
			});
		},
		open: function (url, data) {
			return data;
		},
		patch: function (asset, assets) {
		}
	});

	function Bundle(files) {
		this._blobUrls = {};
		for (var i = 0, len = files.length; i < len; i++) {
			if (files[i].url) {
				this._blobUrls[files[i].name] = files[i].url;
			}
		}
	}
	Bundle.prototype.hasBlobUrl = function (url) {
		return !!this._blobUrls[url];
	};
	Bundle.prototype.getBlobUrl = function (url) {
		return this._blobUrls[url];
	};
	Bundle.prototype.destroy = function () {
		for (var key in this._blobUrls) {
			URL.revokeObjectURL(this._blobUrls[key]);
		}
		this._blobUrls = null;
	};

	var Untar;
	function UntarScope(isWorker) {
		var utfDecoder;
		var asciiDecoder;
		if (typeof TextDecoder !== 'undefined') {
			utfDecoder = new TextDecoder('utf-8');
			asciiDecoder = new TextDecoder('windows-1252');
		} else {
			console.warn('TextDecoder not supported - pc.Untar module will not work');
		}
		function PaxHeader(fields) {
			this._fields = fields;
		}
		PaxHeader.parse = function (buffer, start, length) {
			var paxArray = new Uint8Array(buffer, start, length);
			var bytesRead = 0;
			var fields = [];
			while (bytesRead < length) {
				var spaceIndex;
				for (spaceIndex = bytesRead; spaceIndex < length; spaceIndex++) {
					if (paxArray[spaceIndex] == 0x20)
						break;
				}
				if (spaceIndex >= length) {
					throw new Error('Invalid PAX header data format.');
				}
				var fieldLength = parseInt(utfDecoder.decode(new Uint8Array(buffer, start + bytesRead, spaceIndex - bytesRead)), 10);
				var fieldText = utfDecoder.decode(new Uint8Array(buffer, start + spaceIndex + 1, fieldLength - (spaceIndex - bytesRead) - 2));
				var field = fieldText.split('=');
				if (field.length !== 2) {
					throw new Error('Invalid PAX header data format.');
				}
				if (field[1].length === 0) {
					field[1] = null;
				}
				fields.push({
					name: field[0],
					value: field[1]
				});
				bytesRead += fieldLength;
			}
			return new PaxHeader(fields);
		};
		PaxHeader.prototype.applyHeader = function (file) {
			for (var i = 0; i < this._fields.length; i++) {
				var fieldName = this._fields[i].name;
				var fieldValue = this._fields[i].value;
				if (fieldName === 'path') {
					fieldName = 'name';
				}
				if (fieldValue === null) {
					delete file[fieldName];
				} else {
					file[fieldName] = fieldValue;
				}
			}
		};
		function UntarInternal(arrayBuffer) {
			this._arrayBuffer = arrayBuffer || new ArrayBuffer(0);
			this._bufferView = new DataView(this._arrayBuffer);
			this._globalPaxHeader = null;
			this._paxHeader = null;
			this._bytesRead = 0;
		}
		if (! isWorker) {
			Untar = UntarInternal;
		}
		UntarInternal.prototype._hasNext = function () {
			return this._bytesRead + 4 < this._arrayBuffer.byteLength && this._bufferView.getUint32(this._bytesRead) !== 0;
		};
		UntarInternal.prototype._readNextFile = function () {
			var headersDataView = new DataView(this._arrayBuffer, this._bytesRead, 512);
			var headers = asciiDecoder.decode(headersDataView);
			this._bytesRead += 512;
			var name = headers.substr(0, 100).replace(/\0/g, '');
			var ustarFormat = headers.substr(257, 6);
			var size = parseInt(headers.substr(124, 12), 8);
			var type = headers.substr(156, 1);
			var start = this._bytesRead;
			var url = null;
			var normalFile = false;
			switch (type) {
				case "0": case "":
					normalFile = true;
					if (!isWorker) {
						var blob = new Blob([this._arrayBuffer.slice(this._bytesRead, this._bytesRead + size)]);
						url = URL.createObjectURL(blob);
					}
					break;
				case "g":
					this._globalPaxHeader = PaxHeader.parse(this._arrayBuffer, this._bytesRead, size);
					break;
				case "x":
					this._paxHeader = PaxHeader.parse(this._arrayBuffer, this._bytesRead, size);
					break;
			}
			this._bytesRead += size;
			var remainder = size % 512;
			if (remainder !== 0) {
				this._bytesRead += (512 - remainder);
			}
			if (! normalFile) {
				return null;
			}
			if (ustarFormat.indexOf("ustar") !== -1) {
				var namePrefix = headers.substr(345, 155).replace(/\0/g, '');
				if (namePrefix.length > 0) {
					name = namePrefix.trim() + name.trim();
				}
			}
			var file = {
				name: name,
				start: start,
				size: size,
				url: url
			};
			if (this._globalPaxHeader) {
				this._globalPaxHeader.applyHeader(file);
			}
			if (this._paxHeader) {
				this._paxHeader.applyHeader(file);
				this._paxHeader = null;
			}
			return file;
		};
		UntarInternal.prototype.untar = function (filenamePrefix) {
			if (! utfDecoder) {
				console.error('Cannot untar because TextDecoder interface is not available for this platform.');
				return [];
			}
			var files = [];
			while (this._hasNext()) {
				var file = this._readNextFile();
				if (! file) continue;
				if (filenamePrefix && file.name) {
					file.name = filenamePrefix + file.name;
				}
				files.push(file);
			}
			return files;
		};
		if (isWorker) {
			self.onmessage = function (e) {
				var id = e.data.id;
				try {
					var archive = new UntarInternal(e.data.arrayBuffer);
					var files = archive.untar(e.data.prefix);
					postMessage({
						id: id,
						files: files,
						arrayBuffer: e.data.arrayBuffer
					}, [e.data.arrayBuffer]);
				} catch (err) {
					postMessage({
						id: id,
						error: err.toString()
					});
				}
			};
		}
	}
	var workerUrl = null;
	var getWorkerUrl = function () {
		if (!workerUrl) {
			var code = '(' + UntarScope.toString() + ')(true)\n\n';
			var blob = new Blob([code], { type: 'application/javascript' });
			workerUrl = URL.createObjectURL(blob);
		}
		return workerUrl;
	};
	function UntarWorker(filenamePrefix) {
		this._requestId = 0;
		this._pendingRequests = {};
		this._filenamePrefix = filenamePrefix;
		this._worker = new Worker(getWorkerUrl());
		this._worker.addEventListener('message', this._onMessage.bind(this));
	}
	UntarWorker.prototype._onMessage = function (e) {
		var id = e.data.id;
		if (! this._pendingRequests[id]) return;
		var callback = this._pendingRequests[id];
		delete this._pendingRequests[id];
		if (e.data.error) {
			callback(e.data.error);
		} else {
			var arrayBuffer = e.data.arrayBuffer;
			for (var i = 0, len = e.data.files.length; i < len; i++) {
				var file = e.data.files[i];
				var blob = new Blob([arrayBuffer.slice(file.start, file.start + file.size)]);
				file.url = URL.createObjectURL(blob);
			}
			callback(null, e.data.files);
		}
	};
	UntarWorker.prototype.untar = function (arrayBuffer, callback) {
		var id = this._requestId++;
		this._pendingRequests[id] = callback;
		this._worker.postMessage({
			id: id,
			prefix: this._filenamePrefix,
			arrayBuffer: arrayBuffer
		}, [arrayBuffer]);
	};
	UntarWorker.prototype.hasPendingRequests = function () {
		for (var key in this._pendingRequests) {
			return true;
		}
		return false;
	};
	UntarWorker.prototype.destroy = function () {
		if (this._worker) {
			this._worker.terminate();
			this._worker = null;
			this._pendingRequests = null;
		}
	};
	UntarScope();

	function BundleHandler(assets) {
		this._assets = assets;
		this._worker = null;
		this.retryRequests = false;
	}
	Object.assign(BundleHandler.prototype, {
		load: function (url, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			var self = this;
			http.get(url.load, {
				responseType: Http.ResponseType.ARRAY_BUFFER,
				retry: this.retryRequests
			}, function (err, response) {
				if (! err) {
					try {
						self._untar(response, callback);
					} catch (ex) {
						callback("Error loading bundle resource " + url.original + ": " + ex);
					}
				} else {
					callback("Error loading bundle resource " + url.original + ": " + err);
				}
			});
		},
		_untar: function (response, callback) {
			var self = this;
			if (platform.workers) {
				if (!self._worker) {
					self._worker = new UntarWorker(self._assets.prefix);
				}
				self._worker.untar(response, function (err, files) {
					callback(err, files);
					if (! self._worker.hasPendingRequests()) {
						self._worker.destroy();
						self._worker = null;
					}
				});
			} else {
				var archive = new Untar(response);
				var files = archive.untar(self._assets.prefix);
				callback(null, files);
			}
		},
		open: function (url, data) {
			return new Bundle(data);
		},
		patch: function (asset, assets) {
		}
	});

	function ContainerResource(data) {
		this.data = data;
		this.model = null;
		this.materials = [];
		this.textures = [];
		this.animations = [];
		this.registry = null;
	}
	Object.assign(ContainerResource.prototype, {
		destroy: function () {
			var registry = this.registry;
			var destroyAsset = function (asset) {
				registry.remove(asset);
				asset.unload();
			};
			var destroyAssets = function (assets) {
				assets.forEach(function (asset) {
					destroyAsset(asset);
				});
			};
			if (this.animations) {
				destroyAssets(this.animations);
				this.animations = null;
			}
			if (this.textures) {
				destroyAssets(this.textures);
				this.textures = null;
			}
			if (this.materials) {
				destroyAssets(this.materials);
				this.materials = null;
			}
			if (this.model) {
				destroyAsset(this.model);
				this.model = null;
			}
			this.data = null;
			this.assets = null;
		}
	});
	function ContainerHandler(device, defaultMaterial) {
		this._device = device;
		this._defaultMaterial = defaultMaterial;
	}
	Object.assign(ContainerHandler.prototype, {
		_getUrlWithoutParams: function (url) {
			return url.indexOf('?') >= 0 ? url.split('?')[0] : url;
		},
		load: function (url, callback, asset) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			var options = {
				responseType: Http.ResponseType.ARRAY_BUFFER,
				retry: false
			};
			var self = this;
			var parseData = function (arrayBuffer) {
				GlbParser.parseAsync(self._getUrlWithoutParams(url.original),
									 path.extractPath(url.load),
									 arrayBuffer,
									 self._device,
									 asset.registry,
									 asset.options,
									 function (err, result) {
										 if (err) {
											 callback(err);
										 } else {
											 callback(null, new ContainerResource(result));
										 }
									 });
			};
			if (asset && asset.file && asset.file.contents) {
				parseData(asset.file.contents);
			} else {
				http.get(url.load, options, function (err, response) {
					if (!callback)
						return;
					if (err) {
						callback("Error loading model: " + url.original + " [" + err + "]");
					} else {
						parseData(response);
					}
				});
			}
		},
		open: function (url, data, asset) {
			return data;
		},
		patch: function (asset, assets) {
			var createAsset = function (type, resource, index) {
				var subAsset = new Asset(asset.name + '/' + type + '/' + index, type, {
					url: ''
				});
				subAsset.resource = resource;
				subAsset.loaded = true;
				assets.add(subAsset);
				return subAsset;
			};
			var container = asset.resource;
			var data = container.data;
			var i;
			var model = (data.meshes.length === 0) ? null : createAsset('model', GlbParser.createModel(data, this._defaultMaterial), 0);
			var materials = [];
			for (i = 0; i < data.materials.length; ++i) {
				materials.push(createAsset('material', data.materials[i], i));
			}
			var animations = [];
			for (i = 0; i < data.animations.length; ++i) {
				animations.push(createAsset('animation', data.animations[i], i));
			}
			container.data = null;
			container.model = model;
			container.materials = materials;
			container.textures = data.textures;
			container.animations = animations;
			container.registry = assets;
		}
	});

	function CssHandler() {
		this.retryRequests = false;
	}
	Object.assign(CssHandler.prototype, {
		load: function (url, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			http.get(url.load, {
				retry: this.retryRequests
			}, function (err, response) {
				if (!err) {
					callback(null, response);
				} else {
					callback("Error loading css resource: " + url.original + " [" + err + "]");
				}
			});
		},
		open: function (url, data) {
			return data;
		},
		patch: function (asset, assets) {
		}
	});
	function createStyle(cssString) {
		var result = document.createElement('style');
		result.type = 'text/css';
		if (result.styleSheet) {
			result.styleSheet.cssText = cssString;
		} else {
			result.appendChild(document.createTextNode(cssString));
		}
		return result;
	}

	function CubemapHandler(device, assets, loader) {
		this._device = device;
		this._registry = assets;
		this._loader = loader;
	}
	Object.assign(CubemapHandler.prototype, {
		load: function (url, callback, asset) {
			this.loadAssets(asset, callback);
		},
		open: function (url, data, asset) {
			return asset ? asset.resource : null;
		},
		patch: function (asset, registry) {
			this.loadAssets(asset, function (err, result) {
				if (err) {
					registry.fire('error', asset);
					registry.fire('error:' + asset.id, err, asset);
					asset.fire('error', asset);
				}
			});
		},
		getAssetIds: function (cubemapAsset) {
			var result = [];
			result[0] = cubemapAsset.file;
			if ((cubemapAsset.loadFaces || !cubemapAsset.file) && cubemapAsset.data && cubemapAsset.data.textures) {
				for (var i = 0; i < 6; ++i) {
					result[i + 1] = cubemapAsset.data.textures[i];
				}
			} else {
				result[1] = result[2] = result[3] = result[4] = result[5] = result[6] = null;
			}
			return result;
		},
		compareAssetIds: function (assetIdA, assetIdB) {
			if (assetIdA && assetIdB) {
				if (parseInt(assetIdA, 10) === assetIdA || typeof assetIdA === "string") {
					return assetIdA === assetIdB;
				}
				return assetIdA.url === assetIdB.url;
			}
			return (assetIdA !== null) === (assetIdB !== null);
		},
		update: function (cubemapAsset, assetIds, assets) {
			var assetData = cubemapAsset.data || {};
			var oldAssets = cubemapAsset._handlerState.assets;
			var oldResources = cubemapAsset._resources;
			var tex, mip, i;
			var resources = [null, null, null, null, null, null, null];
			var getType = function () {
				if (assetData.hasOwnProperty('type')) {
					return assetData.type;
				}
				if (assetData.hasOwnProperty('rgbm')) {
					return assetData.rgbm ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT;
				}
				return null;
			};
			if (!cubemapAsset.loaded || assets[0] !== oldAssets[0]) {
				if (assets[0]) {
					tex = assets[0].resource;
					for (i = 0; i < 6; ++i) {
						var prelitLevels = [tex._levels[i]];
						if (i === 0 && this._device.useTexCubeLod) {
							for (mip = 1; mip < tex._levels.length; ++mip) {
								prelitLevels[mip] = tex._levels[mip];
							}
						}
						var prelit = new Texture(this._device, {
							name: cubemapAsset.name + '_prelitCubemap' + (tex.width >> i),
							cubemap: true,
							type: getType() || tex.type,
							width: tex.width >> i,
							height: tex.height >> i,
							format: tex.format,
							levels: prelitLevels,
							fixCubemapSeams: true,
							addressU: ADDRESS_CLAMP_TO_EDGE,
							addressV: ADDRESS_CLAMP_TO_EDGE
						});
						resources[i + 1] = prelit;
					}
				}
			} else {
				resources[1] = oldResources[1] || null;
				resources[2] = oldResources[2] || null;
				resources[3] = oldResources[3] || null;
				resources[4] = oldResources[4] || null;
				resources[5] = oldResources[5] || null;
				resources[6] = oldResources[6] || null;
			}
			var faceAssets = assets.slice(1);
			if (!cubemapAsset.loaded || !this.cmpArrays(faceAssets, oldAssets.slice(1))) {
				if (faceAssets.indexOf(null) === -1) {
					var faceTextures = faceAssets.map(function (asset) {
						return asset.resource;
					});
					var faceLevels = [];
					for (mip = 0; mip < faceTextures[0]._levels.length; ++mip) {
						faceLevels.push(faceTextures.map(function (faceTexture) {
							return faceTexture._levels[mip];
						}));
					}
					var faces = new Texture(this._device, {
						name: cubemapAsset.name + '_faces',
						cubemap: true,
						type: getType() || faceTextures[0].type,
						width: faceTextures[0].width,
						height: faceTextures[0].height,
						format: faceTextures[0].format,
						levels: faceLevels,
						minFilter: assetData.hasOwnProperty('minFilter') ? assetData.minFilter : faceTextures[0].minFilter,
						magFilter: assetData.hasOwnProperty('magFilter') ? assetData.magFilter : faceTextures[0].magFilter,
						anisotropy: assetData.hasOwnProperty('anisotropy') ? assetData.anisotropy : 1,
						addressU: ADDRESS_CLAMP_TO_EDGE,
						addressV: ADDRESS_CLAMP_TO_EDGE,
						fixCubemapSeams: !!assets[0]
					});
					resources[0] = faces;
				}
			} else {
				resources[0] = oldResources[0] || null;
			}
			if (!this.cmpArrays(resources, oldResources)) {
				cubemapAsset.resources = resources;
				cubemapAsset._handlerState.assetIds = assetIds;
				cubemapAsset._handlerState.assets = assets;
				for (i = 0; i < oldResources.length; ++i) {
					if (oldResources[i] !== null && resources.indexOf(oldResources[i]) === -1) {
						oldResources[i].destroy();
					}
				}
			}
			for (i = 0; i < oldAssets.length; ++i) {
				if (oldAssets[i] !== null && assets.indexOf(oldAssets[i]) === -1) {
					oldAssets[i].unload();
				}
			}
		},
		cmpArrays: function (arr1, arr2) {
			if (arr1.length !== arr2.length) {
				return false;
			}
			for (var i = 0; i < arr1.length; ++i) {
				if (arr1[i] !== arr2[i]) {
					return false;
				}
			}
			return true;
		},
		loadAssets: function (cubemapAsset, callback) {
			if (!cubemapAsset.hasOwnProperty('_handlerState')) {
				cubemapAsset._handlerState = {
					assetIds: [null, null, null, null, null, null, null],
					assets: [null, null, null, null, null, null, null]
				};
			}
			var self = this;
			var assetIds = self.getAssetIds(cubemapAsset);
			var assets = [null, null, null, null, null, null, null];
			var loadedAssetIds = cubemapAsset._handlerState.assetIds;
			var loadedAssets = cubemapAsset._handlerState.assets;
			var registry = self._registry;
			var awaiting = 7;
			var onReady = function (index, asset) {
				assets[index] = asset;
				awaiting--;
				if (awaiting === 0) {
					self.update(cubemapAsset, assetIds, assets);
					callback(null, cubemapAsset.resources);
				}
			};
			var onLoad = function (index, asset) {
				var level0 = asset && asset.resource && asset.resource._levels[0];
				if (level0 && typeof ImageBitmap !== 'undefined' && level0 instanceof ImageBitmap) {
					createImageBitmap(level0, {
						premultiplyAlpha: 'none',
						imageOrientation: 'flipY'
					})
						.then( function (imageBitmap) {
							asset.resource._levels[0] = imageBitmap;
							onReady(index, asset);
						})
						.catch( function (e) {
							callback(e);
						});
				} else {
					onReady(index, asset);
				}
			};
			var onError = function (index, err, asset) {
				callback(err);
			};
			var processTexAsset = function (index, texAsset) {
				if (texAsset.loaded) {
					onLoad(index, texAsset);
				} else {
					registry.once('load:' + texAsset.id, onLoad.bind(self, index));
					registry.once('error:' + texAsset.id, onError.bind(self, index));
					if (!texAsset.loading) {
						registry.load(texAsset);
					}
				}
			};
			var texAsset;
			for (var i = 0; i < 7; ++i) {
				var assetId = assetIds[i];
				if (!assetId) {
					onReady(i, null);
				} else if (self.compareAssetIds(assetId, loadedAssetIds[i])) {
					onReady(i, loadedAssets[i]);
				} else if (parseInt(assetId, 10) === assetId) {
					texAsset = registry.get(assetId);
					if (texAsset) {
						processTexAsset(i, texAsset);
					} else {
						setTimeout(function (index, assetId_) {
							var texAsset = registry.get(assetId_);
							if (texAsset) {
								processTexAsset(index, texAsset);
							} else {
								onError(index, "failed to find dependent cubemap asset=" + assetId_);
							}
						}.bind(null, i, assetId));
					}
				} else {
					var file = (typeof assetId === "string") ? {
						url: assetId,
						filename: assetId
					} : assetId;
					texAsset = new Asset(cubemapAsset.name + "_part_" + i, "texture", file);
					registry.add(texAsset);
					registry.once('load:' + texAsset.id, onLoad.bind(self, i));
					registry.once('error:' + texAsset.id, onError.bind(self, i));
					registry.load(texAsset);
				}
			}
		}
	});

	function FolderHandler() {}
	Object.assign(FolderHandler.prototype, {
		load: function (url, callback) {
			callback(null, null);
		},
		open: function (url, data) {
			return data;
		}
	});

	var FONT_MSDF = 'msdf';
	var FONT_BITMAP = 'bitmap';
	function Font(textures, data) {
		this.type = data ? data.type || FONT_MSDF : FONT_MSDF;
		this.em = 1;
		this.textures = textures;
		this.intensity = 0.0;
		this._data = null;
		this.data = data;
	}
	Object.defineProperty(Font.prototype, "data", {
		get: function () {
			return this._data;
		},
		set: function (value){
			this._data = value;
			if (!value)
				return;
			if (this._data.intensity !== undefined) {
				this.intensity = this._data.intensity;
			}
			if (!this._data.info)
				this._data.info = {};
			if (!this._data.version || this._data.version < 2) {
				this._data.info.maps = [{
					width: this._data.info.width,
					height: this._data.info.height
				}];
				if (this._data.chars) {
					for (var key in this._data.chars) {
						this._data.chars[key].map = 0;
					}
				}
			}
		}
	});

	function upgradeDataSchema(data) {
		if (data.version < 3) {
			if (data.version < 2) {
				data.info.maps = data.info.maps || [{
					width: data.info.width,
					height: data.info.height
				}];
			}
			data.chars = Object.keys(data.chars || {}).reduce(function (newChars, key) {
				var existing = data.chars[key];
				var newKey = existing.letter !== undefined ? existing.letter : string.fromCodePoint(key);
				if (data.version < 2) {
					existing.map = existing.map || 0;
				}
				newChars[newKey] = existing;
				return newChars;
			}, {});
			data.version = 3;
		}
		return data;
	}
	function FontHandler(loader) {
		this._loader = loader;
		this.retryRequests = false;
	}
	Object.assign(FontHandler.prototype, {
		load: function (url, callback, asset) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			var self = this;
			if (path.getExtension(url.original) === '.json') {
				http.get(url.load, {
					retry: this.retryRequests
				}, function (err, response) {
					var data = upgradeDataSchema(response);
					if (!err) {
						self._loadTextures(url.load.replace('.json', '.png'), data, function (err, textures) {
							if (err) return callback(err);
							callback(null, {
								data: data,
								textures: textures
							});
						});
					} else {
						callback("Error loading font resource: " + url.original + " [" + err + "]");
					}
				});
			} else {
				if (asset && asset.data) {
					asset.data = upgradeDataSchema(asset.data);
				}
				this._loadTextures(url.load, asset && asset.data, callback);
			}
		},
		_loadTextures: function (url, data, callback) {
			var numTextures = data.info.maps.length;
			var numLoaded = 0;
			var error = null;
			var textures = new Array(numTextures);
			var loader = this._loader;
			var loadTexture = function (index) {
				var onLoaded = function (err, texture) {
					if (error) return;
					if (err) {
						error = err;
						return callback(err);
					}
					texture.upload();
					textures[index] = texture;
					numLoaded++;
					if (numLoaded === numTextures) {
						callback(null, textures);
					}
				};
				if (index === 0) {
					loader.load(url, "texture", onLoaded);
				} else {
					loader.load(url.replace('.png', index + '.png'), "texture", onLoaded);
				}
			};
			for (var i = 0; i < numTextures; i++)
				loadTexture(i);
		},
		open: function (url, data, asset) {
			var font;
			if (data.textures) {
				font = new Font(data.textures, data.data);
			} else {
				font = new Font(data, null);
			}
			return font;
		},
		patch: function (asset, assets) {
			var font = asset.resource;
			if (!font.data && asset.data) {
				font.data = asset.data;
			} else if (!asset.data && font.data) {
				asset.data = font.data;
			}
			if (asset.data) {
				asset.data = upgradeDataSchema(asset.data);
			}
		}
	});

	function AssetListLoader(assetList, assetRegistry) {
		EventHandler.call(this);
		this._assets = [];
		this._registry = assetRegistry;
		this._loaded = false;
		this._count = 0;
		this._total = 0;
		this._failed = [];
		this._waitingAssets = [];
		if (assetList.length && assetList[0] instanceof Asset) {
			this._assets = assetList;
		} else {
			for (var i = 0; i < assetList.length; i++) {
				var asset = assetRegistry.get(assetList[i]);
				if (asset) {
					this._assets.push(asset);
				} else {
					this._waitForAsset(assetList[i]);
					this._total++;
				}
			}
		}
	}
	AssetListLoader.prototype = Object.create(EventHandler.prototype);
	AssetListLoader.prototype.constructor = AssetListLoader;
	AssetListLoader.prototype.destroy = function () {
		var self = this;
		this._registry.off("load", this._onLoad);
		this._registry.off("error", this._onError);
		this._waitingAssets.forEach(function (id) {
			self._registry.off("add:" + id, this._onAddAsset);
		});
		this.off("progress");
		this.off("load");
	};
	AssetListLoader.prototype.load = function (done, scope) {
		var i = 0;
		var l = this._assets.length;
		var asset;
		this._count = 0;
		this._failed = [];
		this._callback = done;
		this._scope = scope;
		this._registry.on("load", this._onLoad, this);
		this._registry.on("error", this._onError, this);
		for (i = 0; i < l; i++) {
			asset = this._assets[i];
			if (!asset.loading && !asset.loaded) {
				this._registry.load(asset);
				this._total++;
			}
		}
	};
	AssetListLoader.prototype.ready = function (done, scope) {
		scope = scope || this;
		if (this._loaded) {
			done.call(scope, this._assets);
		} else {
			this.once("load", function (assets) {
				done.call(scope, assets);
			});
		}
	};
	AssetListLoader.prototype._loadingComplete = function () {
		this._loaded = true;
		this._registry.off("load", this._onLoad, this);
		this._registry.off("error", this._onError, this);
		if (this._failed && this._failed.length) {
			if (this._callback) {
				this._callback.call(this._scope, "Failed to load some assets", this._failed);
			}
			this.fire("error", this._failed);
		} else {
			if (this._callback) {
				this._callback.call(this._scope);
			}
			this.fire("load", this._assets);
		}
	};
	AssetListLoader.prototype._onLoad = function (asset) {
		var self = this;
		if (this._assets.indexOf(asset) >= 0) {
			this._count++;
			this.fire("progress", asset);
		}
		if (this._count === this._total) {
			setTimeout(function () {
				self._loadingComplete(self._failed);
			}, 0);
		}
	};
	AssetListLoader.prototype._onError = function (err, asset) {
		var self = this;
		if (this._assets.indexOf(asset) >= 0) {
			this._count++;
			this._failed.push(asset);
		}
		if (this._count === this._total) {
			setTimeout(function () {
				self._loadingComplete(self._failed);
			}, 0);
		}
	};
	AssetListLoader.prototype._onAddAsset = function (asset) {
		var index = this._waitingAssets.indexOf(asset);
		if (index >= 0) {
			this._waitingAssets.splice(index, 1);
		}
		this._assets.push(asset);
		var i;
		var l = this._assets.length;
		for (i = 0; i < l; i++) {
			asset = this._assets[i];
			if (!asset.loading && !asset.loaded) {
				this._registry.load(asset);
			}
		}
	};
	AssetListLoader.prototype._waitForAsset = function (assetId) {
		this._waitingAssets.push(assetId);
		this._registry.once('add:' + assetId, this._onAddAsset, this);
	};

	var TemplateUtils = {
		waitForTemplatesInScene: function (data, assets, callback) {
			if (data.collapsedInstances) {
				var entities = TemplateUtils._getAllCollapsedEntities(data);
				TemplateUtils.waitForTemplateAssets(
					entities,
					assets,
					callback,
					data);
			} else {
				callback(null, data);
			}
		},
		waitForTemplateAssets: function (entities, assets, callback, response) {
			var templateIds = TemplateUtils._extractTemplateIds(entities);
			var loader = new AssetListLoader(templateIds, assets);
			loader.load(function (err) {
				callback(err, response);
			});
		},
		_getAllCollapsedEntities: function (data) {
			var entities = {};
			data.collapsedInstances.forEach(function (h) {
				Object.assign(entities, h.instanceEntities);
			});
			return entities;
		},
		_extractTemplateIds: function (entities) {
			var templateIds = [];
			for (var guid in entities) {
				var id = entities[guid].template_id;
				if (id) {
					templateIds.push(id);
				}
			}
			return templateIds;
		},
		expandTemplateEntities: function (app, entities) {
			var result = {};
			for (var guid in entities) {
				var h = entities[guid];
				result[guid] = h.collapsed_entity ?
					TemplateUtils.expandEntity(app, h) : h;
			}
			return result;
		},
		expandEntity: function (app, data) {
		}
	};

	function SceneParser(app, isTemplate) {
		this._app = app;
		this._isTemplate = isTemplate;
	}
	Object.assign(SceneParser.prototype, {
		parse: function (data) {
			var entities = {};
			var id, i;
			var parent = null;
			if (data.collapsedInstances) {
				this._addCollapsedToEntities(this._app, data);
			}
			for (id in data.entities) {
				entities[id] = this._createEntity(data.entities[id]);
				if (data.entities[id].parent === null) {
					parent = entities[id];
				}
			}
			for (id in data.entities) {
				var l = data.entities[id].children.length;
				for (i = 0; i < l; i++) {
					var resource_id = data.entities[id].children[i];
					if (entities[resource_id]) {
						entities[id].addChild(entities[resource_id]);
					}
				}
			}
			this._openComponentData(parent, data.entities);
			return parent;
		},
		_createEntity: function (data) {
			var entity = new Entity();
			var p = data.position;
			var r = data.rotation;
			var s = data.scale;
			entity.name = data.name;
			entity.setGuid(data.resource_id);
			entity.setLocalPosition(p[0], p[1], p[2]);
			entity.setLocalEulerAngles(r[0], r[1], r[2]);
			entity.setLocalScale(s[0], s[1], s[2]);
			entity._enabled = data.enabled !== undefined ? data.enabled : true;
			if (!this._isTemplate) {
				entity._enabledInHierarchy = entity._enabled;
			}
			entity.template = data.template;
			if (data.tags) {
				for (var i = 0; i < data.tags.length; i++) {
					entity.tags.add(data.tags[i]);
				}
			}
			if (data.labels) {
				data.labels.forEach(function (label) {
					entity.addLabel(label);
				});
			}
			return entity;
		},
		_openComponentData: function (entity, entities) {
			var systemsList = this._app.systems.list;
			var i, len = systemsList.length;
			var entityData = entities[entity.getGuid()];
			for (i = 0; i < len; i++) {
				var system = systemsList[i];
				var componentData = entityData.components[system.id];
				if (componentData) {
					system.addComponent(entity, componentData);
				}
			}
			len = entityData.children.length;
			var children = entity._children;
			for (i = 0; i < len; i++) {
				children[i] = this._openComponentData(children[i], entities);
			}
			return entity;
		},
		_addCollapsedToEntities: function (app, data) {
			data.collapsedInstances.forEach(function (h) {
				var expanded = TemplateUtils.expandTemplateEntities(
					app, h.instanceEntities);
				Object.assign(data.entities, expanded);
			});
		}
	});

	function HierarchyHandler(app) {
		this._app = app;
		this.retryRequests = false;
	}
	Object.assign(HierarchyHandler.prototype, {
		load: function (url, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			var assets = this._app.assets;
			http.get(url.load, {
				retry: this.retryRequests
			}, function (err, response) {
				if (!err) {
					TemplateUtils.waitForTemplatesInScene(
						response,
						assets,
						callback);
				} else {
					var errMsg = 'Error while loading scene ' + url.original;
					if (err.message) {
						errMsg += ': ' + err.message;
						if (err.stack) {
							errMsg += '\n' + err.stack;
						}
					} else {
						errMsg += ': ' + err;
					}
					callback(errMsg);
				}
			});
		},
		open: function (url, data) {
			this._app.systems.script.preloading = true;
			var parser = new SceneParser(this._app, false);
			var parent = parser.parse(data);
			this._app.systems.script.preloading = false;
			return parent;
		}
	});

	function HtmlHandler() {
		this.retryRequests = false;
	}
	Object.assign(HtmlHandler.prototype, {
		load: function (url, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			http.get(url.load, {
				retry: this.retryRequests
			}, function (err, response) {
				if (!err) {
					callback(null, response);
				} else {
					callback("Error loading html resource: " + url.original + " [" + err + "]");
				}
			});
		},
		open: function (url, data) {
			return data;
		},
		patch: function (asset, assets) {
		}
	});

	function JsonHandler() {
		this.retryRequests = false;
	}
	Object.assign(JsonHandler.prototype, {
		load: function (url, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			var options = {
				retry: this.retryRequests
			};
			if (url.load.startsWith('blob:')) {
				options.responseType = Http.ResponseType.JSON;
			}
			http.get(url.load, options, function (err, response) {
				if (!err) {
					callback(null, response);
				} else {
					callback("Error loading JSON resource: " + url.original + " [" + err + "]");
				}
			});
		},
		open: function (url, data) {
			return data;
		},
		patch: function (asset, assets) {
		}
	});

	var standardMaterialParameterTypes = {
		name: 'string',
		chunks: 'chunks',
		mappingFormat: 'string',
		_engine: 'boolean',
		ambient: 'rgb',
		ambientTint: 'boolean',
		aoVertexColor: 'boolean',
		aoVertexColorChannel: 'string',
		aoMap: 'texture',
		aoMapChannel: 'string',
		aoMapUv: 'number',
		aoMapTiling: 'vec2',
		aoMapOffset: 'vec2',
		diffuse: 'rgb',
		diffuseTint: 'boolean',
		diffuseVertexColor: 'boolean',
		diffuseVertexColorChannel: 'string',
		diffuseMap: 'texture',
		diffuseMapChannel: 'string',
		diffuseMapUv: 'number',
		diffuseMapTiling: 'vec2',
		diffuseMapOffset: 'vec2',
		diffuseDetailMap: 'texture',
		diffuseDetailMapChannel: 'string',
		diffuseDetailMapUv: 'number',
		diffuseDetailMapTiling: 'vec2',
		diffuseDetailMapOffset: 'vec2',
		diffuseDetailMode: 'string',
		specular: 'rgb',
		specularTint: 'boolean',
		specularVertexColor: 'boolean',
		specularVertexColorChannel: 'string',
		specularMap: 'texture',
		specularMapChannel: 'string',
		specularMapUv: 'number',
		specularMapTiling: 'vec2',
		specularMapOffset: 'vec2',
		specularAntialias: 'boolean',
		occludeSpecular: 'enum:occludeSpecular',
		useMetalness: 'boolean',
		metalness: 'number',
		enableGGXSpecular: 'boolean',
		anisotropy: 'number',
		clearCoat: 'number',
		clearCoatGlossiness: 'number',
		metalnessTint: 'boolean',
		metalnessVertexColor: 'boolean',
		metalnessVertexColorChannel: 'string',
		metalnessMap: 'texture',
		metalnessMapChannel: 'string',
		metalnessMapUv: 'number',
		metalnessMapTiling: 'vec2',
		metalnessMapOffset: 'vec2',
		conserveEnergy: 'boolean',
		shininess: 'number',
		glossVertexColor: 'boolean',
		glossVertexColorChannel: 'string',
		glossMap: 'texture',
		glossMapChannel: 'string',
		glossMapUv: 'number',
		glossMapTiling: 'vec2',
		glossMapOffset: 'vec2',
		fresnelModel: 'number',
		emissive: 'rgb',
		emissiveTint: 'boolean',
		emissiveVertexColor: 'boolean',
		emissiveVertexColorChannel: 'string',
		emissiveMap: 'texture',
		emissiveMapChannel: 'string',
		emissiveMapUv: 'number',
		emissiveMapTiling: 'vec2',
		emissiveMapOffset: 'vec2',
		emissiveIntensity: 'number',
		normalMap: 'texture',
		normalMapTiling: 'vec2',
		normalMapOffset: 'vec2',
		normalMapUv: 'number',
		bumpiness: 'number',
		normalDetailMap: 'texture',
		normalDetailMapTiling: 'vec2',
		normalDetailMapOffset: 'vec2',
		normalDetailMapUv: 'number',
		normalDetailMapBumpiness: 'number',
		heightMap: 'texture',
		heightMapChannel: 'string',
		heightMapUv: 'number',
		heightMapTiling: 'vec2',
		heightMapOffset: 'vec2',
		heightMapFactor: 'number',
		alphaToCoverage: 'boolean',
		alphaTest: 'number',
		opacity: 'number',
		opacityVertexColor: 'boolean',
		opacityVertexColorChannel: 'string',
		opacityMap: 'texture',
		opacityMapChannel: 'string',
		opacityMapUv: 'number',
		opacityMapTiling: 'vec2',
		opacityMapOffset: 'vec2',
		reflectivity: 'number',
		refraction: 'number',
		refractionIndex: 'number',
		sphereMap: 'texture',
		cubeMap: 'cubemap',
		cubeMapProjection: 'number',
		cubeMapProjectionBox: 'boundingbox',
		lightVertexColor: 'boolean',
		lightVertexColorChannel: 'string',
		lightMap: 'texture',
		lightMapChannel: 'string',
		lightMapUv: 'number',
		lightMapTiling: 'vec2',
		lightMapOffset: 'vec2',
		depthTest: 'boolean',
		depthWrite: 'boolean',
		depthBias: 'number',
		slopeDepthBias: 'number',
		cull: 'enum:cull',
		blendType: 'enum:blendType',
		shadingModel: 'enum:shadingModel',
		useFog: 'boolean',
		useLighting: 'boolean',
		useSkybox: 'boolean',
		useGammaTonemap: 'boolean',
		prefilteredCubeMap128: 'texture',
		prefilteredCubeMap64: 'texture',
		prefilteredCubeMap32: 'texture',
		prefilteredCubeMap16: 'texture',
		prefilteredCubeMap8: 'texture',
		prefilteredCubeMap4: 'texture'
	};
	var key, type$1;
	var standardMaterialTextureParameters = [];
	for (key in standardMaterialParameterTypes) {
		type$1 = standardMaterialParameterTypes[key];
		if (type$1 === 'texture') {
			standardMaterialTextureParameters.push(key);
		}
	}
	var standardMaterialCubemapParameters = [];
	for (key in standardMaterialParameterTypes) {
		type$1 = standardMaterialParameterTypes[key];
		if (type$1 === 'cubemap') {
			standardMaterialCubemapParameters.push(key);
		}
	}

	function AssetReference(propertyName, parent, registry, callbacks, scope) {
		this.propertyName = propertyName;
		this.parent = parent;
		this._scope = scope;
		this._registry = registry;
		this.id = null;
		this.url = null;
		this.asset = null;
		this._onAssetLoad = callbacks.load;
		this._onAssetAdd = callbacks.add;
		this._onAssetRemove = callbacks.remove;
	}
	AssetReference.prototype._bind = function () {
		if (this.id) {
			if (this._onAssetLoad) this._registry.on("load:" + this.id, this._onLoad, this);
			if (this._onAssetAdd) this._registry.once("add:" + this.id, this._onAdd, this);
			if (this._onAssetRemove) this._registry.on("remove:" + this.id, this._onRemove, this);
		}
		if (this.url) {
			if (this._onAssetLoad) this._registry.on("load:url:" + this.url, this._onLoad, this);
			if (this._onAssetAdd) this._registry.once("add:url:" + this.url, this._onAdd, this);
			if (this._onAssetRemove) this._registry.on("remove:url:" + this.url, this._onRemove, this);
		}
	};
	AssetReference.prototype._unbind = function () {
		if (this.id) {
			if (this._onAssetLoad) this._registry.off('load:' + this.id, this._onLoad, this);
			if (this._onAssetAdd) this._registry.off('add:' + this.id, this._onAdd, this);
			if (this._onAssetRemove) this._registry.off('remove:' + this.id, this._onRemove, this);
		}
		if (this.url) {
			if (this._onAssetLoad) this._registry.off('load:' + this.url, this._onLoad, this);
			if (this._onAssetAdd) this._registry.off('add:' + this.url, this._onAdd, this);
			if (this._onAssetRemove) this._registry.off('remove:' + this.url, this._onRemove, this);
		}
	};
	AssetReference.prototype._onLoad = function (asset) {
		this._onAssetLoad.call(this._scope, this.propertyName, this.parent, asset);
	};
	AssetReference.prototype._onAdd = function (asset) {
		this._onAssetAdd.call(this._scope, this.propertyName, this.parent, asset);
	};
	AssetReference.prototype._onRemove = function (asset) {
		this._onAssetRemove.call(this._scope, this.propertyName, this.parent, asset);
	};
	Object.defineProperty(AssetReference.prototype, 'id', {
		get: function () {
			return this._id;
		},
		set: function (value) {
			if (this.url) throw Error("Can't set id and url");
			this._unbind();
			this._id = value;
			this.asset = this._registry.get(this._id);
			this._bind();
		}
	});
	Object.defineProperty(AssetReference.prototype, 'url', {
		get: function () {
			return this._url;
		},
		set: function (value) {
			if (this.id) throw Error("Can't set id and url");
			this._unbind();
			this._url = value;
			this.asset = this._registry.getByUrl(this._url);
			this._bind();
		}
	});

	var PLACEHOLDER_MAP = {
		aoMap: 'white',
		diffuseMap: 'gray',
		specularMap: 'gray',
		metalnessMap: 'black',
		glossMap: 'gray',
		emissiveMap: 'gray',
		normalMap: 'normal',
		heightMap: 'gray',
		opacityMap: 'gray',
		sphereMap: 'gray',
		lightMap: 'white'
	};
	function StandardMaterialBinder(app, parser) {
		this._assets = app.assets;
		this._device = app.graphicsDevice;
		this._parser = parser;
		this._placeholderTextures = null;
	}
	Object.assign(StandardMaterialBinder.prototype, {
		_createPlaceholders: function () {
			this._placeholderTextures = {};
			var textures = {
				white: [255, 255, 255, 255],
				gray: [128, 128, 128, 255],
				black: [0, 0, 0, 255],
				normal: [128, 128, 255, 255]
			};
			for (var key in textures) {
				if (!textures.hasOwnProperty(key))
					continue;
				this._placeholderTextures[key] = new Texture(this._device, {
					width: 2,
					height: 2,
					format: PIXELFORMAT_R8_G8_B8_A8
				});
				this._placeholderTextures[key].name = 'placeholder';
				var pixels = this._placeholderTextures[key].lock();
				for (var i = 0; i < 4; i++) {
					for (var c = 0; c < 4; c++) {
						pixels[i * 4 + c] = textures[key][c];
					}
				}
				this._placeholderTextures[key].unlock();
			}
		},
		onAssetUnload: function (asset) {
			delete asset.data.parameters;
			delete asset.data.chunks;
			delete asset.data.name;
		},
		_assignTexture: function (parameterName, materialAsset, texture) {
			materialAsset.data[parameterName] = texture;
			materialAsset.resource[parameterName] = texture;
		},
		_assignPlaceholderTexture: function (parameterName, materialAsset) {
			if (!this._placeholderTextures) {
				this._createPlaceholders();
			}
			var placeholder = PLACEHOLDER_MAP[parameterName];
			var texture = this._placeholderTextures[placeholder];
			materialAsset.resource[parameterName] = texture;
		},
		_onTextureLoad: function (parameterName, materialAsset, textureAsset) {
			this._assignTexture(parameterName, materialAsset, textureAsset.resource);
			materialAsset.resource.update();
		},
		_onTextureAdd: function (parameterName, materialAsset, textureAsset) {
			this._assets.load(textureAsset);
		},
		_onTextureRemove: function (parameterName, materialAsset, textureAsset) {
			var material = materialAsset.resource;
			if (material[parameterName] === textureAsset.resource) {
				this._assignTexture(parameterName, materialAsset, null);
				material.update();
			}
		},
		_assignCubemap: function (parameterName, materialAsset, textures) {
			materialAsset.data[parameterName] = textures[0];
			if (textures.length === 7) {
				materialAsset.data.prefilteredCubeMap128 = textures[1];
				materialAsset.data.prefilteredCubeMap64 = textures[2];
				materialAsset.data.prefilteredCubeMap32 = textures[3];
				materialAsset.data.prefilteredCubeMap16 = textures[4];
				materialAsset.data.prefilteredCubeMap8 = textures[5];
				materialAsset.data.prefilteredCubeMap4 = textures[6];
			}
		},
		_onCubemapLoad: function (parameterName, materialAsset, cubemapAsset) {
			this._assignCubemap(parameterName, materialAsset, cubemapAsset.resources);
			this._parser.initialize(materialAsset.resource, materialAsset.data);
		},
		_onCubemapAdd: function (parameterName, materialAsset, cubemapAsset) {
			if (materialAsset.data.shadingModel === SPECULAR_PHONG) {
				materialAsset.loadFaces = true;
			}
			this._assets.load(cubemapAsset);
		},
		_onCubemapRemove: function (parameterName, materialAsset, cubemapAsset) {
			var material = materialAsset.resource;
			if (material[parameterName] === cubemapAsset.resource) {
				this._assignCubemap(parameterName, materialAsset, [null, null, null, null, null, null, null]);
				material.update();
			}
		},
		bindAndAssignAssets: function (materialAsset, assets) {
			var data = this._parser.migrate(materialAsset.data);
			var material = materialAsset.resource;
			var pathMapping = (data.mappingFormat === "path");
			var TEXTURES = standardMaterialTextureParameters;
			var i, name, assetReference;
			for (i = 0; i < TEXTURES.length; i++) {
				name = TEXTURES[i];
				assetReference = material._assetReferences[name];
				if (data[name] && !(data[name] instanceof Texture)) {
					if (!assetReference) {
						assetReference = new AssetReference(name, materialAsset, assets, {
							load: this._onTextureLoad,
							add: this._onTextureAdd,
							remove: this._onTextureRemove
						}, this);
						material._assetReferences[name] = assetReference;
					}
					if (pathMapping) {
						assetReference.url = materialAsset.getAbsoluteUrl(data[name]);
					} else {
						assetReference.id = data[name];
					}
					if (assetReference.asset) {
						if (assetReference.asset.resource) {
							this._assignTexture(name, materialAsset, assetReference.asset.resource);
						} else {
							this._assignPlaceholderTexture(name, materialAsset);
						}
						assets.load(assetReference.asset);
					}
				} else {
					if (assetReference) {
						if (pathMapping) {
							assetReference.url = null;
						} else {
							assetReference.id = null;
						}
					}
				}
			}
			var CUBEMAPS = standardMaterialCubemapParameters;
			for (i = 0; i < CUBEMAPS.length; i++) {
				name = CUBEMAPS[i];
				assetReference = material._assetReferences[name];
				if (data[name] && !(data[name] instanceof Texture)) {
					if (!assetReference) {
						assetReference = new AssetReference(name, materialAsset, assets, {
							load: this._onCubemapLoad,
							add: this._onCubemapAdd,
							remove: this._onCubemapRemove
						}, this);
						material._assetReferences[name] = assetReference;
					}
					if (pathMapping) {
						assetReference.url = data[name];
					} else {
						assetReference.id = data[name];
					}
					if (assetReference.asset) {
						if (assetReference.asset.loaded) {
							this._assignCubemap(name, materialAsset, assetReference.asset.resources);
						}
						assets.load(assetReference.asset);
					}
				}
			}
			this._parser.initialize(material, data);
		}
	});

	function StandardMaterialValidator() {
		this.removeInvalid = true;
		this.valid = true;
		this.enumValidators = {
			occludeSpecular: this._createEnumValidator([
				SPECOCC_NONE,
				SPECOCC_AO,
				SPECOCC_GLOSSDEPENDENT
			]),
			cull: this._createEnumValidator([
				CULLFACE_NONE,
				CULLFACE_BACK,
				CULLFACE_FRONT,
				CULLFACE_FRONTANDBACK
			]),
			blendType: this._createEnumValidator([
				BLEND_SUBTRACTIVE,
				BLEND_ADDITIVE,
				BLEND_NORMAL,
				BLEND_NONE,
				BLEND_PREMULTIPLIED,
				BLEND_MULTIPLICATIVE,
				BLEND_ADDITIVEALPHA,
				BLEND_MULTIPLICATIVE2X,
				BLEND_SCREEN,
				BLEND_MIN,
				BLEND_MAX
			]),
			shadingModel: this._createEnumValidator([
				SPECULAR_PHONG,
				SPECULAR_BLINN
			])
		};
	}
	StandardMaterialValidator.prototype.setInvalid = function (key, data) {
		this.valid = false;
		if (this.removeInvalid) {
			delete data[key];
		}
	};
	StandardMaterialValidator.prototype.validate = function (data) {
		var TYPES = standardMaterialParameterTypes;
		var type;
		var i;
		var pathMapping = (data.mappingFormat === "path");
		for (var key in data) {
			type = TYPES[key];
			if (!type) {
				this.valid = false;
				continue;
			}
			if (type.startsWith("enum")) {
				var enumType = type.split(":")[1];
				if (this.enumValidators[enumType]) {
					if (!this.enumValidators[enumType](data[key])) {
						this.setInvalid(key, data);
					}
				}
			} else if (type === 'number') {
				if (typeof(data[key]) !== 'number') {
					this.setInvalid(key, data);
				}
			} else if (type === 'boolean') {
				if (typeof(data[key]) !== 'boolean') {
					this.setInvalid(key, data);
				}
			} else if (type === 'string') {
				if (typeof(data[key]) !== 'string') {
					this.setInvalid(key, data);
				}
			} else if (type === 'vec2') {
				if (!(data[key] instanceof Array && data[key].length === 2)) {
					this.setInvalid(key, data);
				}
			} else if (type === 'rgb') {
				if (!(data[key] instanceof Array && data[key].length === 3)) {
					this.setInvalid(key, data);
				}
			} else if (type === 'texture') {
				if (!pathMapping) {
					if (typeof(data[key]) === 'number' || data[key] === null) ; else if (!(data[key] instanceof Texture)) {
						this.setInvalid(key, data);
					}
				} else {
					if (typeof(data[key]) === 'string' || data[key === null]) ; else if (!(data[key] instanceof Texture)) {
						this.setInvalid(key, data);
					}
				}
			} else if (type === 'boundingbox') {
				if (!(data[key].center && data[key].center instanceof Array && data[key].center.length === 3)) {
					this.setInvalid(key, data);
				}
				if (!(data[key].halfExtents && data[key].halfExtents instanceof Array && data[key].halfExtents.length === 3)) {
					this.setInvalid(key, data);
				}
			} else if (type === 'cubemap') {
				if (typeof(data[key]) === 'number' || data[key] === null || data[key] === undefined) ; else if (!(data[key] instanceof Texture && data[key].cubemap)) {
					this.setInvalid(key, data);
				}
			} else if (type === 'chunks') {
				var chunkNames = Object.keys(data[key]);
				for (i = 0; i < chunkNames.length; i++) {
					if (typeof(data[key][chunkNames[i]]) !== 'string') {
						this.setInvalid(chunkNames[i], data[key]);
					}
				}
			} else {
				console.error("Unknown material type: " + type);
			}
		}
		data.validated = true;
		return this.valid;
	};
	StandardMaterialValidator.prototype._createEnumValidator = function (values) {
		return function (value) {
			return (values.indexOf(value) >= 0);
		};
	};

	function JsonStandardMaterialParser() {
		this._validator = null;
	}
	JsonStandardMaterialParser.prototype.parse = function (input) {
		var migrated = this.migrate(input);
		var validated = this._validate(migrated);
		var material = new StandardMaterial();
		this.initialize(material, validated);
		return material;
	};
	JsonStandardMaterialParser.prototype.initialize = function (material, data) {
		if (!data.validated) {
			if (!this._validator) {
				this._validator = new StandardMaterialValidator();
			}
			this._validator.validate(data);
		}
		if (data.chunks) {
			material.chunks.copy(data.chunks);
		}
		for (var key in data) {
			var type = standardMaterialParameterTypes[key];
			var value = data[key];
			if (type === 'vec2') {
				material[key] = new Vec2(value[0], value[1]);
			} else if (type === 'rgb') {
				material[key] = new Color(value[0], value[1], value[2]);
			} else if (type === 'texture') {
				if (value instanceof Texture) {
					material[key] = value;
				} else if (material[key] instanceof Texture && typeof(value) === 'number' && value > 0) ; else {
					material[key] = null;
				}
			} else if (type === 'cubemap') {
				if (value instanceof Texture) {
					material[key] = value;
				} else if (material[key] instanceof Texture && typeof(value) === 'number' && value > 0) ; else {
					material[key] = null;
				}
			} else if (type === 'boundingbox') {
				var center = new Vec3(value.center[0], value.center[1], value.center[2]);
				var halfExtents = new Vec3(value.halfExtents[0], value.halfExtents[1], value.halfExtents[2]);
				material[key] = new BoundingBox(center, halfExtents);
			} else {
				material[key] = data[key];
			}
		}
		material.update();
	};
	JsonStandardMaterialParser.prototype.migrate = function (data) {
		if (data.shadingModel === undefined) {
			if (data.shader === 'blinn') {
				data.shadingModel = SPECULAR_BLINN;
			} else {
				data.shadingModel = SPECULAR_PHONG;
			}
		}
		if (data.shader) delete data.shader;
		if (data.mapping_format) {
			data.mappingFormat = data.mapping_format;
			delete data.mapping_format;
		}
		var i;
		var RENAMED_PROPERTIES = [
			["bumpMapFactor", "bumpiness"],
			["aoUvSet", "aoMapUv"],
			["aoMapVertexColor", "aoVertexColor"],
			["diffuseMapVertexColor", "diffuseVertexColor"],
			["emissiveMapVertexColor", "emissiveVertexColor"],
			["specularMapVertexColor", "specularVertexColor"],
			["metalnessMapVertexColor", "metalnessVertexColor"],
			["opacityMapVertexColor", "opacityVertexColor"],
			["glossMapVertexColor", "glossVertexColor"],
			["lightMapVertexColor", "lightVertexColor"],
			["diffuseMapTint", "diffuseTint"],
			["specularMapTint", "specularTint"],
			["emissiveMapTint", "emissiveTint"],
			["metalnessMapTint", "metalnessTint"]
		];
		for (i = 0; i < RENAMED_PROPERTIES.length; i++) {
			var _old = RENAMED_PROPERTIES[i][0];
			var _new = RENAMED_PROPERTIES[i][1];
			if (data[_old] !== undefined && !(data[_new] !== undefined)) {
				data[_new] = data[_old];
				delete data[_old];
			}
		}
		var DEPRECATED_PROPERTIES = [
			'fresnelFactor',
			'shadowSampleType'
		];
		for (i = 0; i < DEPRECATED_PROPERTIES.length; i++) {
			var name = DEPRECATED_PROPERTIES[i];
			if (data.hasOwnProperty(name)) {
				delete data[name];
			}
		}
		return data;
	};
	JsonStandardMaterialParser.prototype._validate = function (data) {
		if (!this._validator) {
			this._validator = new StandardMaterialValidator();
		}
		this._validator.validate(data);
		return data;
	};

	var NodeMaterial = function (funcGlsl, declGlsl) {
		Material.call(this);
		this._graphVarAssetReferences = [];
		this._glslAssetReferences = {};
		this._subGraphAssetReferences = [];
		this.graphData = {};
		this.graphData.graphVars = [];
		if (funcGlsl) {
			this.graphData.customFuncGlsl = funcGlsl;
			this.graphData.customDeclGlsl = declGlsl;
			this.genCustomFuncVars();
		} else {
			this.graphData.subGraphs = [];
			this.graphData.connections = [];
		}
		this.shaderVariants = [];
	};
	NodeMaterial.prototype = Object.create(Material.prototype);
	NodeMaterial.prototype.constructor = NodeMaterial;
	Object.assign(NodeMaterial.prototype, {
		clone: function () {
			var clone = new NodeMaterial();
			Material.prototype._cloneInternal.call(this, clone);
			clone.graphData = {};
			clone.graphData.graphVars = this.graphData.graphVars.slice(0);
			clone.graphData.subGraphs = this.graphData.subGraphs.slice(0);
			clone.graphData.connections = this.graphData.connections.slice(0);
			clone.graphData.customDeclGlsl = this.graphData.customDeclGlsl;
			clone.graphData.customFuncGlsl = this.graphData.customFuncGlsl;
			clone.shaderVariants = this.shaderVariants.slice(0);
			return clone;
		},
		updateShaderGraphUniforms: function (mat) {
			for (var n = 0; n < this.graphData.graphVars.length; n++) {
				var graphVar = this.graphData.graphVars[n];
				if (graphVar.name.startsWith('IN_') || (graphVar.name.startsWith('CONST_') && graphVar.type === 'sampler2D')) {
					var chunkId = '_' + this.id;
					switch (graphVar.type) {
						case 'sampler2D':
							mat.setParameter(graphVar.name + chunkId, graphVar.valueTex);
							break;
						case 'float':
							mat.setParameter(graphVar.name + chunkId, graphVar.valueX);
							break;
						case 'vec2':
							mat.setParameter(graphVar.name + chunkId, [graphVar.valueX, graphVar.valueY]);
							break;
						case 'vec3':
							mat.setParameter(graphVar.name + chunkId, [graphVar.valueX, graphVar.valueY, graphVar.valueZ]);
							break;
						case 'vec4':
							mat.setParameter(graphVar.name + chunkId, [graphVar.valueX, graphVar.valueY, graphVar.valueZ, graphVar.valueW]);
							break;
					}
				}
			}
		},
		updateUniforms: function (material) {
			this.clearParameters();
			for (var n = 0; n < this.graphData.graphVars.length; n++) {
				var graphVar = this.graphData.graphVars[n];
				if (graphVar.name.startsWith('IN_') || (graphVar.name.startsWith('CONST_') && graphVar.type === 'sampler2D')) {
					var matId = '_' + this.id;
					switch (graphVar.type) {
						case 'sampler2D':
							this.setParameter(graphVar.name + matId, graphVar.valueTex);
							break;
						case 'float':
							this.setParameter(graphVar.name + matId, graphVar.valueX);
							break;
						case 'vec2':
							this.setParameter(graphVar.name + matId, [graphVar.valueX, graphVar.valueY]);
							break;
						case 'vec3':
							this.setParameter(graphVar.name + matId, [graphVar.valueX, graphVar.valueY, graphVar.valueZ]);
							break;
						case 'vec4':
							this.setParameter(graphVar.name + matId, [graphVar.valueX, graphVar.valueY, graphVar.valueZ, graphVar.valueW]);
							break;
					}
				}
			}
			if (this.dirtyShader || !this._scene) {
				this.shader = null;
				this.clearVariants();
			}
		},
		updateShader: function (device, scene, objDefs, staticLightList, pass, sortedLights) {
			if (this.hasValidGraphData()) {
				this.initShader(device);
				this.dirtyShader = false;
			}
			if (this.shaderVariants[pass]) {
				this.shader = this.shaderVariants[pass];
			} else {
				this.shader = this._placeHolderShader;
			}
		},
		setPlaceHolderShader: function (placeHolderMat) {
			this._placeHolderShader = placeHolderMat.shaderVariants[SHADER_FORWARD];
		},
		hasValidGraphData: function (graphRootTime) {
			var i;
			if (this.graphData.graphVars && this.graphData.graphVars.length > 0 && (this.graphData.customFuncGlsl || ( this.graphData.subGraphs && this.graphData.subGraphs.length > 0 && this.graphData.connections))) {
				for (i = 0; i < this.graphData.graphVars.length; i++) {
					if (this.graphData.graphVars[i] && this.graphData.graphVars[i].name && this.graphData.graphVars[i].type) {
						if (this.graphData.graphVars[i].type === 'sampler2D' && !this.graphData.graphVars[i].name.startsWith('OUT_') ) {
							if (!(this.graphData.graphVars[i].valueTex && this.graphData.graphVars[i].valueTex instanceof Texture)) {
								return false;
							}
						} else if (this.graphData.graphVars[i].type === 'float' && !this.graphData.graphVars[i].name.startsWith('OUT_') ) {
							if (!(this.graphData.graphVars[i].valueX != undefined && typeof(this.graphData.graphVars[i].valueX) === 'number')) {
								return false;
							}
						} else if (this.graphData.graphVars[i].type === 'vec2' && !this.graphData.graphVars[i].name.startsWith('OUT_') ) {
							if (!(this.graphData.graphVars[i].valueX != undefined && typeof(this.graphData.graphVars[i].valueX) === 'number' &&
								  this.graphData.graphVars[i].valueY != undefined && typeof(this.graphData.graphVars[i].valueY) === 'number' )) {
								return false;
							}
						} else if (this.graphData.graphVars[i].type === 'vec3' && !this.graphData.graphVars[i].name.startsWith('OUT_') ) {
							if (!(this.graphData.graphVars[i].valueX != undefined && typeof(this.graphData.graphVars[i].valueX) === 'number' &&
								  this.graphData.graphVars[i].valueY != undefined && typeof(this.graphData.graphVars[i].valueY) === 'number' &&
								  this.graphData.graphVars[i].valueZ != undefined && typeof(this.graphData.graphVars[i].valueZ) === 'number' )) {
								return false;
							}
						} else if (this.graphData.graphVars[i].type === 'vec4' && !this.graphData.graphVars[i].name.startsWith('OUT_') ) {
							if (!(this.graphData.graphVars[i].valueX != undefined && typeof(this.graphData.graphVars[i].valueX) === 'number' &&
								  this.graphData.graphVars[i].valueY != undefined && typeof(this.graphData.graphVars[i].valueY) === 'number' &&
								  this.graphData.graphVars[i].valueZ != undefined && typeof(this.graphData.graphVars[i].valueZ) === 'number' &&
								  this.graphData.graphVars[i].valueW != undefined && typeof(this.graphData.graphVars[i].valueW) === 'number' )) {
								return false;
							}
						}
					} else {
						return false;
					}
				}
				if (this.graphData.customFuncGlsl) {
					if (typeof(this.graphData.customFuncGlsl) === 'number') {
						return false;
					}
				} else {
					for (i = 0; i < this.graphData.connections.length; i++) {
						if (this.graphData.connections[i]) {
							if (!(this.graphData.connections[i].srcVarName && this.graphData.connections[i].dstVarName && (this.graphData.connections[i].srcIndex >= 0 || this.graphData.connections[i].dstIndex >= 0 ))) {
								return false;
							}
						} else {
							return false;
						}
					}
					if (!graphRootTime) {
						graphRootTime = new Date().getTime();
						this._tmpRootTime = graphRootTime;
					}
					for (i = 0; i < this.graphData.subGraphs.length; i++) {
						if (this.graphData.subGraphs[i] && this.graphData.subGraphs[i] instanceof NodeMaterial && this.graphData.subGraphs[i].name) {
							if (this.graphData.subGraphs[i]._tmpRootTime === graphRootTime) {
								return false;
							}
							this._tmpRootTime = graphRootTime;
							if (!(this.graphData.subGraphs[i].hasValidGraphData(graphRootTime))) {
								return false;
							}
						} else {
							return false;
						}
					}
				}
				return true;
			}
			return false;
		},
		initShader: function (device) {
			var passes = [SHADER_FORWARD];
			for (var i = 0; i < passes.length; i++) {
				var useSkin = false;
				if (this.meshInstances && this.meshInstances[0] && this.meshInstances[0].skinInstance) {
					useSkin = true;
				}
				var options = {
					skin: useSkin,
					shaderGraph: this,
					pass: passes[i],
					maxPixelLights: (this.maxPixelLights) ? this.maxPixelLights : 4,
					maxVertexLights: (this.maxVertexLights) ? this.maxVertexLights : 8
				};
				var shaderDefinition = programlib.node.createShaderDefinition(device, options);
				this.shaderVariants[passes[i]] = new Shader(device, shaderDefinition);
			}
		},
		_addGraphVar: function (type, name, value) {
			var graphVar;
			if (value instanceof Texture) {
				graphVar = { type: type, name: name, valueTex: value };
			} else if (value instanceof Vec4) {
				graphVar = { type: type, name: name, valueX: value.x, valueY: value.y, valueZ: value.z, valueW: value.w };
			} else if (value instanceof Vec3) {
				graphVar = { type: type, name: name, valueX: value.x, valueY: value.y, valueZ: value.z };
			} else if (value instanceof Vec2) {
				graphVar = { type: type, name: name, valueX: value.x, valueY: value.y };
			} else if (typeof(value) === 'number') {
				graphVar = { type: type, name: name, valueX: value };
			} else {
				graphVar = { type: type, name: name };
			}
			this.graphData.graphVars.push(graphVar);
			return graphVar;
		},
		addInput: function (type, name, value) {
			return this._addGraphVar(type, 'IN_' + name, value);
		},
		addOutput: function (type, name, value) {
			return this._addGraphVar(type, 'OUT_' + name, value);
		},
		addConstant: function (type, value) {
			return this._addGraphVar(type, 'CONST_' + type + '_' + this.graphData.graphVars.length, value);
		},
		genCustomFuncVars: function () {
			var functionString = this.graphData.customFuncGlsl.trim();
			var head = functionString.split(")")[0];
			var retTypeAndFuncName = head.split("(")[0];
			var retType = retTypeAndFuncName.split(" ")[0];
			var params = head.split("(")[1].split(",");
			this.name = retTypeAndFuncName.split(" ")[1];
			if (retType != "void") {
				this.addOutput(retType, 'ret');
			}
			for (var p = 0; p < params.length; p++) {
				var inOrOutAndTypeAndName = params[p].split(" ");
				if (inOrOutAndTypeAndName[0] === "") inOrOutAndTypeAndName.shift();
				if (inOrOutAndTypeAndName[0] === "out") {
					this.addOutput(inOrOutAndTypeAndName[1], inOrOutAndTypeAndName[2]);
				}
				if (inOrOutAndTypeAndName[0] === "in") {
					this.addInput(inOrOutAndTypeAndName[1], inOrOutAndTypeAndName[2]);
				}
			}
		},
		addSubGraph: function (graph) {
			var ret = this.graphData.subGraphs.length;
			this.graphData.subGraphs.push(graph);
			return ret;
		},
		connect: function (srcIndex, srcVarName, dstIndex, dstVarName) {
			var connection = { srcIndex: srcIndex, srcVarName: srcVarName, dstIndex: dstIndex, dstVarName: dstVarName };
			this.graphData.connections.push(connection);
		},
		_getGraphVarValueString: function (graphVar) {
			var ret;
			if (graphVar.type === 'float') {
				ret = 'float(' + graphVar.valueX + ')';
			} else if (graphVar.type === 'vec2') {
				ret = 'vec2(' + graphVar.valueX + ', ' + graphVar.valueY + ')';
			} else if (graphVar.type === 'vec3') {
				ret = 'vec3(' + graphVar.valueX + ', ' + graphVar.valueY + ', ' + graphVar.valueZ + ')';
			} else if (graphVar.type === 'vec4') {
				ret = 'vec4(' + graphVar.valueX + ', ' + graphVar.valueY + ', ' + graphVar.valueZ + ', ' + graphVar.valueW + ')';
			}
			return ret;
		},
		_generateSubGraphCall: function (inNames, outNames) {
			var i;
			var graphVar;
			var callString = '';
			for (i = 0; i < this.graphData.graphVars.length; i++) {
				graphVar = this.graphData.graphVars[i];
				if (graphVar.name.startsWith('OUT_ret')) {
					if (outNames[graphVar.name] != undefined) {
						callString += outNames[graphVar.name] + ' = ';
					}
				}
			}
			if (this.graphData.customFuncGlsl) {
				callString += this.name + '( ';
			} else {
				callString += this.name + '_' + this.id + '( ';
			}
			for (i = 0; i < this.graphData.graphVars.length; i++) {
				graphVar = this.graphData.graphVars[i];
				if (graphVar.name.startsWith('IN_')) {
					if (inNames && inNames[graphVar.name] != undefined) {
						callString += inNames[graphVar.name] + ', ';
					} else {
						callString += graphVar.name + '_' + this.id + ', ';
					}
				}
			}
			for (i = 0; i < this.graphData.graphVars.length; i++) {
				graphVar = this.graphData.graphVars[i];
				if (graphVar.name.startsWith('OUT_') && !graphVar.name.startsWith('OUT_ret')) {
					if (outNames[graphVar.name] != undefined) {
						callString += outNames[graphVar.name] + ', ';
					}
				}
			}
			if (callString.endsWith(', ')) callString = callString.slice(0, -2);
			callString += ' );\n';
			return callString;
		},
		getGraphVarByName: function (name) {
			return this.graphData.graphVars.filter(function (graphVar) {
				return graphVar.name === name;
			})[0];
		},
		_generateSubGraphFuncs: function (depGraphFuncs, depGraphVarList) {
			var i;
			if (this.graphData.subGraphs != undefined) {
				for (i = 0; i < this.graphData.subGraphs.length; i++) {
					var subGraph = this.graphData.subGraphs[i];
					var name = subGraph.name;
					if (!subGraph.graphData.customFuncGlsl) {
						name += '_' + subGraph.id;
					}
					if (depGraphFuncs[name] === undefined) {
						if (subGraph.graphData.graphVars) {
							for (var v = 0; v < subGraph.graphData.graphVars.length; v++) {
								var graphVar = subGraph.graphData.graphVars[v];
								if (graphVar.name.startsWith('IN_') || (graphVar.name.startsWith('CONST_') && graphVar.type === 'sampler2D') ) {
									var depGraphVar = 'uniform ' + graphVar.type + ' ' + graphVar.name + '_' + subGraph.id + ';\n';
									depGraphVarList.push(depGraphVar);
								}
							}
						}
						depGraphFuncs[name] = subGraph._generateFuncGlsl();
						subGraph._generateSubGraphFuncs(depGraphFuncs, depGraphVarList);
					}
				}
			}
		},
		generateRootDeclGlsl: function () {
			var i;
			var graphVar;
			var generatedGlsl = '';
			for (i = 0; i < this.graphData.graphVars.length; i++) {
				var matId = '_' + this.id;
				graphVar = this.graphData.graphVars[i];
				if (graphVar.name.startsWith('IN_') || (graphVar.name.startsWith('CONST_') && graphVar.type === 'sampler2D')) {
					generatedGlsl += 'uniform ' + graphVar.type + ' ' + graphVar.name + matId + ';\n';
				}
			}
			for (i = 0; i < this.graphData.graphVars.length; i++) {
				graphVar = this.graphData.graphVars[i];
				if (graphVar.name.startsWith('CONST_') && (graphVar.type != 'sampler2D' )) {
					generatedGlsl += graphVar.type + ' ' + graphVar.name + ' = ' + this._getGraphVarValueString(graphVar) + ';\n';
				}
			}
			var depGraphFuncs = {};
			var depGraphVarList = [];
			var depName = this.name;
			if (!this.graphData.customFuncGlsl) {
				depName += '_' + this.id;
			}
			depGraphFuncs[depName] = this._generateFuncGlsl();
			this._generateSubGraphFuncs(depGraphFuncs, depGraphVarList);
			for (i = 0; i < depGraphVarList.length; i++) {
				generatedGlsl += depGraphVarList[i];
			}
			var depGraphList = [];
			for (var func in depGraphFuncs) {
				var funcString = '';
				if ( func.endsWith('PS') ) {
					funcString += '#ifdef SG_PS\n';
				} else if ( func.endsWith('VS') ) {
					funcString += '#ifdef SG_VS\n';
				}
				funcString += depGraphFuncs[func] + '\n';
				if ( func.endsWith('PS')  ) {
					funcString += '#endif //SG_PS\n';
				} else if ( func.endsWith('VS') ) {
					funcString += '#endif //SG_VS\n';
				}
				depGraphList.push(funcString);
			}
			var tLen = depGraphList.length;
			for (i = 0; i < tLen; i++) {
				generatedGlsl += depGraphList.pop();
			}
			return generatedGlsl;
		},
		generateRootCallGlsl: function () {
			var generatedGlsl = '';
			var inNames = {};
			var outNames = {};
			for (var i = 0; i < this.graphData.graphVars.length; i++) {
				var matId = '_' + this.id;
				var graphVar = this.graphData.graphVars[i];
				if (graphVar.name.startsWith('IN_')) {
					inNames[graphVar.name] = graphVar.name + matId;
				}
				if (graphVar.name.startsWith('OUT_')) {
					generatedGlsl += graphVar.type + ' ' + graphVar.name + ';\n';
					outNames[graphVar.name] = graphVar.name;
				}
			}
			generatedGlsl += this._generateSubGraphCall(inNames, outNames);
			return generatedGlsl;
		},
		_generateFuncGlsl: function () {
			var i;
			var graphVar;
			var generatedGlsl;
			if (this.graphData.customFuncGlsl) {
				generatedGlsl = this.graphData.customFuncGlsl.trim();
			} else if (this.graphData.subGraphs) {
				var retUsed = false;
				for (i = 0; i < this.graphData.graphVars.length; i++) {
					graphVar = this.graphData.graphVars[i];
					if (graphVar.name.startsWith('OUT_ret')) {
						generatedGlsl = graphVar.type + ' ';
						retUsed = true;
					}
				}
				if (retUsed === true) {
					generatedGlsl += this.name + '_' + this.id + '( ';
				} else {
					generatedGlsl = 'void ' + this.name + '_' + this.id + '( ';
				}
				for (i = 0; i < this.graphData.graphVars.length; i++) {
					graphVar = this.graphData.graphVars[i];
					if (graphVar.name.startsWith('IN_')) {
						generatedGlsl += 'in ' + graphVar.type + ' ' + graphVar.name + ', ';
					}
				}
				for (i = 0; i < this.graphData.graphVars.length; i++) {
					graphVar = this.graphData.graphVars[i];
					if (graphVar.name.startsWith('OUT_')) {
						if (!graphVar.name.startsWith('OUT_ret')) {
							generatedGlsl += 'out ' + graphVar.type + ' ' + graphVar.name + ', ';
						}
					}
				}
				if (generatedGlsl.endsWith(', ')) generatedGlsl = generatedGlsl.slice(0, -2);
				generatedGlsl += ' ) {\n';
				var tmpVarCounter = 0;
				var srcTmpVarMap = [];
				var dstTmpVarMap = [];
				var graphOutputVarTmpVarMap = {};
				var srcConnectedMap = [];
				var dstConnectedMap = [];
				for (i = 0; i < this.graphData.connections.length; i++) {
					var con = this.graphData.connections[i];
					if (con.srcIndex >= 0) {
						var srcSubGraph = this.graphData.subGraphs[con.srcIndex];
						if (srcTmpVarMap[con.srcIndex] === undefined) {
							srcTmpVarMap[con.srcIndex] = {};
							for (var o = 0; o < srcSubGraph.graphData.graphVars.length; o++) {
								var outputVar = srcSubGraph.graphData.graphVars[o];
								if (outputVar.name.startsWith('OUT_')) {
									generatedGlsl += outputVar.type + ' temp_' + outputVar.type + '_' + tmpVarCounter + ';\n';
									srcTmpVarMap[con.srcIndex][outputVar.name] = 'temp_' + outputVar.type + '_' + tmpVarCounter;
									tmpVarCounter++;
								}
							}
						}
					}
					if (con.dstIndex >= 0) {
						if (con.srcIndex >= 0) {
							if (srcConnectedMap[con.srcIndex] === undefined) srcConnectedMap[con.srcIndex] = [];
							srcConnectedMap[con.srcIndex].push(con.dstIndex);
							if (dstConnectedMap[con.dstIndex] === undefined) dstConnectedMap[con.dstIndex] = [];
							dstConnectedMap[con.dstIndex].push(con.srcIndex);
							if (dstTmpVarMap[con.dstIndex] === undefined) dstTmpVarMap[con.dstIndex] = {};
							dstTmpVarMap[con.dstIndex][con.dstVarName] = srcTmpVarMap[con.srcIndex][con.srcVarName];
						} else {
							if (dstTmpVarMap[con.dstIndex] === undefined) dstTmpVarMap[con.dstIndex] = {};
							dstTmpVarMap[con.dstIndex][con.dstVarName] = con.srcVarName;
						}
					} else {
						if (con.srcIndex >= 0) {
							graphOutputVarTmpVarMap[con.dstVarName] = srcTmpVarMap[con.srcIndex][con.srcVarName];
						} else {
							graphOutputVarTmpVarMap[con.dstVarName] = con.srcVarName;
						}
					}
				}
				var subGraphOnListFlags = [];
				var subGraphList = [];
				var whileLoopCount = 0;
				while (subGraphList.length < this.graphData.subGraphs.length || whileLoopCount < this.graphData.connections.length) {
					whileLoopCount++;
					for (i = 0; i < this.graphData.subGraphs.length; i++) {
						if (subGraphOnListFlags[i] != true) {
							var allInputsOnList = true;
							if (dstConnectedMap[i] != undefined) {
								for (var n = 0; n < dstConnectedMap[i].length; n++) {
									var connectedSrcIndex = dstConnectedMap[i][n];
									if (subGraphOnListFlags[connectedSrcIndex] != true) {
										allInputsOnList = false;
										break;
									}
								}
							}
							if (allInputsOnList === true) {
								subGraphList.push(i);
								subGraphOnListFlags[i] = true;
							}
						}
					}
				}
				for (i = 0; i < subGraphList.length; i++) {
					var subGraphIndex = subGraphList[i];
					if (srcTmpVarMap[subGraphIndex] != undefined) {
						var func = this.graphData.subGraphs[subGraphIndex].name;
						if ( func.endsWith('PS') ) {
							generatedGlsl += '#ifdef SG_PS\n';
						} else if ( func.endsWith('VS') ) {
							generatedGlsl += '#ifdef SG_VS\n';
						}
						generatedGlsl += this.graphData.subGraphs[subGraphIndex]._generateSubGraphCall(dstTmpVarMap[subGraphIndex], srcTmpVarMap[subGraphIndex]);
						if ( func.endsWith('PS')  ) {
							generatedGlsl += '#endif //SG_PS\n';
						} else if ( func.endsWith('VS') ) {
							generatedGlsl += '#endif //SG_VS\n';
						}
					}
				}
				for (i = 0; i < this.graphData.graphVars.length; i++) {
					graphVar = this.graphData.graphVars[i];
					if (graphVar.name.startsWith('OUT_') && !graphVar.name.startsWith('OUT_ret')) {
						generatedGlsl += graphVar.name + ' = ' + graphOutputVarTmpVarMap[graphVar.name] + ';\n';
					}
				}
				generatedGlsl += '}\n';
			}
			return generatedGlsl;
		}
	});

	function NodeMaterialBinder(assets, device, parser) {
		this._assets = assets;
		this._device = device;
		this._parser = parser;
		this._placeholderGraph = null;
		this._placeholderGlsl = null;
		this._placeholderTextures = null;
	}
	Object.assign(NodeMaterialBinder.prototype, {
		_createPlaceholders: function () {
			this._placeholderTextures = {};
			var textures = {
				white: [255, 255, 255, 255],
				gray: [128, 128, 128, 255],
				black: [0, 0, 0, 255],
				normal: [128, 128, 255, 255]
			};
			for (var key in textures) {
				if (!textures.hasOwnProperty(key))
					continue;
				this._placeholderTextures[key] = new Texture(this._device, {
					width: 2,
					height: 2,
					format: PIXELFORMAT_R8_G8_B8_A8
				});
				this._placeholderTextures[key].name = 'placeholder';
				var pixels = this._placeholderTextures[key].lock();
				for (var i = 0; i < 4; i++) {
					for (var c = 0; c < 4; c++) {
						pixels[i * 4 + c] = textures[key][c];
					}
				}
				this._placeholderTextures[key].unlock();
			}
			this._placeholderGraph = new NodeMaterial('vec4 v4_zero() { return vec4(0); }');
			this._placeholderGlsl = 'vec4 v4_zero() { return vec4(0); }';
		},
		onAssetUnload: function (asset) {
		},
		_assignTexture: function (graphVarIndex, materialAsset, resource) {
			materialAsset.data.graphData.graphVars[graphVarIndex].valueTex = resource;
			materialAsset.resource.graphData.graphVars[graphVarIndex].valueTex = resource;
		},
		_assignSubGraph: function (subGraphIndex, materialAsset, resource) {
			materialAsset.data.graphData.subGraphs[subGraphIndex] = resource;
			materialAsset.resource.graphData.subGraphs[subGraphIndex] = resource;
		},
		_assignGlsl: function (propertyName, materialAsset, resource) {
			materialAsset.data.graphData[propertyName] = resource;
			materialAsset.resource.graphData[propertyName] = resource;
		},
		_assignPlaceholderTexture: function (graphVarIndex, materialAsset) {
			if (!this._placeholderTextures) {
				this._createPlaceholders();
			}
			var texture = this._placeholderTextures.white;
			materialAsset.resource.graphData.graphVars[graphVarIndex].valueTex = texture;
		},
		_assignPlaceholderSubGraph: function (subGraphIndex, materialAsset) {
			if (!this._placeholderGraph) {
				this._createPlaceholders();
			}
			var graph = this._placeholderGraph;
			materialAsset.resource.graphData.subGraphs[subGraphIndex] = graph;
		},
		_assignPlaceholderCustomGlsl: function (propertyName, materialAsset) {
			if (!this._placeholderGlsl) {
				this._createPlaceholders();
			}
			var glsl = this._placeholderGlsl;
			materialAsset.resource.graphData[propertyName] = glsl;
		},
		_onGlslLoad: function (parameterName, materialAsset, glslAsset) {
			this._assignGlsl(parameterName, materialAsset, glslAsset.resource);
			this._parser.initialize(materialAsset.resource, materialAsset.data);
		},
		_onGlslAdd: function (parameterName, materialAsset, glslAsset) {
			this._assets.load(glslAsset);
		},
		_onGlslRemove: function (parameterName, materialAsset, glslAsset) {
			var material = materialAsset.resource;
			if (material.graphData[parameterName] === glslAsset.resource) {
				this._assignGlsl(parameterName, materialAsset, null);
				this._parser.initialize(materialAsset.resource, materialAsset.data);
			}
		},
		_onGraphVarTexLoad: function (i, materialAsset, textureAsset) {
			this._assignTexture(i, materialAsset, textureAsset.resource);
			this._parser.initialize(materialAsset.resource, materialAsset.data);
		},
		_onGraphVarTexAdd: function (i, materialAsset, textureAsset) {
			this._assets.load(textureAsset);
		},
		_onGraphVarTexRemove: function (i, materialAsset, textureAsset) {
			var material = materialAsset.resource;
			if (material.graphData.graphVars[i].valueTex === textureAsset.resource) {
				this._assignTexture(i, materialAsset, null);
				this._parser.initialize(materialAsset.resource, materialAsset.data);
			}
		},
		_onSubGraphLoad: function (i, materialAsset, subGraphAsset) {
			this._assignSubGraph(i, materialAsset, subGraphAsset.resource);
			this._parser.initialize(materialAsset.resource, materialAsset.data);
		},
		_onSubGraphAdd: function (i, materialAsset, subGraphAsset) {
			this._assets.load(subGraphAsset);
		},
		_onSubGraphRemove: function (i, materialAsset, subGraphAsset) {
			var material = materialAsset.resource;
			if (material.graphData.subGraphs[i] === subGraphAsset.resource) {
				this._assignSubGraph(i, materialAsset, null);
				this._parser.initialize(materialAsset.resource, materialAsset.data);
			}
		},
		bindAndAssignAssets: function (materialAsset, assets) {
			var i;
			var data = this._parser.migrate(materialAsset.data);
			var material = materialAsset.resource;
			var pathMapping = (data.mappingFormat === "path");
			var assetReference;
			if (data.graphData.graphVars) {
				for (i = 0; i < Object.keys(data.graphData.graphVars).length; i++) {
					if (data.graphData.graphVars[i].type === 'sampler2D' && data.graphData.graphVars[i].valueTex) {
						assetReference = material._graphVarAssetReferences[i];
						if (!(data.graphData.graphVars[i].valueTex instanceof Texture)) {
							if (!assetReference) {
								assetReference = new AssetReference(i, materialAsset, assets, {
									load: this._onGraphVarTexLoad,
									add: this._onGraphVarTexAdd,
									remove: this._onGraphVarTexRemove
								}, this);
								material._graphVarAssetReferences[i] = assetReference;
							}
							if (pathMapping) {
								assetReference.url = materialAsset.getAbsoluteUrl(data.graphVars[i].valueTex);
							} else {
								assetReference.id = data.graphData.graphVars[i].valueTex;
							}
							if (assetReference.asset) {
								if (assetReference.asset.resource) {
									material.graphData.graphVars[i] = {};
									Object.assign(material.graphData.graphVars[i], data.graphData.graphVars[i]);
									this._assignTexture(i, materialAsset, assetReference.asset.resource);
								} else {
									material.graphData.graphVars[i] = {};
									Object.assign(material.graphData.graphVars[i], data.graphData.graphVars[i]);
									this._assignPlaceholderTexture(i, materialAsset);
								}
								assets.load(assetReference.asset);
							}
						}
					}
				}
			}
			var customGlslNames = ['customFuncGlsl', 'customDeclGlsl'];
			for (i = 0; i < customGlslNames.length; i++) {
				var name = customGlslNames[i];
				if (data.graphData[name]) {
					assetReference = material._glslAssetReferences[name];
					if (typeof(data.graphData[name]) === 'number' && data.graphData[name] > 0) {
						if (!assetReference) {
							assetReference = new AssetReference(name, materialAsset, assets, {
								load: this._onGlslLoad,
								add: this._onGlslAdd,
								remove: this._onGlslRemove
							}, this);
							material._glslAssetReferences[name] = assetReference;
						}
						if (pathMapping) {
							assetReference.url = materialAsset.getAbsoluteUrl(data[name]);
						} else {
							assetReference.id = data.graphData[name];
						}
						if (assetReference.asset) {
							if (assetReference.asset.resource) {
								this._assignGlsl(name, materialAsset, assetReference.asset.resource);
							}
							assets.load(assetReference.asset);
						}
					}
				}
			}
			if (data.graphData.subGraphs) {
				for (i = 0; i < Object.keys(data.graphData.subGraphs).length; i++) {
					if (data.graphData.subGraphs[i]) {
						assetReference = material._subGraphAssetReferences[i];
						if (!(data.graphData.subGraphs[i] instanceof NodeMaterial)) {
							if (!assetReference) {
								assetReference = new AssetReference(i, materialAsset, assets, {
									load: this._onSubGraphLoad,
									add: this._onSubGraphAdd,
									remove: this._onSubGraphRemove
								}, this);
								material._subGraphAssetReferences[i] = assetReference;
							}
							if (pathMapping) {
								assetReference.url = materialAsset.getAbsoluteUrl(data.graphData.subGraphs[i]);
							} else {
								assetReference.id = data.graphData.subGraphs[i];
							}
							if (assetReference.asset) {
								if (assetReference.asset.resource) {
									this._assignSubGraph(i, materialAsset, assetReference.asset.resource);
								}
								assets.load(assetReference.asset);
							}
						}
					}
				}
			}
			this._parser.initialize(material, data);
		}
	});

	function JsonNodeMaterialParser(device) {
		this._device = device;
		this._validator = null;
		this._placeholderNodeMat = this._genPlaceholderNodeMat();
	}
	JsonNodeMaterialParser.prototype.parse = function (input) {
		var migrated = this.migrate(input);
		var validated = this._validate(migrated);
		var material = new NodeMaterial();
		this.initialize(material, validated);
		return material;
	};
	JsonNodeMaterialParser.prototype.initialize = function (material, data) {
		var i = 0;
		var materialReady = true;
		var varType;
		if (data.graphData.graphVars) {
			for (i = 0; i < Object.keys(data.graphData.graphVars).length; i++) {
				if (data.graphData.graphVars[i].type === 'sampler2D' && data.graphData.graphVars[i].valueTex) {
					if (typeof(data.graphData.graphVars[i].valueTex) === 'number' && data.graphData.graphVars[i].valueTex > 0) {
						if (!(material.graphData.graphVars[i] && material.graphData.graphVars[i].valueTex)) {
							materialReady = false;
						}
					} else {
						material.graphData.graphVars[i] = {};
						Object.assign(material.graphData.graphVars[i], data.graphData.graphVars[i]);
					}
				} else {
					material.graphData.graphVars[i] = {};
					Object.assign(material.graphData.graphVars[i], data.graphData.graphVars[i]);
					varType = material.graphData.graphVars[i].type;
					if (material.graphData.graphVars[i].valueW === undefined && varType === 'vec4') material.graphData.graphVars[i].valueW = 0;
					if (material.graphData.graphVars[i].valueZ === undefined && (varType === 'vec4' || varType === 'vec3' )) material.graphData.graphVars[i].valueZ = 0;
					if (material.graphData.graphVars[i].valueY === undefined && (varType === 'vec4' || varType === 'vec3' || varType === 'vec2' )) material.graphData.graphVars[i].valueY = 0;
					if (material.graphData.graphVars[i].valueX === undefined && (varType === 'vec4' || varType === 'vec3' || varType === 'vec2' || varType === 'float' )) material.graphData.graphVars[i].valueX = 0;
				}
			}
		}
		if (data.graphData.customFuncGlsl) {
			if (data.graphData.customDeclGlsl) {
				if (typeof(data.graphData.customDeclGlsl) === 'number' && data.graphData.customDeclGlsl > 0) {
					materialReady = false;
				} else {
					material.graphData.customDeclGlsl = data.graphData.customDeclGlsl;
				}
			}
			if (data.graphData.customFuncGlsl) {
				if (typeof(data.graphData.customFuncGlsl) === 'number' && data.graphData.customFuncGlsl > 0) {
					materialReady = false;
				} else {
					material.graphData.customFuncGlsl = data.graphData.customFuncGlsl;
					material.graphData.graphVars.length = 0;
					material.genCustomFuncVars();
					if (material.graphData.graphVars) {
						for (i = 0; i < material.graphData.graphVars.length; i++) {
							if (data.graphData.graphVars && i < Object.keys(data.graphData.graphVars).length && material.graphData.graphVars[i].name === data.graphData.graphVars[i].name && material.graphData.graphVars[i].type === data.graphData.graphVars[i].type ) {
								Object.assign(material.graphData.graphVars[i], data.graphData.graphVars[i]);
								varType = material.graphData.graphVars[i].type;
								if (material.graphData.graphVars[i].valueW === undefined && varType === 'vec4') material.graphData.graphVars[i].valueW = 0;
								if (material.graphData.graphVars[i].valueZ === undefined && (varType === 'vec4' || varType === 'vec3' )) material.graphData.graphVars[i].valueZ = 0;
								if (material.graphData.graphVars[i].valueY === undefined && (varType === 'vec4' || varType === 'vec3' || varType === 'vec2' )) material.graphData.graphVars[i].valueY = 0;
								if (material.graphData.graphVars[i].valueX === undefined && (varType === 'vec4' || varType === 'vec3' || varType === 'vec2' || varType === 'float' )) material.graphData.graphVars[i].valueX = 0;
							}
						}
					}
				}
			}
		} else if (data.graphData.subGraphs) {
			if (data.graphData.connections) {
				material.graphData.connections = [];
				for (i = 0; i < Object.keys(data.graphData.connections).length; i++) {
					material.graphData.connections[i] = {};
					Object.assign(material.graphData.connections[i], data.graphData.connections[i]);
				}
			}
			if (data.graphData.subGraphs) {
				if (material.graphData.subGraphs.length != Object.keys(data.graphData.subGraphs).length) {
					material.graphData.subGraphs.length = Object.keys(data.graphData.subGraphs).length;
				}
				for (i = 0; i < Object.keys(data.graphData.subGraphs).length; i++) {
					if (typeof(data.graphData.subGraphs[i]) === 'number' && data.graphData.subGraphs[i] > 0) {
						materialReady = false;
						material.graphData.subGraphs[i] = i;
					} else {
						material.graphData.subGraphs[i] = data.graphData.subGraphs[i];
					}
				}
			}
		} else {
			if (data.graphData.graphVars) {
				materialReady = false;
			} else {
				materialReady = false;
			}
		}
		if (materialReady) {
			material.dirtyShader = true;
			material.update();
		} else {
			material.setPlaceHolderShader(this._placeholderNodeMat);
		}
	};
	JsonNodeMaterialParser.prototype.migrate = function (data) {
		return data;
	};
	JsonNodeMaterialParser.prototype._validate = function (data) {
		return data;
	};
	JsonNodeMaterialParser.prototype._genPlaceholderNodeMat = function () {
		var material = new NodeMaterial('void placeHolder(out vec3 vertOff, out vec4 fragOut){ vertOff=vec3(0); fragOut=vec4(0,0,1,1);}');
		material.initShader(this._device);
		material.updateUniforms();
		return material;
	};

	function MaterialHandler(app) {
		this._app = app;
		this._assets = app.assets;
		this._device = app.graphicsDevice;
		this._parsers = {};
		this._binders = {};
		this.retryRequests = false;
	}
	Object.assign(MaterialHandler.prototype, {
		load: function (url, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			http.get(url.load, {
				retry: this.retryRequests
			}, function (err, response) {
				if (!err) {
					if (callback) {
						response._engine = true;
						callback(null, response);
					}
				} else {
					if (callback) {
						callback("Error loading material: " + url.original + " [" + err + "]");
					}
				}
			});
		},
		_getSubClass: function (data) {
			var subclass = 'Standard';
			if (data.graphData) {
				subclass = 'Node';
				if (!this._parsers[subclass]) this._parsers[subclass] = new JsonNodeMaterialParser(this._device);
				if (!this._binders[subclass]) this._binders[subclass] = new NodeMaterialBinder(this._app, this._parsers[subclass]);
			} else {
				if (!this._parsers[subclass]) this._parsers[subclass] = new JsonStandardMaterialParser();
				if (!this._binders[subclass]) this._binders[subclass] = new StandardMaterialBinder(this._app, this._parsers[subclass]);
			}
			return subclass;
		},
		open: function (url, data) {
			var subclass = this._getSubClass(data);
			var material = this._parsers[subclass].parse(data);
			if (data._engine) {
				material._data = data;
				delete data._engine;
			}
			return material;
		},
		patch: function (asset, assets) {
			if (asset.resource._data) {
				asset._data = asset.resource._data;
				delete asset.resource._data;
			}
			asset.data.name = asset.name;
			asset.resource.name = asset.name;
			var subclass = this._getSubClass(asset.data);
			if (subclass == 'Node') {
				asset.resource.name = asset.name.replace(/[^A-Z0-9]+/ig, "_");
			}
			if (subclass == 'Node' && !(asset.resource instanceof NodeMaterial)) {
				asset.resource = this._parsers[subclass].parse(asset.data);
			} else if (subclass == 'Standard' && !(asset.resource instanceof StandardMaterial)) {
				asset.resource = this._parsers[subclass].parse(asset.data);
			}
			this._binders[subclass].bindAndAssignAssets(asset, assets);
			asset.off('unload', this._binders[subclass].onAssetUnload, this);
			asset.on('unload', this._binders[subclass].onAssetUnload, this);
		}
	});

	function GlbModelParser(device) {
		this._device = device;
		this._defaultMaterial = getDefaultMaterial();
	}
	Object.assign(GlbModelParser.prototype, {
		parse: function (data) {
			var glb = GlbParser.parse("filename.glb", data, this._device);
			if (!glb) {
				return null;
			}
			return GlbParser.createModel(glb, this._defaultMaterial);
		}
	});

	function PartitionedVertex() {
		this.index = 0;
		this.boneIndices = [0, 0, 0, 0];
	}
	function SkinPartition() {
		this.partition = 0;
		this.vertexStart = 0;
		this.vertexCount = 0;
		this.indexStart = 0;
		this.indexCount = 0;
		this.boneIndices = [];
		this.vertices = [];
		this.indices = [];
		this.indexMap = {};
	}
	Object.assign(SkinPartition.prototype, {
		addVertex: function (vertex, idx, vertexArray) {
			var remappedIndex = -1;
			if (this.indexMap[idx] !== undefined) {
				remappedIndex = this.indexMap[idx];
				this.indices.push(remappedIndex);
			} else {
				for (var influence = 0; influence < 4; influence++ ) {
					if (vertexArray.blendWeight.data[idx * 4 + influence] === 0)
						continue;
					var originalBoneIndex = vertexArray.blendIndices.data[vertex.index * 4 + influence];
					vertex.boneIndices[influence] = this.getBoneRemap(originalBoneIndex);
				}
				remappedIndex = this.vertices.length;
				this.indices.push(remappedIndex);
				this.vertices.push(vertex);
				this.indexMap[idx] = remappedIndex;
			}
		},
		addPrimitive: function (vertices, vertexIndices, vertexArray, boneLimit) {
			var i, j;
			var bonesToAdd = [];
			var bonesToAddCount = 0;
			var vertexCount = vertices.length;
			for (i = 0; i < vertexCount; i++) {
				var vertex = vertices[i];
				var idx = vertex.index;
				for (var influence = 0; influence < 4; influence++) {
					if (vertexArray.blendWeight.data[idx * 4 + influence] > 0) {
						var boneIndex = vertexArray.blendIndices.data[idx * 4 + influence];
						var needToAdd = true;
						for (j = 0; j < bonesToAddCount; j++) {
							if (bonesToAdd[j] == boneIndex) {
								needToAdd = false;
								break;
							}
						}
						if (needToAdd) {
							bonesToAdd[bonesToAddCount] = boneIndex;
							var boneRemap = this.getBoneRemap(boneIndex);
							bonesToAddCount += (boneRemap === -1 ? 1 : 0);
						}
					}
				}
			}
			if ((this.boneIndices.length + bonesToAddCount) > boneLimit) {
				return false;
			}
			for (i = 0; i < bonesToAddCount; i++) {
				this.boneIndices.push(bonesToAdd[i]);
			}
			for (i = 0; i < vertexCount; i++) {
				this.addVertex(vertices[i], vertexIndices[i], vertexArray);
			}
			return true;
		},
		getBoneRemap: function (boneIndex) {
			for (var i = 0; i < this.boneIndices.length; i++ ) {
				if (this.boneIndices[i] === boneIndex) {
					return i;
				}
			}
			return -1;
		}
	});
	function indicesToReferences(model) {
		var i;
		var vertices = model.vertices;
		var skins = model.skins;
		var meshes = model.meshes;
		var meshInstances = model.meshInstances;
		for (i = 0; i < meshes.length; i++) {
			meshes[i].vertices = vertices[meshes[i].vertices];
			if (meshes[i].skin !== undefined) {
				meshes[i].skin = skins[meshes[i].skin];
			}
		}
		for (i = 0; i < meshInstances.length; i++) {
			meshInstances[i].mesh = meshes[meshInstances[i].mesh];
		}
	}
	function referencesToIndices(model) {
		var i;
		var vertices = model.vertices;
		var skins = model.skins;
		var meshes = model.meshes;
		var meshInstances = model.meshInstances;
		for (i = 0; i < meshes.length; i++) {
			meshes[i].vertices = vertices.indexOf(meshes[i].vertices);
			if (meshes[i].skin !== undefined) {
				meshes[i].skin = skins.indexOf(meshes[i].skin);
			}
		}
		for (i = 0; i < meshInstances.length; i++) {
			meshInstances[i].mesh = meshes.indexOf(meshInstances[i].mesh);
		}
	}
	function partitionSkin(model, materialMappings, boneLimit) {
		var i, j, k, index;
		indicesToReferences(model);
		var vertexArrays = model.vertices;
		var skins = model.skins;
		var mesh;
		var meshes = model.meshes;
		var meshInstances = model.meshInstances;
		var getVertex = function (idx) {
			var vert = new PartitionedVertex();
			vert.index = idx;
			return vert;
		};
		for (i = skins.length - 1; i >= 0; i--) {
			if (skins[i].boneNames.length > boneLimit) {
				var skin = skins.splice(i, 1)[0];
				var meshesToSplit = [];
				for (j = 0; j < meshes.length; j++) {
					if (meshes[j].skin === skin) {
						meshesToSplit.push(meshes[j]);
					}
				}
				for (j = 0; j < meshesToSplit.length; j++) {
					index = meshes.indexOf(meshesToSplit[j]);
					if (index !== -1) {
						meshes.splice(index, 1);
					}
				}
				if (meshesToSplit.length === 0) {
					throw new Error('partitionSkin: There should be at least one mesh that references a skin');
				}
				var vertexArray = meshesToSplit[0].vertices;
				for (j = 1; j < meshesToSplit.length; j++) {
					if (meshesToSplit[j].vertices !== vertexArray) {
						throw new Error('partitionSkin: All meshes that share a skin should also share the same vertex buffer');
					}
				}
				var partition;
				var partitions = [];
				var primitiveVertices = [];
				var primitiveIndices = [];
				var basePartition = 0;
				for (j = 0; j < meshesToSplit.length; j++) {
					mesh = meshesToSplit[j];
					var indices = mesh.indices;
					for (var iIndex = mesh.base; iIndex < mesh.base + mesh.count; ) {
						index = indices[iIndex++];
						primitiveVertices[0] = getVertex(index);
						primitiveIndices[0] = index;
						index = indices[iIndex++];
						primitiveVertices[1] = getVertex(index);
						primitiveIndices[1] = index;
						index = indices[iIndex++];
						primitiveVertices[2] = getVertex(index);
						primitiveIndices[2] = index;
						var added = false;
						for (var iBonePartition = basePartition; iBonePartition < partitions.length; iBonePartition++) {
							partition = partitions[iBonePartition];
							if (partition.addPrimitive(primitiveVertices, primitiveIndices, vertexArray, boneLimit)) {
								added = true;
								break;
							}
						}
						if (!added) {
							partition = new SkinPartition();
							partition.originalMesh = mesh;
							partition.addPrimitive(primitiveVertices, primitiveIndices, vertexArray, boneLimit);
							partitions.push(partition);
						}
					}
					basePartition = partitions.length;
				}
				var partitionedVertices = [];
				var partitionedIndices = [];
				for (j = 0; j < partitions.length; j++) {
					partition = partitions[j];
					if (partition.vertices.length && partition.indices.length) {
						var vertexStart = partitionedVertices.length;
						var vertexCount = partition.vertices.length;
						var indexStart = partitionedIndices.length;
						var indexCount = partition.indices.length;
						partition.partition = j;
						partition.vertexStart = vertexStart;
						partition.vertexCount = vertexCount;
						partition.indexStart = indexStart;
						partition.indexCount = indexCount;
						var iSour;
						var iDest;
						iSour = 0;
						iDest = vertexStart;
						while (iSour < vertexCount) {
							partitionedVertices[iDest++] = partition.vertices[iSour++];
						}
						iSour = 0;
						iDest = indexStart;
						while (iSour < indexCount) {
							partitionedIndices[iDest++] = partition.indices[iSour++] + vertexStart;
						}
					}
				}
				var splitSkins = [];
				for (j = 0; j < partitions.length; j++) {
					partition = partitions[j];
					var ibp = [];
					var boneNames = [];
					for (k = 0; k < partition.boneIndices.length; k++) {
						ibp.push(skin.inverseBindMatrices[partition.boneIndices[k]]);
						boneNames.push(skin.boneNames[partition.boneIndices[k]]);
					}
					var splitSkin = {
						inverseBindMatrices: ibp,
						boneNames: boneNames
					};
					splitSkins.push(splitSkin);
					skins.push(splitSkin);
				}
				var attrib, attribName, data, components;
				var splitVertexArray = {};
				for (attribName in vertexArray) {
					splitVertexArray[attribName] = {
						components: vertexArray[attribName].components,
						data: [],
						type: vertexArray[attribName].type
					};
				}
				for (attribName in vertexArray) {
					if (attribName === 'blendIndices') {
						var dstBoneIndices = splitVertexArray[attribName].data;
						for (j = 0; j < partitionedVertices.length; j++) {
							var srcBoneIndices = partitionedVertices[j].boneIndices;
							dstBoneIndices.push(srcBoneIndices[0], srcBoneIndices[1], srcBoneIndices[2], srcBoneIndices[3]);
						}
					} else {
						attrib = vertexArray[attribName];
						data = attrib.data;
						components = attrib.components;
						for (j = 0; j < partitionedVertices.length; j++) {
							index = partitionedVertices[j].index;
							for (k = 0; k < components; k++) {
								splitVertexArray[attribName].data.push(data[index * components + k]);
							}
						}
					}
				}
				vertexArrays[vertexArrays.indexOf(vertexArray)] = splitVertexArray;
				for (j = 0; j < partitions.length; j++) {
					partition = partitions[j];
					mesh = {
						aabb: {
							min: [0, 0, 0],
							max: [0, 0, 0]
						},
						vertices: splitVertexArray,
						skin: splitSkins[j],
						indices: partitionedIndices.splice(0, partition.indexCount),
						type: 'triangles',
						base: 0,
						count: partition.indexCount
					};
					meshes.push(mesh);
					for (k = meshInstances.length - 1; k >= 0; k--) {
						if (meshInstances[k].mesh === partition.originalMesh) {
							meshInstances.push({
								mesh: mesh,
								node: meshInstances[k].node
							});
							if (materialMappings) {
								materialMappings.push({
									material: materialMappings[k].material,
									path: materialMappings[k].path
								});
							}
						}
					}
				}
				for (j = 0; j < partitions.length; j++) {
					partition = partitions[j];
					for (k = meshInstances.length - 1; k >= 0; k--) {
						if (meshInstances[k].mesh === partition.originalMesh) {
							meshInstances.splice(k, 1);
							if (materialMappings) {
								materialMappings.splice(k, 1);
							}
						}
					}
				}
			}
		}
		referencesToIndices(model);
	}

	var JSON_PRIMITIVE_TYPE = {
		"points": PRIMITIVE_POINTS,
		"lines": PRIMITIVE_LINES,
		"lineloop": PRIMITIVE_LINELOOP,
		"linestrip": PRIMITIVE_LINESTRIP,
		"triangles": PRIMITIVE_TRIANGLES,
		"trianglestrip": PRIMITIVE_TRISTRIP,
		"trianglefan": PRIMITIVE_TRIFAN
	};
	var JSON_VERTEX_ELEMENT_TYPE = {
		"int8": TYPE_INT8,
		"uint8": TYPE_UINT8,
		"int16": TYPE_INT16,
		"uint16": TYPE_UINT16,
		"int32": TYPE_INT32,
		"uint32": TYPE_UINT32,
		"float32": TYPE_FLOAT32
	};
	function JsonModelParser(device) {
		this._device = device;
		this._defaultMaterial = getDefaultMaterial();
	}
	Object.assign(JsonModelParser.prototype, {
		parse: function (data) {
			var modelData = data.model;
			if (!modelData) {
				return null;
			}
			if (modelData.version <= 1) {
				return null;
			}
			var nodes = this._parseNodes(data);
			var skins = this._parseSkins(data, nodes);
			var vertexBuffers = this._parseVertexBuffers(data);
			var indices = this._parseIndexBuffers(data, vertexBuffers);
			var morphs = this._parseMorphs(data, nodes, vertexBuffers);
			var meshes = this._parseMeshes(data, skins.skins, morphs.morphs, vertexBuffers, indices.buffer, indices.data);
			var meshInstances = this._parseMeshInstances(data, nodes, meshes, skins.skins, skins.instances, morphs.morphs, morphs.instances);
			var model = new Model();
			model.graph = nodes[0];
			model.meshInstances = meshInstances;
			model.skinInstances = skins.instances;
			model.morphInstances = morphs.instances;
			model.getGraph().syncHierarchy();
			return model;
		},
		_parseNodes: function (data) {
			var modelData = data.model;
			var nodes = [];
			var i;
			for (i = 0; i < modelData.nodes.length; i++) {
				var nodeData = modelData.nodes[i];
				var node = new GraphNode(nodeData.name);
				node.setLocalPosition(nodeData.position[0], nodeData.position[1], nodeData.position[2]);
				node.setLocalEulerAngles(nodeData.rotation[0], nodeData.rotation[1], nodeData.rotation[2]);
				node.setLocalScale(nodeData.scale[0], nodeData.scale[1], nodeData.scale[2]);
				node.scaleCompensation = !!nodeData.scaleCompensation;
				nodes.push(node);
			}
			for (i = 1; i < modelData.parents.length; i++) {
				nodes[modelData.parents[i]].addChild(nodes[i]);
			}
			return nodes;
		},
		_parseSkins: function (data, nodes) {
			var modelData = data.model;
			var skins = [];
			var skinInstances = [];
			var i, j;
			if (!this._device.supportsBoneTextures && modelData.skins.length > 0) {
				var boneLimit = this._device.getBoneLimit();
				partitionSkin(modelData, null, boneLimit);
			}
			for (i = 0; i < modelData.skins.length; i++) {
				var skinData = modelData.skins[i];
				var inverseBindMatrices = [];
				for (j = 0; j < skinData.inverseBindMatrices.length; j++) {
					var ibm = skinData.inverseBindMatrices[j];
					inverseBindMatrices[j] = new Mat4().set(ibm);
				}
				var skin = new Skin(this._device, inverseBindMatrices, skinData.boneNames);
				skins.push(skin);
				var skinInstance = new SkinInstance(skin);
				var bones = [];
				for (j = 0; j < skin.boneNames.length; j++) {
					var boneName = skin.boneNames[j];
					var bone = nodes[0].findByName(boneName);
					bones.push(bone);
				}
				skinInstance.bones = bones;
				skinInstances.push(skinInstance);
			}
			return {
				skins: skins,
				instances: skinInstances
			};
		},
		_getMorphVertexCount: function (modelData, morphIndex, vertexBuffers) {
			for (var i = 0; i < modelData.meshes.length; i++) {
				var meshData = modelData.meshes[i];
				if (meshData.morph === morphIndex) {
					var vertexBuffer = vertexBuffers[meshData.vertices];
					return vertexBuffer.numVertices;
				}
			}
			return undefined;
		},
		_parseMorphs: function (data, nodes, vertexBuffers) {
			var modelData = data.model;
			var morphs = [];
			var morphInstances = [];
			var i, j, vertexCount;
			var targets, morphTarget, morphTargetArray;
			if (modelData.morphs) {
				var sparseToFull = function (data, indices, totalCount) {
					var full = new Float32Array(totalCount * 3);
					for (var s = 0; s < indices.length; s++) {
						var dstIndex = indices[s] * 3;
						full[dstIndex] = data[s * 3];
						full[dstIndex + 1] = data[s * 3 + 1];
						full[dstIndex + 2] = data[s * 3 + 2];
					}
					return full;
				};
				for (i = 0; i < modelData.morphs.length; i++) {
					targets = modelData.morphs[i].targets;
					morphTargetArray = [];
					vertexCount = this._getMorphVertexCount(modelData, i, vertexBuffers);
					for (j = 0; j < targets.length; j++) {
						var targetAabb = targets[j].aabb;
						var min = targetAabb.min;
						var max = targetAabb.max;
						var aabb = new BoundingBox(
							new Vec3((max[0] + min[0]) * 0.5, (max[1] + min[1]) * 0.5, (max[2] + min[2]) * 0.5),
							new Vec3((max[0] - min[0]) * 0.5, (max[1] - min[1]) * 0.5, (max[2] - min[2]) * 0.5)
						);
						var indices = targets[j].indices;
						var deltaPositions = targets[j].deltaPositions;
						var deltaNormals = targets[j].deltaNormals;
						if (indices) {
							deltaPositions = sparseToFull(deltaPositions, indices, vertexCount);
							deltaNormals = sparseToFull(deltaNormals, indices, vertexCount);
						}
						morphTarget = new MorphTarget({ deltaPositions: deltaPositions,
							deltaNormals: deltaNormals,
							name: targets[j].name,
							aabb: aabb });
						morphTargetArray.push(morphTarget);
					}
					var morph = new Morph(morphTargetArray, this._device);
					morphs.push(morph);
					var morphInstance = new MorphInstance(morph);
					morphInstances.push(morphInstance);
				}
			}
			return {
				morphs: morphs,
				instances: morphInstances
			};
		},
		_parseVertexBuffers: function (data) {
			var modelData = data.model;
			var vertexBuffers = [];
			var attribute, attributeName;
			var attributeMap = {
				position: SEMANTIC_POSITION,
				normal: SEMANTIC_NORMAL,
				tangent: SEMANTIC_TANGENT,
				blendWeight: SEMANTIC_BLENDWEIGHT,
				blendIndices: SEMANTIC_BLENDINDICES,
				color: SEMANTIC_COLOR,
				texCoord0: SEMANTIC_TEXCOORD0,
				texCoord1: SEMANTIC_TEXCOORD1,
				texCoord2: SEMANTIC_TEXCOORD2,
				texCoord3: SEMANTIC_TEXCOORD3,
				texCoord4: SEMANTIC_TEXCOORD4,
				texCoord5: SEMANTIC_TEXCOORD5,
				texCoord6: SEMANTIC_TEXCOORD6,
				texCoord7: SEMANTIC_TEXCOORD7
			};
			var i, j;
			for (i = 0; i < modelData.vertices.length; i++) {
				var vertexData = modelData.vertices[i];
				var formatDesc = [];
				for (attributeName in vertexData) {
					attribute = vertexData[attributeName];
					formatDesc.push({
						semantic: attributeMap[attributeName],
						components: attribute.components,
						type: JSON_VERTEX_ELEMENT_TYPE[attribute.type],
						normalize: (attributeMap[attributeName] === SEMANTIC_COLOR)
					});
				}
				var vertexFormat = new VertexFormat(this._device, formatDesc);
				var numVertices = vertexData.position.data.length / vertexData.position.components;
				var vertexBuffer = new VertexBuffer(this._device, vertexFormat, numVertices);
				var iterator = new VertexIterator(vertexBuffer);
				for (j = 0; j < numVertices; j++) {
					for (attributeName in vertexData) {
						attribute = vertexData[attributeName];
						switch (attribute.components) {
							case 1:
								iterator.element[attributeMap[attributeName]].set(attribute.data[j]);
								break;
							case 2:
								iterator.element[attributeMap[attributeName]].set(attribute.data[j * 2], attribute.data[j * 2 + 1]);
								break;
							case 3:
								iterator.element[attributeMap[attributeName]].set(attribute.data[j * 3], attribute.data[j * 3 + 1], attribute.data[j * 3 + 2]);
								break;
							case 4:
								iterator.element[attributeMap[attributeName]].set(attribute.data[j * 4], attribute.data[j * 4 + 1], attribute.data[j * 4 + 2], attribute.data[j * 4 + 3]);
								break;
						}
					}
					iterator.next();
				}
				iterator.end();
				vertexBuffers.push(vertexBuffer);
			}
			return vertexBuffers;
		},
		_parseIndexBuffers: function (data, vertexBuffers) {
			var modelData = data.model;
			var indexBuffer = null;
			var indexData = null;
			var i;
			var numIndices = 0;
			for (i = 0; i < modelData.meshes.length; i++) {
				var meshData = modelData.meshes[i];
				if (meshData.indices !== undefined) {
					numIndices += meshData.indices.length;
				}
			}
			var maxVerts = 0;
			for (i = 0; i < vertexBuffers.length; i++) {
				maxVerts = Math.max(maxVerts, vertexBuffers[i].numVertices);
			}
			if (numIndices > 0) {
				if (maxVerts > 0xFFFF && this._device.extUintElement) {
					indexBuffer = new IndexBuffer(this._device, INDEXFORMAT_UINT32, numIndices);
					indexData = new Uint32Array(indexBuffer.lock());
				} else {
					indexBuffer = new IndexBuffer(this._device, INDEXFORMAT_UINT16, numIndices);
					indexData = new Uint16Array(indexBuffer.lock());
				}
			}
			return {
				buffer: indexBuffer,
				data: indexData
			};
		},
		_parseMeshes: function (data, skins, morphs, vertexBuffers, indexBuffer, indexData) {
			var modelData = data.model;
			var meshes = [];
			var indexBase = 0;
			var i;
			for (i = 0; i < modelData.meshes.length; i++) {
				var meshData = modelData.meshes[i];
				var meshAabb = meshData.aabb;
				var min = meshAabb.min;
				var max = meshAabb.max;
				var aabb = new BoundingBox(
					new Vec3((max[0] + min[0]) * 0.5, (max[1] + min[1]) * 0.5, (max[2] + min[2]) * 0.5),
					new Vec3((max[0] - min[0]) * 0.5, (max[1] - min[1]) * 0.5, (max[2] - min[2]) * 0.5)
				);
				var indexed = (meshData.indices !== undefined);
				var mesh = new Mesh(this._device);
				mesh.vertexBuffer = vertexBuffers[meshData.vertices];
				mesh.indexBuffer[0] = indexed ? indexBuffer : null;
				mesh.primitive[0].type = JSON_PRIMITIVE_TYPE[meshData.type];
				mesh.primitive[0].base = indexed ? (meshData.base + indexBase) : meshData.base;
				mesh.primitive[0].count = meshData.count;
				mesh.primitive[0].indexed = indexed;
				mesh.skin = (meshData.skin !== undefined) ? skins[meshData.skin] : null;
				mesh.morph = (meshData.morph !== undefined) ? morphs[meshData.morph] : null;
				mesh.aabb = aabb;
				if (indexed) {
					indexData.set(meshData.indices, indexBase);
					indexBase += meshData.indices.length;
				}
				meshes.push(mesh);
			}
			if (indexBuffer !== null) {
				indexBuffer.unlock();
			}
			return meshes;
		},
		_parseMeshInstances: function (data, nodes, meshes, skins, skinInstances, morphs, morphInstances) {
			var modelData = data.model;
			var meshInstances = [];
			var i;
			for (i = 0; i < modelData.meshInstances.length; i++) {
				var meshInstanceData = modelData.meshInstances[i];
				var node = nodes[meshInstanceData.node];
				var mesh = meshes[meshInstanceData.mesh];
				var meshInstance = new MeshInstance(node, mesh, this._defaultMaterial);
				if (mesh.skin) {
					var skinIndex = skins.indexOf(mesh.skin);
					meshInstance.skinInstance = skinInstances[skinIndex];
				}
				if (mesh.morph) {
					var morphIndex = morphs.indexOf(mesh.morph);
					meshInstance.morphInstance = morphInstances[morphIndex];
				}
				meshInstances.push(meshInstance);
			}
			return meshInstances;
		}
	});

	function ModelHandler(device, defaultMaterial) {
		this._device = device;
		this._parsers = [];
		this._defaultMaterial = defaultMaterial;
		this.retryRequests = false;
		this.addParser(new JsonModelParser(this._device), function (url, data) {
			return (path.getExtension(url) === '.json');
		});
		this.addParser(new GlbModelParser(this._device), function (url, data) {
			return (path.getExtension(url) === '.glb');
		});
	}
	Object.assign(ModelHandler.prototype, {
		load: function (url, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			var options = {
				retry: this.retryRequests
			};
			if (url.load.startsWith('blob:')) {
				if (path.getExtension(url.original).toLowerCase() === '.glb') {
					options.responseType = Http.ResponseType.ARRAY_BUFFER;
				} else {
					options.responseType = Http.ResponseType.JSON;
				}
			}
			http.get(url.load, options, function (err, response) {
				if (!callback)
					return;
				if (!err) {
					callback(null, response);
				} else {
					callback("Error loading model: " + url.original + " [" + err + "]");
				}
			});
		},
		open: function (url, data) {
			for (var i = 0; i < this._parsers.length; i++) {
				var p = this._parsers[i];
				if (p.decider(url, data)) {
					return p.parser.parse(data);
				}
			}
			return null;
		},
		patch: function (asset, assets) {
			if (!asset.resource)
				return;
			var data = asset.data;
			var self = this;
			asset.resource.meshInstances.forEach(function (meshInstance, i) {
				if (data.mapping) {
					var handleMaterial = function (asset) {
						if (asset.resource) {
							meshInstance.material = asset.resource;
						} else {
							asset.once('load', handleMaterial);
							assets.load(asset);
						}
						asset.once('remove', function (asset) {
							if (meshInstance.material === asset.resource) {
								meshInstance.material = self._defaultMaterial;
							}
						});
					};
					if (!data.mapping[i]) {
						meshInstance.material = self._defaultMaterial;
						return;
					}
					var id = data.mapping[i].material;
					var url = data.mapping[i].path;
					var material;
					if (id !== undefined) {
						if (!id) {
							meshInstance.material = self._defaultMaterial;
						} else {
							material = assets.get(id);
							if (material) {
								handleMaterial(material);
							} else {
								assets.once('add:' + id, handleMaterial);
							}
						}
					} else if (url) {
						var path = asset.getAbsoluteUrl(data.mapping[i].path);
						material = assets.getByUrl(path);
						if (material) {
							handleMaterial(material);
						} else {
							assets.once('add:url:' + path, handleMaterial);
						}
					}
				}
			});
		},
		addParser: function (parser, decider) {
			this._parsers.push({
				parser: parser,
				decider: decider
			});
		}
	});

	function ResourceLoader(app) {
		this._handlers = {};
		this._requests = {};
		this._cache = {};
		this._app = app;
	}
	Object.assign(ResourceLoader.prototype, {
		addHandler: function (type, handler) {
			this._handlers[type] = handler;
			handler._loader = this;
		},
		removeHandler: function (type) {
			delete this._handlers[type];
		},
		getHandler: function (type) {
			return this._handlers[type];
		},
		load: function (url, type, callback, asset) {
			var handler = this._handlers[type];
			if (!handler) {
				var err = "No handler for asset type: " + type;
				callback(err);
				return;
			}
			if (!url) {
				this._loadNull(handler, callback, asset);
				return;
			}
			var key = url + type;
			if (this._cache[key] !== undefined) {
				callback(null, this._cache[key]);
			} else if (this._requests[key]) {
				this._requests[key].push(callback);
			} else {
				this._requests[key] = [callback];
				var self = this;
				var handleLoad = function (err, urlObj) {
					if (err) {
						self._onFailure(key, err);
						return;
					}
					handler.load(urlObj, function (err, data, extra) {
						if (!self._requests[key]) {
							return;
						}
						if (err) {
							self._onFailure(key, err);
							return;
						}
						try {
							self._onSuccess(key, handler.open(urlObj.original, data, asset), extra);
						} catch (e) {
							self._onFailure(key, e);
						}
					}, asset);
				};
				var normalizedUrl = url.split('?')[0];
				if (this._app.enableBundles && this._app.bundles.hasUrl(normalizedUrl)) {
					if (!this._app.bundles.canLoadUrl(normalizedUrl)) {
						handleLoad('Bundle for ' + url + ' not loaded yet');
						return;
					}
					this._app.bundles.loadUrl(normalizedUrl, function (err, fileUrlFromBundle) {
						handleLoad(err, {
							load: fileUrlFromBundle,
							original: normalizedUrl
						});
					});
				} else {
					handleLoad(null, {
						load: url,
						original: asset && asset.getPreferredFile().filename || url
					});
				}
			}
		},
		_loadNull: function (handler, callback, asset) {
			var onLoad = function (err, data, extra) {
				if (err) {
					callback(err);
				} else {
					try {
						callback(null, handler.open(null, data, asset), extra);
					} catch (e) {
						callback(e);
					}
				}
			};
			handler.load(null, onLoad, asset);
		},
		_onSuccess: function (key, result, extra) {
			this._cache[key] = result;
			for (var i = 0; i < this._requests[key].length; i++) {
				this._requests[key][i](null, result, extra);
			}
			delete this._requests[key];
		},
		_onFailure: function (key, err) {
			console.error(err);
			if (this._requests[key]) {
				for (var i = 0; i < this._requests[key].length; i++) {
					this._requests[key][i](err);
				}
				delete this._requests[key];
			}
		},
		open: function (type, data) {
			var handler = this._handlers[type];
			if (!handler) {
				console.warn("No resource handler found for: " + type);
				return data;
			}
			return handler.open(null, data);
		},
		patch: function (asset, assets) {
			var handler = this._handlers[asset.type];
			if (!handler)  {
				console.warn("No resource handler found for: " + asset.type);
				return;
			}
			if (handler.patch) {
				handler.patch(asset, assets);
			}
		},
		clearCache: function (url, type) {
			delete this._cache[url + type];
		},
		getFromCache: function (url, type) {
			if (this._cache[url + type]) {
				return this._cache[url + type];
			}
		},
		enableRetry: function () {
			for (var key in this._handlers) {
				this._handlers[key].retryRequests = true;
			}
		},
		disableRetry: function () {
			for (var key in this._handlers) {
				this._handlers[key].retryRequests = false;
			}
		},
		destroy: function () {
			this._handlers = {};
			this._requests = {};
			this._cache = {};
		}
	});

	function SceneHandler(app) {
		this._app = app;
		this.retryRequests = false;
	}
	Object.assign(SceneHandler.prototype, {
		load: function (url, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			var assets = this._app.assets;
			http.get(url.load, {
				retry: this.retryRequests
			}, function (err, response) {
				if (!err) {
					TemplateUtils.waitForTemplatesInScene(
						response,
						assets,
						callback);
				} else {
					var errMsg = 'Error while loading scene ' + url.original;
					if (err.message) {
						errMsg += ': ' + err.message;
						if (err.stack) {
							errMsg += '\n' + err.stack;
						}
					} else {
						errMsg += ': ' + err;
					}
					callback(errMsg);
				}
			});
		},
		open: function (url, data) {
			this._app.systems.script.preloading = true;
			var parser = new SceneParser(this._app, false);
			var parent = parser.parse(data);
			var scene = this._app.scene;
			scene.root = parent;
			this._app.applySceneSettings(data.settings);
			this._app.systems.script.preloading = false;
			return scene;
		},
		patch: function (asset, assets) {
		}
	});

	function SceneSettingsHandler(app) {
		this._app = app;
		this.retryRequests = false;
	}
	Object.assign(SceneSettingsHandler.prototype, {
		load: function (url, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			http.get(url.load, {
				retry: this.retryRequests
			}, function (err, response) {
				if (!err) {
					callback(null, response);
				} else {
					var errMsg = 'Error while loading scene settings ' + url.original;
					if (err.message) {
						errMsg += ': ' + err.message;
						if (err.stack) {
							errMsg += '\n' + err.stack;
						}
					} else {
						errMsg += ': ' + err;
					}
					callback(errMsg);
				}
			});
		},
		open: function (url, data) {
			return data.settings;
		}
	});

	var _legacy = false;
	var _createdLoadingScreen = false;
	var script = {
		app: null,
		create: function (name, callback) {
			if (!_legacy)
				return;
			var ScriptType = callback(script.app);
			ScriptType._pcScriptName = name;
			ScriptHandler._push(ScriptType);
			this.fire("created", name, callback);
		},
		attribute: function (name, type, defaultValue, options) {
		},
		createLoadingScreen: function (callback) {
			if (_createdLoadingScreen)
				return;
			_createdLoadingScreen = true;
			var app = Application.getApplication();
			callback(app);
		}
	};
	Object.defineProperty(script, 'legacy', {
		get: function () {
			return _legacy;
		},
		set: function (value) {
			_legacy = value;
		}
	});
	events.attach(script);

	function ScriptHandler(app) {
		this._app = app;
		this._scripts = { };
		this._cache = { };
	}
	ScriptHandler._types = [];
	ScriptHandler._push = function (Type) {
		if (script.legacy && ScriptHandler._types.length > 0) {
			console.assert("Script Ordering Error. Contact support@playcanvas.com");
		} else {
			ScriptHandler._types.push(Type);
		}
	};
	Object.assign(ScriptHandler.prototype, {
		load: function (url, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			var self = this;
			script.app = this._app;
			this._loadScript(url.load, function (err, url, extra) {
				if (!err) {
					if (script.legacy) {
						var Type = null;
						if (ScriptHandler._types.length) {
							Type = ScriptHandler._types.pop();
						}
						if (Type) {
							this._scripts[url] = Type;
						} else {
							Type = null;
						}
						callback(null, Type, extra);
					} else {
						var obj = { };
						for (var i = 0; i < ScriptHandler._types.length; i++)
							obj[ScriptHandler._types[i].name] = ScriptHandler._types[i];
						ScriptHandler._types.length = 0;
						callback(null, obj, extra);
						delete self._loader._cache[url + 'script'];
					}
				} else {
					callback(err);
				}
			}.bind(this));
		},
		open: function (url, data) {
			return data;
		},
		patch: function (asset, assets) { },
		_loadScript: function (url, callback) {
			var head = document.head;
			var element = document.createElement('script');
			this._cache[url] = element;
			element.async = false;
			element.addEventListener('error', function (e) {
				callback("Script: " + e.target.src + " failed to load");
			}, false);
			var done = false;
			element.onload = element.onreadystatechange = function () {
				if (!done && (!this.readyState || (this.readyState == "loaded" || this.readyState == "complete"))) {
					done = true;
					callback(null, url, element);
				}
			};
			element.src = url;
			head.appendChild(element);
		}
	});

	function ShaderHandler() {
		this.retryRequests = false;
	}
	Object.assign(ShaderHandler.prototype, {
		load: function (url, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			http.get(url.load, {
				retry: this.retryRequests
			}, function (err, response) {
				if (!err) {
					callback(null, response);
				} else {
					callback("Error loading shader resource: " + url.original + " [" + err + "]");
				}
			});
		},
		open: function (url, data) {
			return data;
		},
		patch: function (asset, assets) {
		}
	});

	var spriteNormals = [
		0, 0, 1,
		0, 0, 1,
		0, 0, 1,
		0, 0, 1
	];
	var spriteIndices = [
		0, 1, 3,
		2, 3, 1
	];
	function Sprite(device, options) {
		EventHandler.call(this);
		this._device = device;
		this._pixelsPerUnit = options && options.pixelsPerUnit !== undefined ? options.pixelsPerUnit : 1;
		this._renderMode = options && options.renderMode !== undefined ? options.renderMode : SPRITE_RENDERMODE_SIMPLE;
		this._atlas = options && options.atlas !== undefined ? options.atlas : null;
		this._frameKeys = options && options.frameKeys !== undefined ? options.frameKeys : null;
		this._meshes = [];
		this._updatingProperties = false;
		this._meshesDirty = false;
		if (this._atlas && this._frameKeys) {
			this._createMeshes();
		}
	}
	Sprite.prototype = Object.create(EventHandler.prototype);
	Sprite.prototype.constructor = Sprite;
	Sprite.prototype._createMeshes = function () {
		var i, len;
		for (i = 0, len = this._meshes.length; i < len; i++) {
			var mesh = this._meshes[i];
			if (!mesh) continue;
			mesh.vertexBuffer.destroy();
			for (var j = 0, len2 = mesh.indexBuffer.length; j < len2; j++) {
				mesh.indexBuffer[j].destroy();
			}
		}
		var count = this._frameKeys.length;
		this._meshes = new Array(count);
		var createMeshFunc = (this.renderMode === SPRITE_RENDERMODE_SLICED || this._renderMode === SPRITE_RENDERMODE_TILED ? this._create9SliceMesh : this._createSimpleMesh);
		for (i = 0; i < count; i++) {
			var frame = this._atlas.frames[this._frameKeys[i]];
			this._meshes[i] = frame ? createMeshFunc.call(this, frame) : null;
		}
		this.fire('set:meshes');
	};
	Sprite.prototype._createSimpleMesh = function (frame) {
		var rect = frame.rect;
		var texWidth = this._atlas.texture.width;
		var texHeight = this._atlas.texture.height;
		var w = rect.z / this._pixelsPerUnit;
		var h = rect.w / this._pixelsPerUnit;
		var hp = frame.pivot.x;
		var vp = frame.pivot.y;
		var positions = [
			-hp * w,	  -vp * h,	  0,
			(1 - hp) * w, -vp * h,	  0,
			(1 - hp) * w, (1 - vp) * h, 0,
			-hp * w,	  (1 - vp) * h, 0
		];
		var lu = rect.x / texWidth;
		var bv = rect.y / texHeight;
		var ru = (rect.x + rect.z) / texWidth;
		var tv = (rect.y + rect.w) / texHeight;
		var uvs = [
			lu, bv,
			ru, bv,
			ru, tv,
			lu, tv
		];
		var mesh = createMesh(this._device, positions, {
			uvs: uvs,
			normals: spriteNormals,
			indices: spriteIndices
		});
		return mesh;
	};
	Sprite.prototype._create9SliceMesh = function () {
		var he = Vec2.ONE;
		var ws = 3;
		var ls = 3;
		var i, j;
		var x, y, z, u, v;
		var positions = [];
		var normals = [];
		var uvs = [];
		var indices = [];
		var vcounter = 0;
		for (i = 0; i <= ws; i++) {
			u = (i === 0 || i === ws) ? 0 : 1;
			for (j = 0; j <= ls; j++) {
				x = -he.x + 2.0 * he.x * (i <= 1 ? 0 : 3) / ws;
				y = 0.0;
				z = -(-he.y + 2.0 * he.y * (j <= 1 ? 0 : 3) / ls);
				v = (j === 0 || j === ls) ? 0 : 1;
				positions.push(-x, y, z);
				normals.push(0.0, 1.0, 0.0);
				uvs.push(u, v);
				if ((i < ws) && (j < ls)) {
					indices.push(vcounter + ls + 1, vcounter + 1, vcounter);
					indices.push(vcounter + ls + 1, vcounter + ls + 2, vcounter + 1);
				}
				vcounter++;
			}
		}
		var options = {
			normals: normals,
			uvs: uvs,
			indices: indices
		};
		return createMesh(this._device, positions, options);
	};
	Sprite.prototype._onSetFrames = function (frames) {
		if (this._updatingProperties) {
			this._meshesDirty = true;
		} else {
			this._createMeshes();
		}
	};
	Sprite.prototype._onFrameChanged = function (frameKey, frame) {
		var idx = this._frameKeys.indexOf(frameKey);
		if (idx < 0) return;
		if (frame) {
			if (this.renderMode === SPRITE_RENDERMODE_SIMPLE) {
				this._meshes[idx] = this._createSimpleMesh(frame);
			}
		} else {
			this._meshes[idx] = null;
		}
		this.fire('set:meshes');
	};
	Sprite.prototype._onFrameRemoved = function (frameKey) {
		var idx = this._frameKeys.indexOf(frameKey);
		if (idx < 0) return;
		this._meshes[idx] = null;
		this.fire('set:meshes');
	};
	Sprite.prototype.startUpdate = function () {
		this._updatingProperties = true;
		this._meshesDirty = false;
	};
	Sprite.prototype.endUpdate = function () {
		this._updatingProperties = false;
		if (this._meshesDirty && this._atlas && this._frameKeys) {
			this._createMeshes();
		}
		this._meshesDirty = false;
	};
	Sprite.prototype.destroy = function () {
		var i;
		var len;
		for (i = 0, len = this._meshes.length; i < len; i++) {
			var mesh = this._meshes[i];
			if (!mesh) continue;
			mesh.vertexBuffer.destroy();
			for (var j = 0, len2 = mesh.indexBuffer.length; j < len2; j++) {
				mesh.indexBuffer[j].destroy();
			}
		}
		this._meshes.length = 0;
	};
	Object.defineProperty(Sprite.prototype, 'frameKeys', {
		get: function () {
			return this._frameKeys;
		},
		set: function (value) {
			this._frameKeys = value;
			if (this._atlas && this._frameKeys) {
				if (this._updatingProperties) {
					this._meshesDirty = true;
				} else {
					this._createMeshes();
				}
			}
			this.fire('set:frameKeys', value);
		}
	});
	Object.defineProperty(Sprite.prototype, 'atlas', {
		get: function () {
			return this._atlas;
		},
		set: function (value) {
			if (value === this._atlas) return;
			if (this._atlas) {
				this._atlas.off('set:frames', this._onSetFrames, this);
				this._atlas.off('set:frame', this._onFrameChanged, this);
				this._atlas.off('remove:frame', this._onFrameRemoved, this);
			}
			this._atlas = value;
			if (this._atlas && this._frameKeys) {
				this._atlas.on('set:frames', this._onSetFrames, this);
				this._atlas.on('set:frame', this._onFrameChanged, this);
				this._atlas.on('remove:frame', this._onFrameRemoved, this);
				if (this._updatingProperties) {
					this._meshesDirty = true;
				} else {
					this._createMeshes();
				}
			}
			this.fire('set:atlas', value);
		}
	});
	Object.defineProperty(Sprite.prototype, 'pixelsPerUnit', {
		get: function () {
			return this._pixelsPerUnit;
		},
		set: function (value) {
			if (this._pixelsPerUnit === value) return;
			this._pixelsPerUnit = value;
			this.fire('set:pixelsPerUnit', value);
			if (this._atlas && this._frameKeys && this.renderMode === SPRITE_RENDERMODE_SIMPLE) {
				if (this._updatingProperties) {
					this._meshesDirty = true;
				} else {
					this._createMeshes();
				}
			}
		}
	});
	Object.defineProperty(Sprite.prototype, 'renderMode', {
		get: function () {
			return this._renderMode;
		},
		set: function (value) {
			if (this._renderMode === value)
				return;
			var prev = this._renderMode;
			this._renderMode = value;
			this.fire('set:renderMode', value);
			if (prev === SPRITE_RENDERMODE_SIMPLE || value === SPRITE_RENDERMODE_SIMPLE) {
				if (this._atlas && this._frameKeys) {
					if (this._updatingProperties) {
						this._meshesDirty = true;
					} else {
						this._createMeshes();
					}
				}
			}
		}
	});
	Object.defineProperty(Sprite.prototype, 'meshes', {
		get: function () {
			return this._meshes;
		}
	});

	function SpriteHandler(assets, device) {
		this._assets = assets;
		this._device = device;
		this.retryRequests = false;
	}
	function onTextureAtlasLoaded(atlasAsset) {
		var spriteAsset = this;
		if (spriteAsset.resource) {
			spriteAsset.resource.atlas = atlasAsset.resource;
		}
	}
	function onTextureAtlasAdded(atlasAsset) {
		var spriteAsset = this;
		spriteAsset.registry.load(atlasAsset);
	}
	Object.assign(SpriteHandler.prototype, {
		load: function (url, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			if (path.getExtension(url.original) === '.json') {
				http.get(url.load, {
					retry: this.retryRequests
				}, function (err, response) {
					if (!err) {
						callback(null, response);
					} else {
						callback(err);
					}
				});
			}
		},
		open: function (url, data) {
			var sprite = new Sprite(this._device);
			if (url) {
				sprite.__data = data;
			}
			return sprite;
		},
		patch: function (asset, assets) {
			var sprite = asset.resource;
			if (sprite.__data) {
				asset.data.pixelsPerUnit = sprite.__data.pixelsPerUnit;
				asset.data.renderMode = sprite.__data.renderMode;
				asset.data.frameKeys = sprite.__data.frameKeys;
				if (sprite.__data.textureAtlasAsset) {
					var atlas = assets.getByUrl(sprite.__data.textureAtlasAsset);
					if (atlas) {
						asset.data.textureAtlasAsset = atlas.id;
					} else {
						console.warn("Could not find textureatlas with url: " + sprite.__data.textureAtlasAsset);
					}
				}
			}
			sprite.startUpdate();
			sprite.renderMode = asset.data.renderMode;
			sprite.pixelsPerUnit = asset.data.pixelsPerUnit;
			sprite.frameKeys = asset.data.frameKeys;
			this._updateAtlas(asset);
			sprite.endUpdate();
			asset.off('change', this._onAssetChange, this);
			asset.on('change', this._onAssetChange, this);
		},
		_updateAtlas: function (asset) {
			var sprite = asset.resource;
			if (!asset.data.textureAtlasAsset) {
				sprite.atlas = null;
				return;
			}
			this._assets.off('load:' + asset.data.textureAtlasAsset, onTextureAtlasLoaded, asset);
			this._assets.on('load:' + asset.data.textureAtlasAsset, onTextureAtlasLoaded, asset);
			var atlasAsset = this._assets.get(asset.data.textureAtlasAsset);
			if (atlasAsset && atlasAsset.resource) {
				sprite.atlas = atlasAsset.resource;
			} else {
				if (!atlasAsset) {
					this._assets.off('add:' + asset.data.textureAtlasAsset, onTextureAtlasAdded, asset);
					this._assets.on('add:' + asset.data.textureAtlasAsset, onTextureAtlasAdded, asset);
				} else {
					this._assets.load(atlasAsset);
				}
			}
		},
		_onAssetChange: function (asset, attribute, value, oldValue) {
			if (attribute === 'data') {
				if (value && value.textureAtlasAsset && oldValue && value.textureAtlasAsset !== oldValue.textureAtlasAsset) {
					this._assets.off('load:' + oldValue.textureAtlasAsset, onTextureAtlasLoaded, asset);
					this._assets.off('add:' + oldValue.textureAtlasAsset, onTextureAtlasAdded, asset);
				}
			}
		}
	});

	function Template(app, data) {
		this._app = app;
		this._data = data;
		this._expandedData = {};
		this._templateRoot = null;
	}
	Template.prototype.instantiate = function () {
		if (!this._templateRoot) {
			this._parseTemplate();
		}
		return this._templateRoot.clone();
	};
	Template.prototype.getExpandedData = function () {
		if (!this._expandedData.entities) {
			this._expandedData.entities = TemplateUtils.expandTemplateEntities(
				this._app, this._data.entities);
		}
		return this._expandedData;
	};
	Template.prototype._parseTemplate = function () {
		var parser = new SceneParser(this._app, true);
		this._templateRoot = parser.parse(this.getExpandedData());
	};

	function TemplateHandler(app) {
		this._app = app;
	}
	Object.assign(TemplateHandler.prototype, {
		load: function (url, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			var assets = this._app.assets;
			http.get(url.load, function (err, response) {
				if (err) {
					callback("Error requesting template: " + url.original);
				} else {
					TemplateUtils.waitForTemplateAssets(
						response.entities,
						assets,
						callback,
						response);
				}
			});
		},
		open: function (url, data) {
			return new Template(this._app, data);
		}
	});

	function TextHandler() {
		this.retryRequests = false;
	}
	Object.assign(TextHandler.prototype, {
		load: function (url, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			http.get(url.load, {
				retry: this.retryRequests
			}, function (err, response) {
				if (!err) {
					callback(null, response);
				} else {
					callback("Error loading text resource: " + url.original + " [" + err + "]");
				}
			});
		},
		open: function (url, data) {
			return data;
		},
		patch: function (asset, assets) {
		}
	});

	function TextureAtlas() {
		EventHandler.call(this);
		this._texture = null;
		this._frames = null;
	}
	TextureAtlas.prototype = Object.create(EventHandler.prototype);
	TextureAtlas.prototype.constructor = TextureAtlas;
	TextureAtlas.prototype.setFrame = function (key, data) {
		var frame = this._frames[key];
		if (!frame) {
			frame = {
				rect: data.rect.clone(),
				pivot: data.pivot.clone(),
				border: data.border.clone()
			};
			this._frames[key] = frame;
		} else {
			frame.rect.copy(data.rect);
			frame.pivot.copy(data.pivot);
			frame.border.copy(data.border);
		}
		this.fire('set:frame', key.toString(), frame);
	};
	TextureAtlas.prototype.removeFrame = function (key) {
		var frame = this._frames[key];
		if (frame) {
			delete this._frames[key];
			this.fire('remove:frame', key.toString(), frame);
		}
	};
	TextureAtlas.prototype.destroy = function () {
		if (this._texture) {
			this._texture.destroy();
		}
	};
	Object.defineProperty(TextureAtlas.prototype, 'texture', {
		get: function () {
			return this._texture;
		},
		set: function (value) {
			this._texture = value;
			this.fire('set:texture', value);
		}
	});
	Object.defineProperty(TextureAtlas.prototype, 'frames', {
		get: function () {
			return this._frames;
		},
		set: function (value) {
			this._frames = value;
			this.fire('set:frames', value);
		}
	});

	var JSON_ADDRESS_MODE = {
		"repeat": ADDRESS_REPEAT,
		"clamp": ADDRESS_CLAMP_TO_EDGE,
		"mirror": ADDRESS_MIRRORED_REPEAT
	};
	var JSON_FILTER_MODE = {
		"nearest": FILTER_NEAREST,
		"linear": FILTER_LINEAR,
		"nearest_mip_nearest": FILTER_NEAREST_MIPMAP_NEAREST,
		"linear_mip_nearest": FILTER_LINEAR_MIPMAP_NEAREST,
		"nearest_mip_linear": FILTER_NEAREST_MIPMAP_LINEAR,
		"linear_mip_linear": FILTER_LINEAR_MIPMAP_LINEAR
	};
	var regexFrame = /^data\.frames\.(\d+)$/;
	function TextureAtlasHandler(loader) {
		this._loader = loader;
		this.retryRequests = false;
	}
	Object.assign(TextureAtlasHandler.prototype, {
		load: function (url, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			var self = this;
			var handler = this._loader.getHandler("texture");
			if (path.getExtension(url.original) === '.json') {
				http.get(url.load, {
					retry: this.retryRequests
				}, function (err, response) {
					if (!err) {
						var textureUrl = url.original.replace('.json', '.png');
						self._loader.load(textureUrl, "texture", function (err, texture) {
							if (err) {
								callback(err);
							} else {
								callback(null, {
									data: response,
									texture: texture
								});
							}
						});
					} else {
						callback(err);
					}
				});
			} else {
				return handler.load(url, callback);
			}
		},
		open: function (url, data) {
			var resource = new TextureAtlas();
			if (data.texture && data.data) {
				resource.texture = data.texture;
				resource.__data = data.data;
			} else {
				var handler = this._loader.getHandler("texture");
				var texture = handler.open(url, data);
				if (!texture) return null;
				resource.texture = texture;
			}
			return resource;
		},
		patch: function (asset, assets) {
			if (asset.resource.__data) {
				if (asset.resource.__data.minfilter !== undefined) asset.data.minfilter = asset.resource.__data.minfilter;
				if (asset.resource.__data.magfilter !== undefined) asset.data.magfilter = asset.resource.__data.magfilter;
				if (asset.resource.__data.addressu !== undefined) asset.data.addressu = asset.resource.__data.addressu;
				if (asset.resource.__data.addressv !== undefined) asset.data.addressv = asset.resource.__data.addressv;
				if (asset.resource.__data.mipmaps !== undefined) asset.data.mipmaps = asset.resource.__data.mipmaps;
				if (asset.resource.__data.anisotropy !== undefined) asset.data.anisotropy = asset.resource.__data.anisotropy;
				if (asset.resource.__data.rgbm !== undefined) asset.data.rgbm = !!asset.resource.__data.rgbm;
				asset.data.frames = asset.resource.__data.frames;
				delete asset.resource.__data;
			}
			var texture = asset.resource.texture;
			if (texture) {
				texture.name = asset.name;
				if (asset.data.hasOwnProperty('minfilter') && texture.minFilter !== JSON_FILTER_MODE[asset.data.minfilter])
					texture.minFilter = JSON_FILTER_MODE[asset.data.minfilter];
				if (asset.data.hasOwnProperty('magfilter') && texture.magFilter !== JSON_FILTER_MODE[asset.data.magfilter])
					texture.magFilter = JSON_FILTER_MODE[asset.data.magfilter];
				if (asset.data.hasOwnProperty('addressu') && texture.addressU !== JSON_ADDRESS_MODE[asset.data.addressu])
					texture.addressU = JSON_ADDRESS_MODE[asset.data.addressu];
				if (asset.data.hasOwnProperty('addressv') && texture.addressV !== JSON_ADDRESS_MODE[asset.data.addressv])
					texture.addressV = JSON_ADDRESS_MODE[asset.data.addressv];
				if (asset.data.hasOwnProperty('mipmaps') && texture.mipmaps !== asset.data.mipmaps)
					texture.mipmaps = asset.data.mipmaps;
				if (asset.data.hasOwnProperty('anisotropy') && texture.anisotropy !== asset.data.anisotropy)
					texture.anisotropy = asset.data.anisotropy;
				if (asset.data.hasOwnProperty('rgbm')) {
					var type = asset.data.rgbm ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT;
					if (texture.type !== type) {
						texture.type = type;
					}
				}
			}
			asset.resource.texture = texture;
			var frames = {};
			for (var key in asset.data.frames) {
				var frame = asset.data.frames[key];
				frames[key] = {
					rect: new Vec4(frame.rect),
					pivot: new Vec2(frame.pivot),
					border: new Vec4(frame.border)
				};
			}
			asset.resource.frames = frames;
			asset.off('change', this._onAssetChange, this);
			asset.on('change', this._onAssetChange, this);
		},
		_onAssetChange: function (asset, attribute, value) {
			var frame;
			if (attribute === 'data' || attribute === 'data.frames') {
				var frames = {};
				for (var key in value.frames) {
					frame = value.frames[key];
					frames[key] = {
						rect: new Vec4(frame.rect),
						pivot: new Vec2(frame.pivot),
						border: new Vec4(frame.border)
					};
				}
				asset.resource.frames = frames;
			} else {
				var match = attribute.match(regexFrame);
				if (match) {
					var frameKey = match[1];
					if (value) {
						if (!asset.resource.frames[frameKey]) {
							asset.resource.frames[frameKey] = {
								rect: new Vec4(value.rect),
								pivot: new Vec2(value.pivot),
								border: new Vec4(value.border)
							};
						} else {
							frame = asset.resource.frames[frameKey];
							frame.rect.set(value.rect[0], value.rect[1], value.rect[2], value.rect[3]);
							frame.pivot.set(value.pivot[0], value.pivot[1]);
							frame.border.set(value.border[0], value.border[1], value.border[2], value.border[3]);
						}
						asset.resource.fire('set:frame', frameKey, asset.resource.frames[frameKey]);
					} else {
						if (asset.resource.frames[frameKey]) {
							delete asset.resource.frames[frameKey];
							asset.resource.fire('remove:frame', frameKey);
						}
					}
				}
			}
		}
	});

	function BasisWorker() {
		var BASIS_FORMAT = {
			cTFETC1: 0,
			cTFETC2: 1,
			cTFBC1: 2,
			cTFBC3: 3,
			cTFPVRTC1_4_RGB: 8,
			cTFPVRTC1_4_RGBA: 9,
			cTFASTC_4x4: 10,
			cTFATC_RGB: 11,
			cTFATC_RGBA_INTERPOLATED_ALPHA: 12,
			cTFRGBA32: 13,
			cTFRGB565: 14,
			cTFRGBA4444: 16
		};
		var opaqueMapping = {
			astc: BASIS_FORMAT.cTFASTC_4x4,
			dxt: BASIS_FORMAT.cTFBC1,
			etc2: BASIS_FORMAT.cTFETC1,
			etc1: BASIS_FORMAT.cTFETC1,
			pvr: BASIS_FORMAT.cTFPVRTC1_4_RGB,
			atc: BASIS_FORMAT.cTFATC_RGB,
			none: BASIS_FORMAT.cTFRGB565
		};
		var alphaMapping = {
			astc: BASIS_FORMAT.cTFASTC_4x4,
			dxt: BASIS_FORMAT.cTFBC3,
			etc2: BASIS_FORMAT.cTFETC2,
			etc1: BASIS_FORMAT.cTFRGBA4444,
			pvr: BASIS_FORMAT.cTFPVRTC1_4_RGBA,
			atc: BASIS_FORMAT.cTFATC_RGBA_INTERPOLATED_ALPHA,
			none: BASIS_FORMAT.cTFRGBA4444
		};
		var basisToEngineMapping = { };
		basisToEngineMapping[BASIS_FORMAT.cTFETC1]		  = PIXELFORMAT_ETC1;
		basisToEngineMapping[BASIS_FORMAT.cTFETC2]		  = PIXELFORMAT_ETC2_RGBA;
		basisToEngineMapping[BASIS_FORMAT.cTFBC1]		   = PIXELFORMAT_DXT1;
		basisToEngineMapping[BASIS_FORMAT.cTFBC3]		   = PIXELFORMAT_DXT5;
		basisToEngineMapping[BASIS_FORMAT.cTFPVRTC1_4_RGB]  = PIXELFORMAT_PVRTC_4BPP_RGB_1;
		basisToEngineMapping[BASIS_FORMAT.cTFPVRTC1_4_RGBA] = PIXELFORMAT_PVRTC_4BPP_RGBA_1;
		basisToEngineMapping[BASIS_FORMAT.cTFASTC_4x4]	  = PIXELFORMAT_ASTC_4x4;
		basisToEngineMapping[BASIS_FORMAT.cTFATC_RGB]	   = PIXELFORMAT_ATC_RGB;
		basisToEngineMapping[BASIS_FORMAT.cTFATC_RGBA_INTERPOLATED_ALPHA] = PIXELFORMAT_ATC_RGBA;
		basisToEngineMapping[BASIS_FORMAT.cTFRGBA32]		= PIXELFORMAT_R8_G8_B8_A8;
		basisToEngineMapping[BASIS_FORMAT.cTFRGB565]		= PIXELFORMAT_R5_G6_B5;
		basisToEngineMapping[BASIS_FORMAT.cTFRGBA4444]	  = PIXELFORMAT_R4_G4_B4_A4;
		var hasPerformance = typeof performance !== 'undefined';
		var unswizzleGGGR = function (data) {
			var genB = function (R, G) {
				var r = R * (2.0 / 255.0) - 1.0;
				var g = G * (2.0 / 255.0) - 1.0;
				var b = Math.sqrt(1.0 - Math.min(1.0, r * r + g * g));
				return Math.max(0, Math.min(255, Math.floor(((b + 1.0) * 0.5) * 255.0)));
			};
			for (var offset = 0; offset < data.length; offset += 4) {
				var R = data[offset + 3];
				var G = data[offset + 1];
				data[offset + 0] = R;
				data[offset + 2] = genB(R, G);
				data[offset + 3] = 255;
			}
			return data;
		};
		var pack565 = function (data) {
			var result = new Uint16Array(data.length / 4);
			for (var offset = 0; offset < data.length; offset += 4) {
				var R = data[offset + 0];
				var G = data[offset + 1];
				var B = data[offset + 2];
				result[offset / 4] = ((R & 0xf8) << 8) |
									 ((G & 0xfc) << 3) |
									 ((B >> 3));
			}
			return result;
		};
		var transcode = function (basis, url, format, data, options) {
			var funcStart = hasPerformance ? performance.now() : 0;
			var basisFile = new basis.BasisFile(new Uint8Array(data));
			var width = basisFile.getImageWidth(0, 0);
			var height = basisFile.getImageHeight(0, 0);
			var images = basisFile.getNumImages();
			var levels = basisFile.getNumLevels(0);
			var hasAlpha = !!basisFile.getHasAlpha();
			if (!width || !height || !images || !levels) {
				basisFile.close();
				basisFile.delete();
				throw new Error('Invalid image dimensions url=' + url + ' width=' + width + ' height=' + height + ' images=' + images + ' levels=' + levels);
			}
			var basisFormat = hasAlpha ? alphaMapping[format] : opaqueMapping[format];
			if ((basisFormat === BASIS_FORMAT.cTFPVRTC1_4_RGB ||
				 basisFormat === BASIS_FORMAT.cTFPVRTC1_4_RGBA)) {
				if (((width & (width - 1)) !== 0) || (width !== height)) {
					basisFormat = (basisFormat === BASIS_FORMAT.cTFPVRTC1_4_RGB) ?
						BASIS_FORMAT.cTFRGB565 : BASIS_FORMAT.cTFRGBA32;
				}
			}
			if (options && options.unswizzleGGGR) {
				basisFormat = BASIS_FORMAT.cTFRGBA32;
			}
			if (!basisFile.startTranscoding()) {
				basisFile.close();
				basisFile.delete();
				throw new Error('Failed to start transcoding url=' + url);
			}
			var i;
			var levelData = [];
			for (var mip = 0; mip < levels; ++mip) {
				var dstSize = basisFile.getImageTranscodedSizeInBytes(0, mip, basisFormat);
				var dst = new Uint8Array(dstSize);
				if (!basisFile.transcodeImage(dst, 0, mip, basisFormat, 1, 0)) {
					basisFile.close();
					basisFile.delete();
					throw new Error('Failed to transcode image url=' + url);
				}
				if (basisFormat === BASIS_FORMAT.cTFRGB565 || basisFormat === BASIS_FORMAT.cTFRGBA4444) {
					var dst16 = new Uint16Array(dstSize / 2);
					for (i = 0; i < dstSize / 2; ++i) {
						dst16[i] = dst[i * 2] + dst[i * 2 + 1] * 256;
					}
					dst = dst16;
				}
				levelData.push(dst);
			}
			basisFile.close();
			basisFile.delete();
			if (options && options.unswizzleGGGR) {
				basisFormat = BASIS_FORMAT.cTFRGB565;
				for (i = 0; i < levelData.length; ++i) {
					levelData[i] = pack565(unswizzleGGGR(levelData[i]));
				}
			}
			return {
				format: basisToEngineMapping[basisFormat],
				width: (width + 3) & ~3,
				height: (height + 3) & ~3,
				levels: levelData,
				cubemap: false,
				mipmaps: true,
				transcodeTime: hasPerformance ? (performance.now() - funcStart) : 0,
				url: url
			};
		};
		var basis = null;
		var queue = [];
		var workerTranscode = function (url, format, data, options) {
			try {
				var result = transcode(basis, url, format, data, options);
				result.levels = result.levels.map(function (v) {
					return v.buffer;
				});
				self.postMessage( { url: url, data: result }, result.levels);
			} catch (err) {
				self.postMessage( { url: url.toString(), err: err.toString() } );
			}
		};
		var workerInit = function (basisModule) {
			var instantiateWasmFunc = function (imports, successCallback) {
				WebAssembly.instantiate(basisModule, imports)
					.then( function (result) {
						successCallback(result);
					});
				return {};
			};
			self.BASIS(basisModule ? { instantiateWasm: instantiateWasmFunc } : null).then( function (instance) {
				basis = instance;
				basis.initializeBasis();
				for (var i = 0; i < queue.length; ++i) {
					workerTranscode(queue[i].url, queue[i].format, queue[i].data, queue[i].options);
				}
				queue = [];
			} );
		};
		self.onmessage = function (message) {
			var data = message.data;
			switch (data.type) {
				case 'init':
					workerInit(data.module);
					break;
				case 'transcode':
					if (basis) {
						workerTranscode(data.url, data.format, data.data, data.options);
					} else {
						queue.push(data);
					}
					break;
			}
		};
	}
	var wasmSupported = (function () {
		try {
			if (typeof WebAssembly === "object" && typeof WebAssembly.instantiate === "function") {
				var module = new WebAssembly.Module(Uint8Array.of(0x0, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00));
				if (module instanceof WebAssembly.Module)
					return new WebAssembly.Instance(module) instanceof WebAssembly.Instance;
			}
		} catch (e) { }
		return false;
	})();
	function chooseTargetFormat(device) {
		if (device.extCompressedTextureASTC) {
			return 'astc';
		} else if (device.extCompressedTextureS3TC) {
			return 'dxt';
		} else if (device.extCompressedTextureETC) {
			return 'etc2';
		} else if (device.extCompressedTextureETC1) {
			return 'etc1';
		} else if (device.extCompressedTexturePVRTC) {
			return 'pvr';
		} else if (device.extCompressedTextureATC) {
			return 'atc';
		}
		return 'none';
	}
	var downloadInitiated = false;
	var worker = null;
	var callbacks = { };
	var format = null;
	var transcodeQueue = [];
	function basisTargetFormat() {
		if (!format) {
			format = chooseTargetFormat(Application.getApplication().graphicsDevice);
		}
		return format;
	}
	function handleWorkerResponse(message) {
		var url = message.data.url;
		var err = message.data.err;
		var data = message.data.data;
		var callback = callbacks[url];
		if (!callback) {
			console.error('internal logical error encountered in basis transcoder');
			return;
		}
		var i;
		if (err) {
			for (i = 0; i < callback.length; ++i) {
				(callback[i])(err);
			}
			return;
		}
		if (data.format === PIXELFORMAT_R5_G6_B5 || data.format === PIXELFORMAT_R4_G4_B4_A4) {
			data.levels = data.levels.map(function (v) {
				return new Uint16Array(v);
			});
		} else {
			data.levels = data.levels.map(function (v) {
				return new Uint8Array(v);
			});
		}
		for (i = 0; i < callback.length; ++i) {
			(callback[i])(null, data);
		}
		delete callbacks[url];
	}
	function transcode(url, data, callback, options) {
		if (!callbacks.hasOwnProperty(url)) {
			callbacks[url] = [callback];
			worker.postMessage({ type: 'transcode', url: url, format: basisTargetFormat(), data: data, options: options }, [data]);
		} else {
			callbacks[url].push(callback);
		}
	}
	function basisInitialize(basisCode, basisModule, callback) {
		var code = [
			"/* basis.js */",
			basisCode,
			"/* mappings */",
			"var PIXELFORMAT_ETC1 = " + PIXELFORMAT_ETC1 + ";",
			"var PIXELFORMAT_ETC2_RGBA = " + PIXELFORMAT_ETC2_RGBA + ";",
			"var PIXELFORMAT_DXT1 = " + PIXELFORMAT_DXT1 + ";",
			"var PIXELFORMAT_DXT5 = " + PIXELFORMAT_DXT5 + ";",
			"var PIXELFORMAT_PVRTC_4BPP_RGB_1 = " + PIXELFORMAT_PVRTC_4BPP_RGB_1 + ";",
			"var PIXELFORMAT_PVRTC_4BPP_RGBA_1 = " + PIXELFORMAT_PVRTC_4BPP_RGBA_1 + ";",
			"var PIXELFORMAT_ASTC_4x4 = " + PIXELFORMAT_ASTC_4x4 + ";",
			"var PIXELFORMAT_ATC_RGB = " + PIXELFORMAT_ATC_RGB + ";",
			"var PIXELFORMAT_ATC_RGBA = " + PIXELFORMAT_ATC_RGBA + ";",
			"var PIXELFORMAT_R8_G8_B8_A8 = " + PIXELFORMAT_R8_G8_B8_A8 + ";",
			"var PIXELFORMAT_R5_G6_B5 = " + PIXELFORMAT_R5_G6_B5 + ";",
			"var PIXELFORMAT_R4_G4_B4_A4 = " + PIXELFORMAT_R4_G4_B4_A4 + ";",
			"",
			"/* worker */",
			'(' + BasisWorker.toString() + ')()\n\n'
		].join('\n');
		var blob = new Blob([code], { type: 'application/javascript' });
		var url = URL.createObjectURL(blob);
		worker = new Worker(url);
		worker.addEventListener('message', handleWorkerResponse);
		worker.postMessage({ type: 'init', module: basisModule });
		if (callback) {
			callback();
		}
		for (var i = 0; i < transcodeQueue.length; ++i) {
			var entry = transcodeQueue[i];
			transcode(entry.url, entry.data, entry.callback, entry.options);
		}
	}
	function basisDownload(glueUrl, wasmUrl, fallbackUrl, callback) {
		if (downloadInitiated) {
			console.warn('basis module is being downloaded more than once');
		}
		downloadInitiated = true;
		if (wasmSupported) {
			var glueCode = null;
			var compiledModule = null;
			var downloadCompleted = function () {
				if (glueCode && compiledModule) {
					basisInitialize(glueCode, compiledModule, callback);
				}
			};
			var performHttpDownload = function () {
				http.get(
					wasmUrl,
					{ cache: true, responseType: "arraybuffer", retry: false },
					function (err, result) {
						if (result) {
							WebAssembly.compile(result)
								.then(function (result) {
									compiledModule = result;
									downloadCompleted();
								});
						}
					});
			};
			if (WebAssembly.compileStreaming) {
				WebAssembly.compileStreaming(fetch(wasmUrl))
					.then(function (result) {
						compiledModule = result;
						downloadCompleted();
					})
					.catch(function (reason) {
						console.error(reason);
						console.warn('compileStreaming() failed for ' + wasmUrl + ', falling back to arraybuffer download...');
						performHttpDownload();
					});
			} else {
				performHttpDownload();
			}
			http.get(
				glueUrl,
				{ cache: true, responseType: "text", retry: false },
				function (err, result) {
					glueCode = result;
					downloadCompleted();
				});
		} else {
			http.get(
				fallbackUrl,
				{ cache: true, responseType: "text", retry: false },
				function (err, result) {
					if (result) {
						basisInitialize(result, null, callback);
					}
				});
		}
	}
	function basisDownloadFromConfig(callback) {
		var modules = (window.config ? window.config.wasmModules : window.PRELOAD_MODULES) || [];
		var wasmModule = modules.find(function (m) {
			return m.moduleName === 'BASIS';
		});
		if (wasmModule) {
			var urlBase = window.ASSET_PREFIX ? window.ASSET_PREFIX : "";
			basisDownload(urlBase + wasmModule.glueUrl,
						  urlBase + wasmModule.wasmUrl,
						  urlBase + wasmModule.fallbackUrl,
						  callback);
		}
	}
	function basisTranscode(url, data, callback, options) {
		if (!worker) {
			transcodeQueue.push({ url: url, data: data, callback: callback, options: options });
			if (!downloadInitiated) {
				basisDownloadFromConfig();
			}
		} else {
			transcode(url, data, callback, options);
		}
	}

	function BasisParser(registry, retryRequests) {
		this.retryRequests = !!retryRequests;
	}
	Object.assign(BasisParser.prototype, {
		load: function (url, callback, asset) {
			var options = {
				cache: true,
				responseType: "arraybuffer",
				retry: this.retryRequests
			};
			http.get(
				url.load,
				options,
				function (err, result) {
					if (err) {
						callback(err, result);
					} else {
						var unswizzleGGGR = basisTargetFormat() === 'pvr' &&
											asset && asset.file && asset.file.variants &&
											asset.file.variants.basis &&
											((asset.file.variants.basis.opt & 8) !== 0);
						if (unswizzleGGGR) {
							asset.file.variants.basis.opt &= ~8;
						}
						basisTranscode(url.load, result, callback, { unswizzleGGGR: unswizzleGGGR });
					}
				}
			);
		},
		open: function (url, data, device) {
			var texture = new Texture(device, {
				name: url,
				addressU: data.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
				addressV: data.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
				width: data.width,
				height: data.height,
				format: data.format,
				cubemap: data.cubemap,
				levels: data.levels
			});
			texture.upload();
			return texture;
		}
	});

	function ImgParser(registry, retryRequests) {
		this.crossOrigin = registry.prefix ? 'anonymous' : null;
		this.retryRequests = !!retryRequests;
		this.useImageBitmap = false  ;
	}
	Object.assign(ImgParser.prototype, {
		load: function (url, callback, asset) {
			var crossOrigin;
			if (asset && asset.options && asset.options.hasOwnProperty('crossOrigin')) {
				crossOrigin = asset.options.crossOrigin;
			} else if (ABSOLUTE_URL.test(url.load)) {
				crossOrigin = this.crossOrigin;
			}
			if (this.useImageBitmap) {
				this._loadImageBitmap(url.load, url.original, crossOrigin, callback);
			} else {
				this._loadImage(url.load, url.original, crossOrigin, callback);
			}
		},
		open: function (url, data, device) {
			var ext = path.getExtension(url).toLowerCase();
			var format = (ext === ".jpg" || ext === ".jpeg") ? PIXELFORMAT_R8_G8_B8 : PIXELFORMAT_R8_G8_B8_A8;
			var texture = new Texture(device, {
				name: url,
				width: data.width,
				height: data.height,
				format: format
			});
			texture.setSource(data);
			return texture;
		},
		_loadImage: function (url, originalUrl, crossOrigin, callback) {
			var image = new Image();
			if (crossOrigin) {
				image.crossOrigin = crossOrigin;
			}
			var retries = 0;
			var maxRetries = 5;
			var retryTimeout;
			var retryRequests = this.retryRequests;
			image.onload = function () {
				callback(null, image);
			};
			image.onerror = function () {
				if (retryTimeout) return;
				if (retryRequests && ++retries <= maxRetries) {
					var retryDelay = Math.pow(2, retries) * 100;
					console.log("Error loading Texture from: '" + originalUrl + "' - Retrying in " + retryDelay + "ms...");
					var idx = url.indexOf('?');
					var separator = idx >= 0 ? '&' : '?';
					retryTimeout = setTimeout(function () {
						image.src = url + separator + 'retry=' + Date.now();
						retryTimeout = null;
					}, retryDelay);
				} else {
					callback("Error loading Texture from: '" + originalUrl + "'");
				}
			};
			image.src = url;
		},
		_loadImageBitmap: function (url, originalUrl, crossOrigin, callback) {
			var options = {
				cache: true,
				responseType: "blob",
				retry: this.retryRequests
			};
			http.get(url, options, function (err, blob) {
				if (err) {
					callback(err);
				} else {
					createImageBitmap(blob, {
						premultiplyAlpha: 'none',
						imageOrientation: 'flipY'
					})
						.then( function (imageBitmap) {
							callback(null, imageBitmap);
						})
						.catch( function (e) {
							callback(e);
						});
				}
			});
		}
	});

	var IDENTIFIER = [0x58544BAB, 0xBB313120, 0x0A1A0A0D];
	var KNOWN_FORMATS = {
		0x83F0: PIXELFORMAT_DXT1,
		0x83F2: PIXELFORMAT_DXT3,
		0x83F3: PIXELFORMAT_DXT5,
		0x8D64: PIXELFORMAT_ETC1,
		0x9274: PIXELFORMAT_ETC2_RGB,
		0x9278: PIXELFORMAT_ETC2_RGBA,
		0x8C00: PIXELFORMAT_PVRTC_4BPP_RGB_1,
		0x8C01: PIXELFORMAT_PVRTC_2BPP_RGB_1,
		0x8C02: PIXELFORMAT_PVRTC_4BPP_RGBA_1,
		0x8C03: PIXELFORMAT_PVRTC_2BPP_RGBA_1
	};
	function KtxParser(registry, retryRequests) {
		this.retryRequests = !!retryRequests;
	}
	Object.assign(KtxParser.prototype, {
		load: function (url, callback, asset) {
			var options = {
				cache: true,
				responseType: "arraybuffer",
				retry: this.retryRequests
			};
			http.get(url.load, options, callback);
		},
		open: function (url, data, device) {
			var textureData = this.parse(data);
			if (!textureData) {
				return null;
			}
			var texture = new Texture(device, {
				name: url,
				addressU: textureData.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
				addressV: textureData.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
				width: textureData.width,
				height: textureData.height,
				format: textureData.format,
				cubemap: textureData.cubemap,
				levels: textureData.levels
			});
			texture.upload();
			return texture;
		},
		parse: function (data) {
			var headerU32 = new Uint32Array(data, 0, 16);
			if (IDENTIFIER[0] !== headerU32[0] || IDENTIFIER[1] !== headerU32[1] || IDENTIFIER[2] !== headerU32[2]) {
				return null;
			}
			var header = {
				endianness: headerU32[3],
				glType: headerU32[4],
				glTypeSize: headerU32[5],
				glFormat: headerU32[6],
				glInternalFormat: headerU32[7],
				glBaseInternalFormat: headerU32[8],
				pixelWidth: headerU32[9],
				pixelHeight: headerU32[10],
				pixelDepth: headerU32[11],
				numberOfArrayElements: headerU32[12],
				numberOfFaces: headerU32[13],
				numberOfMipmapLevels: headerU32[14],
				bytesOfKeyValueData: headerU32[15]
			};
			if (header.pixelDepth > 1) {
				return null;
			}
			if (header.numberOfArrayElements > 1) {
				return null;
			}
			if (header.glFormat !== 0) {
				return null;
			}
			if (!KNOWN_FORMATS[header.glInternalFormat]) {
				return null;
			}
			var offset = (16 * 4) + header.bytesOfKeyValueData;
			var levels = [];
			var isCubeMap = false;
			for (var mipmapLevel = 0; mipmapLevel < (header.numberOfMipmapLevels || 1); mipmapLevel++) {
				var imageSizeInBytes = new Uint32Array(data.slice(offset, offset + 4))[0];
				offset += 4;
				var faceSizeInBytes = imageSizeInBytes / (header.numberOfFaces || 1);
				if (header.numberOfFaces > 1) {
					isCubeMap = true;
					levels.push([]);
				}
				for (var face = 0; face < header.numberOfFaces; face++) {
					var mipData = new Uint8Array(data, offset, faceSizeInBytes);
					if (header.numberOfFaces > 1) {
						levels[mipmapLevel].push(mipData);
					} else {
						levels.push(mipData);
					}
					offset += faceSizeInBytes;
				}
				offset += 3 - ((offset + 3) % 4);
			}
			return {
				format: KNOWN_FORMATS[header.glInternalFormat],
				width: header.pixelWidth,
				height: header.pixelHeight,
				levels: levels,
				cubemap: isCubeMap
			};
		}
	});

	function LegacyDdsParser(registry, retryRequests) {
		this.retryRequests = !!retryRequests;
	}
	Object.assign(LegacyDdsParser.prototype, {
		load: function (url, callback, asset) {
			var options = {
				cache: true,
				responseType: "arraybuffer",
				retry: this.retryRequests
			};
			http.get(url.load, options, callback);
		},
		open: function (url, data, device) {
			var header = new Uint32Array(data, 0, 128 / 4);
			var width = header[4];
			var height = header[3];
			var mips = Math.max(header[7], 1);
			var isFourCc = header[20] === 4;
			var fcc = header[21];
			var bpp = header[22];
			var isCubemap = header[28] === 65024;
			var FCC_DXT1 = 827611204;
			var FCC_DXT5 = 894720068;
			var FCC_FP32 = 116;
			var FCC_ETC1 = 826496069;
			var FCC_PVRTC_2BPP_RGB_1 = 825438800;
			var FCC_PVRTC_2BPP_RGBA_1 = 825504336;
			var FCC_PVRTC_4BPP_RGB_1 = 825439312;
			var FCC_PVRTC_4BPP_RGBA_1 = 825504848;
			var compressed = false;
			var floating = false;
			var etc1 = false;
			var pvrtc2 = false;
			var pvrtc4 = false;
			var format = null;
			var texture;
			if (isFourCc) {
				if (fcc === FCC_DXT1) {
					format = PIXELFORMAT_DXT1;
					compressed = true;
				} else if (fcc === FCC_DXT5) {
					format = PIXELFORMAT_DXT5;
					compressed = true;
				} else if (fcc === FCC_FP32) {
					format = PIXELFORMAT_RGBA32F;
					floating = true;
				} else if (fcc === FCC_ETC1) {
					format = PIXELFORMAT_ETC1;
					compressed = true;
					etc1 = true;
				} else if (fcc === FCC_PVRTC_2BPP_RGB_1 || fcc === FCC_PVRTC_2BPP_RGBA_1) {
					format = fcc === FCC_PVRTC_2BPP_RGB_1 ? PIXELFORMAT_PVRTC_2BPP_RGB_1 : PIXELFORMAT_PVRTC_2BPP_RGBA_1;
					compressed = true;
					pvrtc2 = true;
				} else if (fcc === FCC_PVRTC_4BPP_RGB_1 || fcc === FCC_PVRTC_4BPP_RGBA_1) {
					format = fcc === FCC_PVRTC_4BPP_RGB_1 ? PIXELFORMAT_PVRTC_4BPP_RGB_1 : PIXELFORMAT_PVRTC_4BPP_RGBA_1;
					compressed = true;
					pvrtc4 = true;
				}
			} else {
				if (bpp === 32) {
					format = PIXELFORMAT_R8_G8_B8_A8;
				}
			}
			if (!format) {
				texture = new Texture(device, {
					width: 4,
					height: 4,
					format: PIXELFORMAT_R8_G8_B8
				});
				texture.name = 'dds-legacy-empty';
				return texture;
			}
			texture = new Texture(device, {
				name: url,
				addressU: isCubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
				addressV: isCubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
				width: width,
				height: height,
				format: format,
				cubemap: isCubemap
			});
			var offset = 128;
			var faces = isCubemap ? 6 : 1;
			var mipSize;
			var DXT_BLOCK_WIDTH = 4;
			var DXT_BLOCK_HEIGHT = 4;
			var blockSize = fcc === FCC_DXT1 ? 8 : 16;
			var numBlocksAcross, numBlocksDown, numBlocks;
			for (var face = 0; face < faces; face++) {
				var mipWidth = width;
				var mipHeight = height;
				for (var i = 0; i < mips; i++) {
					if (compressed) {
						if (etc1) {
							mipSize = Math.floor((mipWidth + 3) / 4) * Math.floor((mipHeight + 3) / 4) * 8;
						} else if (pvrtc2) {
							mipSize = Math.max(mipWidth, 16) * Math.max(mipHeight, 8) / 4;
						} else if (pvrtc4) {
							mipSize = Math.max(mipWidth, 8) * Math.max(mipHeight, 8) / 2;
						} else {
							numBlocksAcross = Math.floor((mipWidth + DXT_BLOCK_WIDTH - 1) / DXT_BLOCK_WIDTH);
							numBlocksDown = Math.floor((mipHeight + DXT_BLOCK_HEIGHT - 1) / DXT_BLOCK_HEIGHT);
							numBlocks = numBlocksAcross * numBlocksDown;
							mipSize = numBlocks * blockSize;
						}
					} else {
						mipSize = mipWidth * mipHeight * 4;
					}
					var mipBuff = floating ? new Float32Array(data, offset, mipSize) : new Uint8Array(data, offset, mipSize);
					if (!isCubemap) {
						texture._levels[i] = mipBuff;
					} else {
						if (!texture._levels[i]) texture._levels[i] = [];
						texture._levels[i][face] = mipBuff;
					}
					offset += floating ? mipSize * 4 : mipSize;
					mipWidth = Math.max(mipWidth * 0.5, 1);
					mipHeight = Math.max(mipHeight * 0.5, 1);
				}
			}
			texture.upload();
			return texture;
		}
	});

	var JSON_ADDRESS_MODE$1 = {
		"repeat": ADDRESS_REPEAT,
		"clamp": ADDRESS_CLAMP_TO_EDGE,
		"mirror": ADDRESS_MIRRORED_REPEAT
	};
	var JSON_FILTER_MODE$1 = {
		"nearest": FILTER_NEAREST,
		"linear": FILTER_LINEAR,
		"nearest_mip_nearest": FILTER_NEAREST_MIPMAP_NEAREST,
		"linear_mip_nearest": FILTER_LINEAR_MIPMAP_NEAREST,
		"nearest_mip_linear": FILTER_NEAREST_MIPMAP_LINEAR,
		"linear_mip_linear": FILTER_LINEAR_MIPMAP_LINEAR
	};
	var JSON_TEXTURE_TYPE = {
		"default": TEXTURETYPE_DEFAULT,
		"rgbm": TEXTURETYPE_RGBM,
		"rgbe": TEXTURETYPE_RGBE,
		"swizzleGGGR": TEXTURETYPE_SWIZZLEGGGR
	};
	function TextureParser() {}
	Object.assign(TextureParser.prototype, {
		load: function (url, callback, asset) {
			throw new Error('not implemented');
		},
		open: function (url, data, device) {
			throw new Error('not implemented');
		}
	});
	var _completePartialMipmapChain = function (texture) {
		var requiredMipLevels = Math.log2(Math.max(texture._width, texture._height)) + 1;
		var isHtmlElement = function (object) {
			return (object instanceof HTMLCanvasElement) ||
				   (object instanceof HTMLImageElement) ||
				   (object instanceof HTMLVideoElement);
		};
		if (!(texture._format === PIXELFORMAT_R8_G8_B8_A8 ||
			  texture._format === PIXELFORMAT_RGBA32F) ||
			  texture._volume ||
			  texture._compressed ||
			  texture._levels.length === 1 ||
			  texture._levels.length === requiredMipLevels ||
			  isHtmlElement(texture._cubemap ? texture._levels[0][0] : texture._levels[0])) {
			return;
		}
		var downsample = function (width, height, data) {
			var sampledWidth = Math.max(1, width >> 1);
			var sampledHeight = Math.max(1, height >> 1);
			var sampledData = new data.constructor(sampledWidth * sampledHeight * 4);
			var xs = Math.floor(width / sampledWidth);
			var ys = Math.floor(height / sampledHeight);
			var xsys = xs * ys;
			for (var y = 0; y < sampledHeight; ++y) {
				for (var x = 0; x < sampledWidth; ++x) {
					for (var e = 0; e < 4; ++e) {
						var sum = 0;
						for (var sy = 0; sy < ys; ++sy) {
							for (var sx = 0; sx < xs; ++sx) {
								sum += data[(x * xs + sx + (y * ys + sy) * width) * 4 + e];
							}
						}
						sampledData[(x + y * sampledWidth) * 4 + e] = sum / xsys;
					}
				}
			}
			return sampledData;
		};
		for (var level = texture._levels.length; level < requiredMipLevels; ++level) {
			var width = Math.max(1, texture._width >> (level - 1));
			var height = Math.max(1, texture._height >> (level - 1));
			if (texture._cubemap) {
				var mips = [];
				for (var face = 0; face < 6; ++face) {
					mips.push(downsample(width, height, texture._levels[level - 1][face]));
				}
				texture._levels.push(mips);
			} else {
				texture._levels.push(downsample(width, height, texture._levels[level - 1]));
			}
		}
		texture._levelsUpdated = texture._cubemap ? [[true, true, true, true, true, true]] : [true];
	};
	function TextureHandler(device, assets, loader) {
		this._device = device;
		this._assets = assets;
		this._loader = loader;
		this.imgParser = new ImgParser(assets, false);
		this.parsers = {
			dds: new LegacyDdsParser(assets, false),
			ktx: new KtxParser(assets, false),
			basis: new BasisParser(assets, false)
		};
	}
	Object.defineProperties(TextureHandler.prototype, {
		crossOrigin: {
			get: function () {
				return this.imgParser.crossOrigin;
			},
			set: function (value) {
				this.imgParser.crossOrigin = value;
			}
		},
		retryRequests: {
			get: function () {
				return this.imgParser.retryRequests;
			},
			set: function (value) {
				this.imgParser.retryRequests = value;
				for (var parser in this.parsers) {
					if (this.parsers.hasOwnProperty(parser)) {
						this.parsers[parser].retryRequests = value;
					}
				}
			}
		}
	});
	Object.assign(TextureHandler.prototype, {
		_getUrlWithoutParams: function (url) {
			return url.indexOf('?') >= 0 ? url.split('?')[0] : url;
		},
		_getParser: function (url) {
			var ext = path.getExtension(this._getUrlWithoutParams(url)).toLowerCase().replace('.', '');
			return this.parsers[ext] || this.imgParser;
		},
		load: function (url, callback, asset) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			this._getParser(url.original).load(url, callback, asset);
		},
		open: function (url, data, asset) {
			if (!url)
				return;
			var texture = this._getParser(url).open(url, data, this._device);
			if (texture === null) {
				texture = new Texture(this._device, {
					width: 4,
					height: 4,
					format: PIXELFORMAT_R8_G8_B8
				});
			} else {
				_completePartialMipmapChain(texture);
			}
			return texture;
		},
		patch: function (asset, assets) {
			var texture = asset.resource;
			if (!texture) {
				return;
			}
			if (asset.name && asset.name.length > 0) {
				texture.name = asset.name;
			}
			var assetData = asset.data;
			if (assetData.hasOwnProperty('minfilter')) {
				texture.minFilter = JSON_FILTER_MODE$1[assetData.minfilter];
			}
			if (assetData.hasOwnProperty('magfilter')) {
				texture.magFilter = JSON_FILTER_MODE$1[assetData.magfilter];
			}
			if (!texture.cubemap) {
				if (assetData.hasOwnProperty('addressu')) {
					texture.addressU = JSON_ADDRESS_MODE$1[assetData.addressu];
				}
				if (assetData.hasOwnProperty('addressv')) {
					texture.addressV = JSON_ADDRESS_MODE$1[assetData.addressv];
				}
			}
			if (assetData.hasOwnProperty('mipmaps')) {
				texture.mipmaps = assetData.mipmaps;
			}
			if (assetData.hasOwnProperty('anisotropy')) {
				texture.anisotropy = assetData.anisotropy;
			}
			if (assetData.hasOwnProperty('flipY')) {
				texture.flipY = !!assetData.flipY;
			}
			if (assetData.hasOwnProperty('type')) {
				texture.type = JSON_TEXTURE_TYPE[assetData.type];
			} else if (assetData.hasOwnProperty('rgbm') && assetData.rgbm) {
				texture.type = TEXTURETYPE_RGBM;
			} else if (asset.file && asset.getPreferredFile) {
				var preferredFile = asset.getPreferredFile();
				if (preferredFile) {
					if (preferredFile.opt && ((preferredFile.opt & 8) !== 0)) {
						texture.type = TEXTURETYPE_SWIZZLEGGGR;
					}
				}
			}
		}
	});

	function AssetRegistry(loader) {
		EventHandler.call(this);
		this._loader = loader;
		this._assets = [];
		this._cache = {};
		this._names = {};
		this._tags = new TagsCache('_id');
		this._urls = {};
		this.prefix = null;
	}
	AssetRegistry.prototype = Object.create(EventHandler.prototype);
	AssetRegistry.prototype.constructor = AssetRegistry;
	Object.assign(AssetRegistry.prototype, {
		list: function (filters) {
			filters = filters || {};
			return this._assets.filter(function (asset) {
				var include = true;
				if (filters.preload !== undefined) {
					include = (asset.preload === filters.preload);
				}
				return include;
			});
		},
		add: function (asset) {
			var index = this._assets.push(asset) - 1;
			var url;
			this._cache[asset.id] = index;
			if (!this._names[asset.name])
				this._names[asset.name] = [];
			this._names[asset.name].push(index);
			if (asset.file) {
				url = asset.file.url;
				this._urls[url] = index;
			}
			asset.registry = this;
			this._tags.addItem(asset);
			asset.tags.on('add', this._onTagAdd, this);
			asset.tags.on('remove', this._onTagRemove, this);
			this.fire("add", asset);
			this.fire("add:" + asset.id, asset);
			if (url)
				this.fire("add:url:" + url, asset);
			if (asset.preload)
				this.load(asset);
		},
		remove: function (asset) {
			var idx = this._cache[asset.id];
			var url = asset.file ? asset.file.url : null;
			if (idx !== undefined) {
				this._assets.splice(idx, 1);
				delete this._cache[asset.id];
				this._names = {};
				this._urls = [];
				for (var i = 0, l = this._assets.length; i < l; i++) {
					var a = this._assets[i];
					this._cache[a.id] = i;
					if (!this._names[a.name]) {
						this._names[a.name] = [];
					}
					this._names[a.name].push(i);
					if (a.file) {
						this._urls[a.file.url] = i;
					}
				}
				this._tags.removeItem(asset);
				asset.tags.off('add', this._onTagAdd, this);
				asset.tags.off('remove', this._onTagRemove, this);
				asset.fire("remove", asset);
				this.fire("remove", asset);
				this.fire("remove:" + asset.id, asset);
				if (url)
					this.fire("remove:url:" + url, asset);
				return true;
			}
			return false;
		},
		get: function (id) {
			var idx = this._cache[id];
			return this._assets[idx];
		},
		getByUrl: function (url) {
			var idx = this._urls[url];
			return this._assets[idx];
		},
		load: function (asset) {
			if (asset.loading || asset.loaded) {
				return;
			}
			var self = this;
			var file = asset.getPreferredFile();
			var _opened = function (resource) {
				if (resource instanceof Array) {
					asset.resources = resource;
				} else {
					asset.resource = resource;
				}
				self._loader.patch(asset, self);
				self.fire("load", asset);
				self.fire("load:" + asset.id, asset);
				if (file && file.url)
					self.fire("load:url:" + file.url, asset);
				asset.fire("load", asset);
			};
			var _loaded = function (err, resource, extra) {
				asset.loaded = true;
				asset.loading = false;
				if (err) {
					self.fire("error", err, asset);
					self.fire("error:" + asset.id, err, asset);
					asset.fire("error", err, asset);
				} else {
					if (!script.legacy && asset.type === 'script') {
						var handler = self._loader.getHandler('script');
						if (handler._cache[asset.id] && handler._cache[asset.id].parentNode === document.head) {
							document.head.removeChild(handler._cache[asset.id]);
						}
						handler._cache[asset.id] = extra;
					}
					_opened(resource);
				}
			};
			if (file || asset.type === 'cubemap') {
				this.fire("load:start", asset);
				this.fire("load:" + asset.id + ":start", asset);
				asset.loading = true;
				self._loader.load(asset.getFileUrl(), asset.type, _loaded, asset);
			} else {
				var resource = self._loader.open(asset.type, asset.data);
				asset.loaded = true;
				_opened(resource);
			}
		},
		loadFromUrl: function (url, type, callback) {
			this.loadFromUrlAndFilename(url, null, type, callback);
		},
		loadFromUrlAndFilename: function (url, filename, type, callback) {
			var self = this;
			var name = path.getBasename(filename || url);
			var file = {
				filename: filename || name,
				url: url
			};
			var asset = self.getByUrl(url);
			if (!asset) {
				asset = new Asset(name, type, file);
				self.add(asset);
			}
			var startLoad = function (asset) {
				asset.once("load", function (loadedAsset) {
					if (type === 'material') {
						self._loadTextures(loadedAsset, function (err, textures) {
							callback(err, loadedAsset);
						});
					} else {
						callback(null, loadedAsset);
					}
				});
				asset.once("error", function (err) {
					callback(err);
				});
				self.load(asset);
			};
			if (asset.resource) {
				callback(null, asset);
			} else if (type === 'model') {
				self._loadModel(asset, startLoad);
			} else {
				startLoad(asset);
			}
		},
		_loadModel: function (modelAsset, continuation) {
			var self = this;
			var url = modelAsset.getFileUrl();
			var ext = path.getExtension(url);
			if (ext === '.json' || ext === '.glb') {
				var dir = path.getDirectory(url);
				var basename = path.getBasename(url);
				var mappingUrl = path.join(dir, basename.replace(ext, ".mapping.json"));
				this._loader.load(mappingUrl, 'json', function (err, data) {
					if (err) {
						modelAsset.data = { mapping: [] };
						continuation(modelAsset);
					} else {
						self._loadMaterials(modelAsset, data, function (e, materials) {
							modelAsset.data = data;
							continuation(modelAsset);
						});
					}
				});
			} else {
				continuation(modelAsset);
			}
		},
		_loadMaterials: function (modelAsset, mapping, callback) {
			var self = this;
			var materials = [];
			var count = 0;
			var onMaterialLoaded = function (err, materialAsset) {
				self._loadTextures(materialAsset, function (err, textures) {
					materials.push(materialAsset);
					if (materials.length === count) {
						callback(null, materials);
					}
				});
			};
			for (var i = 0; i < mapping.mapping.length; i++) {
				var path = mapping.mapping[i].path;
				if (path) {
					count++;
					self.loadFromUrl(modelAsset.getAbsoluteUrl(path), "material", onMaterialLoaded);
				}
			}
			if (count === 0) {
				callback(null, materials);
			}
		},
		_loadTextures: function (materialAsset, callback) {
			var self = this;
			var textures = [];
			var count = 0;
			var data = materialAsset.data;
			if (data.mappingFormat !== 'path') {
				callback(null, textures);
				return;
			}
			var onTextureLoaded = function (err, texture) {
				if (err) console.error(err);
				textures.push(texture);
				if (textures.length === count) {
					callback(null, textures);
				}
			};
			var texParams = standardMaterialTextureParameters;
			for (var i = 0; i < texParams.length; i++) {
				var path = data[texParams[i]];
				if (path && typeof(path) === 'string') {
					count++;
					self.loadFromUrl(materialAsset.getAbsoluteUrl(path), "texture", onTextureLoaded);
				}
			}
			if (count === 0) {
				callback(null, textures);
			}
		},
		findAll: function (name, type) {
			var self = this;
			var idxs = this._names[name];
			if (idxs) {
				var assets = idxs.map(function (idx) {
					return self._assets[idx];
				});
				if (type) {
					return assets.filter(function (asset) {
						return (asset.type === type);
					});
				}
				return assets;
			}
			return [];
		},
		_onTagAdd: function (tag, asset) {
			this._tags.add(tag, asset);
		},
		_onTagRemove: function (tag, asset) {
			this._tags.remove(tag, asset);
		},
		findByTag: function () {
			return this._tags.find(arguments);
		},
		filter: function (callback) {
			var items = [];
			for (var i = 0, len = this._assets.length; i < len; i++) {
				if (callback(this._assets[i]))
					items.push(this._assets[i]);
			}
			return items;
		},
		find: function (name, type) {
			var asset = this.findAll(name, type);
			return asset ? asset[0] : null;
		}
	});

	function BundleRegistry(assets) {
		this._assets = assets;
		this._bundleAssets = {};
		this._assetsInBundles = {};
		this._urlsInBundles = {};
		this._fileRequests = {};
		this._assets.on('add', this._onAssetAdded, this);
		this._assets.on('remove', this._onAssetRemoved, this);
	}
	Object.assign(BundleRegistry.prototype, {
		_onAssetAdded: function (asset) {
			if (asset.type === 'bundle') {
				this._bundleAssets[asset.id] = asset;
				this._registerBundleEventListeners(asset.id);
				for (var i = 0, len = asset.data.assets.length; i < len; i++) {
					this._indexAssetInBundle(asset.data.assets[i], asset);
				}
			} else {
				if (this._assetsInBundles[asset.id]) {
					this._indexAssetFileUrls(asset);
				}
			}
		},
		_registerBundleEventListeners: function (bundleAssetId) {
			this._assets.on('load:' + bundleAssetId, this._onBundleLoaded, this);
			this._assets.on('error:' + bundleAssetId, this._onBundleError, this);
		},
		_unregisterBundleEventListeners: function (bundleAssetId) {
			this._assets.off('load:' + bundleAssetId, this._onBundleLoaded, this);
			this._assets.off('error:' + bundleAssetId, this._onBundleError, this);
		},
		_indexAssetInBundle: function (assetId, bundleAsset) {
			if (! this._assetsInBundles[assetId]) {
				this._assetsInBundles[assetId] = [bundleAsset];
			} else {
				var bundles = this._assetsInBundles[assetId];
				var idx = bundles.indexOf(bundleAsset);
				if (idx === -1) {
					bundles.push(bundleAsset);
				}
			}
			var asset = this._assets.get(assetId);
			if (asset) {
				this._indexAssetFileUrls(asset);
			}
		},
		_indexAssetFileUrls: function (asset) {
			var urls = this._getAssetFileUrls(asset);
			if (! urls) return;
			for (var i = 0, len = urls.length; i < len; i++) {
				var url = urls[i];
				this._urlsInBundles[url] = this._assetsInBundles[asset.id];
			}
		},
		_getAssetFileUrls: function (asset) {
			var url = asset.getFileUrl();
			if (! url) return null;
			url = this._normalizeUrl(url);
			var urls = [url];
			if (asset.type === 'font') {
				var numFiles = asset.data.info.maps.length;
				for (var i = 1; i < numFiles; i++) {
					urls.push(url.replace('.png', i + '.png'));
				}
			}
			return urls;
		},
		_normalizeUrl: function (url) {
			return url && url.split('?')[0];
		},
		_onAssetRemoved: function (asset) {
			if (asset.type === 'bundle') {
				delete this._bundleAssets[asset.id];
				this._unregisterBundleEventListeners(asset.id);
				var idx, id;
				for (id in this._assetsInBundles) {
					var array = this._assetsInBundles[id];
					idx = array.indexOf(asset);
					if (idx !== -1) {
						array.splice(idx, 1);
						if (! array.length) {
							delete this._assetsInBundles[id];
							for (var url in this._urlsInBundles) {
								if (this._urlsInBundles[url] === array) {
									delete this._urlsInBundles[url];
								}
							}
						}
					}
				}
				this._onBundleError('Bundle ' + asset.id + ' was removed', asset);
			} else if (this._assetsInBundles[asset.id]) {
				delete this._assetsInBundles[asset.id];
				var urls = this._getAssetFileUrls(asset);
				for (var i = 0, len = urls.length; i < len; i++) {
					delete this._urlsInBundles[urls[i]];
				}
			}
		},
		_onBundleLoaded: function (bundleAsset) {
			if (! bundleAsset.resource) {
				this._onBundleError('Bundle ' + bundleAsset.id + ' failed to load', bundleAsset);
				return;
			}
			requestAnimationFrame(function () {
				if (!this._fileRequests) {
					return;
				}
				for (var url in this._fileRequests) {
					var bundles = this._urlsInBundles[url];
					if (!bundles || bundles.indexOf(bundleAsset) === -1) continue;
					var decodedUrl = decodeURIComponent(url);
					var err = null;
					if (!bundleAsset.resource.hasBlobUrl(decodedUrl)) {
						err = 'Bundle ' + bundleAsset.id + ' does not contain URL ' + url;
					}
					var requests = this._fileRequests[url];
					for (var i = 0, len = requests.length; i < len; i++) {
						if (err) {
							requests[i](err);
						} else {
							requests[i](null, bundleAsset.resource.getBlobUrl(decodedUrl));
						}
					}
					delete this._fileRequests[url];
				}
			}.bind(this));
		},
		_onBundleError: function (err, bundleAsset) {
			for (var url in this._fileRequests) {
				var bundle = this._findLoadedOrLoadingBundleForUrl(url);
				if (! bundle) {
					var requests = this._fileRequests[url];
					for (var i = 0, len = requests.length; i < len; i++) {
						requests[i](err);
					}
					delete this._fileRequests[url];
				}
			}
		},
		_findLoadedOrLoadingBundleForUrl: function (url) {
			var bundles = this._urlsInBundles[url];
			if (! bundles) return null;
			var len = bundles.length;
			var i;
			for (i = 0; i < len; i++) {
				if (bundles[i].loaded && bundles[i].resource) {
					return bundles[i];
				}
			}
			for (i = 0; i < len; i++) {
				if (bundles[i].loading) {
					return bundles[i];
				}
			}
			return null;
		},
		listBundlesForAsset: function (asset) {
			return this._assetsInBundles[asset.id] || null;
		},
		list: function () {
			var result = [];
			for (var id in this._bundleAssets) {
				result.push(this._bundleAssets[id]);
			}
			return result;
		},
		hasUrl: function (url) {
			return !!this._urlsInBundles[url];
		},
		canLoadUrl: function (url) {
			return !!this._findLoadedOrLoadingBundleForUrl(url);
		},
		loadUrl: function (url, callback) {
			var bundle = this._findLoadedOrLoadingBundleForUrl(url);
			if (! bundle) {
				callback('URL ' + url + ' not found in any bundles');
				return;
			}
			if (bundle.loaded) {
				var decodedUrl = decodeURIComponent(url);
				if (!bundle.resource.hasBlobUrl(decodedUrl)) {
					callback('Bundle ' + bundle.id + ' does not contain URL ' + url);
					return;
				}
				callback(null, bundle.resource.getBlobUrl(decodedUrl));
			} else if (this._fileRequests.hasOwnProperty(url)) {
				this._fileRequests[url].push(callback);
			} else {
				this._fileRequests[url] = [callback];
			}
		},
		destroy: function () {
			this._assets.off('add', this._onAssetAdded, this);
			this._assets.off('remove', this._onAssetRemoved, this);
			for (var id in this._bundleAssets) {
				this._unregisterBundleEventListeners(id);
			}
			this._assets = null;
			this._bundleAssets = null;
			this._assetsInBundles = null;
			this._urlsInBundles = null;
			this._fileRequests = null;
		}
	});

	function ScriptRegistry(app) {
		EventHandler.call(this);
		this.app = app;
		this._scripts = { };
		this._list = [];
	}
	ScriptRegistry.prototype = Object.create(EventHandler.prototype);
	ScriptRegistry.prototype.constructor = ScriptRegistry;
	ScriptRegistry.prototype.destroy = function () {
		this.app = null;
		this.off();
	};
	ScriptRegistry.prototype.add = function (script) {
		var self = this;
		var scriptName = script.__name;
		if (this._scripts.hasOwnProperty(scriptName)) {
			setTimeout(function () {
				if (script.prototype.swap) {
					var old = self._scripts[scriptName];
					var ind = self._list.indexOf(old);
					self._list[ind] = script;
					self._scripts[scriptName] = script;
					self.fire('swap', scriptName, script);
					self.fire('swap:' + scriptName, script);
				} else {
					console.warn('script registry already has \'' + scriptName + '\' script, define \'swap\' method for new script type to enable code hot swapping');
				}
			});
			return false;
		}
		this._scripts[scriptName] = script;
		this._list.push(script);
		this.fire('add', scriptName, script);
		this.fire('add:' + scriptName, script);
		setTimeout(function () {
			if (!self._scripts.hasOwnProperty(scriptName))
				return;
			if (!self.app || !self.app.systems || !self.app.systems.script) {
				return;
			}
			var components = self.app.systems.script._components;
			var i, scriptInstance, attributes;
			var scriptInstances = [];
			var scriptInstancesInitialized = [];
			for (components.loopIndex = 0; components.loopIndex < components.length; components.loopIndex++) {
				var component = components.items[components.loopIndex];
				if (component._scriptsIndex[scriptName] && component._scriptsIndex[scriptName].awaiting) {
					if (component._scriptsData && component._scriptsData[scriptName])
						attributes = component._scriptsData[scriptName].attributes;
					scriptInstance = component.create(scriptName, {
						preloading: true,
						ind: component._scriptsIndex[scriptName].ind,
						attributes: attributes
					});
					if (scriptInstance)
						scriptInstances.push(scriptInstance);
				}
			}
			for (i = 0; i < scriptInstances.length; i++)
				scriptInstances[i].__initializeAttributes();
			for (i = 0; i < scriptInstances.length; i++) {
				if (scriptInstances[i].enabled) {
					scriptInstances[i]._initialized = true;
					scriptInstancesInitialized.push(scriptInstances[i]);
					if (scriptInstances[i].initialize)
						scriptInstances[i].initialize();
				}
			}
			for (i = 0; i < scriptInstancesInitialized.length; i++) {
				if (!scriptInstancesInitialized[i].enabled || scriptInstancesInitialized[i]._postInitialized) {
					continue;
				}
				scriptInstancesInitialized[i]._postInitialized = true;
				if (scriptInstancesInitialized[i].postInitialize)
					scriptInstancesInitialized[i].postInitialize();
			}
		});
		return true;
	};
	ScriptRegistry.prototype.remove = function (nameOrType) {
		var scriptType = nameOrType;
		var scriptName = nameOrType;
		if (typeof scriptName !== 'string') {
			scriptName = scriptType.__name;
		} else {
			scriptType = this.get(scriptName);
		}
		if (this.get(scriptName) !== scriptType)
			return false;
		delete this._scripts[scriptName];
		var ind = this._list.indexOf(scriptType);
		this._list.splice(ind, 1);
		this.fire('remove', scriptName, scriptType);
		this.fire('remove:' + scriptName, scriptType);
		return true;
	};
	ScriptRegistry.prototype.get = function (name) {
		return this._scripts[name] || null;
	};
	ScriptRegistry.prototype.has = function (nameOrType) {
		if (typeof nameOrType === 'string') {
			return this._scripts.hasOwnProperty(nameOrType);
		}
		if (!nameOrType) return false;
		var scriptName = nameOrType.__name;
		return this._scripts[scriptName] === nameOrType;
	};
	ScriptRegistry.prototype.list = function () {
		return this._list;
	};

	var FILLMODE_NONE = 'NONE';
	var FILLMODE_FILL_WINDOW = 'FILL_WINDOW';
	var FILLMODE_KEEP_ASPECT = 'KEEP_ASPECT';
	var RESOLUTION_AUTO = 'AUTO';
	var RESOLUTION_FIXED = 'FIXED';

	function VrDisplay(app, display) {
		EventHandler.call(this);
		var self = this;
		this._app = app;
		this._device = app.graphicsDevice;
		this.id = display.displayId;
		this._frameData = null;
		if (window.VRFrameData) {
			this._frameData = new window.VRFrameData();
		}
		this.display = display;
		this._camera = null;
		this.sitToStandInv = new Mat4();
		this.leftView = new Mat4();
		this.leftProj = new Mat4();
		this.leftViewInv = new Mat4();
		this.leftPos = new Vec3();
		this.rightView = new Mat4();
		this.rightProj = new Mat4();
		this.rightViewInv = new Mat4();
		this.rightPos = new Vec3();
		this.combinedPos = new Vec3();
		this.combinedView = new Mat4();
		this.combinedProj = new Mat4();
		this.combinedViewInv = new Mat4();
		this.combinedFov = 0;
		this.combinedAspect = 0;
		this.presenting = false;
		self._presentChange = function (event) {
			var display;
			if (event.display) {
				display = event.display;
			} else if (event.detail && event.detail.display) {
				display = event.detail.display;
			} else if (event.detail && event.detail.vrdisplay) {
				display = event.detail.vrdisplay;
			} else {
				display = self.display;
			}
			if (display === self.display) {
				self.presenting = (self.display && self.display.isPresenting);
				if (self.presenting) {
					var leftEye = self.display.getEyeParameters("left");
					var rightEye = self.display.getEyeParameters("right");
					var w = Math.max(leftEye.renderWidth, rightEye.renderWidth) * 2;
					var h = Math.max(leftEye.renderHeight, rightEye.renderHeight);
					self._app.graphicsDevice.setResolution(w, h);
					self._app._allowResize = false;
				} else {
					self._app.setCanvasResolution(RESOLUTION_AUTO);
					self._app._allowResize = true;
				}
				self.fire('beforepresentchange', self);
				self.fire('presentchange', self);
			}
		};
		window.addEventListener('vrdisplaypresentchange', self._presentChange, false);
	}
	VrDisplay.prototype = Object.create(EventHandler.prototype);
	VrDisplay.prototype.constructor = VrDisplay;
	Object.assign(VrDisplay.prototype, {
		destroy: function () {
			window.removeEventListener('vrdisplaypresentchange', self._presentChange);
			if (this._camera) this._camera.vrDisplay = null;
			this._camera = null;
		},
		poll: function () {
			if (this.display) {
				this.display.getFrameData(this._frameData);
				this.leftProj.data = this._frameData.leftProjectionMatrix;
				this.rightProj.data = this._frameData.rightProjectionMatrix;
				var stage = this.display.stageParameters;
				if (stage) {
					this.sitToStandInv.set(stage.sittingToStandingTransform).invert();
					this.combinedView.set(this._frameData.leftViewMatrix);
					this.leftView.mul2(this.combinedView, this.sitToStandInv);
					this.combinedView.set(this._frameData.rightViewMatrix);
					this.rightView.mul2(this.combinedView, this.sitToStandInv);
				} else {
					this.leftView.set(this._frameData.leftViewMatrix);
					this.rightView.set(this._frameData.rightViewMatrix);
				}
				var nx = this.leftProj.data[3] + this.leftProj.data[0];
				var nz = this.leftProj.data[11] + this.leftProj.data[8];
				var l = 1.0 / Math.sqrt(nx * nx + nz * nz);
				nx *= l;
				nz *= l;
				var maxFov = -Math.atan2(nz, nx);
				nx = this.rightProj.data[3] + this.rightProj.data[0];
				nz = this.rightProj.data[11] + this.rightProj.data[8];
				l = 1.0 / Math.sqrt(nx * nx + nz * nz);
				nx *= l;
				nz *= l;
				maxFov = Math.max(maxFov, -Math.atan2(nz, nx));
				maxFov *= 2.0;
				this.combinedFov = maxFov;
				var aspect = this.rightProj.data[5] / this.rightProj.data[0];
				this.combinedAspect = aspect;
				var view = this.combinedView;
				view.copy(this.leftView);
				view.invert();
				this.leftViewInv.copy(view);
				var pos = this.combinedPos;
				pos.x = this.leftPos.x = view.data[12];
				pos.y = this.leftPos.y = view.data[13];
				pos.z = this.leftPos.z = view.data[14];
				view.copy(this.rightView);
				view.invert();
				this.rightViewInv.copy(view);
				var deltaX = pos.x - view.data[12];
				var deltaY = pos.y - view.data[13];
				var deltaZ = pos.z - view.data[14];
				var dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ);
				this.rightPos.x = view.data[12];
				this.rightPos.y = view.data[13];
				this.rightPos.z = view.data[14];
				pos.x += view.data[12];
				pos.y += view.data[13];
				pos.z += view.data[14];
				pos.x *= 0.5;
				pos.y *= 0.5;
				pos.z *= 0.5;
				var b = Math.PI * 0.5;
				var c = maxFov * 0.5;
				var a = Math.PI - (b + c);
				var offset = dist * 0.5 * ( Math.sin(a) );
				var fwdX = view.data[8];
				var fwdY = view.data[9];
				var fwdZ = view.data[10];
				view.data[12] = pos.x + fwdX * offset;
				view.data[13] = pos.y + fwdY * offset;
				view.data[14] = pos.z + fwdZ * offset;
				this.combinedViewInv.copy(view);
				view.invert();
				this.combinedProj.setPerspective(maxFov * math.RAD_TO_DEG,
												 aspect,
												 this.display.depthNear + offset,
												 this.display.depthFar + offset,
												 true);
			}
		},
		requestPresent: function (callback) {
			if (!this.display) {
				if (callback) callback(new Error("No VrDisplay to requestPresent"));
				return;
			}
			if (this.presenting) {
				if (callback) callback(new Error("VrDisplay already presenting"));
				return;
			}
			this.display.requestPresent([{ source: this._device.canvas }]).then(function () {
				if (callback) callback();
			}, function (err) {
				if (callback) callback(err);
			});
		},
		exitPresent: function (callback) {
			if (!this.display) {
				if (callback) callback(new Error("No VrDisplay to exitPresent"));
			}
			if (!this.presenting) {
				if (callback) callback(new Error("VrDisplay not presenting"));
				return;
			}
			this.display.exitPresent().then(function () {
				if (callback) callback();
			}, function () {
				if (callback) callback(new Error("exitPresent failed"));
			});
		},
		requestAnimationFrame: function (fn) {
			if (this.display) this.display.requestAnimationFrame(fn);
		},
		submitFrame: function () {
			if (this.display) this.display.submitFrame();
		},
		reset: function () {
			if (this.display) this.display.resetPose();
		},
		setClipPlanes: function (n, f) {
			if (this.display) {
				this.display.depthNear = n;
				this.display.depthFar = f;
			}
		},
		getFrameData: function () {
			if (this.display) return this._frameData;
		}
	});
	Object.defineProperty(VrDisplay.prototype, "capabilities", {
		get: function () {
			if (this.display) return this.display.capabilities;
			return {};
		}
	});

	function VrManager(app) {
		EventHandler.call(this);
		var self = this;
		this.isSupported = VrManager.isSupported;
		this._index = { };
		this.displays = [];
		this.display = null;
		this._app = app;
		this._onDisplayConnect = this._onDisplayConnect.bind(this);
		this._onDisplayDisconnect = this._onDisplayDisconnect.bind(this);
		self._attach();
		this._getDisplays(function (err, displays) {
			if (err) {
				self.fire('error', err);
			} else {
				for (var i = 0; i < displays.length; i++) {
					self._addDisplay(displays[i]);
				}
				self.fire('ready', self.displays);
			}
		});
	}
	VrManager.prototype = Object.create(EventHandler.prototype);
	VrManager.prototype.constructor = VrManager;
	if (typeof navigator !== 'undefined') {
		VrManager.isSupported = !!navigator.getVRDisplays;
	} else {
		VrManager.isSupported = false;
	}
	Object.assign(VrManager.prototype, {
		_attach: function () {
			window.addEventListener('vrdisplayconnect', this._onDisplayConnect);
			window.addEventListener('vrdisplaydisconnect', this._onDisplayDisconnect);
		},
		_detach: function () {
			window.removeEventListener('vrdisplayconnect', this._onDisplayConnect);
			window.removeEventListener('vrdisplaydisconnect', this._onDisplayDisconnect);
		},
		destroy: function () {
			this._detach();
		},
		poll: function () {
			var l = this.displays.length;
			if (!l) return;
			for (var i = 0; i < l; i++) {
				if (this.displays[i]._camera) this.displays[i].poll();
			}
		},
		_getDisplays: function (callback) {
			if (navigator.getVRDisplays) {
				navigator.getVRDisplays().then(function (displays) {
					if (callback) callback(null, displays);
				});
			} else {
				if (callback) callback(new Error('WebVR not supported'));
			}
		},
		_addDisplay: function (vrDisplay) {
			if (this._index[vrDisplay.displayId])
				return;
			var display = new VrDisplay(this._app, vrDisplay);
			this._index[display.id] = display;
			this.displays.push(display);
			if (!this.display)
				this.display = display;
			this.fire('displayconnect', display);
		},
		_onDisplayConnect: function (e) {
			if (e.detail && e.detail.display) {
				this._addDisplay(e.detail.display);
			} else {
				this._addDisplay(e.display);
			}
		},
		_onDisplayDisconnect: function (e) {
			var id;
			if (e.detail && e.detail.display) {
				id = e.detail.display.displayId;
			} else {
				id = e.display.displayId;
			}
			var display = this._index[id];
			if (!display)
				return;
			display.destroy();
			delete this._index[display.id];
			var ind = this.displays.indexOf(display);
			this.displays.splice(ind, 1);
			if (this.display === display) {
				if (this.displays.length) {
					this.display = this.displays[0];
				} else {
					this.display = null;
				}
			}
			this.fire('displaydisconnect', display);
		}
	});

	var XRTYPE_INLINE = 'inline';
	var XRTYPE_VR = 'immersive-vr';
	var XRTYPE_AR = 'immersive-ar';
	var XRSPACE_VIEWER = 'viewer';
	var XRSPACE_LOCAL = 'local';
	var XRSPACE_LOCALFLOOR = 'local-floor';
	var XRSPACE_BOUNDEDFLOOR = 'bounded-floor';
	var XRSPACE_UNBOUNDED = 'unbounded';
	var XRTARGETRAY_GAZE = 'gaze';
	var XRTARGETRAY_SCREEN = 'screen';
	var XRTARGETRAY_POINTER = 'tracked-pointer';
	var XRHAND_NONE = 'none';
	var XRHAND_LEFT = 'left';
	var XRHAND_RIGHT = 'right';
	var XRTRACKABLE_POINT = 'point';
	var XRTRACKABLE_PLANE = 'plane';
	var XRTRACKABLE_MESH = 'mesh';

	var poolVec3 = [];
	var poolQuat = [];
	function XrHitTestSource(manager, xrHitTestSource, transient) {
		EventHandler.call(this);
		this.manager = manager;
		this._xrHitTestSource = xrHitTestSource;
		this._transient = transient;
	}
	XrHitTestSource.prototype = Object.create(EventHandler.prototype);
	XrHitTestSource.prototype.constructor = XrHitTestSource;
	XrHitTestSource.prototype.remove = function () {
		if (! this._xrHitTestSource)
			return;
		var sources = this.manager.hitTest.sources;
		var ind = sources.indexOf(this);
		if (ind !== -1) sources.splice(ind, 1);
		this.onStop();
	};
	XrHitTestSource.prototype.onStop = function () {
		this._xrHitTestSource.cancel();
		this._xrHitTestSource = null;
		this.fire('remove');
		this.manager.hitTest.fire('remove', this);
	};
	XrHitTestSource.prototype.update = function (frame) {
		if (this._transient) {
			var transientResults = frame.getHitTestResultsForTransientInput(this._xrHitTestSource);
			for (var i = 0; i < transientResults.length; i++) {
				var transientResult = transientResults[i];
				var inputSource;
				if (transientResult.inputSource)
					inputSource = this.manager.input._getByInputSource(transientResult.inputSource);
				this.updateHitResults(transientResult.results, inputSource);
			}
		} else {
			this.updateHitResults(frame.getHitTestResults(this._xrHitTestSource));
		}
	};
	XrHitTestSource.prototype.updateHitResults = function (results, inputSource) {
		for (var i = 0; i < results.length; i++) {
			var pose = results[i].getPose(this.manager._referenceSpace);
			var position = poolVec3.pop();
			if (! position) position = new Vec3();
			position.copy(pose.transform.position);
			var rotation = poolQuat.pop();
			if (! rotation) rotation = new Quat();
			rotation.copy(pose.transform.orientation);
			this.fire('result', position, rotation, inputSource);
			this.manager.hitTest.fire('result', this, position, rotation, inputSource);
			poolVec3.push(position);
			poolQuat.push(rotation);
		}
	};

	function XrHitTest(manager) {
		EventHandler.call(this);
		this.manager = manager;
		this._supported = !! (window.XRSession && window.XRSession.prototype.requestHitTestSource);
		this._session = null;
		this.sources = [];
		if (this._supported) {
			this.manager.on('start', this._onSessionStart, this);
			this.manager.on('end', this._onSessionEnd, this);
		}
	}
	XrHitTest.prototype = Object.create(EventHandler.prototype);
	XrHitTest.prototype.constructor = XrHitTest;
	XrHitTest.prototype._onSessionStart = function () {
		if (this.manager.type !== XRTYPE_AR)
			return;
		this._session = this.manager.session;
	};
	XrHitTest.prototype._onSessionEnd = function () {
		if (! this._session)
			return;
		this._session = null;
		for (var i = 0; i < this.sources.length; i++) {
			this.sources[i].onStop();
		}
		this.sources = [];
	};
	XrHitTest.prototype.isAvailable = function (callback, fireError) {
		var err;
		if (! this._supported)
			err = new Error('XR HitTest is not supported');
		if (! this._session)
			err = new Error('XR Session is not started (1)');
		if (this.manager.type !== XRTYPE_AR)
			err = new Error('XR HitTest is available only for AR');
		if (err) {
			if (callback) callback(err);
			if (fireError) fireError.fire('error', err);
			return false;
		}
		return true;
	};
	XrHitTest.prototype.start = function (options) {
		var self = this;
		options = options || { };
		if (! this.isAvailable(options.callback, this))
			return;
		if (! options.profile && ! options.spaceType)
			options.spaceType = XRSPACE_VIEWER;
		var xrRay;
		var offsetRay = options.offsetRay;
		if (offsetRay) xrRay = new XRRay(new DOMPoint(offsetRay.origin.x, offsetRay.origin.y, offsetRay.origin.z), new DOMPoint(offsetRay.direction.x, offsetRay.direction.y, offsetRay.direction.z));
		var callback = options.callback;
		if (options.spaceType) {
			this._session.requestReferenceSpace(options.spaceType).then(function (referenceSpace) {
				if (! self._session) {
					var err = new Error('XR Session is not started (2)');
					if (callback) callback(err);
					self.fire('error', err);
					return;
				}
				self._session.requestHitTestSource({
					space: referenceSpace,
					entityTypes: options.entityTypes || undefined,
					offsetRay: xrRay
				}).then(function (xrHitTestSource) {
					self._onHitTestSource(xrHitTestSource, false, callback);
				}).catch(function (ex) {
					if (callback) callback(ex);
					self.fire('error', ex);
				});
			}).catch(function (ex) {
				if (callback) callback(ex);
				self.fire('error', ex);
			});
		} else {
			this._session.requestHitTestSourceForTransientInput({
				profile: options.profile,
				entityTypes: options.entityTypes || undefined,
				offsetRay: xrRay
			}).then(function (xrHitTestSource) {
				self._onHitTestSource(xrHitTestSource, true, callback);
			}).catch(function (ex) {
				if (callback) callback(ex);
				self.fire('error', ex);
			});
		}
	};
	XrHitTest.prototype._onHitTestSource = function (xrHitTestSource, transient, callback) {
		if (! this._session) {
			xrHitTestSource.cancel();
			var err = new Error('XR Session is not started (3)');
			if (callback) callback(err);
			this.fire('error', err);
			return;
		}
		var hitTestSource = new XrHitTestSource(this.manager, xrHitTestSource, transient);
		this.sources.push(hitTestSource);
		if (callback) callback(null, hitTestSource);
		this.fire('add', hitTestSource);
	};
	XrHitTest.prototype.update = function (frame) {
		for (var i = 0; i < this.sources.length; i++) {
			this.sources[i].update(frame);
		}
	};
	Object.defineProperty(XrHitTest.prototype, 'supported', {
		get: function () {
			return this._supported;
		}
	});

	function XrFinger(index, hand) {
		this._index = index;
		this._hand = hand;
		this._hand._fingers.push(this);
		this._joints = [];
		this._tip = null;
	}
	Object.defineProperty(XrFinger.prototype, 'index', {
		get: function () {
			return this._index;
		}
	});
	Object.defineProperty(XrFinger.prototype, 'hand', {
		get: function () {
			return this._hand;
		}
	});
	Object.defineProperty(XrFinger.prototype, 'joints', {
		get: function () {
			return this._joints;
		}
	});
	Object.defineProperty(XrFinger.prototype, 'tip', {
		get: function () {
			return this._tip;
		}
	});

	var tipJointIds = window.XRHand ? [
		XRHand.THUMB_PHALANX_TIP,
		XRHand.INDEX_PHALANX_TIP,
		XRHand.MIDDLE_PHALANX_TIP,
		XRHand.RING_PHALANX_TIP,
		XRHand.LITTLE_PHALANX_TIP
	] : [];
	var tipJointIdsIndex = {};
	for (var i = 0; i < tipJointIds.length; i++) {
		tipJointIdsIndex[tipJointIds[i]] = true;
	}
	function XrJoint(index, id, hand, finger) {
		this._index = index;
		this._id = id;
		this._hand = hand;
		this._hand._joints.push(this);
		this._hand._jointsById[id] = this;
		this._finger = finger || null;
		if (this._finger) this._finger._joints.push(this);
		this._wrist = id === XRHand.WRIST;
		if (this._wrist) this._hand._wrist = this;
		this._tip = this._finger && !! tipJointIdsIndex[id];
		if (this._tip) {
			this._hand._tips.push(this);
			if (this._finger) this._finger._tip = this;
		}
		this._radius = null;
		this._localTransform = new Mat4();
		this._worldTransform = new Mat4();
		this._localPosition = new Vec3();
		this._localRotation = new Quat();
		this._position = new Vec3();
		this._rotation = new Quat();
		this._dirtyLocal = true;
	}
	XrJoint.prototype.update = function (pose) {
		this._dirtyLocal = true;
		this._radius = pose.radius;
		this._localPosition.copy(pose.transform.position);
		this._localRotation.copy(pose.transform.orientation);
	};
	XrJoint.prototype._updateTransforms = function () {
		var dirty;
		if (this._dirtyLocal) {
			dirty = true;
			this._dirtyLocal = false;
			this._localTransform.setTRS(this._localPosition, this._localRotation, Vec3.ONE);
		}
		var manager = this._hand._manager;
		var parent = manager.camera.parent;
		if (parent) {
			dirty = dirty || parent._dirtyLocal || parent._dirtyWorld;
			if (dirty) this._worldTransform.mul2(parent.getWorldTransform(), this._localTransform);
		} else {
			this._worldTransform.copy(this._localTransform);
		}
	};
	XrJoint.prototype.getPosition = function () {
		this._updateTransforms();
		this._worldTransform.getTranslation(this._position);
		return this._position;
	};
	XrJoint.prototype.getRotation = function () {
		this._updateTransforms();
		this._rotation.setFromMat4(this._worldTransform);
		return this._rotation;
	};
	Object.defineProperty(XrJoint.prototype, 'index', {
		get: function () {
			return this._index;
		}
	});
	Object.defineProperty(XrJoint.prototype, 'hand', {
		get: function () {
			return this._hand;
		}
	});
	Object.defineProperty(XrJoint.prototype, 'finger', {
		get: function () {
			return this._finger;
		}
	});
	Object.defineProperty(XrJoint.prototype, 'wrist', {
		get: function () {
			return this._wrist;
		}
	});
	Object.defineProperty(XrJoint.prototype, 'tip', {
		get: function () {
			return this._tip;
		}
	});
	Object.defineProperty(XrJoint.prototype, 'radius', {
		get: function () {
			return this._radius || 0.005;
		}
	});

	var fingerJointIds = [];
	var vecA = new Vec3();
	var vecB = new Vec3();
	var vecC = new Vec3();
	if (window.XRHand) {
		fingerJointIds = [
			[XRHand.THUMB_METACARPAL, XRHand.THUMB_PHALANX_PROXIMAL, XRHand.THUMB_PHALANX_DISTAL, XRHand.THUMB_PHALANX_TIP],
			[XRHand.INDEX_METACARPAL, XRHand.INDEX_PHALANX_PROXIMAL, XRHand.INDEX_PHALANX_INTERMEDIATE, XRHand.INDEX_PHALANX_DISTAL, XRHand.INDEX_PHALANX_TIP],
			[XRHand.MIDDLE_METACARPAL, XRHand.MIDDLE_PHALANX_PROXIMAL, XRHand.MIDDLE_PHALANX_INTERMEDIATE, XRHand.MIDDLE_PHALANX_DISTAL, XRHand.MIDDLE_PHALANX_TIP],
			[XRHand.RING_METACARPAL, XRHand.RING_PHALANX_PROXIMAL, XRHand.RING_PHALANX_INTERMEDIATE, XRHand.RING_PHALANX_DISTAL, XRHand.RING_PHALANX_TIP],
			[XRHand.LITTLE_METACARPAL, XRHand.LITTLE_PHALANX_PROXIMAL, XRHand.LITTLE_PHALANX_INTERMEDIATE, XRHand.LITTLE_PHALANX_DISTAL, XRHand.LITTLE_PHALANX_TIP]
		];
	}
	function XrHand(inputSource) {
		EventHandler.call(this);
		var xrHand = inputSource._xrInputSource.hand;
		this._manager = inputSource._manager;
		this._inputSource = inputSource;
		this._tracking = false;
		this._fingers = [];
		this._joints = [];
		this._jointsById = {};
		this._tips = [];
		this._wrist = null;
		if (xrHand[XRHand.WRIST])
			this._wrist = new XrJoint(0, XRHand.WRIST, this, null);
		for (var f = 0; f < fingerJointIds.length; f++) {
			var finger = new XrFinger(f, this);
			for (var j = 0; j < fingerJointIds[f].length; j++) {
				var jointId = fingerJointIds[f][j];
				if (! xrHand[jointId]) continue;
				new XrJoint(j, jointId, this, finger);
			}
		}
	}
	XrHand.prototype = Object.create(EventHandler.prototype);
	XrHand.prototype.constructor = XrHand;
	XrHand.prototype.update = function (frame) {
		var xrInputSource = this._inputSource._xrInputSource;
		for (var j = 0; j < this._joints.length; j++) {
			var joint = this._joints[j];
			var jointSpace = xrInputSource.hand[joint._id];
			if (jointSpace) {
				var pose = frame.getJointPose(jointSpace, this._manager._referenceSpace);
				if (pose) {
					joint.update(pose);
					if (joint.wrist && ! this._tracking) {
						this._tracking = true;
						this.fire('tracking');
					}
				} else if (joint.wrist) {
					if (this._tracking) {
						this._tracking = false;
						this.fire('trackinglost');
					}
					break;
				}
			}
		}
		var j1 = this._jointsById[XRHand.THUMB_METACARPAL];
		var j4 = this._jointsById[XRHand.THUMB_PHALANX_TIP];
		var j6 = this._jointsById[XRHand.INDEX_PHALANX_PROXIMAL];
		var j9 = this._jointsById[XRHand.INDEX_PHALANX_TIP];
		var j16 = this._jointsById[XRHand.RING_PHALANX_PROXIMAL];
		var j21 = this._jointsById[XRHand.LITTLE_PHALANX_PROXIMAL];
		if (j1 && j4 && j6 && j9 && j16 && j21) {
			this._inputSource._dirtyRay = true;
			this._inputSource._rayLocal.origin.lerp(j4._localPosition, j9._localPosition, 0.5);
			var jointL = j1;
			var jointR = j21;
			if (this._inputSource.handedness === XRHAND_LEFT) {
				var t = jointL;
				jointL = jointR;
				jointR = t;
			}
			vecA.sub2(jointL._localPosition, this._wrist._localPosition);
			vecB.sub2(jointR._localPosition, this._wrist._localPosition);
			vecC.cross(vecA, vecB).normalize();
			vecA.lerp(j6._localPosition, j16._localPosition, 0.5);
			vecA.sub(this._wrist._localPosition).normalize();
			this._inputSource._rayLocal.direction.lerp(vecC, vecA, 0.5).normalize();
		}
		if (j4 && j9) {
			vecA.copy(j4._localPosition);
			var d = vecA.distance(j9._localPosition);
			if (d < 0.015) {
				if (! this._inputSource._selecting) {
					this._inputSource._selecting = true;
					this._inputSource.fire('selectstart');
					this._manager.input.fire('selectstart', this._inputSource);
				}
			} else {
				if (this._inputSource._selecting) {
					this._inputSource._selecting = false;
					this._inputSource.fire('select');
					this._manager.input.fire('select', this._inputSource);
					this._inputSource.fire('selectend');
					this._manager.input.fire('selectend', this._inputSource);
				}
			}
		}
	};
	XrHand.prototype.getJointById = function (id) {
		return this._jointsById[id] || null;
	};
	Object.defineProperty(XrHand.prototype, 'fingers', {
		get: function () {
			return this._fingers;
		}
	});
	Object.defineProperty(XrHand.prototype, 'joints', {
		get: function () {
			return this._joints;
		}
	});
	Object.defineProperty(XrHand.prototype, 'tips', {
		get: function () {
			return this._tips;
		}
	});
	Object.defineProperty(XrHand.prototype, 'wrist', {
		get: function () {
			return this._wrist;
		}
	});
	Object.defineProperty(XrHand.prototype, 'tracking', {
		get: function () {
			return this._tracking;
		}
	});

	var quat = new Quat();
	var ids = 0;
	function XrInputSource(manager, xrInputSource) {
		EventHandler.call(this);
		this._id = ++ids;
		this._manager = manager;
		this._xrInputSource = xrInputSource;
		this._ray = new Ray();
		this._rayLocal = new Ray();
		this._grip = false;
		this._hand = null;
		if (xrInputSource.hand)
			this._hand = new XrHand(this);
		this._localTransform = null;
		this._worldTransform = null;
		this._position = new Vec3();
		this._rotation = new Quat();
		this._localPosition = null;
		this._localRotation = null;
		this._dirtyLocal = true;
		this._selecting = false;
		this._elementInput = true;
		this._elementEntity = null;
		this._hitTestSources = [];
	}
	XrInputSource.prototype = Object.create(EventHandler.prototype);
	XrInputSource.prototype.constructor = XrInputSource;
	XrInputSource.prototype.update = function (frame) {
		if (this._hand) {
			this._hand.update(frame);
		} else {
			if (this._xrInputSource.gripSpace) {
				var gripPose = frame.getPose(this._xrInputSource.gripSpace, this._manager._referenceSpace);
				if (gripPose) {
					if (! this._grip) {
						this._grip = true;
						this._localTransform = new Mat4();
						this._worldTransform = new Mat4();
						this._localPosition = new Vec3();
						this._localRotation = new Quat();
					}
					this._dirtyLocal = true;
					this._localPosition.copy(gripPose.transform.position);
					this._localRotation.copy(gripPose.transform.orientation);
				}
			}
			var targetRayPose = frame.getPose(this._xrInputSource.targetRaySpace, this._manager._referenceSpace);
			if (targetRayPose) {
				this._dirtyRay = true;
				this._rayLocal.origin.copy(targetRayPose.transform.position);
				this._rayLocal.direction.set(0, 0, -1);
				quat.copy(targetRayPose.transform.orientation);
				quat.transformVector(this._rayLocal.direction, this._rayLocal.direction);
			}
		}
	};
	XrInputSource.prototype._updateTransforms = function () {
		var dirty;
		if (this._dirtyLocal) {
			dirty = true;
			this._dirtyLocal = false;
			this._localTransform.setTRS(this._localPosition, this._localRotation, Vec3.ONE);
		}
		var parent = this._manager.camera.parent;
		if (parent) {
			dirty = dirty || parent._dirtyLocal || parent._dirtyWorld;
			if (dirty) this._worldTransform.mul2(parent.getWorldTransform(), this._localTransform);
		} else {
			this._worldTransform.copy(this._localTransform);
		}
	};
	XrInputSource.prototype._updateRayTransforms = function () {
		var dirty = this._dirtyRay;
		this._dirtyRay = false;
		var parent = this._manager.camera.parent;
		if (parent) {
			dirty = dirty || parent._dirtyLocal || parent._dirtyWorld;
			if (dirty) {
				var parentTransform = this._manager.camera.parent.getWorldTransform();
				parentTransform.getTranslation(this._position);
				this._rotation.setFromMat4(parentTransform);
				this._rotation.transformVector(this._rayLocal.origin, this._ray.origin);
				this._ray.origin.add(this._position);
				this._rotation.transformVector(this._rayLocal.direction, this._ray.direction);
			}
		} else if (dirty) {
			this._ray.origin.copy(this._rayLocal.origin);
			this._ray.direction.copy(this._rayLocal.direction);
		}
	};
	XrInputSource.prototype.getPosition = function () {
		if (! this._position) return null;
		this._updateTransforms();
		this._worldTransform.getTranslation(this._position);
		return this._position;
	};
	XrInputSource.prototype.getLocalPosition = function () {
		return this._localPosition;
	};
	XrInputSource.prototype.getRotation = function () {
		if (! this._rotation) return null;
		this._updateTransforms();
		this._rotation.setFromMat4(this._worldTransform);
		return this._rotation;
	};
	XrInputSource.prototype.getLocalRotation = function () {
		return this._localRotation;
	};
	XrInputSource.prototype.getOrigin = function () {
		this._updateRayTransforms();
		return this._ray.origin;
	};
	XrInputSource.prototype.getDirection = function () {
		this._updateRayTransforms();
		return this._ray.direction;
	};
	XrInputSource.prototype.hitTestStart = function (options) {
		var self = this;
		options = options || { };
		options.profile = this._xrInputSource.profiles[0];
		var callback = options.callback;
		options.callback = function (err, hitTestSource) {
			if (hitTestSource) self.onHitTestSourceAdd(hitTestSource);
			if (callback) callback(err, hitTestSource);
		};
		this._manager.hitTest.start(options);
	};
	XrInputSource.prototype.onHitTestSourceAdd = function (hitTestSource) {
		this._hitTestSources.push(hitTestSource);
		this.fire('hittest:add', hitTestSource);
		hitTestSource.on('result', function (position, rotation, inputSource) {
			if (inputSource !== this)
				return;
			this.fire('hittest:result', hitTestSource, position, rotation);
		}, this);
		hitTestSource.once('remove', function () {
			this.onHitTestSourceRemove(hitTestSource);
			this.fire('hittest:remove', hitTestSource);
		}, this);
	};
	XrInputSource.prototype.onHitTestSourceRemove = function (hitTestSource) {
		var ind = this._hitTestSources.indexOf(hitTestSource);
		if (ind !== -1) this._hitTestSources.splice(ind, 1);
	};
	Object.defineProperty(XrInputSource.prototype, 'id', {
		get: function () {
			return this._id;
		}
	});
	Object.defineProperty(XrInputSource.prototype, 'inputSource', {
		get: function () {
			return this._xrInputSource;
		}
	});
	Object.defineProperty(XrInputSource.prototype, 'targetRayMode', {
		get: function () {
			return this._xrInputSource.targetRayMode;
		}
	});
	Object.defineProperty(XrInputSource.prototype, 'handedness', {
		get: function () {
			return this._xrInputSource.handedness;
		}
	});
	Object.defineProperty(XrInputSource.prototype, 'profiles', {
		get: function () {
			return this._xrInputSource.profiles;
		}
	});
	Object.defineProperty(XrInputSource.prototype, 'grip', {
		get: function () {
			return this._grip;
		}
	});
	Object.defineProperty(XrInputSource.prototype, 'hand', {
		get: function () {
			return this._hand;
		}
	});
	Object.defineProperty(XrInputSource.prototype, 'gamepad', {
		get: function () {
			return this._xrInputSource.gamepad || null;
		}
	});
	Object.defineProperty(XrInputSource.prototype, 'selecting', {
		get: function () {
			return this._selecting;
		}
	});
	Object.defineProperty(XrInputSource.prototype, 'elementInput', {
		get: function () {
			return this._elementInput;
		},
		set: function (value) {
			if (this._elementInput === value)
				return;
			this._elementInput = value;
			if (! this._elementInput)
				this._elementEntity = null;
		}
	});
	Object.defineProperty(XrInputSource.prototype, 'elementEntity', {
		get: function () {
			return this._elementEntity;
		}
	});
	Object.defineProperty(XrInputSource.prototype, 'hitTestSources', {
		get: function () {
			return this._hitTestSources;
		}
	});

	function XrInput(manager) {
		EventHandler.call(this);
		var self = this;
		this.manager = manager;
		this._session = null;
		this._inputSources = [];
		this._onInputSourcesChangeEvt = function (evt) {
			self._onInputSourcesChange(evt);
		};
		this.manager.on('start', this._onSessionStart, this);
		this.manager.on('end', this._onSessionEnd, this);
	}
	XrInput.prototype = Object.create(EventHandler.prototype);
	XrInput.prototype.constructor = XrInput;
	XrInput.prototype._onSessionStart = function () {
		this._session = this.manager.session;
		this._session.addEventListener('inputsourceschange', this._onInputSourcesChangeEvt);
		var self = this;
		this._session.addEventListener('select', function (evt) {
			var inputSource = self._getByInputSource(evt.inputSource);
			inputSource.update(evt.frame);
			inputSource.fire('select', evt);
			self.fire('select', inputSource, evt);
		});
		this._session.addEventListener('selectstart', function (evt) {
			var inputSource = self._getByInputSource(evt.inputSource);
			inputSource.update(evt.frame);
			inputSource._selecting = true;
			inputSource.fire('selectstart', evt);
			self.fire('selectstart', inputSource, evt);
		});
		this._session.addEventListener('selectend', function (evt) {
			var inputSource = self._getByInputSource(evt.inputSource);
			inputSource.update(evt.frame);
			inputSource._selecting = false;
			inputSource.fire('selectend', evt);
			self.fire('selectend', inputSource, evt);
		});
		var inputSources = this._session.inputSources;
		for (var i = 0; i < inputSources.length; i++) {
			this._addInputSource(inputSources[i]);
		}
	};
	XrInput.prototype._onSessionEnd = function () {
		var i = this._inputSources.length;
		while (i--) {
			var inputSource = this._inputSources[i];
			this._inputSources.splice(i, 1);
			inputSource.fire('remove');
			this.fire('remove', inputSource);
		}
		this._session.removeEventListener('inputsourceschange', this._onInputSourcesChangeEvt);
		this._session = null;
	};
	XrInput.prototype._onInputSourcesChange = function (evt) {
		var i;
		for (i = 0; i < evt.removed.length; i++) {
			this._removeInputSource(evt.removed[i]);
		}
		for (i = 0; i < evt.added.length; i++) {
			this._addInputSource(evt.added[i]);
		}
	};
	XrInput.prototype._getByInputSource = function (xrInputSource) {
		for (var i = 0; i < this._inputSources.length; i++) {
			if (this._inputSources[i].inputSource === xrInputSource) {
				return this._inputSources[i];
			}
		}
		return null;
	};
	XrInput.prototype._addInputSource = function (xrInputSource) {
		if (this._getByInputSource(xrInputSource))
			return;
		var inputSource = new XrInputSource(this.manager, xrInputSource);
		this._inputSources.push(inputSource);
		this.fire('add', inputSource);
	};
	XrInput.prototype._removeInputSource = function (xrInputSource) {
		for (var i = 0; i < this._inputSources.length; i++) {
			if (this._inputSources[i].inputSource !== xrInputSource)
				continue;
			var inputSource = this._inputSources[i];
			this._inputSources.splice(i, 1);
			var h = inputSource.hitTestSources.length;
			while (h--) {
				inputSource.hitTestSources[h].remove();
			}
			inputSource.fire('remove');
			this.fire('remove', inputSource);
			return;
		}
	};
	XrInput.prototype.update = function (frame) {
		for (var i = 0; i < this._inputSources.length; i++) {
			this._inputSources[i].update(frame);
		}
	};
	Object.defineProperty(XrInput.prototype, 'inputSources', {
		get: function () {
			return this._inputSources;
		}
	});

	var vec3A = new Vec3();
	var vec3B = new Vec3();
	var mat4A = new Mat4();
	var mat4B = new Mat4();
	function XrLightEstimation(manager) {
		EventHandler.call(this);
		this._manager = manager;
		this._supported = false;
		this._available = false;
		this._lightProbeRequested = false;
		this._lightProbe = null;
		this._intensity = 0;
		this._rotation = new Quat();
		this._color = new Color();
		this._sphericalHarmonics = new Float32Array(27);
		this._manager.on('start', this._onSessionStart, this);
		this._manager.on('end', this._onSessionEnd, this);
	}
	XrLightEstimation.prototype = Object.create(EventHandler.prototype);
	XrLightEstimation.prototype.constructor = XrLightEstimation;
	XrLightEstimation.prototype._onSessionStart = function () {
		var supported = !! this._manager.session.requestLightProbe;
		if (! supported) return;
		this._supported = true;
	};
	XrLightEstimation.prototype._onSessionEnd = function () {
		this._supported = false;
		this._available = false;
		this._lightProbeRequested = false;
		this._lightProbe = null;
	};
	XrLightEstimation.prototype.start = function () {
		var err;
		if (! this._manager.session)
			err = new Error('XR session is not running');
		if (! err && this._manager.type !== XRTYPE_AR)
			err = new Error('XR session type is not AR');
		if (! err && ! this._supported)
			err = new Error('light-estimation is not supported');
		if (! err && this._lightProbe || this._lightProbeRequested)
			err = new Error('light estimation is already requested');
		if (err) {
			this.fire('error', err);
			return;
		}
		var self = this;
		this._lightProbeRequested = true;
		this._manager.session.requestLightProbe(
		).then(function (lightProbe) {
			var wasRequested = self._lightProbeRequested;
			self._lightProbeRequested = false;
			if (self._manager.active) {
				if (wasRequested) {
					self._lightProbe = lightProbe;
				}
			} else {
				self.fire('error', new Error('XR session is not active'));
			}
		}).catch(function (ex) {
			self._lightProbeRequested = false;
			self.fire('error', ex);
		});
	};
	XrLightEstimation.prototype.end = function () {
		this._lightProbeRequested = false;
		this._lightProbe = null;
		this._available = false;
	};
	XrLightEstimation.prototype.update = function (frame) {
		if (! this._lightProbe) return;
		var lightEstimate = frame.getLightEstimate(this._lightProbe);
		if (! lightEstimate) return;
		if (! this._available) {
			this._available = true;
			this.fire('available');
		}
		var pli = lightEstimate.primaryLightIntensity;
		this._intensity = Math.max(1.0, Math.max(pli.x, Math.max(pli.y, pli.z)));
		vec3A.copy(pli).scale(1 / this._intensity);
		this._color.set(vec3A.x, vec3A.y, vec3A.z);
		vec3A.set(0, 0, 0);
		vec3B.copy(lightEstimate.primaryLightDirection);
		mat4A.setLookAt(vec3B, vec3A, Vec3.UP);
		mat4B.setFromAxisAngle(Vec3.RIGHT, 90);
		mat4A.mul(mat4B);
		this._rotation.setFromMat4(mat4A);
		this._sphericalHarmonics.set(lightEstimate.sphericalHarmonicsCoefficients);
	};
	Object.defineProperty(XrLightEstimation.prototype, 'supported', {
		get: function () {
			return this._supported;
		}
	});
	Object.defineProperty(XrLightEstimation.prototype, 'available', {
		get: function () {
			return !! this._available;
		}
	});
	Object.defineProperty(XrLightEstimation.prototype, 'intensity', {
		get: function () {
			return this._available ? this._intensity : null;
		}
	});
	Object.defineProperty(XrLightEstimation.prototype, 'color', {
		get: function () {
			return this._available ? this._color : null;
		}
	});
	Object.defineProperty(XrLightEstimation.prototype, 'rotation', {
		get: function () {
			return this._available ? this._rotation : null;
		}
	});
	Object.defineProperty(XrLightEstimation.prototype, 'sphericalHarmonics', {
		get: function () {
			return this._available ? this._sphericalHarmonics : null;
		}
	});

	function XrManager(app) {
		EventHandler.call(this);
		var self = this;
		this.app = app;
		this._supported = !! navigator.xr;
		this._available = { };
		this._available[XRTYPE_INLINE] = false;
		this._available[XRTYPE_VR] = false;
		this._available[XRTYPE_AR] = false;
		this._type = null;
		this._spaceType = null;
		this._session = null;
		this._baseLayer = null;
		this._referenceSpace = null;
		this.input = new XrInput(this);
		this.hitTest = new XrHitTest(this);
		this.lightEstimation = new XrLightEstimation(this);
		this._camera = null;
		this.views = [];
		this.viewsPool = [];
		this._localPosition = new Vec3();
		this._localRotation = new Quat();
		this._depthNear = 0.1;
		this._depthFar = 1000;
		this._width = 0;
		this._height = 0;
		if (this._supported) {
			navigator.xr.addEventListener('devicechange', function () {
				self._deviceAvailabilityCheck();
			});
			this._deviceAvailabilityCheck();
		}
	}
	XrManager.prototype = Object.create(EventHandler.prototype);
	XrManager.prototype.constructor = XrManager;
	XrManager.prototype.start = function (camera, type, spaceType, callback) {
		if (! this._available[type]) {
			if (callback) callback(new Error('XR is not available'));
			return;
		}
		if (this._session) {
			if (callback) callback(new Error('XR session is already started'));
			return;
		}
		var self = this;
		this._camera = camera;
		this._camera.camera.xr = this;
		this._type = type;
		this._spaceType = spaceType;
		this._setClipPlanes(camera.nearClip, camera.farClip);
		var optionalFeatures = [];
		if (type === XRTYPE_AR)
			optionalFeatures.push('light-estimation');
		if (type === XRTYPE_VR)
			optionalFeatures.push('hand-tracking');
		navigator.xr.requestSession(type, {
			requiredFeatures: [spaceType],
			optionalFeatures: optionalFeatures
		}).then(function (session) {
			self._onSessionStart(session, spaceType, callback);
		}).catch(function (ex) {
			self._camera.camera.xr = null;
			self._camera = null;
			self._type = null;
			self._spaceType = null;
			if (callback) callback(ex);
			self.fire('error', ex);
		});
	};
	XrManager.prototype.end = function (callback) {
		if (! this._session) {
			if (callback) callback(new Error('XR Session is not initialized'));
			return;
		}
		if (callback) this.once('end', callback);
		this._session.end();
	};
	XrManager.prototype.isAvailable = function (type) {
		return this._available[type];
	};
	XrManager.prototype._deviceAvailabilityCheck = function () {
		for (var key in this._available) {
			this._sessionSupportCheck(key);
		}
	};
	XrManager.prototype._sessionSupportCheck = function (type) {
		var self = this;
		navigator.xr.isSessionSupported(type).then(function (available) {
			if (self._available[type] === available)
				return;
			self._available[type] = available;
			self.fire('available', type, available);
			self.fire('available:' + type, available);
		}).catch(function (ex) {
			self.fire('error', ex);
		});
	};
	XrManager.prototype._onSessionStart = function (session, spaceType, callback) {
		var self = this;
		var failed = false;
		this._session = session;
		var onVisibilityChange = function () {
			self.fire('visibility:change', session.visibilityState);
		};
		var onClipPlanesChange = function () {
			self._setClipPlanes(self._camera.nearClip, self._camera.farClip);
		};
		var onEnd = function () {
			self._session = null;
			self._referenceSpace = null;
			self.views = [];
			self._width = 0;
			self._height = 0;
			self._type = null;
			self._spaceType = null;
			if (self._camera) {
				self._camera.off('set_nearClip', onClipPlanesChange);
				self._camera.off('set_farClip', onClipPlanesChange);
				self._camera.camera.xr = null;
				self._camera = null;
			}
			session.removeEventListener('end', onEnd);
			session.removeEventListener('visibilitychange', onVisibilityChange);
			if (! failed) self.fire('end');
			self.app.tick();
		};
		session.addEventListener('end', onEnd);
		session.addEventListener('visibilitychange', onVisibilityChange);
		this._camera.on('set_nearClip', onClipPlanesChange);
		this._camera.on('set_farClip', onClipPlanesChange);
		this._baseLayer = new XRWebGLLayer(session, this.app.graphicsDevice.gl);
		session.updateRenderState({
			baseLayer: this._baseLayer,
			depthNear: this._depthNear,
			depthFar: this._depthFar
		});
		session.requestReferenceSpace(spaceType).then(function (referenceSpace) {
			self._referenceSpace = referenceSpace;
			self.app.tick();
			if (callback) callback(null);
			self.fire('start');
		}).catch(function (ex) {
			failed = true;
			session.end();
			if (callback) callback(ex);
			self.fire('error', ex);
		});
	};
	XrManager.prototype._setClipPlanes = function (near, far) {
		if (this._depthNear === near && this._depthFar === far)
			return;
		this._depthNear = near;
		this._depthFar = far;
		if (! this._session)
			return;
		this._session.updateRenderState({
			depthNear: this._depthNear,
			depthFar: this._depthFar
		});
	};
	XrManager.prototype.update = function (frame) {
		if (! this._session) return;
		var i, view, viewRaw, layer, viewport;
		var lengthNew;
		var width = frame.session.renderState.baseLayer.framebufferWidth;
		var height = frame.session.renderState.baseLayer.framebufferHeight;
		if (this._width !== width || this._height !== height) {
			this._width = width;
			this._height = height;
			this.app.graphicsDevice.setResolution(width, height);
		}
		var pose = frame.getViewerPose(this._referenceSpace);
		lengthNew = pose ? pose.views.length : 0;
		if (lengthNew > this.views.length) {
			for (i = 0; i <= (lengthNew - this.views.length); i++) {
				view = this.viewsPool.pop();
				if (! view) {
					view = {
						viewport: new Vec4(),
						projMat: new Mat4(),
						viewMat: new Mat4(),
						viewOffMat: new Mat4(),
						viewInvMat: new Mat4(),
						viewInvOffMat: new Mat4(),
						projViewOffMat: new Mat4(),
						viewMat3: new Mat3(),
						position: new Float32Array(3),
						rotation: new Quat()
					};
				}
				this.views.push(view);
			}
		} else if (lengthNew <= this.views.length) {
			for (i = 0; i < (this.views.length - lengthNew); i++) {
				this.viewsPool.push(this.views.pop());
			}
		}
		if (pose) {
			var posePosition = pose.transform.position;
			var poseOrientation = pose.transform.orientation;
			this._localPosition.set(posePosition.x, posePosition.y, posePosition.z);
			this._localRotation.set(poseOrientation.x, poseOrientation.y, poseOrientation.z, poseOrientation.w);
			layer = frame.session.renderState.baseLayer;
			for (i = 0; i < pose.views.length; i++) {
				viewRaw = pose.views[i];
				view = this.views[i];
				viewport = layer.getViewport(viewRaw);
				view.viewport.x = viewport.x;
				view.viewport.y = viewport.y;
				view.viewport.z = viewport.width;
				view.viewport.w = viewport.height;
				view.projMat.set(viewRaw.projectionMatrix);
				view.viewMat.set(viewRaw.transform.inverse.matrix);
				view.viewInvMat.set(viewRaw.transform.matrix);
			}
		}
		this._camera.camera._node.setLocalPosition(this._localPosition);
		this._camera.camera._node.setLocalRotation(this._localRotation);
		this.input.update(frame);
		if (this._type === XRTYPE_AR) {
			if (this.hitTest.supported) {
				this.hitTest.update(frame);
			}
			if (this.lightEstimation.supported) {
				this.lightEstimation.update(frame);
			}
		}
		this.fire('update');
	};
	Object.defineProperty(XrManager.prototype, 'supported', {
		get: function () {
			return this._supported;
		}
	});
	Object.defineProperty(XrManager.prototype, 'active', {
		get: function () {
			return !! this._session;
		}
	});
	Object.defineProperty(XrManager.prototype, 'type', {
		get: function () {
			return this._type;
		}
	});
	Object.defineProperty(XrManager.prototype, 'spaceType', {
		get: function () {
			return this._spaceType;
		}
	});
	Object.defineProperty(XrManager.prototype, 'session', {
		get: function () {
			return this._session;
		}
	});
	Object.defineProperty(XrManager.prototype, 'visibilityState', {
		get: function () {
			if (! this._session)
				return null;
			return this._session.visibilityState;
		}
	});
	Object.defineProperty(XrManager.prototype, 'camera', {
		get: function () {
			return this._camera ? this._camera.entity : null;
		}
	});

	function Component(system, entity) {
		EventHandler.call(this);
		this.system = system;
		this.entity = entity;
		if (this.system.schema && !this._accessorsBuilt) {
			this.buildAccessors(this.system.schema);
		}
		this.on("set", function (name, oldValue, newValue) {
			this.fire("set_" + name, name, oldValue, newValue);
		});
		this.on('set_enabled', this.onSetEnabled, this);
	}
	Component.prototype = Object.create(EventHandler.prototype);
	Component.prototype.constructor = Component;
	Component._buildAccessors = function (obj, schema) {
		schema.forEach(function (descriptor) {
			var name = (typeof descriptor === 'object') ? descriptor.name : descriptor;
			Object.defineProperty(obj, name, {
				get: function () {
					return this.data[name];
				},
				set: function (value) {
					var data = this.data;
					var oldValue = data[name];
					data[name] = value;
					this.fire('set', name, oldValue, value);
				},
				configurable: true
			});
		});
		obj._accessorsBuilt = true;
	};
	Object.assign(Component.prototype, {
		buildAccessors: function (schema) {
			Component._buildAccessors(this, schema);
		},
		onSetEnabled: function (name, oldValue, newValue) {
			if (oldValue !== newValue) {
				if (this.entity.enabled) {
					if (newValue) {
						this.onEnable();
					} else {
						this.onDisable();
					}
				}
			}
		},
		onEnable: function () { },
		onDisable: function () { },
		onPostStateChange: function () { }
	});
	Object.defineProperty(Component.prototype, "data", {
		get: function () {
			var record = this.system.store[this.entity.getGuid()];
			return record ? record.data : null;
		}
	});

	function ComponentSystem(app) {
		EventHandler.call(this);
		this.app = app;
		this.store = {};
		this.schema = [];
	}
	ComponentSystem.prototype = Object.create(EventHandler.prototype);
	ComponentSystem.prototype.constructor = ComponentSystem;
	Object.assign(ComponentSystem, {
		_helper: function (a, p) {
			for (var i = 0, l = a.length; i < l; i++) {
				a[i].f.call(a[i].s, p);
			}
		},
		initialize: function (root) {
			this._helper(this._init, root);
		},
		postInitialize: function (root) {
			this._helper(this._postInit, root);
			this.fire('postinitialize', root);
		},
		update: function (dt, inTools) {
			this._helper(inTools ? this._toolsUpdate : this._update, dt);
		},
		animationUpdate: function (dt, inTools) {
			this._helper(this._animationUpdate, dt);
		},
		fixedUpdate: function (dt, inTools) {
			this._helper(this._fixedUpdate, dt);
		},
		postUpdate: function (dt, inTools) {
			this._helper(this._postUpdate, dt);
		},
		_init: [],
		_postInit: [],
		_toolsUpdate: [],
		_update: [],
		_animationUpdate: [],
		_fixedUpdate: [],
		_postUpdate: [],
		bind: function (event, func, scope) {
			switch (event) {
				case 'initialize':
					this._init.push({ f: func, s: scope });
					break;
				case 'postInitialize':
					this._postInit.push({ f: func, s: scope });
					break;
				case 'update':
					this._update.push({ f: func, s: scope });
					break;
				case 'animationUpdate':
					this._animationUpdate.push({ f: func, s: scope });
					break;
				case 'postUpdate':
					this._postUpdate.push({ f: func, s: scope });
					break;
				case 'fixedUpdate':
					this._fixedUpdate.push({ f: func, s: scope });
					break;
				case 'toolsUpdate':
					this._toolsUpdate.push({ f: func, s: scope });
					break;
				default:
					console.error('Component System does not support event', event);
			}
		},
		_erase: function (a, f, s) {
			for (var i = 0; i < a.length; i++) {
				if (a[i].f === f && a[i].s === s) {
					a.splice(i--, 1);
				}
			}
		},
		unbind: function (event, func, scope) {
			switch (event) {
				case 'initialize':
					this._erase(this._init, func, scope);
					break;
				case 'postInitialize':
					this._erase(this._postInit, func, scope);
					break;
				case 'update':
					this._erase(this._update, func, scope);
					break;
				case 'animationUpdate':
					this._erase(this._animationUpdate, func, scope);
					break;
				case 'postUpdate':
					this._erase(this._postUpdate, func, scope);
					break;
				case 'fixedUpdate':
					this._erase(this._fixedUpdate, func, scope);
					break;
				case 'toolsUpdate':
					this._erase(this._toolsUpdate, func, scope);
					break;
				default:
					console.error('Component System does not support event', event);
			}
		}
	});
	Object.assign(ComponentSystem.prototype, {
		addComponent: function (entity, data) {
			var component = new this.ComponentType(this, entity);
			var componentData = new this.DataType();
			data = data || {};
			this.store[entity.getGuid()] = {
				entity: entity,
				data: componentData
			};
			entity[this.id] = component;
			entity.c[this.id] = component;
			this.initializeComponentData(component, data, []);
			this.fire('add', entity, component);
			return component;
		},
		removeComponent: function (entity) {
			var record = this.store[entity.getGuid()];
			var component = entity.c[this.id];
			this.fire('beforeremove', entity, component);
			delete this.store[entity.getGuid()];
			delete entity[this.id];
			delete entity.c[this.id];
			this.fire('remove', entity, record.data);
		},
		cloneComponent: function (entity, clone) {
			var src = this.store[entity.getGuid()];
			return this.addComponent(clone, src.data);
		},
		initializeComponentData: function (component, data, properties) {
			data = data || {};
			var descriptor;
			var name, type, value;
			for (var i = 0, len = properties.length; i < len; i++) {
				descriptor = properties[i];
				if (typeof descriptor === 'object') {
					name = descriptor.name;
					type = descriptor.type;
				} else {
					name = descriptor;
					type = undefined;
				}
				value = data[name];
				if (value !== undefined) {
					if (type !== undefined) {
						value = convertValue(value, type);
					}
					component[name] = value;
				} else {
					component[name] = component.data[name];
				}
			}
			if (component.enabled && component.entity.enabled) {
				component.onEnable();
			}
		},
		getPropertiesOfType: function (type) {
			var matchingProperties = [];
			var schema = this.schema || [];
			schema.forEach(function (descriptor) {
				if (descriptor && typeof descriptor === 'object' && descriptor.type === type) {
					matchingProperties.push(descriptor);
				}
			});
			return matchingProperties;
		},
		destroy: function () {
			this.off();
		}
	});
	function convertValue(value, type) {
		if (!value) {
			return value;
		}
		switch (type) {
			case 'rgb':
				if (value instanceof Color) {
					return value.clone();
				}
				return new Color(value[0], value[1], value[2]);
			case 'rgba':
				if (value instanceof Color) {
					return value.clone();
				}
				return new Color(value[0], value[1], value[2], value[3]);
			case 'vec2':
				if (value instanceof Vec2) {
					return value.clone();
				}
				return new Vec2(value[0], value[1]);
			case 'vec3':
				if (value instanceof Vec3) {
					return value.clone();
				}
				return new Vec3(value[0], value[1], value[2]);
			case 'vec4':
				if (value instanceof Vec4) {
					return value.clone();
				}
				return new Vec4(value[0], value[1], value[2], value[3]);
			case 'boolean':
			case 'number':
			case 'string':
				return value;
			case 'entity':
				return value;
			default:
				throw new Error('Could not convert unhandled type: ' + type);
		}
	}
	events.attach(ComponentSystem);
	ComponentSystem.destroy = function () {
		ComponentSystem.off('initialize');
		ComponentSystem.off('postInitialize');
		ComponentSystem.off('toolsUpdate');
		ComponentSystem.off('update');
		ComponentSystem.off('animationUpdate');
		ComponentSystem.off('fixedUpdate');
		ComponentSystem.off('postUpdate');
	};

	function InterpolatedKey() {
		this._written = false;
		this._name = "";
		this._keyFrames = [];
		this._quat = new Quat();
		this._pos = new Vec3();
		this._scale = new Vec3();
		this._targetNode = null;
	}
	Object.assign(InterpolatedKey.prototype, {
		getTarget: function () {
			return this._targetNode;
		},
		setTarget: function (node) {
			this._targetNode = node;
		}
	});
	function Skeleton(graph) {
		this._animation = null;
		this._time = 0;
		this.looping = true;
		this._interpolatedKeys = [];
		this._interpolatedKeyDict = {};
		this._currKeyIndices = {};
		this.graph = null;
		var self = this;
		function addInterpolatedKeys(node) {
			var interpKey = new InterpolatedKey();
			interpKey._name = node.name;
			self._interpolatedKeys.push(interpKey);
			self._interpolatedKeyDict[node.name] = interpKey;
			self._currKeyIndices[node.name] = 0;
			for (var i = 0; i < node._children.length; i++)
				addInterpolatedKeys(node._children[i]);
		}
		addInterpolatedKeys(graph);
	}
	Skeleton.prototype.addTime = function (delta) {
		if (this._animation !== null) {
			var i;
			var node, nodeName;
			var keys, interpKey;
			var k1, k2, alpha;
			var nodes = this._animation._nodes;
			var duration = this._animation.duration;
			if ((this._time === duration) && !this.looping) {
				return;
			}
			this._time += delta;
			if (this._time > duration) {
				this._time = this.looping ? 0.0 : duration;
				for (i = 0; i < nodes.length; i++) {
					node = nodes[i];
					nodeName = node._name;
					this._currKeyIndices[nodeName] = 0;
				}
			} else if (this._time < 0) {
				this._time = this.looping ? duration : 0.0;
				for (i = 0; i < nodes.length; i++) {
					node = nodes[i];
					nodeName = node._name;
					this._currKeyIndices[nodeName] = node._keys.length - 2;
				}
			}
			var offset = (delta >= 0 ? 1 : -1);
			var foundKey;
			for (i = 0; i < nodes.length; i++) {
				node = nodes[i];
				nodeName = node._name;
				keys = node._keys;
				interpKey = this._interpolatedKeyDict[nodeName];
				if (interpKey === undefined) {
					continue;
				}
				foundKey = false;
				if (keys.length !== 1) {
					for (var currKeyIndex = this._currKeyIndices[nodeName]; currKeyIndex < keys.length - 1 && currKeyIndex >= 0; currKeyIndex += offset) {
						k1 = keys[currKeyIndex];
						k2 = keys[currKeyIndex + 1];
						if ((k1.time <= this._time) && (k2.time >= this._time)) {
							alpha = (this._time - k1.time) / (k2.time - k1.time);
							interpKey._pos.lerp(k1.position, k2.position, alpha);
							interpKey._quat.slerp(k1.rotation, k2.rotation, alpha);
							interpKey._scale.lerp(k1.scale, k2.scale, alpha);
							interpKey._written = true;
							this._currKeyIndices[nodeName] = currKeyIndex;
							foundKey = true;
							break;
						}
					}
				}
				if (keys.length === 1 || (!foundKey && this._time === 0.0 && this.looping)) {
					interpKey._pos.copy(keys[0].position);
					interpKey._quat.copy(keys[0].rotation);
					interpKey._scale.copy(keys[0].scale);
					interpKey._written = true;
				}
			}
		}
	};
	Skeleton.prototype.blend = function (skel1, skel2, alpha) {
		var numNodes = this._interpolatedKeys.length;
		for (var i = 0; i < numNodes; i++) {
			var key1 = skel1._interpolatedKeys[i];
			var key2 = skel2._interpolatedKeys[i];
			var dstKey = this._interpolatedKeys[i];
			if (key1._written && key2._written) {
				dstKey._quat.slerp(key1._quat, skel2._interpolatedKeys[i]._quat, alpha);
				dstKey._pos.lerp(key1._pos, skel2._interpolatedKeys[i]._pos, alpha);
				dstKey._scale.lerp(key1._scale, key2._scale, alpha);
				dstKey._written = true;
			} else if (key1._written) {
				dstKey._quat.copy(key1._quat);
				dstKey._pos.copy(key1._pos);
				dstKey._scale.copy(key1._scale);
				dstKey._written = true;
			} else if (key2._written) {
				dstKey._quat.copy(key2._quat);
				dstKey._pos.copy(key2._pos);
				dstKey._scale.copy(key2._scale);
				dstKey._written = true;
			}
		}
	};
	Object.defineProperty(Skeleton.prototype, 'animation', {
		get: function () {
			return this._animation;
		},
		set: function (value) {
			this._animation = value;
			this.currentTime = 0;
		}
	});
	Skeleton.prototype.getAnimation = function () {
		return this._animation;
	};
	Object.defineProperty(Skeleton.prototype, 'currentTime', {
		get: function () {
			return this._time;
		},
		set: function (value) {
			this._time = value;
			var numNodes = this._interpolatedKeys.length;
			for (var i = 0; i < numNodes; i++) {
				var node = this._interpolatedKeys[i];
				var nodeName = node._name;
				this._currKeyIndices[nodeName] = 0;
			}
			this.addTime(0);
			this.updateGraph();
		}
	});
	Skeleton.prototype.getCurrentTime = function () {
		return this._time;
	};
	Skeleton.prototype.setCurrentTime = function (time) {
		this.currentTime = time;
	};
	Object.defineProperty(Skeleton.prototype, 'numNodes', {
		get: function () {
			return this._interpolatedKeys.length;
		}
	});
	Skeleton.prototype.getNumNodes = function () {
		return this._interpolatedKeys.length;
	};
	Skeleton.prototype.setAnimation = function (animation) {
		this.animation = animation;
	};
	Skeleton.prototype.setGraph = function (graph) {
		var i;
		this.graph = graph;
		if (graph) {
			for (i = 0; i < this._interpolatedKeys.length; i++) {
				var interpKey = this._interpolatedKeys[i];
				var graphNode = graph.findByName(interpKey._name);
				this._interpolatedKeys[i].setTarget(graphNode);
			}
		} else {
			for (i = 0; i < this._interpolatedKeys.length; i++) {
				this._interpolatedKeys[i].setTarget(null);
			}
		}
	};
	Skeleton.prototype.updateGraph = function () {
		if (this.graph) {
			for (var i = 0; i < this._interpolatedKeys.length; i++) {
				var interpKey = this._interpolatedKeys[i];
				if (interpKey._written) {
					var transform = interpKey.getTarget();
					transform.localPosition.copy(interpKey._pos);
					transform.localRotation.copy(interpKey._quat);
					transform.localScale.copy(interpKey._scale);
					if (!transform._dirtyLocal)
						transform._dirtifyLocal();
					interpKey._written = false;
				}
			}
		}
	};
	Skeleton.prototype.setLooping = function (looping) {
		this.looping = looping;
	};
	Skeleton.prototype.getLooping = function () {
		return this.looping;
	};

	function AnimationComponent(system, entity) {
		Component.call(this, system, entity);
		this.animationsIndex = { };
		this.on('set_animations', this.onSetAnimations, this);
		this.on('set_assets', this.onSetAssets, this);
		this.on('set_loop', this.onSetLoop, this);
	}
	AnimationComponent.prototype = Object.create(Component.prototype);
	AnimationComponent.prototype.constructor = AnimationComponent;
	Object.assign(AnimationComponent.prototype, {
		play: function (name, blendTime) {
			if (!this.enabled || !this.entity.enabled) {
				return;
			}
			var data = this.data;
			if (!data.animations[name]) {
				return;
			}
			blendTime = blendTime || 0;
			data.prevAnim = data.currAnim;
			data.currAnim = name;
			if (data.model) {
				if (!data.skeleton && !data.animEvaluator) {
					this._createAnimationController();
				}
				var prevAnim = data.animations[data.prevAnim];
				var currAnim = data.animations[data.currAnim];
				data.blending = blendTime > 0 && data.prevAnim;
				if (data.blending) {
					data.blend = 0;
					data.blendSpeed = 1.0 / blendTime;
				}
				if (data.skeleton) {
					if (data.blending) {
						data.fromSkel.animation = prevAnim;
						data.fromSkel.addTime(data.skeleton._time);
						data.toSkel.animation = currAnim;
					} else {
						data.skeleton.animation = currAnim;
					}
				}
				if (data.animEvaluator) {
					var animEvaluator = data.animEvaluator;
					if (data.blending) {
						while (animEvaluator.clips.length > 1) {
							animEvaluator.removeClip(0);
						}
					} else {
						data.animEvaluator.removeClips();
					}
					var clip = new AnimClip(data.animations[data.currAnim], 0, 1.0, true, data.loop);
					clip.name = data.currAnim;
					clip.blendWeight = data.blending ? 0 : 1;
					clip.reset();
					data.animEvaluator.addClip(clip);
				}
			}
			data.playing = true;
		},
		getAnimation: function (name) {
			return this.data.animations[name];
		},
		setModel: function (model) {
			var data = this.data;
			if (model !== data.model) {
				this._resetAnimationController();
				data.model = model;
				if (data.animations && data.currAnim && data.animations[data.currAnim]) {
					this.play(data.currAnim);
				}
			}
		},
		_resetAnimationController: function () {
			var data = this.data;
			data.skeleton = null;
			data.fromSkel = null;
			data.toSkel = null;
			data.animEvaluator = null;
		},
		_createAnimationController: function () {
			var data = this.data;
			var model = data.model;
			var animations = data.animations;
			var hasJson = false;
			var hasGlb = false;
			for (var animation in animations) {
				if (animations.hasOwnProperty(animation)) {
					var anim = animations[animation];
					if (anim.constructor === AnimTrack) {
						hasGlb = true;
					} else {
						hasJson = true;
					}
				}
			}
			var graph = model.getGraph();
			if (hasJson) {
				data.fromSkel = new Skeleton(graph);
				data.toSkel = new Skeleton(graph);
				data.skeleton = new Skeleton(graph);
				data.skeleton.looping = data.loop;
				data.skeleton.setGraph(graph);
			} else if (hasGlb) {
				data.animEvaluator = new AnimEvaluator(new DefaultAnimBinder(graph));
			}
		},
		loadAnimationAssets: function (ids) {
			if (!ids || !ids.length)
				return;
			var self = this;
			var assets = this.system.app.assets;
			var i, l = ids.length;
			var onAssetReady = function (asset) {
				if (asset.resources.length > 1) {
					for (var i = 0; i < asset.resources.length; i++) {
						self.animations[asset.resources[i].name] = asset.resources[i];
						self.animationsIndex[asset.id] = asset.resources[i].name;
					}
				} else {
					self.animations[asset.name] = asset.resource;
					self.animationsIndex[asset.id] = asset.name;
				}
				self.animations = self.animations;
			};
			var onAssetAdd = function (asset) {
				asset.off('change', self.onAssetChanged, self);
				asset.on('change', self.onAssetChanged, self);
				asset.off('remove', self.onAssetRemoved, self);
				asset.on('remove', self.onAssetRemoved, self);
				if (asset.resource) {
					onAssetReady(asset);
				} else {
					asset.once('load', onAssetReady, self);
					if (self.enabled && self.entity.enabled)
						assets.load(asset);
				}
			};
			for (i = 0; i < l; i++) {
				var asset = assets.get(ids[i]);
				if (asset) {
					onAssetAdd(asset);
				} else {
					assets.on('add:' + ids[i], onAssetAdd);
				}
			}
		},
		onAssetChanged: function (asset, attribute, newValue, oldValue) {
			var i;
			if (attribute === 'resource' || attribute === 'resources') {
				if (newValue) {
					var restarted = false;
					if (newValue.length > 1) {
						if (oldValue && oldValue.length > 1) {
							for (i = 0; i < oldValue.length; i++) {
								delete this.animations[oldValue[i].name];
							}
						} else {
							delete this.animations[asset.name];
						}
						restarted = false;
						for (i = 0; i < newValue.length; i++) {
							this.animations[newValue[i].name] = newValue[i];
							if (!restarted && this.data.currAnim === newValue[i].name) {
								if (this.data.playing && this.data.enabled && this.entity.enabled) {
									restarted = true;
									this.play(newValue[i].name, 0);
								}
							}
						}
						if (!restarted) {
							this._stopCurrentAnimation();
							this.onSetAnimations();
						}
					} else {
						if (oldValue && oldValue.length > 1) {
							for (i = 0; i < oldValue.length; i++) {
								delete this.animations[oldValue[i].name];
							}
						}
						this.animations[asset.name] = newValue[0] || newValue;
						restarted = false;
						if (this.data.currAnim === asset.name) {
							if (this.data.playing && this.data.enabled && this.entity.enabled) {
								restarted = true;
								this.play(asset.name, 0);
							}
						}
						if (!restarted) {
							this._stopCurrentAnimation();
							this.onSetAnimations();
						}
					}
					this.animationsIndex[asset.id] = asset.name;
				} else {
					if (oldValue.length > 1) {
						for (i = 0; i < oldValue.length; i++) {
							delete this.animations[oldValue[i].name];
						}
					} else {
						delete this.animations[asset.name];
					}
					delete this.animationsIndex[asset.id];
				}
			}
		},
		onAssetRemoved: function (asset) {
			asset.off('remove', this.onAssetRemoved, this);
			if (this.animations) {
				if (asset.resources.length > 1) {
					for (var i = 0; i < asset.resources.length; i++) {
						delete this.animations[asset.resources[i].name];
						if (this.data.currAnim === asset.resources[i].name)
							this._stopCurrentAnimation();
					}
				} else {
					delete this.animations[asset.name];
					if (this.data.currAnim === asset.name)
						this._stopCurrentAnimation();
				}
				delete this.animationsIndex[asset.id];
			}
		},
		_stopCurrentAnimation: function () {
			var data = this.data;
			data.currAnim = null;
			data.playing = false;
			if (data.skeleton) {
				data.skeleton.currentTime = 0;
				data.skeleton.animation = null;
			}
			if (data.animEvaluator) {
				data.animEvaluator.removeClips();
			}
		},
		onSetAnimations: function (name, oldValue, newValue) {
			var data = this.data;
			var modelComponent = this.entity.model;
			if (modelComponent) {
				var m = modelComponent.model;
				if (m && m !== data.model) {
					this.setModel(m);
				}
			}
			if (!data.currAnim && data.activate && data.enabled && this.entity.enabled) {
				for (var animName in data.animations) {
					this.play(animName, 0);
					break;
				}
			}
		},
		onSetAssets: function (name, oldValue, newValue) {
			if (oldValue && oldValue.length) {
				for (var i = 0; i < oldValue.length; i++) {
					if (oldValue[i]) {
						var asset = this.system.app.assets.get(oldValue[i]);
						if (asset) {
							asset.off('change', this.onAssetChanged, this);
							asset.off('remove', this.onAssetRemoved, this);
							var animName = this.animationsIndex[asset.id];
							if (this.data.currAnim === animName)
								this._stopCurrentAnimation();
							delete this.animations[animName];
							delete this.animationsIndex[asset.id];
						}
					}
				}
			}
			var ids = newValue.map(function (value) {
				return (value instanceof Asset) ? value.id : value;
			});
			this.loadAnimationAssets(ids);
		},
		onSetLoop: function (name, oldValue, newValue) {
			var data = this.data;
			if (data.skeleton) {
				data.skeleton.looping = data.loop;
			}
			if (data.animEvaluator) {
				for (var i = 0; i < data.animEvaluator.clips.length; ++i) {
					data.animEvaluator.clips[i].loop = data.loop;
				}
			}
		},
		onSetCurrentTime: function (name, oldValue, newValue) {
			var data = this.data;
			if (data.skeleton) {
				var skeleton = data.skeleton;
				skeleton.currentTime = newValue;
				skeleton.addTime(0);
				skeleton.updateGraph();
			}
			if (data.animEvaluator) {
				var animEvaluator = data.animEvaluator;
				for (var i = 0; i < animEvaluator.clips.length; ++i) {
					animEvaluator.clips[i].time = newValue;
				}
			}
		},
		onEnable: function () {
			Component.prototype.onEnable.call(this);
			var data = this.data;
			var assets = data.assets;
			var registry = this.system.app.assets;
			if (assets) {
				for (var i = 0, len = assets.length; i < len; i++) {
					var asset = assets[i];
					if (!(asset instanceof Asset))
						asset = registry.get(asset);
					if (asset && !asset.resource)
						registry.load(asset);
				}
			}
			if (data.activate && !data.currAnim) {
				for (var animName in data.animations) {
					this.play(animName, 0);
					break;
				}
			}
		},
		onBeforeRemove: function () {
			for (var i = 0; i < this.assets.length; i++) {
				var asset = this.system.app.assets.get(this.assets[i]);
				if (!asset) continue;
				asset.off('change', this.onAssetChanged, this);
				asset.off('remove', this.onAssetRemoved, this);
			}
			var data = this.data;
			delete data.animation;
			delete data.skeleton;
			delete data.fromSkel;
			delete data.toSkel;
			delete data.animEvaluator;
		}
	});
	Object.defineProperties(AnimationComponent.prototype, {
		currentTime: {
			get: function () {
				var data = this.data;
				if (data.skeleton) {
					return this.data.skeleton._time;
				}
				if (data.animEvaluator) {
					var clips = data.animEvaluator.clips;
					if (clips.length > 0) {
						return clips[clips.length - 1].time;
					}
				}
				return 0;
			},
			set: function (currentTime) {
				var data = this.data;
				if (data.skeleton) {
					var skeleton = data.skeleton;
					skeleton.currentTime = currentTime;
					skeleton.addTime(0);
					skeleton.updateGraph();
				}
				if (data.animEvaluator) {
					var animEvaluator = data.animEvaluator;
					for (var i = 0; i < animEvaluator.clips.length; ++i) {
						animEvaluator.clips[i].time = currentTime;
					}
				}
			}
		},
		duration: {
			get: function () {
				return this.data.animations[this.data.currAnim].duration;
			}
		}
	});

	function AnimationComponentData() {
		this.assets = [];
		this.speed = 1.0;
		this.loop = true;
		this.activate = true;
		this.enabled = true;
		this.animations = { };
		this.model = null;
		this.prevAnim = null;
		this.currAnim = null;
		this.blending = false;
		this.blend = 0;
		this.blendSpeed = 0;
		this.playing = false;
		this.skeleton = null;
		this.fromSkel = null;
		this.toSkel = null;
		this.animEvaluator = null;
	}

	var _schema = [
		'enabled',
		'assets',
		'speed',
		'loop',
		'activate',
		'animations',
		'skeleton',
		'model',
		'prevAnim',
		'currAnim',
		'fromSkel',
		'toSkel',
		'blending',
		'blendTimeRemaining',
		'playing'
	];
	function AnimationComponentSystem(app) {
		ComponentSystem.call(this, app);
		this.id = 'animation';
		this.ComponentType = AnimationComponent;
		this.DataType = AnimationComponentData;
		this.schema = _schema;
		this.on('beforeremove', this.onBeforeRemove, this);
		this.on('update', this.onUpdate, this);
		ComponentSystem.bind('update', this.onUpdate, this);
	}
	AnimationComponentSystem.prototype = Object.create(ComponentSystem.prototype);
	AnimationComponentSystem.prototype.constructor = AnimationComponentSystem;
	Component._buildAccessors(AnimationComponent.prototype, _schema);
	Object.assign(AnimationComponentSystem.prototype, {
		initializeComponentData: function (component, data, properties) {
			properties = ['activate', 'enabled', 'loop', 'speed', 'assets'];
			ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
		},
		cloneComponent: function (entity, clone) {
			var key;
			this.addComponent(clone, {});
			clone.animation.assets = entity.animation.assets.slice();
			clone.animation.data.speed = entity.animation.speed;
			clone.animation.data.loop = entity.animation.loop;
			clone.animation.data.activate = entity.animation.activate;
			clone.animation.data.enabled = entity.animation.enabled;
			var clonedAnimations = { };
			var animations = entity.animation.animations;
			for (key in animations) {
				if (animations.hasOwnProperty(key)) {
					clonedAnimations[key] = animations[key];
				}
			}
			clone.animation.animations = clonedAnimations;
			var clonedAnimationsIndex = { };
			var animationsIndex = entity.animation.animationsIndex;
			for (key in animationsIndex) {
				if (animationsIndex.hasOwnProperty(key)) {
					clonedAnimationsIndex[key] = animationsIndex[key];
				}
			}
			clone.animation.animationsIndex = clonedAnimationsIndex;
		},
		onBeforeRemove: function (entity, component) {
			component.onBeforeRemove();
		},
		onUpdate: function (dt) {
			var components = this.store;
			for (var id in components) {
				if (components.hasOwnProperty(id)) {
					var component = components[id];
					var componentData = component.data;
					if (componentData.enabled && component.entity.enabled) {
						if (componentData.blending) {
							componentData.blend += dt * componentData.blendSpeed;
							if (componentData.blend >= 1.0) {
								componentData.blend = 1.0;
							}
						}
						if (componentData.playing) {
							var skeleton = componentData.skeleton;
							if (skeleton !== null && componentData.model !== null) {
								if (componentData.blending) {
									skeleton.blend(componentData.fromSkel, componentData.toSkel, componentData.blend);
								} else {
									var delta = dt * componentData.speed;
									skeleton.addTime(delta);
									if (componentData.speed > 0 && (skeleton._time === skeleton._animation.duration) && !componentData.loop) {
										componentData.playing = false;
									} else if (componentData.speed < 0 && skeleton._time === 0 && !componentData.loop) {
										componentData.playing = false;
									}
								}
								if (componentData.blending && (componentData.blend === 1.0)) {
									skeleton.animation = componentData.toSkel._animation;
								}
								skeleton.updateGraph();
							}
						}
						var animEvaluator = componentData.animEvaluator;
						if (animEvaluator) {
							for (var i = 0; i < animEvaluator.clips.length; ++i) {
								var clip = animEvaluator.clips[i];
								clip.speed = componentData.speed;
								if (!componentData.playing) {
									clip.pause();
								} else {
									clip.resume();
								}
							}
							if (componentData.blending) {
								animEvaluator.clips[1].blendWeight = componentData.blend;
							}
							animEvaluator.update(dt);
						}
						if (componentData.blending && componentData.blend === 1.0) {
							componentData.blending = false;
						}
					}
				}
			}
		}
	});

	var ANIM_INTERRUPTION_NONE = 'NONE';
	var ANIM_INTERRUPTION_PREV = 'PREV_STATE';
	var ANIM_INTERRUPTION_NEXT = 'NEXT_STATE';
	var ANIM_INTERRUPTION_PREV_NEXT = 'PREV_STATE_NEXT_STATE';
	var ANIM_INTERRUPTION_NEXT_PREV = 'NEXT_STATE_PREV_STATE';
	var ANIM_GREATER_THAN = 'GREATER_THAN';
	var ANIM_LESS_THAN = 'LESS_THAN';
	var ANIM_GREATER_THAN_EQUAL_TO = 'GREATER_THAN_EQUAL_TO';
	var ANIM_LESS_THAN_EQUAL_TO = 'LESS_THAN_EQUAL_TO';
	var ANIM_EQUAL_TO = 'EQUAL_TO';
	var ANIM_NOT_EQUAL_TO = 'NOT_EQUAL_TO';
	var ANIM_PARAMETER_INTEGER = 'INTEGER';
	var ANIM_PARAMETER_FLOAT = 'FLOAT';
	var ANIM_PARAMETER_BOOLEAN = 'BOOLEAN';
	var ANIM_PARAMETER_TRIGGER = 'TRIGGER';
	var ANIM_STATE_START = 'START';
	var ANIM_STATE_END = 'END';

	function AnimComponentBinder(animComponent, graph) {
		this.animComponent = animComponent;
		if (graph) {
			DefaultAnimBinder.call(this, graph);
		} else {
			this.propertyLocator = new AnimPropertyLocator();
		}
	}
	AnimComponentBinder.prototype = Object.create(DefaultAnimBinder.prototype);
	AnimComponentBinder.prototype.constructor = AnimComponentBinder;
	Object.assign(AnimComponentBinder.prototype, {
		resolve: function (path) {
			var pathSections = this.propertyLocator.decode(path);
			var entityHierarchy = pathSections[0];
			var component = pathSections[1];
			var propertyHierarchy = pathSections[2];
			var entity = this._getEntityFromHierarchy(entityHierarchy);
			if (!entity)
				return null;
			var propertyComponent;
			switch (component) {
				case 'entity':
					propertyComponent = entity;
					break;
				case 'graph':
					if (!this.nodes || !this.nodes[entityHierarchy[0]]) {
						return null;
					}
					propertyComponent = this.nodes[entityHierarchy[0]].node;
					break;
				default:
					propertyComponent = entity.findComponent(component);
					if (!propertyComponent)
						return null;
			}
			return this._createAnimTargetForProperty(propertyComponent, propertyHierarchy);
		},
		update: function (deltaTime) {
			var activeNodes = this.activeNodes;
			if (activeNodes) {
				for (var i = 0; i < activeNodes.length; i++) {
					activeNodes[i]._dirtifyLocal();
				}
			}
		},
		_getEntityFromHierarchy: function (entityHierarchy) {
			if (!this.animComponent.entity.name === entityHierarchy[0]) {
				return null;
			}
			var currEntity = this.animComponent.entity;
			if (entityHierarchy.length === 1) {
				return currEntity;
			}
			return currEntity._parent.findByPath(entityHierarchy.join('/'));
		},
		_floatSetter: function (propertyComponent, propertyHierarchy) {
			var setter = function (values) {
				this._setProperty(propertyComponent, propertyHierarchy, values[0]);
			};
			return setter.bind(this);
		},
		_booleanSetter: function (propertyComponent, propertyHierarchy) {
			var setter = function (values) {
				this._setProperty(propertyComponent, propertyHierarchy, !!values[0]);
			};
			return setter.bind(this);
		},
		_colorSetter: function (propertyComponent, propertyHierarchy) {
			var colorKeys = ['r', 'g', 'b', 'a'];
			var setter = function (values) {
				for (var i = 0; i < values.length; i++) {
					this._setProperty(propertyComponent, propertyHierarchy.concat(colorKeys[i]), values[i]);
				}
			};
			return setter.bind(this);
		},
		_vecSetter: function (propertyComponent, propertyHierarchy) {
			var vectorKeys = ['x', 'y', 'z', 'w'];
			var setter = function (values) {
				for (var i = 0; i < values.length; i++) {
					this._setProperty(propertyComponent, propertyHierarchy.concat(vectorKeys[i]), values[i]);
				}
			};
			return setter.bind(this);
		},
		_getProperty: function (propertyComponent, propertyHierarchy) {
			if (propertyHierarchy.length === 1) {
				return propertyComponent[propertyHierarchy[0]];
			}
			var propertyObject = propertyComponent[propertyHierarchy[0]];
			return propertyObject[propertyHierarchy[1]];
		},
		_setProperty: function (propertyComponent, propertyHierarchy, value) {
			if (propertyHierarchy.length === 1) {
				propertyComponent[propertyHierarchy[0]] = value;
			} else {
				var propertyObject = propertyComponent[propertyHierarchy[0]];
				propertyObject[propertyHierarchy[1]] = value;
				propertyComponent[propertyHierarchy[0]] = propertyObject;
			}
		},
		_getEntityProperty: function (propertyHierarchy) {
			var entityProperties = [
				'localScale',
				'localPosition',
				'localRotation',
				'localEulerAngles',
				'position',
				'rotation',
				'eulerAngles'
			];
			var entityProperty;
			for (var i = 0; i < entityProperties.length; i++) {
				if (propertyHierarchy.indexOf(entityProperties[i]) !== -1) {
					entityProperty = entityProperties[i];
				}
			}
			return entityProperty;
		},
		_createAnimTargetForProperty: function (propertyComponent, propertyHierarchy) {
			if (this.handlers && propertyHierarchy[0] === 'weights') {
				return this.handlers.weights(propertyComponent);
			} else if (this.handlers && propertyHierarchy[0] === 'material' && propertyHierarchy.length === 2) {
				var materialPropertyName = propertyHierarchy[1];
				if (materialPropertyName.indexOf('Map') === materialPropertyName.length - 3) {
					return this.handlers.materialTexture(propertyComponent, materialPropertyName);
				}
			}
			var property = this._getProperty(propertyComponent, propertyHierarchy);
			if (typeof property === 'undefined')
				return null;
			var setter;
			var animDataType;
			var animDataComponents;
			if (typeof property === 'number') {
				setter = this._floatSetter(propertyComponent, propertyHierarchy);
				animDataType = 'vector';
				animDataComponents = 1;
			} else if (typeof property === 'boolean') {
				setter = this._booleanSetter(propertyComponent, propertyHierarchy);
				animDataType = 'vector';
				animDataComponents = 1;
			} else if (typeof property === 'object') {
				switch (property.constructor) {
					case Vec2:
						setter = this._vecSetter(propertyComponent, propertyHierarchy);
						animDataType = 'vector';
						animDataComponents = 2;
						break;
					case Vec3:
						setter = this._vecSetter(propertyComponent, propertyHierarchy);
						animDataType = 'vector';
						animDataComponents = 3;
						break;
					case Vec4:
						setter = this._vecSetter(propertyComponent, propertyHierarchy);
						animDataType = 'vector';
						animDataComponents = 4;
						break;
					case Color:
						setter = this._colorSetter(propertyComponent, propertyHierarchy);
						animDataType = 'vector';
						animDataComponents = 4;
						break;
					case Quat:
						setter = this._vecSetter(propertyComponent, propertyHierarchy);
						animDataType = 'quaternion';
						animDataComponents = 4;
						break;
					default:
						return null;
				}
			}
			var entityProperty = this._getEntityProperty(propertyHierarchy);
			if (entityProperty) {
				var entityPropertySetter = function (values) {
					setter(values);
					var entityPropertySetterFunctionName = "set" +
						entityProperty.substring(0, 1).toUpperCase() +
						entityProperty.substring(1);
					propertyComponent[entityPropertySetterFunctionName](this._getProperty(propertyComponent, [entityProperty]));
				};
				return new AnimTarget(entityPropertySetter.bind(this), animDataType, animDataComponents);
			} else if (propertyHierarchy.indexOf('material') !== -1) {
				return new AnimTarget(function (values) {
					setter(values);
					propertyComponent.material.update();
				}, animDataType, animDataComponents);
			}
			return new AnimTarget(setter, animDataType, animDataComponents);
		}
	});

	function AnimComponentLayer(name, controller, component) {
		this._name = name;
		this._controller = controller;
		this._component = component;
	}
	Object.assign(AnimComponentLayer.prototype, {
		play: function (name) {
			this._controller.play(name);
		},
		pause: function () {
			this._controller.pause();
		},
		reset: function () {
			this._controller.reset();
		},
		update: function (dt) {
			this._controller.update(dt);
		},
		assignAnimation: function (nodeName, animTrack) {
			if (animTrack.constructor !== AnimTrack) {
				return;
			}
			this._controller.assignAnimation(nodeName, animTrack);
			if (this._component.activate && this._component.playable) {
				this._component.playing = true;
			}
		},
		removeNodeAnimations: function (nodeName) {
			this._controller.removeNodeAnimations(nodeName);
			this._component.playing = false;
		}
	});
	Object.defineProperties(AnimComponentLayer.prototype, {
		name: {
			get: function () {
				return this._name;
			}
		},
		playing: {
			get: function () {
				return this._controller.playing;
			},
			set: function (value) {
				this._controller.playing = value;
			}
		},
		playable: {
			get: function () {
				return this._controller.playable;
			}
		},
		activeState: {
			get: function () {
				return this._controller.activeStateName;
			}
		},
		previousState: {
			get: function () {
				return this._controller.previousStateName;
			}
		},
		activeStateProgress: {
			get: function () {
				return this._controller.activeStateProgress;
			}
		},
		activeStateDuration: {
			get: function () {
				return this._controller.activeStateDuration;
			}
		},
		activeStateCurrentTime: {
			get: function () {
				return this._controller.activeStateCurrentTime;
			},
			set: function (time) {
				this._controller.activeStateCurrentTime = time;
			}
		},
		transitioning: {
			get: function () {
				return this._controller.transitioning;
			}
		},
		transitionProgress: {
			get: function () {
				if (this.transitioning) {
					return this._controller.transitionProgress;
				}
				return null;
			}
		},
		states: {
			get: function () {
				return this._controller.states;
			}
		}
	});

	function AnimState(controller, name, speed, loop) {
		this._controller = controller;
		this._name = name;
		this._animations = [];
		this._speed = speed || 1.0;
		this._loop = loop === undefined ? true : loop;
	}
	Object.defineProperties(AnimState.prototype, {
		name: {
			get: function () {
				return this._name;
			}
		},
		animations: {
			get: function () {
				return this._animations;
			},
			set: function (value) {
				this._animations = value;
			}
		},
		speed: {
			get: function () {
				return this._speed;
			}
		},
		loop: {
			get: function () {
				return this._loop;
			}
		},
		playable: {
			get: function () {
				return (this.animations.length > 0 || this.name === ANIM_STATE_START || this.name === ANIM_STATE_END);
			}
		},
		looping: {
			get: function () {
				if (this.animations.length > 0) {
					var trackClipName = this.name + '.' + this.animations[0].animTrack.name;
					var trackClip = this._controller.animEvaluator.findClip(trackClipName);
					if (trackClip) {
						return trackClip.loop;
					}
				}
				return false;
			}
		},
		totalWeight: {
			get: function () {
				var sum = 0;
				var i;
				for (i = 0; i < this.animations.length; i++) {
					sum += this.animations[i].weight;
				}
				return sum;
			}
		},
		timelineDuration: {
			get: function () {
				var duration = 0;
				var i;
				for (i = 0; i < this.animations.length; i++) {
					var animation = this.animations[i];
					if (animation.animTrack.duration > duration) {
						duration = animation.animTrack.duration > duration;
					}
				}
				return duration;
			}
		}
	});
	function AnimTransition(controller, from, to, time, priority, conditions, exitTime, transitionOffset, interruptionSource) {
		this._controller = controller;
		this._from = from;
		this._to = to;
		this._time = time;
		this._priority = priority;
		this._conditions = conditions || [];
		this._exitTime = exitTime || null;
		this._transitionOffset = transitionOffset || null;
		this._interruptionSource = interruptionSource || ANIM_INTERRUPTION_NONE;
	}
	Object.defineProperties(AnimTransition.prototype, {
		from: {
			get: function () {
				return this._from;
			}
		},
		to: {
			get: function () {
				return this._to;
			}
		},
		time: {
			get: function () {
				return this._time;
			}
		},
		priority: {
			get: function () {
				return this._priority;
			}
		},
		conditions: {
			get: function () {
				return this._conditions;
			}
		},
		exitTime: {
			get: function () {
				return this._exitTime;
			}
		},
		transitionOffset: {
			get: function () {
				return this._transitionOffset;
			}
		},
		interruptionSource: {
			get: function () {
				return this._interruptionSource;
			}
		},
		hasExitTime: {
			get: function () {
				return !!this.exitTime;
			}
		},
		hasConditionsMet: {
			get: function () {
				var conditionsMet = true;
				var i;
				for (i = 0; i < this.conditions.length; i++) {
					var condition = this.conditions[i];
					var parameter = this._controller.findParameter(condition.parameterName);
					switch (condition.predicate) {
						case ANIM_GREATER_THAN:
							conditionsMet = conditionsMet && parameter.value > condition.value;
							break;
						case ANIM_LESS_THAN:
							conditionsMet = conditionsMet && parameter.value < condition.value;
							break;
						case ANIM_GREATER_THAN_EQUAL_TO:
							conditionsMet = conditionsMet && parameter.value >= condition.value;
							break;
						case ANIM_LESS_THAN_EQUAL_TO:
							conditionsMet = conditionsMet && parameter.value <= condition.value;
							break;
						case ANIM_EQUAL_TO:
							conditionsMet = conditionsMet && parameter.value === condition.value;
							break;
						case ANIM_NOT_EQUAL_TO:
							conditionsMet = conditionsMet && parameter.value !== condition.value;
							break;
					}
					if (!conditionsMet)
						return conditionsMet;
				}
				return conditionsMet;
			}
		}
	});
	function AnimController(animEvaluator, states, transitions, parameters, activate) {
		this._animEvaluator = animEvaluator;
		this._states = {};
		this._stateNames = [];
		var i;
		for (i = 0; i < states.length; i++) {
			this._states[states[i].name] = new AnimState(
				this,
				states[i].name,
				states[i].speed,
				states[i].loop
			);
			this._stateNames.push(states[i].name);
		}
		this._transitions = transitions.map(function (transition) {
			return new AnimTransition(
				this,
				transition.from,
				transition.to,
				transition.time,
				transition.priority,
				transition.conditions,
				transition.exitTime,
				transition.transitionOffset,
				transition.interruptionSource
			);
		}.bind(this));
		this._findTransitionsFromStateCache = {};
		this._findTransitionsBetweenStatesCache = {};
		this._parameters = parameters;
		this._previousStateName = null;
		this._activeStateName = ANIM_STATE_START;
		this._playing = false;
		this._activate = activate;
		this._currTransitionTime = 1.0;
		this._totalTransitionTime = 1.0;
		this._isTransitioning = false;
		this._transitionInterruptionSource = ANIM_INTERRUPTION_NONE;
		this._transitionPreviousStates = [];
		this._timeInState = 0;
		this._timeInStateBefore = 0;
	}
	Object.defineProperties(AnimController.prototype, {
		animEvaluator: {
			get: function () {
				return this._animEvaluator;
			}
		},
		activeState: {
			get: function () {
				return this._findState(this._activeStateName);
			},
			set: function (stateName) {
				this._activeStateName = stateName;
			}
		},
		activeStateName: {
			get: function () {
				return this._activeStateName;
			}
		},
		activeStateAnimations: {
			get: function () {
				return this.activeState.animations;
			}
		},
		previousState: {
			get: function () {
				return this._findState(this._previousStateName);
			},
			set: function (stateName) {
				this._previousStateName = stateName;
			}
		},
		previousStateName: {
			get: function () {
				return this._previousStateName;
			}
		},
		playable: {
			get: function () {
				var playable = true;
				var i;
				for (i = 0; i < this._stateNames.length; i++) {
					if (!this._states[this._stateNames[i]].playable) {
						playable = false;
					}
				}
				return playable;
			}
		},
		playing: {
			get: function () {
				return this._playing;
			},
			set: function (value) {
				this._playing = value;
			}
		},
		activeStateProgress: {
			get: function () {
				return this._getActiveStateProgressForTime(this._timeInState);
			}
		},
		activeStateDuration: {
			get: function () {
				if (this.activeStateName === ANIM_STATE_START || this.activeStateName === ANIM_STATE_END)
					return 0.0;
				var maxDuration = 0.0;
				for (var i = 0; i < this.activeStateAnimations.length; i++) {
					var activeClip = this._animEvaluator.findClip(this.activeStateAnimations[i].name);
					maxDuration = Math.max(maxDuration, activeClip.track.duration);
				}
				return maxDuration;
			}
		},
		activeStateCurrentTime: {
			get: function () {
				return this._timeInState;
			},
			set: function (time) {
				this._timeInStateBefore = time;
				this._timeInState = time;
				for (var i = 0; i < this.activeStateAnimations.length; i++) {
					var clip = this.animEvaluator.findClip(this.activeStateAnimations[i].name);
					if (clip) {
						clip.time = time;
					}
				}
			}
		},
		transitioning: {
			get: function () {
				return this._isTransitioning;
			}
		},
		transitionProgress: {
			get: function () {
				return this._currTransitionTime / this._totalTransitionTime;
			}
		},
		states: {
			get: function () {
				return this._stateNames;
			}
		}
	});
	Object.assign(AnimController.prototype, {
		_findState: function (stateName) {
			return this._states[stateName];
		},
		_getActiveStateProgressForTime: function (time) {
			if (this.activeStateName === ANIM_STATE_START || this.activeStateName === ANIM_STATE_END)
				return 1.0;
			var activeClip = this._animEvaluator.findClip(this.activeStateAnimations[0].name);
			if (activeClip) {
				return time / activeClip.track.duration;
			}
			return null;
		},
		_findTransitionsFromState: function (stateName) {
			var transitions = this._findTransitionsFromStateCache[stateName];
			if (!transitions) {
				transitions = this._transitions.filter(function (transition) {
					return transition.from === stateName;
				});
				transitions.sort(function (a, b) {
					return a.priority < b.priority;
				});
				this._findTransitionsFromStateCache[stateName] = transitions;
			}
			return transitions;
		},
		_findTransitionsBetweenStates: function (sourceStateName, destinationStateName) {
			var transitions = this._findTransitionsBetweenStatesCache[sourceStateName + '->' + destinationStateName];
			if (!transitions) {
				transitions = this._transitions.filter(function (transition) {
					return transition.from === sourceStateName && transition.to === destinationStateName;
				});
				transitions.sort(function (a, b) {
					return a.priority < b.priority;
				});
				this._findTransitionsBetweenStatesCache[sourceStateName + '->' + destinationStateName] = transitions;
			}
			return transitions;
		},
		_findTransition: function (from, to) {
			var transitions = [];
			if (from && to) {
				transitions.concat(this._findTransitionsBetweenStates(this._activeStateName));
			} else {
				if (!this._isTransitioning) {
					transitions = transitions.concat(this._findTransitionsFromState(this._activeStateName));
				} else {
					switch (this._transitionInterruptionSource) {
						case ANIM_INTERRUPTION_PREV:
							transitions = transitions.concat(this._findTransitionsFromState(this._previousStateName));
							break;
						case ANIM_INTERRUPTION_NEXT:
							transitions = transitions.concat(this._findTransitionsFromState(this._activeStateName));
							break;
						case ANIM_INTERRUPTION_PREV_NEXT:
							transitions = transitions.concat(this._findTransitionsFromState(this._previousStateName));
							transitions = transitions.concat(this._findTransitionsFromState(this._activeStateName));
							break;
						case ANIM_INTERRUPTION_NEXT_PREV:
							transitions = transitions.concat(this._findTransitionsFromState(this._activeStateName));
							transitions = transitions.concat(this._findTransitionsFromState(this._previousStateName));
							break;
					}
				}
			}
			transitions = transitions.filter(function (transition) {
				if (transition.to === this.activeStateName) {
					return false;
				}
				if (transition.hasExitTime) {
					var progressBefore = this._getActiveStateProgressForTime(this._timeInStateBefore);
					var progress = this._getActiveStateProgressForTime(this._timeInState);
					if (transition.exitTime < 1.0 && this.activeState.looping) {
						progressBefore -= Math.floor(progressBefore);
						progress -= Math.floor(progress);
					}
					if (!(transition.exitTime > progressBefore && transition.exitTime <= progress)) {
						return null;
					}
				}
				return transition.hasConditionsMet;
			}.bind(this));
			if (transitions.length > 0) {
				return transitions[0];
			}
			return null;
		},
		_updateStateFromTransition: function (transition) {
			var i;
			var j;
			var state;
			var animation;
			var clip;
			this.previousState = transition.from;
			this.activeState = transition.to;
			for (i = 0; i < transition.conditions.length; i++) {
				var condition = transition.conditions[i];
				var parameter = this.findParameter(condition.parameterName);
				if (parameter.type === ANIM_PARAMETER_TRIGGER) {
					parameter.value = false;
				}
			}
			if (this.previousState) {
				if (!this._isTransitioning) {
					this._transitionPreviousStates = [];
				}
				this._transitionPreviousStates.push({
					name: this._previousStateName,
					weight: 1
				});
				var interpolatedTime = this._currTransitionTime / this._totalTransitionTime;
				for (i = 0; i < this._transitionPreviousStates.length; i++) {
					if (i !== this._transitionPreviousStates.length - 1) {
						this._transitionPreviousStates[i].weight *= (1.0 - interpolatedTime);
					} else {
						this._transitionPreviousStates[i].weight = interpolatedTime;
					}
					state = this._findState(this._transitionPreviousStates[i].name);
					for (j = 0; j < state.animations.length; j++) {
						animation = state.animations[j];
						clip = this._animEvaluator.findClip(animation.name + '.previous.' + i);
						if (!clip) {
							clip = this._animEvaluator.findClip(animation.name);
							clip.name = animation.name + '.previous.' + i;
						}
						clip.pause();
					}
				}
			}
			if (transition.time > 0) {
				this._isTransitioning = true;
				this._totalTransitionTime = transition.time;
				this._currTransitionTime = 0;
				this._transitionInterruptionSource = transition.interruptionSource;
			}
			var hasTransitionOffset = transition.transitionOffset && transition.transitionOffset > 0.0 && transition.transitionOffset < 1.0;
			var activeState = this.activeState;
			for (i = 0; i < activeState.animations.length; i++) {
				clip = this._animEvaluator.findClip(activeState.animations[i].name);
				if (!clip) {
					clip = new AnimClip(activeState.animations[i].animTrack, 0, activeState.speed, true, activeState.loop);
					clip.name = activeState.animations[i].name;
					this._animEvaluator.addClip(clip);
				} else {
					clip.reset();
				}
				if (transition.time > 0) {
					clip.blendWeight = 0.0;
				} else {
					clip.blendWeight = 1.0 / activeState.totalWeight;
				}
				clip.play();
				if (hasTransitionOffset) {
					clip.time = activeState.timelineDuration * transition.transitionOffset;
				} else {
					var startTime = activeState.speed >= 0 ? 0 : this.activeStateDuration;
					clip.time = startTime;
				}
			}
			var timeInState = 0;
			var timeInStateBefore = 0;
			if (hasTransitionOffset) {
				var offsetTime = activeState.timelineDuration * transition.transitionOffset;
				timeInState = offsetTime;
				timeInStateBefore = offsetTime;
			}
			this._timeInState = timeInState;
			this._timeInStateBefore = timeInStateBefore;
		},
		_transitionToState: function (newStateName) {
			if (newStateName === this._activeStateName) {
				return;
			}
			if (!this._findState(newStateName)) {
				return;
			}
			var transition = this._findTransition(this._activeStateName, newStateName);
			if (!transition) {
				this._animEvaluator.removeClips();
				transition = new AnimTransition(this, null, newStateName, 0, 0);
			}
			this._updateStateFromTransition(transition);
		},
		assignAnimation: function (stateName, animTrack) {
			var state = this._findState(stateName);
			if (!state) {
				return;
			}
			var animation = {
				name: stateName + '.' + animTrack.name,
				animTrack: animTrack,
				weight: 1.0
			};
			if (state.animations.length > 0) {
				state.animations = [];
				this.reset();
			}
			state.animations.push(animation);
			if (!this._playing && this._activate && this.playable) {
				this.play();
			}
		},
		removeNodeAnimations: function (nodeName) {
			var state = this._findState(nodeName);
			if (!state) {
				return;
			}
			state.animations = [];
		},
		play: function (stateName) {
			if (stateName) {
				this._transitionToState(stateName);
			}
			this._playing = true;
		},
		pause: function () {
			this._playing = false;
		},
		reset: function () {
			this._previousStateName = null;
			this._activeStateName = ANIM_STATE_START;
			this._playing = false;
			this._currTransitionTime = 1.0;
			this._totalTransitionTime = 1.0;
			this._isTransitioning = false;
			this._timeInState = 0;
			this._timeInStateBefore = 0;
			this._animEvaluator.removeClips();
		},
		update: function (dt) {
			if (!this._playing) {
				return;
			}
			var i;
			var j;
			var state;
			var animation;
			var clip;
			this._timeInStateBefore = this._timeInState;
			this._timeInState += dt;
			var transition = this._findTransition(this._activeStateName);
			if (transition)
				this._updateStateFromTransition(transition);
			if (this._isTransitioning) {
				if (this._currTransitionTime < this._totalTransitionTime) {
					var interpolatedTime = this._currTransitionTime / this._totalTransitionTime;
					for (i = 0; i < this._transitionPreviousStates.length; i++) {
						state = this._findState(this._transitionPreviousStates[i].name);
						var stateWeight = this._transitionPreviousStates[i].weight;
						for (j = 0; j < state.animations.length; j++) {
							animation = state.animations[j];
							clip = this._animEvaluator.findClip(animation.name + '.previous.' + i);
							if (clip) {
								clip.blendWeight = (1.0 - interpolatedTime) * animation.weight / state.totalWeight * stateWeight;
							}
						}
					}
					state = this.activeState;
					for (i = 0; i < state.animations.length; i++) {
						animation = state.animations[i];
						this._animEvaluator.findClip(animation.name).blendWeight = interpolatedTime * animation.weight / state.totalWeight;
					}
				} else {
					this._isTransitioning = false;
					var activeClips = this.activeStateAnimations.length;
					var totalClips = this._animEvaluator.clips.length;
					for (i = 0; i < totalClips - activeClips; i++) {
						this._animEvaluator.removeClip(0);
					}
					this._transitionPreviousStates = [];
					state = this.activeState;
					for (i = 0; i < state.animations.length; i++) {
						animation = state.animations[i];
						clip = this._animEvaluator.findClip(animation.name);
						if (clip) {
							clip.blendWeight = animation.weight / state.totalWeight;
						}
					}
				}
				this._currTransitionTime += dt;
			}
			this._animEvaluator.update(dt);
		},
		findParameter: function (name) {
			return this._parameters[name];
		}
	});

	function AnimComponent(system, entity) {
		Component.call(this, system, entity);
	}
	AnimComponent.prototype = Object.create(Component.prototype);
	AnimComponent.prototype.constructor = AnimComponent;
	Object.assign(AnimComponent.prototype, {
		loadStateGraph: function (stateGraph) {
			var data = this.data;
			data.stateGraph = stateGraph;
			data.parameters = stateGraph.parameters;
			data.layers = [];
			var graph;
			var modelComponent = this.entity.model;
			if (modelComponent) {
				var m = modelComponent.model;
				if (m) {
					graph = m.getGraph();
				}
			}
			function addLayer(name, states, transitions, order) {
				var animBinder = new AnimComponentBinder(this, graph);
				var animEvaluator = new AnimEvaluator(animBinder);
				var controller = new AnimController(
					animEvaluator,
					states,
					transitions,
					data.parameters,
					data.activate
				);
				data.layers.push(new AnimComponentLayer(name, controller, this));
				data.layerIndices[name] = order;
			}
			for (var i = 0; i < stateGraph.layers.length; i++) {
				var layer = stateGraph.layers[i];
				addLayer.bind(this)(layer.name, layer.states, layer.transitions, i);
			}
			this.setupAnimationAssets();
		},
		setupAnimationAssets: function () {
			for (var i = 0; i < this.data.layers.length; i++) {
				var layer = this.data.layers[i];
				var layerName = layer.name;
				for (var j = 0; j < layer.states.length; j++) {
					var stateName = layer.states[j];
					if (stateName !== 'START' && stateName !== 'END') {
						var stateKey = layerName + ':' + stateName;
						if (!this.data.animationAssets[stateKey]) {
							this.data.animationAssets[stateKey] = {
								asset: null
							};
						}
					}
				}
			}
			this.loadAnimationAssets();
		},
		loadAnimationAssets: function () {
			for (var i = 0; i < this.data.layers.length; i++) {
				var layer = this.data.layers[i];
				for (var j = 0; j < layer.states.length; j++) {
					var stateName = layer.states[j];
					var animationAsset = this.data.animationAssets[layer.name + ':' + stateName];
					if (!animationAsset || !animationAsset.asset) {
						this.removeNodeAnimations(stateName, layer.name);
						continue;
					}
					var assetId = animationAsset.asset;
					var asset = this.system.app.assets.get(assetId);
					if (asset.resource) {
						this.assignAnimation(stateName, asset.resource, layer.name);
					} else {
						asset.once('load', function (layerName, stateName) {
							return function (asset) {
								this.assignAnimation(stateName, asset.resource, layerName);
							}.bind(this);
						}.bind(this)(layer.name, stateName));
						this.system.app.assets.load(asset);
					}
				}
			}
		},
		removeStateGraph: function () {
			this.data.stateGraph = null;
			this.data.stateGraphAsset = null;
			this.data.animationAssets = {};
			this.data.layers = [];
			this.data.layerIndices = {};
			this.data.parameters = {};
			this.data.playing = false;
		},
		resetStateGraph: function () {
			if (this.stateGraphAsset) {
				var stateGraph = this.system.app.assets.get(this.stateGraphAsset).resource;
				this.loadStateGraph(stateGraph);
			} else {
				this.removeStateGraph();
			}
		},
		reset: function () {
			this.data.parameters = Object.assign({}, this.data.stateGraph.parameters);
			for (var i = 0; i < this.data.layers.length; i++) {
				var layerPlaying = this.data.layers[i].playing;
				this.data.layers[i].reset();
				this.data.layers[i].playing = layerPlaying;
			}
		},
		findAnimationLayer: function (layerName) {
			var layerIndex = this.data.layerIndices[layerName];
			return this.data.layers[layerIndex] || null;
		},
		assignAnimation: function (nodeName, animTrack, layerName) {
			if (!this.data.stateGraph) {
				return;
			}
			var layer = layerName ? this.findAnimationLayer(layerName) : this.baseLayer;
			if (!layer) {
				return;
			}
			layer.assignAnimation(nodeName, animTrack);
		},
		removeNodeAnimations: function (nodeName, layerName) {
			var layer = layerName ? this.findAnimationLayer(layerName) : this.baseLayer;
			if (!layer) {
				return;
			}
			layer.removeNodeAnimations(nodeName);
		},
		getParameterValue: function (name, type) {
			var param = this.data.parameters[name];
			if (param && param.type === type) {
				return param.value;
			}
		},
		setParameterValue: function (name, type, value) {
			var param = this.data.parameters[name];
			if (param && param.type === type) {
				param.value = value;
				return;
			}
		},
		getFloat: function (name) {
			return this.getParameterValue(name, ANIM_PARAMETER_FLOAT);
		},
		setFloat: function (name, value) {
			this.setParameterValue(name, ANIM_PARAMETER_FLOAT, value);
		},
		getInteger: function (name) {
			return this.getParameterValue(name, ANIM_PARAMETER_INTEGER);
		},
		setInteger: function (name, value) {
			if (typeof value === 'number' && value % 1 === 0) {
				this.setParameterValue(name, ANIM_PARAMETER_INTEGER, value);
			}
		},
		getBoolean: function (name) {
			return this.getParameterValue(name, ANIM_PARAMETER_BOOLEAN);
		},
		setBoolean: function (name, value) {
			this.setParameterValue(name, ANIM_PARAMETER_BOOLEAN, !!value);
		},
		getTrigger: function (name) {
			return this.getParameterValue(name, ANIM_PARAMETER_TRIGGER);
		},
		setTrigger: function (name) {
			this.setParameterValue(name, ANIM_PARAMETER_TRIGGER, true);
		},
		resetTrigger: function (name) {
			this.setParameterValue(name, ANIM_PARAMETER_TRIGGER, false);
		}
	});
	Object.defineProperties(AnimComponent.prototype, {
		stateGraphAsset: {
			get: function () {
				return this.data.stateGraphAsset;
			},
			set: function (value) {
				if (value === null) {
					this.removeStateGraph();
					return;
				}
				var _id;
				var _asset;
				if (value instanceof Asset) {
					_id = value.id;
					_asset = this.system.app.assets.get(_id);
					if (!_asset) {
						this.system.app.assets.add(value);
						_asset = this.system.app.assets.get(_id);
					}
				} else {
					_id = value;
					_asset = this.system.app.assets.get(_id);
				}
				if (!_asset || this.data.stateGraphAsset === _id) {
					return;
				}
				if (_asset.resource) {
					this.data.stateGraph = _asset.resource;
					this.loadStateGraph(this.data.stateGraph);
					_asset.on('change', function (asset) {
						this.data.stateGraph = new AnimStateGraph(asset._data);
						this.loadStateGraph(this.data.stateGraph);
					}.bind(this));
				} else {
					_asset.once('load', function (asset) {
						this.data.stateGraph = asset.resource;
						this.loadStateGraph(this.data.stateGraph);
					}.bind(this));
					_asset.on('change', function (asset) {
						this.data.stateGraph = new AnimStateGraph(asset._data);
						this.loadStateGraph(this.data.stateGraph);
					}.bind(this));
					this.system.app.assets.load(_asset);
				}
				this.data.stateGraphAsset = _id;
			}
		},
		animationAssets: {
			get: function () {
				return this.data.animationAssets;
			},
			set: function (value) {
				this.data.animationAssets = value;
				this.loadAnimationAssets();
			}
		},
		playable: {
			get: function () {
				for (var i = 0; i < this.data.layers.length; i++) {
					if (!this.data.layers[i].playable) {
						return false;
					}
				}
				return true;
			}
		},
		baseLayer: {
			get: function () {
				if (this.data.layers.length > 0) {
					return this.data.layers[0];
				}
				return null;
			}
		}
	});

	function AnimComponentData() {
		this.stateGraphAsset = null;
		this.animationAssets = {};
		this.speed = 1.0;
		this.activate = true;
		this.enabled = true;
		this.playing = false;
		this.stateGraph = null;
		this.layers = [];
		this.layerIndices = {};
		this.parameters = {};
	}

	var _schema$1 = [
		'enabled',
		'speed',
		'activate',
		'playing'
	];
	function AnimComponentSystem(app) {
		ComponentSystem.call(this, app);
		this.id = 'anim';
		this.ComponentType = AnimComponent;
		this.DataType = AnimComponentData;
		this.schema = _schema$1;
		this.on('beforeremove', this.onBeforeRemove, this);
		ComponentSystem.bind('animationUpdate', this.onAnimationUpdate, this);
	}
	AnimComponentSystem.prototype = Object.create(ComponentSystem.prototype);
	AnimComponentSystem.prototype.constructor = AnimComponentSystem;
	Component._buildAccessors(AnimComponent.prototype, _schema$1);
	Object.assign(AnimComponentSystem.prototype, {
		initializeComponentData: function (component, data, properties) {
			properties = ['activate', 'enabled', 'speed', 'playing'];
			ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
			if (data.stateGraphAsset) {
				component.stateGraphAsset = data.stateGraphAsset;
			}
			if (data.animationAssets) {
				component.animationAssets = Object.assign(component.data.animationAssets, data.animationAssets);
			}
		},
		onAnimationUpdate: function (dt) {
			var components = this.store;
			for (var id in components) {
				if (components.hasOwnProperty(id)) {
					var component = components[id];
					var componentData = component.data;
					if (componentData.enabled && component.entity.enabled && componentData.playing) {
						for (var i = 0; i < componentData.layers.length; i++) {
							componentData.layers[i].update(dt * componentData.speed);
						}
					}
				}
			}
		}
	});

	function AudioListenerComponent(system, entity) {
		Component.call(this, system, entity);
	}
	AudioListenerComponent.prototype = Object.create(Component.prototype);
	AudioListenerComponent.prototype.constructor = AudioListenerComponent;
	Object.assign(AudioListenerComponent.prototype, {
		setCurrentListener: function () {
			if (this.enabled && this.entity.audiolistener && this.entity.enabled) {
				this.system.current = this.entity;
				var position = this.system.current.getPosition();
				this.system.manager.listener.setPosition(position);
			}
		},
		onEnable: function () {
			this.setCurrentListener();
		},
		onDisable: function () {
			if (this.system.current === this.entity) {
				this.system.current = null;
			}
		}
	});

	function AudioListenerComponentData() {
		this.enabled = true;
	}

	var _schema$2 = ['enabled'];
	function AudioListenerComponentSystem(app, manager) {
		ComponentSystem.call(this, app);
		this.id = "audiolistener";
		this.ComponentType = AudioListenerComponent;
		this.DataType = AudioListenerComponentData;
		this.schema = _schema$2;
		this.manager = manager;
		this.current = null;
		ComponentSystem.bind('update', this.onUpdate, this);
	}
	AudioListenerComponentSystem.prototype = Object.create(ComponentSystem.prototype);
	AudioListenerComponentSystem.prototype.constructor = AudioListenerComponentSystem;
	Component._buildAccessors(AudioListenerComponent.prototype, _schema$2);
	Object.assign(AudioListenerComponentSystem.prototype, {
		initializeComponentData: function (component, data, properties) {
			properties = ['enabled'];
			ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
		},
		onUpdate: function (dt) {
			if (this.current) {
				var position = this.current.getPosition();
				this.manager.listener.setPosition(position);
				var wtm = this.current.getWorldTransform();
				this.manager.listener.setOrientation(wtm);
			}
		}
	});

	function AudioSourceComponent(system, entity) {
		Component.call(this, system, entity);
		this.on("set_assets", this.onSetAssets, this);
		this.on("set_loop", this.onSetLoop, this);
		this.on("set_volume", this.onSetVolume, this);
		this.on("set_pitch", this.onSetPitch, this);
		this.on("set_minDistance", this.onSetMinDistance, this);
		this.on("set_maxDistance", this.onSetMaxDistance, this);
		this.on("set_rollOffFactor", this.onSetRollOffFactor, this);
		this.on("set_distanceModel", this.onSetDistanceModel, this);
		this.on("set_3d", this.onSet3d, this);
	}
	AudioSourceComponent.prototype = Object.create(Component.prototype);
	AudioSourceComponent.prototype.constructor = AudioSourceComponent;
	Object.assign(AudioSourceComponent.prototype, {
		play: function (name) {
			if (!this.enabled || !this.entity.enabled) {
				return;
			}
			if (this.channel) {
				this.stop();
			}
			var channel;
			var componentData = this.data;
			if (componentData.sources[name]) {
				if (!componentData['3d']) {
					channel = this.system.manager.playSound(componentData.sources[name], componentData);
					componentData.currentSource = name;
					componentData.channel = channel;
				} else {
					var pos = this.entity.getPosition();
					channel = this.system.manager.playSound3d(componentData.sources[name], pos, componentData);
					componentData.currentSource = name;
					componentData.channel = channel;
				}
			}
		},
		pause: function () {
			if (this.channel) {
				this.channel.pause();
			}
		},
		unpause: function () {
			if (this.channel && this.channel.paused) {
				this.channel.unpause();
			}
		},
		stop: function () {
			if (this.channel) {
				this.channel.stop();
				this.channel = null;
			}
		},
		onSetAssets: function (name, oldValue, newValue) {
			var newAssets = [];
			var i, len = newValue.length;
			if (oldValue && oldValue.length) {
				for (i = 0; i < oldValue.length; i++) {
					if (oldValue[i]) {
						var asset = this.system.app.assets.get(oldValue[i]);
						if (asset) {
							asset.off('change', this.onAssetChanged, this);
							asset.off('remove', this.onAssetRemoved, this);
							if (this.currentSource === asset.name) {
								this.stop();
							}
						}
					}
				}
			}
			if (len) {
				for (i = 0; i < len; i++) {
					if (oldValue.indexOf(newValue[i]) < 0) {
						if (newValue[i] instanceof Asset) {
							newAssets.push(newValue[i].id);
						} else {
							newAssets.push(newValue[i]);
						}
					}
				}
			}
			if (!this.system._inTools && newAssets.length) {
				this.loadAudioSourceAssets(newAssets);
			}
		},
		onAssetChanged: function (asset, attribute, newValue, oldValue) {
			if (attribute === 'resource') {
				var sources = this.data.sources;
				if (sources) {
					this.data.sources[asset.name] = newValue;
					if (this.data.currentSource === asset.name) {
						if (this.channel) {
							if (this.channel.paused) {
								this.play(asset.name);
								this.pause();
							} else {
								this.play(asset.name);
							}
						}
					}
				}
			}
		},
		onAssetRemoved: function (asset) {
			asset.off('remove', this.onAssetRemoved, this);
			if (this.data.sources[asset.name]) {
				delete this.data.sources[asset.name];
				if (this.data.currentSource === asset.name) {
					this.stop();
					this.data.currentSource = null;
				}
			}
		},
		onSetLoop: function (name, oldValue, newValue) {
			if (oldValue != newValue) {
				if (this.channel) {
					this.channel.setLoop(newValue);
				}
			}
		},
		onSetVolume: function (name, oldValue, newValue) {
			if (oldValue != newValue) {
				if (this.channel) {
					this.channel.setVolume(newValue);
				}
			}
		},
		onSetPitch: function (name, oldValue, newValue) {
			if (oldValue != newValue) {
				if (this.channel) {
					this.channel.setPitch(newValue);
				}
			}
		},
		onSetMaxDistance: function (name, oldValue, newValue) {
			if (oldValue != newValue) {
				if (this.channel instanceof Channel3d) {
					this.channel.setMaxDistance(newValue);
				}
			}
		},
		onSetMinDistance: function (name, oldValue, newValue) {
			if (oldValue != newValue) {
				if (this.channel instanceof Channel3d) {
					this.channel.setMinDistance(newValue);
				}
			}
		},
		onSetRollOffFactor: function (name, oldValue, newValue) {
			if (oldValue != newValue) {
				if (this.channel instanceof Channel3d) {
					this.channel.setRollOffFactor(newValue);
				}
			}
		},
		onSetDistanceModel: function (name, oldValue, newValue) {
			if (oldValue !== newValue) {
				if (this.channel instanceof Channel3d) {
					this.channel.setDistanceModel(newValue);
				}
			}
		},
		onSet3d: function (name, oldValue, newValue) {
			if (oldValue !== newValue) {
				if (this.system.initialized && this.currentSource) {
					var paused = false;
					var suspended = false;
					if (this.channel) {
						paused = this.channel.paused;
						suspended = this.channel.suspended;
					}
					this.play(this.currentSource);
					if (this.channel) {
						this.channel.paused = paused;
						this.channel.suspended = suspended;
					}
				}
			}
		},
		onEnable: function () {
			var assets = this.data.assets;
			if (assets) {
				var registry = this.system.app.assets;
				for (var i = 0, len = assets.length; i < len; i++) {
					var asset = assets[i];
					if (!(asset instanceof Asset))
						asset = registry.get(asset);
					if (asset && !asset.resource) {
						registry.load(asset);
					}
				}
			}
			if (this.system.initialized) {
				if (this.data.activate && !this.channel) {
					this.play(this.currentSource);
				} else {
					this.unpause();
				}
			}
		},
		onDisable: function () {
			this.pause();
		},
		loadAudioSourceAssets: function (ids) {
			var self = this;
			var assets = ids.map(function (id) {
				return this.system.app.assets.get(id);
			}, this);
			var sources = {};
			var currentSource = null;
			var count = assets.length;
			var _error = function (e) {
				count--;
			};
			var _done = function () {
				this.data.sources = sources;
				this.data.currentSource = currentSource;
				if (this.enabled && this.activate && currentSource) {
					this.onEnable();
				}
			}.bind(this);
			assets.forEach(function (asset, index) {
				if (asset) {
					currentSource = currentSource || asset.name;
					asset.off('change', this.onAssetChanged, this);
					asset.on('change', this.onAssetChanged, this);
					asset.off('remove', this.onAssetRemoved, this);
					asset.on('remove', this.onAssetRemoved, this);
					asset.off('error', _error, this);
					asset.on('error', _error, this);
					asset.ready(function (asset) {
						sources[asset.name] = asset.resource;
						count--;
						if (count === 0) {
							_done();
						}
					});
					if (!asset.resource && self.enabled && self.entity.enabled)
						this.system.app.assets.load(asset);
				} else {
					count--;
					if (count === 0) {
						_done();
					}
					this.system.app.assets.on("add:" + ids[index], function (asset) {
						asset.ready(function (asset) {
							self.data.sources[asset.name] = asset.resource;
						});
						if (!asset.resource)
							self.system.app.assets.load(asset);
					});
				}
			}, this);
		}
	});

	function AudioSourceComponentData() {
		this.enabled = true;
		this.assets = [];
		this.activate = true;
		this.volume = 1;
		this.pitch = 1;
		this.loop = false;
		this['3d'] = true;
		this.minDistance = 1;
		this.maxDistance = 10000;
		this.rollOffFactor = 1;
		this.distanceModel = DISTANCE_INVERSE;
		this.paused = true;
		this.sources = {};
		this.currentSource = null;
		this.channel = null;
	}

	var _schema$3 = [
		'enabled',
		'assets',
		'volume',
		'pitch',
		'loop',
		'activate',
		'3d',
		'minDistance',
		'maxDistance',
		'rollOffFactor',
		'distanceModel',
		'sources',
		'currentSource',
		'channel'
	];
	function AudioSourceComponentSystem(app, manager) {
		ComponentSystem.call(this, app);
		this.id = "audiosource";
		this.ComponentType = AudioSourceComponent;
		this.DataType = AudioSourceComponentData;
		this.schema = _schema$3;
		this.manager = manager;
		this.initialized = false;
		ComponentSystem.bind('initialize', this.onInitialize, this);
		ComponentSystem.bind('update', this.onUpdate, this);
		this.on('remove', this.onRemove, this);
	}
	AudioSourceComponentSystem.prototype = Object.create(ComponentSystem.prototype);
	AudioSourceComponentSystem.prototype.constructor = AudioSourceComponentSystem;
	Component._buildAccessors(AudioSourceComponent.prototype, _schema$3);
	Object.assign(AudioSourceComponentSystem.prototype, {
		initializeComponentData: function (component, data, properties) {
			properties = ['activate', 'volume', 'pitch', 'loop', '3d', 'minDistance', 'maxDistance', 'rollOffFactor', 'distanceModel', 'enabled', 'assets'];
			ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
			component.paused = !(component.enabled && component.activate);
		},
		onInitialize: function (root) {
			if (root.audiosource &&
				root.enabled &&
				root.audiosource.enabled &&
				root.audiosource.activate) {
				root.audiosource.play(root.audiosource.currentSource);
			}
			var children = root._children;
			var i, len = children.length;
			for (i = 0; i < len; i++) {
				if (children[i] instanceof Entity) {
					this.onInitialize(children[i]);
				}
			}
			this.initialized = true;
		},
		onUpdate: function (dt) {
			var components = this.store;
			for (var id in components) {
				if (components.hasOwnProperty(id)) {
					var component = components[id];
					var entity = component.entity;
					var componentData = component.data;
					if (componentData.enabled && entity.enabled && componentData.channel instanceof Channel3d) {
						var pos = entity.getPosition();
						componentData.channel.setPosition(pos);
					}
				}
			}
		},
		onRemove: function (entity, data) {
			if (data.channel) {
				data.channel.stop();
				data.channel = null;
			}
		},
		setVolume: function (volume) {
			this.manager.setVolume(volume);
		}
	});

	function EntityReference(parentComponent, entityPropertyName, eventConfig) {
		if (!parentComponent || !(parentComponent instanceof Component)) {
			throw new Error('The parentComponent argument is required and must be a Component');
		} else if (!entityPropertyName || typeof entityPropertyName !== 'string') {
			throw new Error('The propertyName argument is required and must be a string');
		} else if (eventConfig && typeof eventConfig !== 'object') {
			throw new Error('If provided, the eventConfig argument must be an object');
		}
		this._parentComponent = parentComponent;
		this._entityPropertyName = entityPropertyName;
		this._entity = null;
		this._app = parentComponent.system.app;
		this._configureEventListeners(eventConfig || {}, {
			'entity#destroy': this._onEntityDestroy
		});
		this._toggleLifecycleListeners('on');
	}
	Object.assign(EntityReference.prototype, {
		_configureEventListeners: function (externalEventConfig, internalEventConfig) {
			var externalEventListenerConfigs = this._parseEventListenerConfig(externalEventConfig, 'external', this._parentComponent);
			var internalEventListenerConfigs = this._parseEventListenerConfig(internalEventConfig, 'internal', this);
			this._eventListenerConfigs = externalEventListenerConfigs.concat(internalEventListenerConfigs);
			this._listenerStatusFlags = {};
			this._gainListeners = {};
			this._loseListeners = {};
		},
		_parseEventListenerConfig: function (eventConfig, prefix, scope) {
			return Object.keys(eventConfig).map(function (listenerDescription, index) {
				var listenerDescriptionParts = listenerDescription.split('#');
				var sourceName = listenerDescriptionParts[0];
				var eventName = listenerDescriptionParts[1];
				var callback = eventConfig[listenerDescription];
				if (listenerDescriptionParts.length !== 2 ||
					typeof sourceName !== 'string' || sourceName.length === 0 ||
					typeof eventName !== 'string' || eventName.length === 0) {
					throw new Error('Invalid event listener description: `' + listenerDescription + '`');
				}
				if (typeof callback !== 'function') {
					throw new Error('Invalid or missing callback for event listener `' + listenerDescription + '`');
				}
				return {
					id: prefix + '_' + index + '_' + listenerDescription,
					sourceName: sourceName,
					eventName: eventName,
					callback: callback,
					scope: scope
				};
			}, this);
		},
		_toggleLifecycleListeners: function (onOrOff) {
			this._parentComponent[onOrOff]('set_' + this._entityPropertyName, this._onSetEntity, this);
			this._parentComponent.system[onOrOff]('beforeremove', this._onParentComponentRemove, this);
			ComponentSystem[onOrOff]('postinitialize', this._onPostInitialize, this);
			this._app[onOrOff]('tools:sceneloaded', this._onSceneLoaded, this);
			var allComponentSystems = [];
			for (var i = 0; i < this._eventListenerConfigs.length; ++i) {
				var config = this._eventListenerConfigs[i];
				var componentSystem = this._app.systems[config.sourceName];
				if (componentSystem) {
					if (allComponentSystems.indexOf(componentSystem) === -1) {
						allComponentSystems.push(componentSystem);
					}
					if (componentSystem && config.eventName === 'gain') {
						this._gainListeners[config.sourceName] = config;
					}
					if (componentSystem && config.eventName === 'lose') {
						this._loseListeners[config.sourceName] = config;
					}
				}
			}
			for (var j = 0; j < allComponentSystems.length; ++j) {
				allComponentSystems[j][onOrOff]('add', this._onComponentAdd, this);
				allComponentSystems[j][onOrOff]('beforeremove', this._onComponentRemove, this);
			}
		},
		_onSetEntity: function (name, oldValue, newValue) {
			if (newValue instanceof Entity) {
				this._updateEntityReference();
			} else  {
				if (newValue !== null && newValue !== undefined && typeof newValue !== 'string') {
					console.warn("Entity field `" + this._entityPropertyName + "` was set to unexpected type '" + (typeof newValue) + "'");
					return;
				}
				if (oldValue !== newValue) {
					this._updateEntityReference();
				}
			}
		},
		_onPostInitialize: function () {
			this._updateEntityReference();
		},
		onParentComponentEnable: function () {
			if (!this._entity) {
				this._updateEntityReference();
			}
		},
		_onSceneLoaded: function () {
			this._updateEntityReference();
		},
		_updateEntityReference: function () {
			var nextEntityGuid = this._parentComponent.data[this._entityPropertyName];
			var nextEntity;
			if (nextEntityGuid instanceof Entity) {
				nextEntity = nextEntityGuid;
				nextEntityGuid = nextEntity.getGuid();
				this._parentComponent.data[this._entityPropertyName] = nextEntityGuid;
			} else {
				var root = this._parentComponent.system.app.root;
				var isOnSceneGraph = this._parentComponent.entity.isDescendantOf(root);
				nextEntity = (isOnSceneGraph && nextEntityGuid) ? root.findByGuid(nextEntityGuid) : null;
			}
			var hasChanged = this._entity !== nextEntity;
			if (hasChanged) {
				if (this._entity) {
					this._onBeforeEntityChange();
				}
				this._entity = nextEntity;
				if (this._entity) {
					this._onAfterEntityChange();
				}
			}
		},
		_onBeforeEntityChange: function () {
			this._toggleEntityListeners('off');
			this._callAllGainOrLoseListeners(this._loseListeners);
		},
		_onAfterEntityChange: function () {
			this._toggleEntityListeners('on');
			this._callAllGainOrLoseListeners(this._gainListeners);
		},
		_onComponentAdd: function (entity, component) {
			var componentName = component.system.id;
			if (entity === this._entity) {
				this._callGainOrLoseListener(componentName, this._gainListeners);
				this._toggleComponentListeners('on', componentName);
			}
		},
		_onComponentRemove: function (entity, component) {
			var componentName = component.system.id;
			if (entity === this._entity) {
				this._callGainOrLoseListener(componentName, this._loseListeners);
				this._toggleComponentListeners('off', componentName, true);
			}
		},
		_callAllGainOrLoseListeners: function (listenerMap) {
			for (var componentName in this._entity.c) {
				this._callGainOrLoseListener(componentName, listenerMap);
			}
		},
		_callGainOrLoseListener: function (componentName, listenerMap) {
			if (this._entity.c.hasOwnProperty(componentName) && listenerMap[componentName]) {
				var config = listenerMap[componentName];
				config.callback.call(config.scope);
			}
		},
		_toggleEntityListeners: function (onOrOff, isDestroying) {
			if (this._entity) {
				for (var i = 0; i < this._eventListenerConfigs.length; ++i) {
					this._safeToggleListener(onOrOff, this._eventListenerConfigs[i], isDestroying);
				}
			}
		},
		_toggleComponentListeners: function (onOrOff, componentName, isDestroying) {
			for (var i = 0; i < this._eventListenerConfigs.length; ++i) {
				var config = this._eventListenerConfigs[i];
				if (config.sourceName === componentName) {
					this._safeToggleListener(onOrOff, config, isDestroying);
				}
			}
		},
		_safeToggleListener: function (onOrOff, config, isDestroying) {
			var isAdding = (onOrOff === 'on');
			if (isAdding && this._listenerStatusFlags[config.id]) {
				return;
			}
			var source = this._getEventSource(config.sourceName, isDestroying);
			if (source) {
				source[onOrOff](config.eventName, config.callback, config.scope);
				this._listenerStatusFlags[config.id] = isAdding;
			}
		},
		_getEventSource: function (sourceName, isDestroying) {
			if (sourceName === 'entity') {
				return this._entity;
			}
			var component = this._entity[sourceName];
			if (component) {
				return component;
			}
			if (!isDestroying) {
				console.warn('Entity has no component with name ' + sourceName);
			}
			return null;
		},
		_onEntityDestroy: function (entity) {
			if (this._entity === entity) {
				this._toggleEntityListeners('off', true);
				this._entity = null;
			}
		},
		_onParentComponentRemove: function (entity, component) {
			if (component === this._parentComponent) {
				this._toggleLifecycleListeners('off');
				this._toggleEntityListeners('off', true);
			}
		},
		hasComponent: function (componentName) {
			return (this._entity && this._entity.c) ? !!this._entity.c[componentName] : false;
		}
	});
	Object.defineProperty(EntityReference.prototype, 'entity', {
		get: function () {
			return this._entity;
		}
	});

	var BUTTON_TRANSITION_MODE_TINT = 0;
	var BUTTON_TRANSITION_MODE_SPRITE_CHANGE = 1;

	var VisualState = {
		DEFAULT: 'DEFAULT',
		HOVER: 'HOVER',
		PRESSED: 'PRESSED',
		INACTIVE: 'INACTIVE'
	};
	var STATES_TO_TINT_NAMES = {};
	STATES_TO_TINT_NAMES[VisualState.DEFAULT] = '_defaultTint';
	STATES_TO_TINT_NAMES[VisualState.HOVER] = 'hoverTint';
	STATES_TO_TINT_NAMES[VisualState.PRESSED] = 'pressedTint';
	STATES_TO_TINT_NAMES[VisualState.INACTIVE] = 'inactiveTint';
	var STATES_TO_SPRITE_ASSET_NAMES = {};
	STATES_TO_SPRITE_ASSET_NAMES[VisualState.DEFAULT] = '_defaultSpriteAsset';
	STATES_TO_SPRITE_ASSET_NAMES[VisualState.HOVER] = 'hoverSpriteAsset';
	STATES_TO_SPRITE_ASSET_NAMES[VisualState.PRESSED] = 'pressedSpriteAsset';
	STATES_TO_SPRITE_ASSET_NAMES[VisualState.INACTIVE] = 'inactiveSpriteAsset';
	var STATES_TO_SPRITE_FRAME_NAMES = {};
	STATES_TO_SPRITE_FRAME_NAMES[VisualState.DEFAULT] = '_defaultSpriteFrame';
	STATES_TO_SPRITE_FRAME_NAMES[VisualState.HOVER] = 'hoverSpriteFrame';
	STATES_TO_SPRITE_FRAME_NAMES[VisualState.PRESSED] = 'pressedSpriteFrame';
	STATES_TO_SPRITE_FRAME_NAMES[VisualState.INACTIVE] = 'inactiveSpriteFrame';
	function ButtonComponent(system, entity) {
		Component.call(this, system, entity);
		this._visualState = VisualState.DEFAULT;
		this._isHovering = false;
		this._hoveringCounter = 0;
		this._isPressed = false;
		this._defaultTint = new Color(1, 1, 1, 1);
		this._defaultSpriteAsset = null;
		this._defaultSpriteFrame = 0;
		this._imageReference = new EntityReference(this, 'imageEntity', {
			'element#gain': this._onImageElementGain,
			'element#lose': this._onImageElementLose,
			'element#set:color': this._onSetColor,
			'element#set:opacity': this._onSetOpacity,
			'element#set:spriteAsset': this._onSetSpriteAsset,
			'element#set:spriteFrame': this._onSetSpriteFrame
		});
		this._toggleLifecycleListeners('on', system);
	}
	ButtonComponent.prototype = Object.create(Component.prototype);
	ButtonComponent.prototype.constructor = ButtonComponent;
	Object.assign(ButtonComponent.prototype, {
		_toggleLifecycleListeners: function (onOrOff, system) {
			this[onOrOff]('set_active', this._onSetActive, this);
			this[onOrOff]('set_transitionMode', this._onSetTransitionMode, this);
			this[onOrOff]('set_hoverTint', this._onSetTransitionValue, this);
			this[onOrOff]('set_pressedTint', this._onSetTransitionValue, this);
			this[onOrOff]('set_inactiveTint', this._onSetTransitionValue, this);
			this[onOrOff]('set_hoverSpriteAsset', this._onSetTransitionValue, this);
			this[onOrOff]('set_hoverSpriteFrame', this._onSetTransitionValue, this);
			this[onOrOff]('set_pressedSpriteAsset', this._onSetTransitionValue, this);
			this[onOrOff]('set_pressedSpriteFrame', this._onSetTransitionValue, this);
			this[onOrOff]('set_inactiveSpriteAsset', this._onSetTransitionValue, this);
			this[onOrOff]('set_inactiveSpriteFrame', this._onSetTransitionValue, this);
			system.app.systems.element[onOrOff]('add', this._onElementComponentAdd, this);
			system.app.systems.element[onOrOff]('beforeremove', this._onElementComponentRemove, this);
		},
		_onSetActive: function (name, oldValue, newValue) {
			if (oldValue !== newValue) {
				this._updateVisualState();
			}
		},
		_onSetTransitionMode: function (name, oldValue, newValue) {
			if (oldValue !== newValue) {
				this._cancelTween();
				this._resetToDefaultVisualState(oldValue);
				this._forceReapplyVisualState();
			}
		},
		_onSetTransitionValue: function (name, oldValue, newValue) {
			if (oldValue !== newValue) {
				this._forceReapplyVisualState();
			}
		},
		_onElementComponentRemove: function (entity) {
			if (this.entity === entity) {
				this._toggleHitElementListeners('off');
			}
		},
		_onElementComponentAdd: function (entity) {
			if (this.entity === entity) {
				this._toggleHitElementListeners('on');
			}
		},
		_onImageElementLose: function () {
			this._cancelTween();
			this._resetToDefaultVisualState(this.transitionMode);
		},
		_onImageElementGain: function () {
			this._storeDefaultVisualState();
			this._forceReapplyVisualState();
		},
		_toggleHitElementListeners: function (onOrOff) {
			if (this.entity.element) {
				var isAdding = (onOrOff === 'on');
				if (isAdding && this._hasHitElementListeners) {
					return;
				}
				this.entity.element[onOrOff]('mouseenter', this._onMouseEnter, this);
				this.entity.element[onOrOff]('mouseleave', this._onMouseLeave, this);
				this.entity.element[onOrOff]('mousedown', this._onMouseDown, this);
				this.entity.element[onOrOff]('mouseup', this._onMouseUp, this);
				this.entity.element[onOrOff]('touchstart', this._onTouchStart, this);
				this.entity.element[onOrOff]('touchend', this._onTouchEnd, this);
				this.entity.element[onOrOff]('touchleave', this._onTouchLeave, this);
				this.entity.element[onOrOff]('touchcancel', this._onTouchCancel, this);
				this.entity.element[onOrOff]('selectstart', this._onSelectStart, this);
				this.entity.element[onOrOff]('selectend', this._onSelectEnd, this);
				this.entity.element[onOrOff]('selectenter', this._onSelectEnter, this);
				this.entity.element[onOrOff]('selectleave', this._onSelectLeave, this);
				this.entity.element[onOrOff]('click', this._onClick, this);
				this._hasHitElementListeners = isAdding;
			}
		},
		_storeDefaultVisualState: function () {
			if (this._imageReference.hasComponent('element')) {
				this._storeDefaultColor(this._imageReference.entity.element.color);
				this._storeDefaultOpacity(this._imageReference.entity.element.opacity);
				this._storeDefaultSpriteAsset(this._imageReference.entity.element.spriteAsset);
				this._storeDefaultSpriteFrame(this._imageReference.entity.element.spriteFrame);
			}
		},
		_storeDefaultColor: function (color) {
			this._defaultTint.r = color.r;
			this._defaultTint.g = color.g;
			this._defaultTint.b = color.b;
		},
		_storeDefaultOpacity: function (opacity) {
			this._defaultTint.a = opacity;
		},
		_storeDefaultSpriteAsset: function (spriteAsset) {
			this._defaultSpriteAsset = spriteAsset;
		},
		_storeDefaultSpriteFrame: function (spriteFrame) {
			this._defaultSpriteFrame = spriteFrame;
		},
		_onSetColor: function (color) {
			if (!this._isApplyingTint) {
				this._storeDefaultColor(color);
				this._forceReapplyVisualState();
			}
		},
		_onSetOpacity: function (opacity) {
			if (!this._isApplyingTint) {
				this._storeDefaultOpacity(opacity);
				this._forceReapplyVisualState();
			}
		},
		_onSetSpriteAsset: function (spriteAsset) {
			if (!this._isApplyingSprite) {
				this._storeDefaultSpriteAsset(spriteAsset);
				this._forceReapplyVisualState();
			}
		},
		_onSetSpriteFrame: function (spriteFrame) {
			if (!this._isApplyingSprite) {
				this._storeDefaultSpriteFrame(spriteFrame);
				this._forceReapplyVisualState();
			}
		},
		_onMouseEnter: function (event) {
			this._isHovering = true;
			this._updateVisualState();
			this._fireIfActive('mouseenter', event);
		},
		_onMouseLeave: function (event) {
			this._isHovering = false;
			this._isPressed = false;
			this._updateVisualState();
			this._fireIfActive('mouseleave', event);
		},
		_onMouseDown: function (event) {
			this._isPressed = true;
			this._updateVisualState();
			this._fireIfActive('mousedown', event);
		},
		_onMouseUp: function (event) {
			this._isPressed = false;
			this._updateVisualState();
			this._fireIfActive('mouseup', event);
		},
		_onTouchStart: function (event) {
			this._isPressed = true;
			this._updateVisualState();
			this._fireIfActive('touchstart', event);
		},
		_onTouchEnd: function (event) {
			event.event.preventDefault();
			this._isPressed = false;
			this._updateVisualState();
			this._fireIfActive('touchend', event);
		},
		_onTouchLeave: function (event) {
			this._isPressed = false;
			this._updateVisualState();
			this._fireIfActive('touchleave', event);
		},
		_onTouchCancel: function (event) {
			this._isPressed = false;
			this._updateVisualState();
			this._fireIfActive('touchcancel', event);
		},
		_onSelectStart: function (event) {
			this._isPressed = true;
			this._updateVisualState();
			this._fireIfActive('selectstart', event);
		},
		_onSelectEnd: function (event) {
			this._isPressed = false;
			this._updateVisualState();
			this._fireIfActive('selectend', event);
		},
		_onSelectEnter: function (event) {
			this._hoveringCounter++;
			if (this._hoveringCounter === 1) {
				this._isHovering = true;
				this._updateVisualState();
			}
			this._fireIfActive('selectenter', event);
		},
		_onSelectLeave: function (event) {
			this._hoveringCounter--;
			if (this._hoveringCounter === 0) {
				this._isHovering = false;
				this._isPressed = false;
				this._updateVisualState();
			}
			this._fireIfActive('selectleave', event);
		},
		_onClick: function (event) {
			this._fireIfActive('click', event);
		},
		_fireIfActive: function (name, event) {
			if (this.data.active) {
				this.fire(name, event);
			}
		},
		_updateVisualState: function (force) {
			var oldVisualState = this._visualState;
			var newVisualState = this._determineVisualState();
			if ((oldVisualState !== newVisualState || force) && this.enabled) {
				this._visualState = newVisualState;
				if (oldVisualState === VisualState.HOVER) {
					this._fireIfActive('hoverend');
				}
				if (oldVisualState === VisualState.PRESSED) {
					this._fireIfActive('pressedend');
				}
				if (newVisualState === VisualState.HOVER) {
					this._fireIfActive('hoverstart');
				}
				if (newVisualState === VisualState.PRESSED) {
					this._fireIfActive('pressedstart');
				}
				switch (this.transitionMode) {
					case BUTTON_TRANSITION_MODE_TINT:
						var tintName = STATES_TO_TINT_NAMES[this._visualState];
						var tintColor = this[tintName];
						this._applyTint(tintColor);
						break;
					case BUTTON_TRANSITION_MODE_SPRITE_CHANGE:
						var spriteAssetName = STATES_TO_SPRITE_ASSET_NAMES[this._visualState];
						var spriteFrameName = STATES_TO_SPRITE_FRAME_NAMES[this._visualState];
						var spriteAsset = this[spriteAssetName];
						var spriteFrame = this[spriteFrameName];
						this._applySprite(spriteAsset, spriteFrame);
						break;
				}
			}
		},
		_forceReapplyVisualState: function () {
			this._updateVisualState(true);
		},
		_resetToDefaultVisualState: function (transitionMode) {
			if (this._imageReference.hasComponent('element')) {
				switch (transitionMode) {
					case BUTTON_TRANSITION_MODE_TINT:
						this._cancelTween();
						this._applyTintImmediately(this._defaultTint);
						break;
					case BUTTON_TRANSITION_MODE_SPRITE_CHANGE:
						this._applySprite(this._defaultSpriteAsset, this._defaultSpriteFrame);
						break;
				}
			}
		},
		_determineVisualState: function () {
			if (!this.active) {
				return VisualState.INACTIVE;
			} else if (this._isPressed) {
				return VisualState.PRESSED;
			} else if (this._isHovering) {
				return VisualState.HOVER;
			}
			return VisualState.DEFAULT;
		},
		_applySprite: function (spriteAsset, spriteFrame) {
			spriteFrame = spriteFrame || 0;
			if (this._imageReference.hasComponent('element')) {
				this._isApplyingSprite = true;
				this._imageReference.entity.element.spriteAsset = spriteAsset;
				this._imageReference.entity.element.spriteFrame = spriteFrame;
				this._isApplyingSprite = false;
			}
		},
		_applyTint: function (tintColor) {
			this._cancelTween();
			if (this.fadeDuration === 0) {
				this._applyTintImmediately(tintColor);
			} else {
				this._applyTintWithTween(tintColor);
			}
		},
		_applyTintImmediately: function (tintColor) {
			if (this._imageReference.hasComponent('element') && tintColor) {
				this._isApplyingTint = true;
				this._imageReference.entity.element.color = toColor3(tintColor);
				this._imageReference.entity.element.opacity = tintColor.a;
				this._isApplyingTint = false;
			}
		},
		_applyTintWithTween: function (tintColor) {
			if (this._imageReference.hasComponent('element') && tintColor) {
				var color = this._imageReference.entity.element.color;
				var opacity = this._imageReference.entity.element.opacity;
				this._tweenInfo = {
					startTime: now(),
					from: new Color(color.r, color.g, color.b, opacity),
					to: tintColor.clone(),
					lerpColor: new Color()
				};
			}
		},
		_updateTintTween: function () {
			var elapsedTime = now() - this._tweenInfo.startTime;
			var elapsedProportion = this.fadeDuration === 0 ? 1 : (elapsedTime / this.fadeDuration);
			elapsedProportion = math.clamp(elapsedProportion, 0, 1);
			if (Math.abs(elapsedProportion - 1) > 1e-5) {
				var lerpColor = this._tweenInfo.lerpColor;
				lerpColor.lerp(this._tweenInfo.from, this._tweenInfo.to, elapsedProportion);
				this._applyTintImmediately(new Color(lerpColor.r, lerpColor.g, lerpColor.b, lerpColor.a));
			} else {
				this._applyTintImmediately(this._tweenInfo.to);
				this._cancelTween();
			}
		},
		_cancelTween: function () {
			delete this._tweenInfo;
		},
		onUpdate: function () {
			if (this._tweenInfo) {
				this._updateTintTween();
			}
		},
		onEnable: function () {
			this._isHovering = false;
			this._hoveringCounter = 0;
			this._isPressed = false;
			this._imageReference.onParentComponentEnable();
			this._toggleHitElementListeners('on');
			this._forceReapplyVisualState();
		},
		onDisable: function () {
			this._toggleHitElementListeners('off');
			this._resetToDefaultVisualState(this.transitionMode);
		},
		onRemove: function () {
			this._toggleLifecycleListeners('off', this.system);
			this.onDisable();
		}
	});
	function toColor3(color4) {
		return new Color(color4.r, color4.g, color4.b);
	}

	function ButtonComponentData() {
		this.enabled = true;
		this.active = true;
		this.imageEntity = null;
		this.hitPadding = new Vec4();
		this.transitionMode = BUTTON_TRANSITION_MODE_TINT;
		this.hoverTint = new Color(0.75, 0.75, 0.75);
		this.pressedTint = new Color(0.5, 0.5, 0.5);
		this.inactiveTint = new Color(0.25, 0.25, 0.25);
		this.fadeDuration = 0;
		this.hoverSpriteAsset = null;
		this.hoverSpriteFrame = 0;
		this.pressedSpriteAsset = null;
		this.pressedSpriteFrame = 0;
		this.inactiveSpriteAsset = null;
		this.inactiveSpriteFrame = 0;
	}

	var _schema$4 = [
		'enabled',
		'active',
		{ name: 'imageEntity', type: 'entity' },
		{ name: 'hitPadding', type: 'vec4' },
		'transitionMode',
		{ name: 'hoverTint', type: 'rgba' },
		{ name: 'pressedTint', type: 'rgba' },
		{ name: 'inactiveTint', type: 'rgba' },
		'fadeDuration',
		'hoverSpriteAsset',
		'hoverSpriteFrame',
		'pressedSpriteAsset',
		'pressedSpriteFrame',
		'inactiveSpriteAsset',
		'inactiveSpriteFrame'
	];
	function ButtonComponentSystem(app) {
		ComponentSystem.call(this, app);
		this.id = 'button';
		this.ComponentType = ButtonComponent;
		this.DataType = ButtonComponentData;
		this.schema = _schema$4;
		this.on('beforeremove', this._onRemoveComponent, this);
		ComponentSystem.bind('update', this.onUpdate, this);
	}
	ButtonComponentSystem.prototype = Object.create(ComponentSystem.prototype);
	ButtonComponentSystem.prototype.constructor = ButtonComponentSystem;
	Component._buildAccessors(ButtonComponent.prototype, _schema$4);
	Object.assign(ButtonComponentSystem.prototype, {
		initializeComponentData: function (component, data, properties) {
			ComponentSystem.prototype.initializeComponentData.call(this, component, data, _schema$4);
		},
		onUpdate: function (dt) {
			var components = this.store;
			for (var id in components) {
				var entity = components[id].entity;
				var component = entity.button;
				if (component.enabled && entity.enabled) {
					component.onUpdate();
				}
			}
		},
		_onRemoveComponent: function (entity, component) {
			component.onRemove();
		}
	});

	var depthLayer;
	function PostEffectQueue(app, camera) {
		var self = this;
		this.app = app;
		this.camera = camera;
		this.effects = [];
		this.enabled = false;
		this.depthTarget = null;
		this.renderTargetScale = 1;
		this.resizeTimeout = null;
		this.resizeLast = 0;
		this._resizeTimeoutCallback = function () {
			self.resizeRenderTargets();
		};
		camera.on('set_rect', this.onCameraRectChanged, this);
		this._origOverrideClear = false;
		this._origClearColorBuffer = false;
		this._origDepthColorBuffer = false;
		this._origStencilColorBuffer = false;
	}
	Object.assign(PostEffectQueue.prototype, {
		_createOffscreenTarget: function (useDepth, hdr) {
			var rect = this.camera.rect;
			var width = Math.floor(rect.z * this.app.graphicsDevice.width * this.renderTargetScale);
			var height = Math.floor(rect.w * this.app.graphicsDevice.height * this.renderTargetScale);
			var device = this.app.graphicsDevice;
			var format = hdr ? device.getHdrFormat() : PIXELFORMAT_R8_G8_B8_A8;
			var useStencil =  this.app.graphicsDevice.supportsStencil;
			var samples = useDepth ? device.samples : 1;
			var colorBuffer = new Texture(device, {
				format: format,
				width: width,
				height: height
			});
			colorBuffer.name = 'posteffect #' + this.effects.length;
			colorBuffer.minFilter = FILTER_NEAREST;
			colorBuffer.magFilter = FILTER_NEAREST;
			colorBuffer.addressU = ADDRESS_CLAMP_TO_EDGE;
			colorBuffer.addressV = ADDRESS_CLAMP_TO_EDGE;
			return new RenderTarget(this.app.graphicsDevice, colorBuffer, { depth: useDepth, stencil: useStencil, samples: samples });
		},
		_resizeOffscreenTarget: function (rt) {
			var rect = this.camera.rect;
			var width = Math.floor(rect.z * this.app.graphicsDevice.width * this.renderTargetScale);
			var height = Math.floor(rect.w * this.app.graphicsDevice.height * this.renderTargetScale);
			var device = this.app.graphicsDevice;
			var format = rt.colorBuffer.format;
			rt._colorBuffer.destroy();
			var colorBuffer = new Texture(device, {
				format: format,
				width: width,
				height: height
			});
			colorBuffer.name = 'posteffect';
			colorBuffer.minFilter = FILTER_NEAREST;
			colorBuffer.magFilter = FILTER_NEAREST;
			colorBuffer.addressU = ADDRESS_CLAMP_TO_EDGE;
			colorBuffer.addressV = ADDRESS_CLAMP_TO_EDGE;
			rt._colorBuffer = colorBuffer;
			rt.destroy();
		},
		_destroyOffscreenTarget: function (rt) {
			if (rt._colorBuffer)
				rt._colorBuffer.destroy();
			if (rt._depthBuffer)
				rt._depthBuffer.destroy();
			rt.destroy();
		},
		setRenderTargetScale: function (scale) {
			this.renderTargetScale = scale;
			this.resizeRenderTargets();
		},
		addEffect: function (effect) {
			var isFirstEffect = this.effects.length === 0;
			var effects = this.effects;
			var newEntry = {
				effect: effect,
				inputTarget: this._createOffscreenTarget(isFirstEffect, effect.hdr),
				outputTarget: null
			};
			if (!this.layer) {
				this.layer = new Layer({
					opaqueSortMode: SORTMODE_NONE,
					transparentSortMode: SORTMODE_NONE,
					passThrough: true,
					name: "PostEffectQueue",
					renderTarget: this.camera.renderTarget,
					clear: false,
					onPostRender: function () {
						for (var i = 0; i < this._commandList.length; i++) {
							this._commandList[i]();
						}
					}
				});
				var layerList = this.app.scene.layers.layerList;
				var order = 0;
				var i;
				var start = layerList.length - 1;
				for (i = start; i >= 0; i--) {
					if (layerList[i].id === LAYERID_UI) {
						start = i - 1;
						this._origOverrideClear = layerList[i].overrideClear;
						this._origClearColorBuffer = layerList[i].clearColorBuffer;
						this._origDepthColorBuffer = layerList[i].clearDepthBuffer;
						this._origStencilColorBuffer = layerList[i].clearStencilBuffer;
						layerList[i].overrideClear = true;
						layerList[i].clearColorBuffer = false;
						layerList[i].clearDepthBuffer = this.camera.clearDepthBuffer;
						layerList[i].clearStencilBuffer = this.camera.clearStencilBuffer;
						break;
					}
				}
				this._sourceLayers = [];
				for (i = 0; i < this.camera.layers.length; i++) {
					var layerID = this.camera.layers[i];
					var layer = this.app.scene.layers.getLayerById(layerID);
					var index = this.app.scene.layers.layerList.indexOf(layer);
					if (index <= start) {
						if (layerID != LAYERID_DEPTH) {
							layer.renderTarget = newEntry.inputTarget;
							this._sourceLayers.push(layer);
						}
						if (index > order)
							order = index;
					}
				}
				this.app.scene.layers.insertOpaque(this.layer, order + 1);
				this._sourceTarget = newEntry.inputTarget;
				this.layer._commandList = [];
				this.layer.isPostEffect = true;
			}
			effects.push(newEntry);
			var len = effects.length;
			if (len > 1) {
				effects[len - 2].outputTarget = newEntry.inputTarget;
			}
			this._newPostEffect = effect;
			if (effect.needsDepthBuffer) {
				this._requestDepthMap();
			}
			this.enable();
			this._newPostEffect = undefined;
		},
		removeEffect: function (effect) {
			var i, len, index = -1;
			for (i = 0, len = this.effects.length; i < len; i++) {
				if (this.effects[i].effect === effect) {
					index = i;
					break;
				}
			}
			if (index >= 0) {
				if (index > 0)  {
					this.effects[index - 1].outputTarget = (index + 1) < this.effects.length ?
						this.effects[index + 1].inputTarget :
						null;
				} else {
					if (this.effects.length > 1) {
						if (!this.effects[1].inputTarget._depth) {
							this._destroyOffscreenTarget(this.effects[1].inputTarget);
							this.effects[1].inputTarget = this._createOffscreenTarget(true, this.effects[1].hdr);
							this._sourceTarget = this.effects[1].inputTarget;
						}
						for (i = 0; i < this._sourceLayers.length; i++) {
							this._sourceLayers[i].renderTarget = this.effects[1].inputTarget;
						}
					}
				}
				this._destroyOffscreenTarget(this.effects[index].inputTarget);
				this.effects.splice(index, 1);
			}
			if (this.enabled) {
				if (effect.needsDepthBuffer) {
					this._releaseDepthMap();
				}
			}
			if (this.effects.length === 0) {
				this.disable();
			}
		},
		_requestDepthMaps: function () {
			for (var i = 0, len = this.effects.length; i < len; i++) {
				var effect = this.effects[i].effect;
				if (this._newPostEffect === effect)
					continue;
				if (effect.needsDepthBuffer) {
					this._requestDepthMap();
				}
			}
		},
		_releaseDepthMaps: function () {
			for (var i = 0, len = this.effects.length; i < len; i++) {
				var effect = this.effects[i].effect;
				if (effect.needsDepthBuffer) {
					this._releaseDepthMap();
				}
			}
		},
		_requestDepthMap: function () {
			if (!depthLayer) depthLayer = this.app.scene.layers.getLayerById(LAYERID_DEPTH);
			if (depthLayer) depthLayer.incrementCounter();
		},
		_releaseDepthMap: function () {
			if (depthLayer) depthLayer.decrementCounter();
		},
		destroy: function () {
			for (var i = 0, len = this.effects.length; i < len; i++) {
				this.effects[i].inputTarget.destroy();
			}
			this.effects.length = 0;
			this.disable();
		},
		enable: function () {
			if (!this.enabled && this.effects.length) {
				this.enabled = true;
				var self = this;
				this._requestDepthMaps();
				this.app.graphicsDevice.on('resizecanvas', this._onCanvasResized, this);
				this.command = function () {
					if (self.enabled) {
						var rect = null;
						var len = self.effects.length;
						if (len) {
							self.layer.renderTarget = self.effects[0].inputTarget;
							for (var i = 0; i < len; i++) {
								var fx = self.effects[i];
								if (i === len - 1) {
									rect = self.camera.rect;
								}
								fx.effect.render(fx.inputTarget, fx.outputTarget, rect);
							}
						}
					}
				};
				this.layer._commandList.push(this.command);
			}
		},
		disable: function () {
			if (this.enabled) {
				this.enabled = false;
				this.app.graphicsDevice.off('resizecanvas', this._onCanvasResized, this);
				this._releaseDepthMaps();
				this._destroyOffscreenTarget(this._sourceTarget);
				var i = this.layer._commandList.indexOf(this.command);
				if (i >= 0) {
					this.layer._commandList.splice(i, 1);
				}
				var layerList = this.app.scene.layers.layerList;
				var start = layerList.length - 1;
				for (i = 0; i <= layerList.length; i++) {
					if (layerList[i].id === LAYERID_UI) {
						start = i - 1;
						layerList[i].overrideClear = this._origOverrideClear;
						layerList[i].clearColorBuffer = this._origClearColorBuffer;
						layerList[i].clearDepthBuffer = this._origDepthColorBuffer;
						layerList[i].clearStencilBuffer = this._origStencilColorBuffer;
						break;
					}
				}
				for (i = start; i >= 0; i--) {
					if (layerList[i].cameras.indexOf(this.camera) >= 0) {
						layerList[i].renderTarget = undefined;
					}
				}
				this.app.scene.layers.removeOpaque(this.layer);
				this.layer = null;
			}
		},
		_onCanvasResized: function (width, height) {
			var rect = this.camera.rect;
			var device = this.app.graphicsDevice;
			this.camera.camera.aspectRatio = (device.width * rect.z) / (device.height * rect.w);
			if (this.resizeTimeout)
				return;
			if ((now() - this.resizeLast) > 100) {
				this.resizeRenderTargets();
			} else {
				this.resizeTimeout = setTimeout(this._resizeTimeoutCallback, 100);
			}
		},
		resizeRenderTargets: function () {
			if (this.resizeTimeout) {
				clearTimeout(this.resizeTimeout);
				this.resizeTimeout = null;
			}
			this.resizeLast = now();
			var rect = this.camera.rect;
			var desiredWidth = Math.floor(rect.z * this.app.graphicsDevice.width * this.renderTargetScale);
			var desiredHeight = Math.floor(rect.w * this.app.graphicsDevice.height * this.renderTargetScale);
			var effects = this.effects;
			for (var i = 0, len = effects.length; i < len; i++) {
				var fx = effects[i];
				if (fx.inputTarget.width !== desiredWidth ||
					fx.inputTarget.height !== desiredHeight)  {
					this._resizeOffscreenTarget(fx.inputTarget);
				}
			}
		},
		onCameraRectChanged: function (name, oldValue, newValue) {
			if (this.enabled) {
				this.resizeRenderTargets();
			}
		}
	});

	var CameraComponent = function CameraComponent(system, entity) {
		Component.call(this, system, entity);
		this._camera = new Camera();
		this._camera.node = entity;
		this._priority = 0;
		this._postEffects = new PostEffectQueue(system.app, this);
	};
	CameraComponent.prototype = Object.create(Component.prototype);
	CameraComponent.prototype.constructor = CameraComponent;
	[
		{ name: 'aspectRatio', readonly: false },
		{ name: 'aspectRatioMode', readonly: false },
		{ name: 'calculateProjection', readonly: false },
		{ name: 'calculateTransform', readonly: false },
		{ name: 'clearColor', readonly: false },
		{ name: 'clearColorBuffer', readonly: false },
		{ name: 'clearDepthBuffer', readonly: false },
		{ name: 'clearStencilBuffer', readonly: false },
		{ name: 'cullFaces', readonly: false },
		{ name: 'farClip', readonly: false },
		{ name: 'flipFaces', readonly: false },
		{ name: 'fov', readonly: false },
		{ name: 'frustum', readonly: true },
		{ name: 'frustumCulling', readonly: false },
		{ name: 'horizontalFov', readonly: false },
		{ name: 'nearClip', readonly: false },
		{ name: 'orthoHeight', readonly: false },
		{ name: 'projection', readonly: false },
		{ name: 'projectionMatrix', readonly: true },
		{ name: 'rect', readonly: false },
		{ name: 'renderTarget', readonly: false },
		{ name: 'scissorRect', readonly: false },
		{ name: 'viewMatrix', readonly: true },
		{ name: 'vrDisplay', readonly: false }
	].forEach(function (property) {
		var name = property.name;
		var options = {};
		options.get = function () {
			return this._camera[name];
		};
		if (!property.readonly) {
			options.set = function (newValue) {
				this._camera[name] = newValue;
			};
		}
		Object.defineProperty(CameraComponent.prototype, name, options);
	});
	Object.defineProperty(CameraComponent.prototype, "camera", {
		get: function () {
			return this._camera;
		}
	});
	Object.defineProperty(CameraComponent.prototype, "layers", {
		get: function () {
			return this._camera.layers;
		},
		set: function (newValue) {
			var i, layer;
			var layers = this._camera.layers;
			for (i = 0; i < layers.length; i++) {
				layer = this.system.app.scene.layers.getLayerById(layers[i]);
				if (!layer) continue;
				layer.removeCamera(this);
			}
			this._camera.layers = newValue;
			if (!this.enabled || !this.entity.enabled) return;
			for (i = 0; i < newValue.length; i++) {
				layer = this.system.app.scene.layers.getLayerById(newValue[i]);
				if (!layer) continue;
				layer.addCamera(this);
			}
		}
	});
	Object.defineProperty(CameraComponent.prototype, "postEffects", {
		get: function () {
			return this._postEffects;
		}
	});
	Object.defineProperty(CameraComponent.prototype, "priority", {
		get: function () {
			return this._priority;
		},
		set: function (newValue) {
			this._priority = newValue;
			var layers = this.layers;
			for (var i = 0; i < layers.length; i++) {
				var layer = this.system.app.scene.layers.getLayerById(layers[i]);
				if (!layer) continue;
				layer._sortCameras();
			}
		}
	});
	Object.assign(CameraComponent.prototype, {
		screenToWorld: function (screenx, screeny, cameraz, worldCoord) {
			var device = this.system.app.graphicsDevice;
			var w = device.clientRect.width;
			var h = device.clientRect.height;
			return this._camera.screenToWorld(screenx, screeny, cameraz, w, h, worldCoord);
		},
		worldToScreen: function (worldCoord, screenCoord) {
			var device = this.system.app.graphicsDevice;
			var w = device.clientRect.width;
			var h = device.clientRect.height;
			return this._camera.worldToScreen(worldCoord, w, h, screenCoord);
		},
		onPrerender: function () {
			this._camera._viewMatDirty = true;
			this._camera._viewProjMatDirty = true;
		},
		addCameraToLayers: function () {
			var layers = this.layers;
			for (var i = 0; i < layers.length; i++) {
				var layer = this.system.app.scene.layers.getLayerById(layers[i]);
				if (!layer) continue;
				layer.addCamera(this);
			}
		},
		removeCameraFromLayers: function () {
			var layers = this.layers;
			for (var i = 0; i < layers.length; i++) {
				var layer = this.system.app.scene.layers.getLayerById(layers[i]);
				if (!layer) continue;
				layer.removeCamera(this);
			}
		},
		onLayersChanged: function (oldComp, newComp) {
			this.addCameraToLayers();
			oldComp.off("add", this.onLayerAdded, this);
			oldComp.off("remove", this.onLayerRemoved, this);
			newComp.on("add", this.onLayerAdded, this);
			newComp.on("remove", this.onLayerRemoved, this);
		},
		onLayerAdded: function (layer) {
			var index = this.layers.indexOf(layer.id);
			if (index < 0) return;
			layer.addCamera(this);
		},
		onLayerRemoved: function (layer) {
			var index = this.layers.indexOf(layer.id);
			if (index < 0) return;
			layer.removeCamera(this);
		},
		onEnable: function () {
			var system = this.system;
			var scene = system.app.scene;
			var layers = scene.layers;
			system.addCamera(this);
			scene.on("set:layers", this.onLayersChanged, this);
			if (layers) {
				layers.on("add", this.onLayerAdded, this);
				layers.on("remove", this.onLayerRemoved, this);
			}
			if (this.enabled && this.entity.enabled) {
				this.addCameraToLayers();
			}
			this.postEffects.enable();
		},
		onDisable: function () {
			var system = this.system;
			var scene = system.app.scene;
			var layers = scene.layers;
			this.postEffects.disable();
			this.removeCameraFromLayers();
			scene.off("set:layers", this.onLayersChanged, this);
			if (layers) {
				layers.off("add", this.onLayerAdded, this);
				layers.off("remove", this.onLayerRemoved, this);
			}
			system.removeCamera(this);
		},
		onRemove: function () {
			this.onDisable();
			this.off();
		},
		calculateAspectRatio: function (rt) {
			var src = rt ? rt : this.system.app.graphicsDevice;
			var rect = this.rect;
			return (src.width * rect.z) / (src.height * rect.w);
		},
		frameBegin: function (rt) {
			if (this.aspectRatioMode === ASPECT_AUTO) {
				this.aspectRatio = this.calculateAspectRatio(rt);
			}
		},
		frameEnd: function () {},
		enterVr: function (display, callback) {
			if ((display instanceof Function) && !callback) {
				callback = display;
				display = null;
			}
			if (!this.system.app.vr) {
				callback("VrManager not created. Enable VR in project settings.");
				return;
			}
			if (!display) {
				display = this.system.app.vr.display;
			}
			if (display) {
				var self = this;
				if (display.capabilities.canPresent) {
					display.requestPresent(function (err) {
						if (!err) {
							self.vrDisplay = display;
							self.vrDisplay.once('beforepresentchange', function (display) {
								if (!display.presenting) {
									self.vrDisplay = null;
								}
							});
						}
						callback(err);
					});
				} else {
					self.vrDisplay = display;
					callback();
				}
			} else {
				callback("No pc.VrDisplay to present");
			}
		},
		exitVr: function (callback) {
			if (this.vrDisplay) {
				if (this.vrDisplay.capabilities.canPresent) {
					var display = this.vrDisplay;
					this.vrDisplay = null;
					display.exitPresent(callback);
				} else {
					this.vrDisplay = null;
					callback();
				}
			} else {
				callback("Not presenting VR");
			}
		},
		startXr: function (type, spaceType, callback) {
			this.system.app.xr.start(this, type, spaceType, callback);
		},
		endXr: function (callback) {
			if (!this._camera.xr) {
				if (callback) callback(new Error("Camera is not in XR"));
				return;
			}
			this._camera.xr.end(callback);
		}
	});

	function CameraComponentData() {
		this.enabled = true;
	}

	var _schema$5 = ['enabled'];
	var CameraComponentSystem = function (app) {
		ComponentSystem.call(this, app);
		this.id = 'camera';
		this.ComponentType = CameraComponent;
		this.DataType = CameraComponentData;
		this.schema = _schema$5;
		this.cameras = [];
		this.on('beforeremove', this.onBeforeRemove, this);
		this.app.on("prerender", this.onPrerender, this);
		ComponentSystem.bind('update', this.onUpdate, this);
	};
	CameraComponentSystem.prototype = Object.create(ComponentSystem.prototype);
	CameraComponentSystem.prototype.constructor = CameraComponentSystem;
	Component._buildAccessors(CameraComponent.prototype, _schema$5);
	Object.assign(CameraComponentSystem.prototype, {
		initializeComponentData: function (component, data, properties) {
			properties = [
				'aspectRatio',
				'aspectRatioMode',
				'calculateProjection',
				'calculateTransform',
				'clearColor',
				'clearColorBuffer',
				'clearDepthBuffer',
				'clearStencilBuffer',
				'cullFaces',
				'farClip',
				'flipFaces',
				'fov',
				'frustumCulling',
				'horizontalFov',
				'layers',
				'renderTarget',
				'nearClip',
				'orthoHeight',
				'projection',
				'priority',
				'rect',
				'scissorRect'
			];
			for (var i = 0; i < properties.length; i++) {
				var property = properties[i];
				if (data.hasOwnProperty(property)) {
					var value = data[property];
					switch (property) {
						case 'rect':
						case 'scissorRect':
							if (Array.isArray(value)) {
								component[property] = new Vec4(value[0], value[1], value[2], value[3]);
							} else {
								component[property] = value;
							}
							break;
						case 'clearColor':
							if (Array.isArray(value)) {
								component[property] = new Color(value[0], value[1], value[2], value[3]);
							} else {
								component[property] = value;
							}
							break;
						default:
							component[property] = value;
							break;
					}
				}
			}
			ComponentSystem.prototype.initializeComponentData.call(this, component, data, ['enabled']);
		},
		cloneComponent: function (entity, clone) {
			var c = entity.camera;
			this.addComponent(clone, {
				aspectRatio: c.aspectRatio,
				aspectRatioMode: c.aspectRatioMode,
				calculateProjection: c.calculateProjection,
				calculateTransform: c.calculateTransform,
				clearColor: c.clearColor,
				clearColorBuffer: c.clearColorBuffer,
				clearDepthBuffer: c.clearDepthBuffer,
				clearStencilBuffer: c.clearStencilBuffer,
				cullFaces: c.cullFaces,
				farClip: c.farClip,
				flipFaces: c.flipFaces,
				fov: c.fov,
				frustumCulling: c.frustumCulling,
				horizontalFov: c.horizontalFov,
				layers: c.layers,
				renderTarget: c.renderTarget,
				nearClip: c.nearClip,
				orthoHeight: c.orthoHeight,
				projection: c.projection,
				priority: c.priority,
				rect: c.rect,
				scissorRect: c.scissorRect
			});
		},
		onBeforeRemove: function (entity, component) {
			this.removeCamera(component);
		},
		onUpdate: function (dt) {
			if (this.app.vr) {
				var components = this.store;
				for (var id in components) {
					var component = components[id];
					if (component.enabled && component.entity.enabled) {
						var vrDisplay = component.vrDisplay;
						if (vrDisplay) {
							vrDisplay.setClipPlanes(component.nearClip, component.farClip);
							if (component.entity) {
								component.entity.localTransform.copy(vrDisplay.combinedViewInv);
								component.entity._dirtyLocal = false;
								component.entity._dirtifyWorld();
							}
						}
					}
				}
			}
		},
		onPrerender: function () {
			for (var i = 0, len = this.cameras.length; i < len; i++) {
				this.cameras[i].onPrerender();
			}
		},
		addCamera: function (camera) {
			this.cameras.push(camera);
			this.sortCamerasByPriority();
		},
		removeCamera: function (camera) {
			var index = this.cameras.indexOf(camera);
			if (index >= 0) {
				this.cameras.splice(index, 1);
				this.sortCamerasByPriority();
			}
		},
		sortCamerasByPriority: function () {
			this.cameras.sort(function (a, b) {
				return a.priority - b.priority;
			});
		}
	});

	var CollisionComponent = function CollisionComponent(system, entity) {
		Component.call(this, system, entity);
		this._compoundParent = null;
		this.entity.on('insert', this._onInsert, this);
		this.on('set_type', this.onSetType, this);
		this.on('set_halfExtents', this.onSetHalfExtents, this);
		this.on('set_radius', this.onSetRadius, this);
		this.on('set_height', this.onSetHeight, this);
		this.on('set_axis', this.onSetAxis, this);
		this.on("set_asset", this.onSetAsset, this);
		this.on("set_model", this.onSetModel, this);
	};
	CollisionComponent.prototype = Object.create(Component.prototype);
	CollisionComponent.prototype.constructor = CollisionComponent;
	Object.assign(CollisionComponent.prototype, {
		onSetType: function (name, oldValue, newValue) {
			if (oldValue !== newValue) {
				this.system.changeType(this, oldValue, newValue);
			}
		},
		onSetHalfExtents: function (name, oldValue, newValue) {
			var t = this.data.type;
			if (this.data.initialized && t === 'box') {
				this.system.recreatePhysicalShapes(this);
			}
		},
		onSetRadius: function (name, oldValue, newValue) {
			var t = this.data.type;
			if (this.data.initialized && (t === 'sphere' || t === 'capsule' || t === 'cylinder' || t === 'cone')) {
				this.system.recreatePhysicalShapes(this);
			}
		},
		onSetHeight: function (name, oldValue, newValue) {
			var t = this.data.type;
			if (this.data.initialized && (t === 'capsule' || t === 'cylinder' || t === 'cone')) {
				this.system.recreatePhysicalShapes(this);
			}
		},
		onSetAxis: function (name, oldValue, newValue) {
			var t = this.data.type;
			if (this.data.initialized && (t === 'capsule' || t === 'cylinder' || t === 'cone')) {
				this.system.recreatePhysicalShapes(this);
			}
		},
		onSetAsset: function (name, oldValue, newValue) {
			var asset;
			var assets = this.system.app.assets;
			if (oldValue) {
				asset = assets.get(oldValue);
				if (asset) {
					asset.off('remove', this.onAssetRemoved, this);
				}
			}
			if (newValue) {
				if (newValue instanceof Asset) {
					this.data.asset = newValue.id;
				}
				asset = assets.get(this.data.asset);
				if (asset) {
					asset.off('remove', this.onAssetRemoved, this);
					asset.on('remove', this.onAssetRemoved, this);
				}
			}
			if (this.data.initialized && this.data.type === 'mesh') {
				if (!newValue) {
					this.data.model = null;
				}
				this.system.recreatePhysicalShapes(this);
			}
		},
		onSetModel: function (name, oldValue, newValue) {
			if (this.data.initialized && this.data.type === 'mesh') {
				this.system.implementations.mesh.doRecreatePhysicalShape(this);
			}
		},
		onAssetRemoved: function (asset) {
			asset.off('remove', this.onAssetRemoved, this);
			if (this.data.asset === asset.id) {
				this.asset = null;
			}
		},
		_getCompoundChildShapeIndex: function (shape) {
			var compound = this.data.shape;
			var shapes = compound.getNumChildShapes();
			for (var i = 0; i < shapes; i++) {
				var childShape = compound.getChildShape(i);
				if (childShape.ptr === shape.ptr) {
					return i;
				}
			}
			return null;
		},
		_onInsert: function (parent) {
			if (typeof Ammo === 'undefined')
				return;
			if (this._compoundParent) {
				this.system.recreatePhysicalShapes(this);
			} else if (! this.entity.rigidbody) {
				var ancestor = this.entity.parent;
				while (ancestor) {
					if (ancestor.collision && ancestor.collision.type === 'compound') {
						if (ancestor.collision.shape.getNumChildShapes() === 0) {
							this.system.recreatePhysicalShapes(ancestor.collision);
						} else {
							this.system.recreatePhysicalShapes(this);
						}
						break;
					}
					ancestor = ancestor.parent;
				}
			}
		},
		_updateCompound: function () {
			var entity = this.entity;
			if (entity._dirtyWorld) {
				var dirty = entity._dirtyLocal;
				var parent = entity;
				while (parent && !dirty) {
					if (parent.collision && parent.collision === this._compoundParent)
						break;
					if (parent._dirtyLocal)
						dirty = true;
					parent = parent.parent;
				}
				if (dirty) {
					entity.forEach(this.system.implementations.compound._updateEachDescendantTransform, entity);
					var bodyComponent = this._compoundParent.entity.rigidbody;
					if (bodyComponent)
						bodyComponent.activate();
				}
			}
		},
		onEnable: function () {
			if (this.data.type === 'mesh' && this.data.asset && this.data.initialized) {
				var asset = this.system.app.assets.get(this.data.asset);
				if (asset && (!asset.resource || !this.data.shape)) {
					this.system.recreatePhysicalShapes(this);
					return;
				}
			}
			if (this.entity.rigidbody) {
				if (this.entity.rigidbody.enabled) {
					this.entity.rigidbody.enableSimulation();
				}
			} else if (this._compoundParent && this !== this._compoundParent) {
				if (this._compoundParent.shape.getNumChildShapes() === 0) {
					this.system.recreatePhysicalShapes(this._compoundParent);
				} else {
					var transform = this.system._getNodeTransform(this.entity, this._compoundParent.entity);
					this._compoundParent.shape.addChildShape(transform, this.data.shape);
					Ammo.destroy(transform);
					if (this._compoundParent.entity.rigidbody)
						this._compoundParent.entity.rigidbody.activate();
				}
			} else if (this.entity.trigger) {
				this.entity.trigger.enable();
			}
		},
		onDisable: function () {
			if (this.entity.rigidbody) {
				this.entity.rigidbody.disableSimulation();
			} else if (this._compoundParent && this !== this._compoundParent) {
				if (! this._compoundParent.entity._destroying) {
					this.system._removeCompoundChild(this._compoundParent, this.data.shape);
					if (this._compoundParent.entity.rigidbody)
						this._compoundParent.entity.rigidbody.activate();
				}
			} else if (this.entity.trigger) {
				this.entity.trigger.disable();
			}
		},
		onBeforeRemove: function () {
			this.entity.off('insert', this._onInsert, this);
		}
	});

	function CollisionComponentData() {
		this.enabled = true;
		this.type = 'box';
		this.halfExtents = new Vec3(0.5, 0.5, 0.5);
		this.radius = 0.5;
		this.axis = 1;
		this.height = 2;
		this.asset = null;
		this.shape = null;
		this.model = null;
		this.initialized = false;
	}

	var BODYTYPE_STATIC = 'static';
	var BODYTYPE_DYNAMIC = 'dynamic';
	var BODYTYPE_KINEMATIC = 'kinematic';
	var BODYFLAG_STATIC_OBJECT = 1;
	var BODYFLAG_KINEMATIC_OBJECT = 2;
	var BODYFLAG_NORESPONSE_OBJECT = 4;
	var BODYSTATE_ACTIVE_TAG = 1;
	var BODYSTATE_ISLAND_SLEEPING = 2;
	var BODYSTATE_WANTS_DEACTIVATION = 3;
	var BODYSTATE_DISABLE_DEACTIVATION = 4;
	var BODYSTATE_DISABLE_SIMULATION = 5;
	var BODYGROUP_NONE = 0;
	var BODYGROUP_DEFAULT = 1;
	var BODYGROUP_DYNAMIC = 1;
	var BODYGROUP_STATIC = 2;
	var BODYGROUP_KINEMATIC = 4;
	var BODYGROUP_ENGINE_1 = 8;
	var BODYGROUP_TRIGGER = 16;
	var BODYGROUP_ENGINE_2 = 32;
	var BODYGROUP_ENGINE_3 = 64;
	var BODYGROUP_USER_1 = 128;
	var BODYGROUP_USER_2 = 256;
	var BODYGROUP_USER_3 = 512;
	var BODYGROUP_USER_4 = 1024;
	var BODYGROUP_USER_5 = 2048;
	var BODYGROUP_USER_6 = 4096;
	var BODYGROUP_USER_7 = 8192;
	var BODYGROUP_USER_8 = 16384;
	var BODYMASK_NONE = 0;
	var BODYMASK_ALL = 65535;
	var BODYMASK_STATIC = 2;
	var BODYMASK_NOT_STATIC = 65535 ^ 2;
	var BODYMASK_NOT_STATIC_KINEMATIC = 65535 ^ (2 | 4);

	var ammoVec1, ammoQuat, ammoTransform;
	function Trigger(app, component, data) {
		this.entity = component.entity;
		this.component = component;
		this.app = app;
		if (typeof Ammo !== 'undefined' && ! ammoVec1) {
			ammoVec1 = new Ammo.btVector3();
			ammoQuat = new Ammo.btQuaternion();
			ammoTransform = new Ammo.btTransform();
		}
		this.initialize(data);
	}
	Object.assign(Trigger.prototype,  {
		initialize: function (data) {
			var entity = this.entity;
			var shape = data.shape;
			if (shape && typeof Ammo !== 'undefined') {
				if (entity.trigger) {
					entity.trigger.destroy();
				}
				var mass = 1;
				var pos = entity.getPosition();
				var rot = entity.getRotation();
				ammoVec1.setValue(pos.x, pos.y, pos.z);
				ammoQuat.setValue(rot.x, rot.y, rot.z, rot.w);
				ammoTransform.setOrigin(ammoVec1);
				ammoTransform.setRotation(ammoQuat);
				var body = this.app.systems.rigidbody.createBody(mass, shape, ammoTransform);
				body.setRestitution(0);
				body.setFriction(0);
				body.setDamping(0, 0);
				ammoVec1.setValue(0, 0, 0);
				body.setLinearFactor(ammoVec1);
				body.setAngularFactor(ammoVec1);
				body.setCollisionFlags(body.getCollisionFlags() | BODYFLAG_NORESPONSE_OBJECT);
				body.entity = entity;
				this.body = body;
				if (this.component.enabled && entity.enabled) {
					this.enable();
				}
			}
		},
		destroy: function () {
			var body = this.body;
			if (!body) return;
			this.disable();
			this.app.systems.rigidbody.destroyBody(body);
		},
		_getEntityTransform: function (transform) {
			var pos = this.entity.getPosition();
			var rot = this.entity.getRotation();
			ammoVec1.setValue(pos.x, pos.y, pos.z);
			ammoQuat.setValue(rot.x, rot.y, rot.z, rot.w);
			transform.setOrigin(ammoVec1);
			transform.setRotation(ammoQuat);
		},
		updateTransform: function () {
			this._getEntityTransform(ammoTransform);
			var body = this.body;
			body.setWorldTransform(ammoTransform);
			body.activate();
		},
		enable: function () {
			var body = this.body;
			if (!body) return;
			var systems = this.app.systems;
			systems.rigidbody.addBody(body, BODYGROUP_TRIGGER, BODYMASK_NOT_STATIC ^ BODYGROUP_TRIGGER);
			systems.rigidbody._triggers.push(this);
			body.forceActivationState(BODYSTATE_ACTIVE_TAG);
			this.updateTransform();
		},
		disable: function () {
			var body = this.body;
			if (!body) return;
			var systems = this.app.systems;
			var idx = systems.rigidbody._triggers.indexOf(this);
			if (idx > -1) {
				systems.rigidbody._triggers.splice(idx, 1);
			}
			systems.rigidbody.removeBody(body);
			body.forceActivationState(BODYSTATE_DISABLE_SIMULATION);
		}
	});

	var mat4 = new Mat4();
	var vec3 = new Vec3();
	var quat$1 = new Quat();
	var _schema$6 = [
		'enabled',
		'type',
		'halfExtents',
		'radius',
		'axis',
		'height',
		'asset',
		'shape',
		'model'
	];
	var CollisionSystemImpl = function (system) {
		this.system = system;
	};
	Object.assign(CollisionSystemImpl.prototype, {
		beforeInitialize: function (component, data) {
			data.shape = null;
			data.model = new Model();
			data.model.graph = new GraphNode();
		},
		afterInitialize: function (component, data) {
			this.recreatePhysicalShapes(component);
			component.data.initialized = true;
		},
		reset: function (component, data) {
			this.beforeInitialize(component, data);
			this.afterInitialize(component, data);
		},
		recreatePhysicalShapes: function (component) {
			var entity = component.entity;
			var data = component.data;
			if (typeof Ammo !== 'undefined') {
				if (entity.trigger) {
					entity.trigger.destroy();
					delete entity.trigger;
				}
				if (data.shape) {
					if (component._compoundParent) {
						this.system._removeCompoundChild(component._compoundParent, data.shape);
						if (component._compoundParent.entity.rigidbody)
							component._compoundParent.entity.rigidbody.activate();
					}
					Ammo.destroy(data.shape);
					data.shape = null;
				}
				data.shape = this.createPhysicalShape(component.entity, data);
				var firstCompoundChild = ! component._compoundParent;
				if (data.type === 'compound' && (! component._compoundParent || component === component._compoundParent)) {
					component._compoundParent = component;
					entity.forEach(this._addEachDescendant, component);
				} else if (data.type !== 'compound') {
					if (component._compoundParent && component === component._compoundParent) {
						entity.forEach(this.system.implementations.compound._updateEachDescendant, component);
					}
					if (! component.rigidbody) {
						component._compoundParent = null;
						var parent = entity.parent;
						while (parent) {
							if (parent.collision && parent.collision.type === 'compound') {
								component._compoundParent = parent.collision;
								break;
							}
							parent = parent.parent;
						}
					}
				}
				if (component._compoundParent) {
					if (component !== component._compoundParent) {
						if (firstCompoundChild && component._compoundParent.shape.getNumChildShapes() === 0) {
							this.system.recreatePhysicalShapes(component._compoundParent);
						} else {
							this.system.updateCompoundChildTransform(entity);
							if (component._compoundParent.entity.rigidbody)
								component._compoundParent.entity.rigidbody.activate();
						}
					}
				}
				if (entity.rigidbody) {
					entity.rigidbody.disableSimulation();
					entity.rigidbody.createBody();
					if (entity.enabled && entity.rigidbody.enabled) {
						entity.rigidbody.enableSimulation();
					}
				} else if (! component._compoundParent) {
					if (! entity.trigger) {
						entity.trigger = new Trigger(this.system.app, component, data);
					} else {
						entity.trigger.initialize(data);
					}
				}
			}
		},
		createPhysicalShape: function (entity, data) {
			return undefined;
		},
		updateTransform: function (component, position, rotation, scale) {
			if (component.entity.trigger) {
				component.entity.trigger.updateTransform();
			}
		},
		beforeRemove: function (entity, component) {
			if (component.data.shape) {
				if (component._compoundParent && ! component._compoundParent.entity._destroying) {
					this.system._removeCompoundChild(component._compoundParent, component.data.shape);
					if (component._compoundParent.entity.rigidbody)
						component._compoundParent.entity.rigidbody.activate();
				}
				component._compoundParent = null;
				Ammo.destroy(component.data.shape);
				component.data.shape = null;
			}
		},
		remove: function (entity, data) {
			var app = this.system.app;
			if (entity.rigidbody && entity.rigidbody.body) {
				app.systems.rigidbody.removeBody(entity.rigidbody.body);
				entity.rigidbody.disableSimulation();
			}
			if (entity.trigger) {
				entity.trigger.destroy();
				delete entity.trigger;
			}
			if (app.scene.containsModel(data.model)) {
				app.root.removeChild(data.model.graph);
				app.scene.removeModel(data.model);
			}
		},
		clone: function (entity, clone) {
			var src = this.system.store[entity.getGuid()];
			var data = {
				enabled: src.data.enabled,
				type: src.data.type,
				halfExtents: [src.data.halfExtents.x, src.data.halfExtents.y, src.data.halfExtents.z],
				radius: src.data.radius,
				axis: src.data.axis,
				height: src.data.height,
				asset: src.data.asset,
				model: src.data.model
			};
			return this.system.addComponent(clone, data);
		}
	});
	var CollisionBoxSystemImpl = function (system) {
		CollisionSystemImpl.call(this, system);
	};
	CollisionBoxSystemImpl.prototype = Object.create(CollisionSystemImpl.prototype);
	CollisionBoxSystemImpl.prototype.constructor = CollisionBoxSystemImpl;
	Object.assign(CollisionBoxSystemImpl.prototype, {
		createPhysicalShape: function (entity, data) {
			if (typeof Ammo !== 'undefined') {
				var he = data.halfExtents;
				var ammoHe = new Ammo.btVector3(he ? he.x : 0.5, he ? he.y : 0.5, he ? he.z : 0.5);
				var shape = new Ammo.btBoxShape(ammoHe);
				Ammo.destroy(ammoHe);
				return shape;
			}
			return undefined;
		}
	});
	var CollisionSphereSystemImpl = function (system) {
		CollisionSystemImpl.call(this, system);
	};
	CollisionSphereSystemImpl.prototype = Object.create(CollisionSystemImpl.prototype);
	CollisionSphereSystemImpl.prototype.constructor = CollisionSphereSystemImpl;
	Object.assign(CollisionSphereSystemImpl.prototype, {
		createPhysicalShape: function (entity, data) {
			if (typeof Ammo !== 'undefined') {
				return new Ammo.btSphereShape(data.radius);
			}
			return undefined;
		}
	});
	var CollisionCapsuleSystemImpl = function (system) {
		CollisionSystemImpl.call(this, system);
	};
	CollisionCapsuleSystemImpl.prototype = Object.create(CollisionSystemImpl.prototype);
	CollisionCapsuleSystemImpl.prototype.constructor = CollisionCapsuleSystemImpl;
	Object.assign(CollisionCapsuleSystemImpl.prototype, {
		createPhysicalShape: function (entity, data) {
			var shape = null;
			var axis = (data.axis !== undefined) ? data.axis : 1;
			var radius = data.radius || 0.5;
			var height = Math.max((data.height || 2) - 2 * radius, 0);
			if (typeof Ammo !== 'undefined') {
				switch (axis) {
					case 0:
						shape = new Ammo.btCapsuleShapeX(radius, height);
						break;
					case 1:
						shape = new Ammo.btCapsuleShape(radius, height);
						break;
					case 2:
						shape = new Ammo.btCapsuleShapeZ(radius, height);
						break;
				}
			}
			return shape;
		}
	});
	var CollisionCylinderSystemImpl = function (system) {
		CollisionSystemImpl.call(this, system);
	};
	CollisionCylinderSystemImpl.prototype = Object.create(CollisionSystemImpl.prototype);
	CollisionCylinderSystemImpl.prototype.constructor = CollisionCylinderSystemImpl;
	Object.assign(CollisionCylinderSystemImpl.prototype, {
		createPhysicalShape: function (entity, data) {
			var halfExtents = null;
			var shape = null;
			var axis = (data.axis !== undefined) ? data.axis : 1;
			var radius = (data.radius !== undefined) ? data.radius : 0.5;
			var height = (data.height !== undefined) ? data.height : 1;
			if (typeof Ammo !== 'undefined') {
				switch (axis) {
					case 0:
						halfExtents = new Ammo.btVector3(height * 0.5, radius, radius);
						shape = new Ammo.btCylinderShapeX(halfExtents);
						break;
					case 1:
						halfExtents = new Ammo.btVector3(radius, height * 0.5, radius);
						shape = new Ammo.btCylinderShape(halfExtents);
						break;
					case 2:
						halfExtents = new Ammo.btVector3(radius, radius, height * 0.5);
						shape = new Ammo.btCylinderShapeZ(halfExtents);
						break;
				}
			}
			if (halfExtents)
				Ammo.destroy(halfExtents);
			return shape;
		}
	});
	var CollisionConeSystemImpl = function (system) {
		CollisionSystemImpl.call(this, system);
	};
	CollisionConeSystemImpl.prototype = Object.create(CollisionSystemImpl.prototype);
	CollisionConeSystemImpl.prototype.constructor = CollisionConeSystemImpl;
	Object.assign(CollisionConeSystemImpl.prototype, {
		createPhysicalShape: function (entity, data) {
			var shape = null;
			var axis = (data.axis !== undefined) ? data.axis : 1;
			var radius = (data.radius !== undefined) ? data.radius : 0.5;
			var height = (data.height !== undefined) ? data.height : 1;
			if (typeof Ammo !== 'undefined') {
				switch (axis) {
					case 0:
						shape = new Ammo.btConeShapeX(radius, height);
						break;
					case 1:
						shape = new Ammo.btConeShape(radius, height);
						break;
					case 2:
						shape = new Ammo.btConeShapeZ(radius, height);
						break;
				}
			}
			return shape;
		}
	});
	var CollisionMeshSystemImpl = function (system) {
		CollisionSystemImpl.call(this, system);
	};
	CollisionMeshSystemImpl.prototype = Object.create(CollisionSystemImpl.prototype);
	CollisionMeshSystemImpl.prototype.constructor = CollisionMeshSystemImpl;
	Object.assign(CollisionMeshSystemImpl.prototype, {
		beforeInitialize: function (component, data) {},
		createPhysicalShape: function (entity, data) {
			if (typeof Ammo !== 'undefined' && data.model) {
				var model = data.model;
				var shape = new Ammo.btCompoundShape();
				var i, j;
				for (i = 0; i < model.meshInstances.length; i++) {
					var meshInstance = model.meshInstances[i];
					var mesh = meshInstance.mesh;
					var triMesh;
					if (this.system._triMeshCache[mesh.id]) {
						triMesh = this.system._triMeshCache[mesh.id];
					} else {
						var ib = mesh.indexBuffer[RENDERSTYLE_SOLID];
						var vb = mesh.vertexBuffer;
						var format = vb.getFormat();
						var stride = format.size / 4;
						var positions;
						for (j = 0; j < format.elements.length; j++) {
							var element = format.elements[j];
							if (element.name === SEMANTIC_POSITION) {
								positions = new Float32Array(vb.lock(), element.offset);
							}
						}
						var indices = new Uint16Array(ib.lock());
						var numTriangles = mesh.primitive[0].count / 3;
						var v1 = new Ammo.btVector3();
						var v2 = new Ammo.btVector3();
						var v3 = new Ammo.btVector3();
						var i1, i2, i3;
						var base = mesh.primitive[0].base;
						triMesh = new Ammo.btTriangleMesh();
						this.system._triMeshCache[mesh.id] = triMesh;
						for (j = 0; j < numTriangles; j++) {
							i1 = indices[base + j * 3] * stride;
							i2 = indices[base + j * 3 + 1] * stride;
							i3 = indices[base + j * 3 + 2] * stride;
							v1.setValue(positions[i1], positions[i1 + 1], positions[i1 + 2]);
							v2.setValue(positions[i2], positions[i2 + 1], positions[i2 + 2]);
							v3.setValue(positions[i3], positions[i3 + 1], positions[i3 + 2]);
							triMesh.addTriangle(v1, v2, v3, true);
						}
						Ammo.destroy(v1);
						Ammo.destroy(v2);
						Ammo.destroy(v3);
					}
					var useQuantizedAabbCompression = true;
					var triMeshShape = new Ammo.btBvhTriangleMeshShape(triMesh, useQuantizedAabbCompression);
					var scaling = this.system._getNodeScaling(meshInstance.node);
					triMeshShape.setLocalScaling(scaling);
					Ammo.destroy(scaling);
					var transform = this.system._getNodeTransform(meshInstance.node);
					shape.addChildShape(transform, triMeshShape);
					Ammo.destroy(transform);
				}
				var entityTransform = entity.getWorldTransform();
				var scale = entityTransform.getScale();
				var vec = new Ammo.btVector3(scale.x, scale.y, scale.z);
				shape.setLocalScaling(vec);
				Ammo.destroy(vec);
				return shape;
			}
			return undefined;
		},
		recreatePhysicalShapes: function (component) {
			var data = component.data;
			if (data.asset !== null && component.enabled && component.entity.enabled) {
				this.loadModelAsset(component);
			} else {
				this.doRecreatePhysicalShape(component);
			}
		},
		loadModelAsset: function (component) {
			var self = this;
			var id = component.data.asset;
			var data = component.data;
			var assets = this.system.app.assets;
			var asset = assets.get(id);
			if (asset) {
				asset.ready(function (asset) {
					data.model = asset.resource;
					self.doRecreatePhysicalShape(component);
				});
				assets.load(asset);
			} else {
				assets.once("add:" + id, function (asset) {
					asset.ready(function (asset) {
						data.model = asset.resource;
						self.doRecreatePhysicalShape(component);
					});
					assets.load(asset);
				});
			}
		},
		doRecreatePhysicalShape: function (component) {
			var entity = component.entity;
			var data = component.data;
			if (data.model) {
				this.destroyShape(data);
				data.shape = this.createPhysicalShape(entity, data);
				if (entity.rigidbody) {
					entity.rigidbody.disableSimulation();
					entity.rigidbody.createBody();
					if (entity.enabled && entity.rigidbody.enabled) {
						entity.rigidbody.enableSimulation();
					}
				} else {
					if (!entity.trigger) {
						entity.trigger = new Trigger(this.system.app, component, data);
					} else {
						entity.trigger.initialize(data);
					}
				}
			} else {
				this.beforeRemove(entity, component);
				this.remove(entity, data);
			}
		},
		updateTransform: function (component, position, rotation, scale) {
			if (component.shape) {
				var entityTransform = component.entity.getWorldTransform();
				var worldScale = entityTransform.getScale();
				var previousScale = component.shape.getLocalScaling();
				if (worldScale.x !== previousScale.x() ||
					worldScale.y !== previousScale.y() ||
					worldScale.z !== previousScale.z() ) {
					this.doRecreatePhysicalShape(component);
				}
			}
			CollisionSystemImpl.prototype.updateTransform.call(this, component, position, rotation, scale);
		},
		destroyShape: function (data) {
			if (!data.shape)
				return;
			var numShapes = data.shape.getNumChildShapes();
			for (var i = 0; i < numShapes; i++) {
				var shape = data.shape.getChildShape(i);
				Ammo.destroy(shape);
			}
			Ammo.destroy(data.shape);
			data.shape = null;
		},
		remove: function (entity, data) {
			this.destroyShape(data);
			CollisionSystemImpl.prototype.remove.call(this, entity, data);
		}
	});
	var CollisionCompoundSystemImpl = function (system) {
		CollisionSystemImpl.call(this, system);
	};
	CollisionCompoundSystemImpl.prototype = Object.create(CollisionSystemImpl.prototype);
	CollisionCompoundSystemImpl.prototype.constructor = CollisionCompoundSystemImpl;
	Object.assign(CollisionCompoundSystemImpl.prototype, {
		createPhysicalShape: function (entity, data) {
			if (typeof Ammo !== 'undefined') {
				return new Ammo.btCompoundShape();
			}
			return undefined;
		},
		_addEachDescendant: function (entity) {
			if (! entity.collision || entity.rigidbody)
				return;
			entity.collision._compoundParent = this;
			if (entity !== this.entity) {
				entity.collision.system.recreatePhysicalShapes(entity.collision);
			}
		},
		_updateEachDescendant: function (entity) {
			if (! entity.collision)
				return;
			if (entity.collision._compoundParent !== this)
				return;
			entity.collision._compoundParent = null;
			if (entity !== this.entity && ! entity.rigidbody) {
				entity.collision.system.recreatePhysicalShapes(entity.collision);
			}
		},
		_updateEachDescendantTransform: function (entity) {
			if (! entity.collision || entity.collision._compoundParent !== this.collision._compoundParent)
				return;
			this.collision.system.updateCompoundChildTransform(entity);
		}
	});
	var CollisionComponentSystem = function CollisionComponentSystem(app) {
		ComponentSystem.call(this, app);
		this.id = "collision";
		this.ComponentType = CollisionComponent;
		this.DataType = CollisionComponentData;
		this.schema = _schema$6;
		this.implementations = { };
		this._triMeshCache = { };
		this.on('beforeremove', this.onBeforeRemove, this);
		this.on('remove', this.onRemove, this);
	};
	CollisionComponentSystem.prototype = Object.create(ComponentSystem.prototype);
	CollisionComponentSystem.prototype.constructor = CollisionComponentSystem;
	Component._buildAccessors(CollisionComponent.prototype, _schema$6);
	Object.assign(CollisionComponentSystem.prototype, {
		initializeComponentData: function (component, _data, properties) {
			properties = ['type', 'halfExtents', 'radius', 'axis', 'height', 'shape', 'model', 'asset', 'enabled'];
			var data = {};
			for (var i = 0, len = properties.length; i < len; i++) {
				var property = properties[i];
				data[property] = _data[property];
			}
			var idx;
			if (_data.hasOwnProperty('asset')) {
				idx = properties.indexOf('model');
				if (idx !== -1) {
					properties.splice(idx, 1);
				}
			} else if (_data.hasOwnProperty('model')) {
				idx = properties.indexOf('asset');
				if (idx !== -1) {
					properties.splice(idx, 1);
				}
			}
			if (!data.type) {
				data.type = component.data.type;
			}
			component.data.type = data.type;
			if (data.halfExtents && Array.isArray(data.halfExtents)) {
				data.halfExtents = new Vec3(data.halfExtents[0], data.halfExtents[1], data.halfExtents[2]);
			}
			var impl = this._createImplementation(data.type);
			impl.beforeInitialize(component, data);
			ComponentSystem.prototype.initializeComponentData.call(this.system, component, data, properties);
			impl.afterInitialize(component, data);
		},
		_createImplementation: function (type) {
			if (this.implementations[type] === undefined) {
				var impl;
				switch (type) {
					case 'box':
						impl = new CollisionBoxSystemImpl(this);
						break;
					case 'sphere':
						impl = new CollisionSphereSystemImpl(this);
						break;
					case 'capsule':
						impl = new CollisionCapsuleSystemImpl(this);
						break;
					case 'cylinder':
						impl = new CollisionCylinderSystemImpl(this);
						break;
					case 'cone':
						impl = new CollisionConeSystemImpl(this);
						break;
					case 'mesh':
						impl = new CollisionMeshSystemImpl(this);
						break;
					case 'compound':
						impl = new CollisionCompoundSystemImpl(this);
						break;
				}
				this.implementations[type] = impl;
			}
			return this.implementations[type];
		},
		_getImplementation: function (entity) {
			return this.implementations[entity.collision.data.type];
		},
		cloneComponent: function (entity, clone) {
			return this._getImplementation(entity).clone(entity, clone);
		},
		onBeforeRemove: function (entity, component) {
			this.implementations[component.data.type].beforeRemove(entity, component);
			component.onBeforeRemove();
		},
		onRemove: function (entity, data) {
			this.implementations[data.type].remove(entity, data);
		},
		updateCompoundChildTransform: function (entity) {
			this._removeCompoundChild(entity.collision._compoundParent, entity.collision.data.shape);
			if (entity.enabled && entity.collision.enabled) {
				var transform = this._getNodeTransform(entity, entity.collision._compoundParent.entity);
				entity.collision._compoundParent.shape.addChildShape(transform, entity.collision.data.shape);
				Ammo.destroy(transform);
			}
		},
		_removeCompoundChild: function (collision, shape) {
			if (collision.shape.removeChildShape) {
				collision.shape.removeChildShape(shape);
			} else {
				var ind = collision._getCompoundChildShapeIndex(shape);
				if (ind !== null) {
					collision.shape.removeChildShapeByIndex(ind);
				}
			}
		},
		onTransformChanged: function (component, position, rotation, scale) {
			this.implementations[component.data.type].updateTransform(component, position, rotation, scale);
		},
		changeType: function (component, previousType, newType) {
			this.implementations[previousType].beforeRemove(component.entity, component);
			this.implementations[previousType].remove(component.entity, component.data);
			this._createImplementation(newType).reset(component, component.data);
		},
		recreatePhysicalShapes: function (component) {
			this.implementations[component.data.type].recreatePhysicalShapes(component);
		},
		_calculateNodeRelativeTransform: function (node, relative) {
			if (node === relative) {
				var scale = node.getWorldTransform().getScale();
				mat4.setScale(scale.x, scale.y, scale.z);
			} else {
				this._calculateNodeRelativeTransform(node.parent, relative);
				mat4.mul(node.getLocalTransform());
			}
		},
		_getNodeScaling: function (node) {
			var wtm = node.getWorldTransform();
			var scl = wtm.getScale();
			return new Ammo.btVector3(scl.x, scl.y, scl.z);
		},
		_getNodeTransform: function (node, relative) {
			var pos, rot;
			if (relative) {
				this._calculateNodeRelativeTransform(node, relative);
				pos = vec3;
				rot = quat$1;
				mat4.getTranslation(pos);
				rot.setFromMat4(mat4);
			} else {
				pos = node.getPosition();
				rot = node.getRotation();
			}
			var transform = new Ammo.btTransform();
			transform.setIdentity();
			var origin = transform.getOrigin();
			origin.setValue(pos.x, pos.y, pos.z);
			var ammoQuat = new Ammo.btQuaternion();
			ammoQuat.setValue(rot.x, rot.y, rot.z, rot.w);
			transform.setRotation(ammoQuat);
			Ammo.destroy(ammoQuat);
			Ammo.destroy(origin);
			return transform;
		},
		destroy: function () {
			for (var key in this._triMeshCache) {
				Ammo.destroy(this._triMeshCache[key]);
			}
			this._triMeshCache = null;
			ComponentSystem.prototype.destroy.call(this);
		}
	});

	function ComponentSystemRegistry() {
		this.list = [];
	}
	Object.assign(ComponentSystemRegistry.prototype, {
		add: function (system) {
			var id = system.id;
			if (this[id]) {
				throw new Error("ComponentSystem name '" + id + "' already registered or not allowed");
			}
			this[id] = system;
			this.list.push(system);
		},
		remove: function (system) {
			var id = system.id;
			if (!this[id]) {
				throw new Error("No ComponentSystem named '" + id + "' registered");
			}
			delete this[id];
			var index = this.list.indexOf(this[id]);
			if (index !== -1) {
				this.list.splice(index, 1);
			}
		}
	});

	var ELEMENTTYPE_GROUP = 'group';
	var ELEMENTTYPE_IMAGE = 'image';
	var ELEMENTTYPE_TEXT = 'text';

	function StencilParameters(options) {
		this.func = options.func === undefined ? FUNC_ALWAYS : options.func;
		this.ref = options.ref || 0;
		this.readMask = options.readMask === undefined ? 0xFF : options.readMask;
		this.writeMask = options.writeMask === undefined ? 0xFF : options.writeMask;
		this.fail = options.fail || STENCILOP_KEEP;
		this.zfail = options.zfail || STENCILOP_KEEP;
		this.zpass = options.zpass || STENCILOP_KEEP;
	}
	StencilParameters.prototype.clone = function () {
		var clone = new StencilParameters({
			func: this.func,
			ref: this.ref,
			readMask: this.readMask,
			writeMask: this.writeMask,
			fail: this.fail,
			zfail: this.zfail,
			zpass: this.zpass
		});
		return clone;
	};

	function ImageRenderable(entity, mesh, material) {
		this._entity = entity;
		this._element = entity.element;
		this.model = new Model();
		this.node = new GraphNode();
		this.model.graph = this.node;
		this.mesh = mesh;
		this.meshInstance = new MeshInstance(this.node, this.mesh, material);
		this.meshInstance.name = 'ImageElement: ' + entity.name;
		this.meshInstance.castShadow = false;
		this.meshInstance.receiveShadow = false;
		this._meshDirty = false;
		this.model.meshInstances.push(this.meshInstance);
		this._entity.addChild(this.model.graph);
		this.model._entity = this._entity;
		this.unmaskMeshInstance = null;
	}
	ImageRenderable.prototype.destroy = function () {
		this.setMaterial(null);
		this._element.removeModelFromLayers(this.model);
		this.model.destroy();
		this.model = null;
		this.node = null;
		this.mesh = null;
		this.meshInstance = null;
		this._entity = null;
		this._element = null;
	};
	ImageRenderable.prototype.setMesh = function (mesh) {
		if (!this.meshInstance) return;
		this.mesh = mesh;
		this.meshInstance.mesh = mesh;
		this.meshInstance.visible = !!mesh;
		if (this.unmaskMeshInstance) {
			this.unmaskMeshInstance.mesh = mesh;
		}
		this.forceUpdateAabb();
	};
	ImageRenderable.prototype.setMask = function (mask) {
		if (!this.meshInstance) return;
		if (mask) {
			this.unmaskMeshInstance = new MeshInstance(this.node, this.mesh, this.meshInstance.material);
			this.unmaskMeshInstance.name = 'Unmask: ' + this._entity.name;
			this.unmaskMeshInstance.castShadow = false;
			this.unmaskMeshInstance.receiveShadow = false;
			this.unmaskMeshInstance.pick = false;
			this.model.meshInstances.push(this.unmaskMeshInstance);
			for (var name in this.meshInstance.parameters) {
				this.unmaskMeshInstance.setParameter(name, this.meshInstance.parameters[name].data);
			}
		} else {
			var idx = this.model.meshInstances.indexOf(this.unmaskMeshInstance);
			if (idx >= 0) {
				this.model.meshInstances.splice(idx, 1);
			}
			this.unmaskMeshInstance = null;
		}
		if (this._entity.enabled && this._element.enabled) {
			this._element.removeModelFromLayers(this.model);
			this._element.addModelToLayers(this.model);
		}
	};
	ImageRenderable.prototype.setMaterial = function (material) {
		if (!this.meshInstance) return;
		this.meshInstance.material = material;
		if (this.unmaskMeshInstance) {
			this.unmaskMeshInstance.material = material;
		}
	};
	ImageRenderable.prototype.setParameter = function (name, value) {
		if (!this.meshInstance) return;
		this.meshInstance.setParameter(name, value);
		if (this.unmaskMeshInstance) {
			this.unmaskMeshInstance.setParameter(name, value);
		}
	};
	ImageRenderable.prototype.deleteParameter = function (name) {
		if (!this.meshInstance) return;
		this.meshInstance.deleteParameter(name);
		if (this.unmaskMeshInstance) {
			this.unmaskMeshInstance.deleteParameter(name);
		}
	};
	ImageRenderable.prototype.setUnmaskDrawOrder = function () {
		if (!this.meshInstance) return;
		var getLastChild = function (e) {
			var last;
			var c = e.children;
			var l = c.length;
			if (l) {
				for (var i = 0; i < l; i++) {
					if (c[i].element) {
						last = c[i];
					}
				}
				if (!last) return null;
				var child = getLastChild(last);
				if (child) {
					return child;
				}
				return last;
			}
			return null;
		};
		if (this.unmaskMeshInstance) {
			var lastChild = getLastChild(this._entity);
			if (lastChild && lastChild.element) {
				this.unmaskMeshInstance.drawOrder = lastChild.element.drawOrder + lastChild.element.getMaskOffset();
			} else {
				this.unmaskMeshInstance.drawOrder = this.meshInstance.drawOrder + this._element.getMaskOffset();
			}
		}
	};
	ImageRenderable.prototype.setDrawOrder = function (drawOrder) {
		if (!this.meshInstance) return;
		this.meshInstance.drawOrder = drawOrder;
	};
	ImageRenderable.prototype.setCull = function (cull) {
		if (!this.meshInstance) return;
		var element = this._element;
		var visibleFn = null;
		if (cull && element._isScreenCulled()) {
			visibleFn = function (camera) {
				return element.isVisibleForCamera(camera);
			};
		}
		this.meshInstance.cull = cull;
		this.meshInstance.isVisibleFunc = visibleFn;
		if (this.unmaskMeshInstance) {
			this.unmaskMeshInstance.cull = cull;
			this.unmaskMeshInstance.isVisibleFunc = visibleFn;
		}
	};
	ImageRenderable.prototype.setScreenSpace = function (screenSpace) {
		if (!this.meshInstance) return;
		this.meshInstance.screenSpace = screenSpace;
		if (this.unmaskMeshInstance) {
			this.unmaskMeshInstance.screenSpace = screenSpace;
		}
	};
	ImageRenderable.prototype.setLayer = function (layer) {
		if (!this.meshInstance) return;
		this.meshInstance.layer = layer;
		if (this.unmaskMeshInstance) {
			this.unmaskMeshInstance.layer = layer;
		}
	};
	ImageRenderable.prototype.forceUpdateAabb = function (mask) {
		if (!this.meshInstance) return;
		this.meshInstance._aabbVer = -1;
		if (this.unmaskMeshInstance) {
			this.unmaskMeshInstance._aabbVer = -1;
		}
	};
	ImageRenderable.prototype.setAabbFunc = function (fn) {
		if (!this.meshInstance) return;
		this.meshInstance._updateAabbFunc = fn;
		if (this.unmaskMeshInstance) {
			this.unmaskMeshInstance._updateAabbFunc = fn;
		}
	};
	function ImageElement(element) {
		this._element = element;
		this._entity = element.entity;
		this._system = element.system;
		this._textureAsset = null;
		this._texture = null;
		this._materialAsset = null;
		this._material = null;
		this._spriteAsset = null;
		this._sprite = null;
		this._spriteFrame = 0;
		this._pixelsPerUnit = null;
		this._rect = new Vec4(0, 0, 1, 1);
		this._mask = false;
		this._maskRef = 0;
		this._outerScale = new Vec2();
		this._outerScaleUniform = new Float32Array(2);
		this._innerOffset = new Vec4();
		this._innerOffsetUniform = new Float32Array(4);
		this._atlasRect = new Vec4();
		this._atlasRectUniform = new Float32Array(4);
		this._defaultMesh = this._createMesh();
		this._renderable = new ImageRenderable(this._entity, this._defaultMesh, this._material);
		this._color = new Color(1, 1, 1, 1);
		this._colorUniform = new Float32Array([1, 1, 1]);
		this._renderable.setParameter('material_emissive', this._colorUniform);
		this._renderable.setParameter('material_opacity', 1);
		this._updateAabbFunc = this._updateAabb.bind(this);
		this._onScreenChange(this._element.screen);
		this._element.on('resize', this._onParentResizeOrPivotChange, this);
		this._element.on('set:pivot', this._onParentResizeOrPivotChange, this);
		this._element.on('screen:set:screenspace', this._onScreenSpaceChange, this);
		this._element.on('set:screen', this._onScreenChange, this);
		this._element.on('set:draworder', this._onDrawOrderChange, this);
		this._element.on('screen:set:resolution', this._onResolutionChange, this);
	}
	Object.assign(ImageElement.prototype, {
		destroy: function () {
			this.textureAsset = null;
			this.spriteAsset = null;
			this.materialAsset = null;
			this._renderable.setMesh(this._defaultMesh);
			this._renderable.destroy();
			this._defaultMesh = null;
			this._element.off('resize', this._onParentResizeOrPivotChange, this);
			this._element.off('set:pivot', this._onParentResizeOrPivotChange, this);
			this._element.off('screen:set:screenspace', this._onScreenSpaceChange, this);
			this._element.off('set:screen', this._onScreenChange, this);
			this._element.off('set:draworder', this._onDrawOrderChange, this);
			this._element.off('screen:set:resolution', this._onResolutionChange, this);
		},
		_onResolutionChange: function (res) {
		},
		_onParentResizeOrPivotChange: function () {
			if (this._renderable.mesh) {
				this._updateMesh(this._renderable.mesh);
			}
		},
		_onScreenSpaceChange: function (value) {
			this._updateMaterial(value);
		},
		_onScreenChange: function (screen, previous) {
			if (screen) {
				this._updateMaterial(screen.screen.screenSpace);
			} else {
				this._updateMaterial(false);
			}
		},
		_onDrawOrderChange: function (order) {
			this._renderable.setDrawOrder(order);
			if (this.mask && this._element.screen) {
				this._element.screen.screen.once('syncdraworder', function () {
					this._renderable.setUnmaskDrawOrder();
				}, this);
			}
		},
		_hasUserMaterial: function () {
			return !!this._materialAsset ||
				   (!!this._material &&
					this._system.defaultImageMaterials.indexOf(this._material) === -1);
		},
		_use9Slicing: function () {
			return this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === SPRITE_RENDERMODE_TILED);
		},
		_updateMaterial: function (screenSpace) {
			var mask = !!this._mask;
			var nineSliced = !!(this.sprite && this.sprite.renderMode === SPRITE_RENDERMODE_SLICED);
			var nineTiled = !!(this.sprite && this.sprite.renderMode === SPRITE_RENDERMODE_TILED);
			if (!this._hasUserMaterial()) {
				this._material = this._system.getImageElementMaterial(screenSpace, mask, nineSliced, nineTiled);
			}
			if (this._renderable) {
				this._renderable.setCull(true);
				this._renderable.setMaterial(this._material);
				this._renderable.setScreenSpace(screenSpace);
				this._renderable.setLayer(screenSpace ? LAYER_HUD : LAYER_WORLD);
			}
		},
		_createMesh: function () {
			var element = this._element;
			var w = element.calculatedWidth;
			var h = element.calculatedHeight;
			var r = this._rect;
			var vertexData = new ArrayBuffer(4 * 8 * 4);
			var vertexDataF32 = new Float32Array(vertexData);
			vertexDataF32[5] = 1;
			vertexDataF32[6] = r.x;
			vertexDataF32[7] = r.y;
			vertexDataF32[8] = w;
			vertexDataF32[13] = 1;
			vertexDataF32[14] = r.x + r.z;
			vertexDataF32[15] = r.y;
			vertexDataF32[16] = w;
			vertexDataF32[17] = h;
			vertexDataF32[21] = 1;
			vertexDataF32[22] = r.x + r.z;
			vertexDataF32[23] = r.y + r.w;
			vertexDataF32[25] = h;
			vertexDataF32[29] = 1;
			vertexDataF32[30] = r.x;
			vertexDataF32[31] = r.y + r.w;
			var vertexDesc = [
				{ semantic: SEMANTIC_POSITION, components: 3, type: TYPE_FLOAT32 },
				{ semantic: SEMANTIC_NORMAL, components: 3, type: TYPE_FLOAT32 },
				{ semantic: SEMANTIC_TEXCOORD0, components: 2, type: TYPE_FLOAT32 }
			];
			var device = this._system.app.graphicsDevice;
			var vertexFormat = new VertexFormat(device, vertexDesc);
			var vertexBuffer = new VertexBuffer(device, vertexFormat, 4, BUFFER_STATIC, vertexData);
			var mesh = new Mesh(device);
			mesh.vertexBuffer = vertexBuffer;
			mesh.primitive[0].type = PRIMITIVE_TRIFAN;
			mesh.primitive[0].base = 0;
			mesh.primitive[0].count = 4;
			mesh.primitive[0].indexed = false;
			mesh.aabb.setMinMax(Vec3.ZERO, new Vec3(w, h, 0));
			this._updateMesh(mesh);
			return mesh;
		},
		_updateMesh: function (mesh) {
			var element = this._element;
			var w = element.calculatedWidth;
			var h = element.calculatedHeight;
			var screenSpace = element._isScreenSpace();
			this._updateMaterial(screenSpace);
			if (this._renderable) this._renderable.forceUpdateAabb();
			if (this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === SPRITE_RENDERMODE_TILED)) {
				var frameData = this._sprite.atlas.frames[this._sprite.frameKeys[this._spriteFrame]];
				var borderWidthScale = 2 / frameData.rect.z;
				var borderHeightScale = 2 / frameData.rect.w;
				this._innerOffset.set(
					frameData.border.x * borderWidthScale,
					frameData.border.y * borderHeightScale,
					frameData.border.z * borderWidthScale,
					frameData.border.w * borderHeightScale
				);
				var tex = this.sprite.atlas.texture;
				this._atlasRect.set(frameData.rect.x / tex.width,
									frameData.rect.y / tex.height,
									frameData.rect.z / tex.width,
									frameData.rect.w / tex.height);
				var ppu = this._pixelsPerUnit !== null ? this._pixelsPerUnit : this.sprite.pixelsPerUnit;
				var scaleMulX = frameData.rect.z / ppu;
				var scaleMulY = frameData.rect.w / ppu;
				this._outerScale.set(Math.max(w, this._innerOffset.x * scaleMulX), Math.max(h, this._innerOffset.y * scaleMulY));
				var scaleX = scaleMulX;
				var scaleY = scaleMulY;
				this._outerScale.x /= scaleMulX;
				this._outerScale.y /= scaleMulY;
				scaleX *= math.clamp(w / (this._innerOffset.x * scaleMulX), 0.0001, 1);
				scaleY *= math.clamp(h / (this._innerOffset.y * scaleMulY), 0.0001, 1);
				if (this._renderable) {
					this._innerOffsetUniform[0] = this._innerOffset.x;
					this._innerOffsetUniform[1] = this._innerOffset.y;
					this._innerOffsetUniform[2] = this._innerOffset.z;
					this._innerOffsetUniform[3] = this._innerOffset.w;
					this._renderable.setParameter('innerOffset', this._innerOffsetUniform);
					this._atlasRectUniform[0] = this._atlasRect.x;
					this._atlasRectUniform[1] = this._atlasRect.y;
					this._atlasRectUniform[2] = this._atlasRect.z;
					this._atlasRectUniform[3] = this._atlasRect.w;
					this._renderable.setParameter('atlasRect', this._atlasRectUniform);
					this._outerScaleUniform[0] = this._outerScale.x;
					this._outerScaleUniform[1] = this._outerScale.y;
					this._renderable.setParameter('outerScale', this._outerScaleUniform);
					this._renderable.setAabbFunc(this._updateAabbFunc);
					this._renderable.node.setLocalScale(scaleX, scaleY, 1);
					this._renderable.node.setLocalPosition((0.5 - element.pivot.x) * w, (0.5 - element.pivot.y) * h, 0);
				}
			} else {
				var vb = mesh.vertexBuffer;
				var vertexDataF32 = new Float32Array(vb.lock());
				var hp = element.pivot.x;
				var vp = element.pivot.y;
				vertexDataF32[0] = 0 - hp * w;
				vertexDataF32[1] = 0 - vp * h;
				vertexDataF32[8] = w - hp * w;
				vertexDataF32[9] = 0 - vp * h;
				vertexDataF32[16] = w - hp * w;
				vertexDataF32[17] = h - vp * h;
				vertexDataF32[24] = 0 - hp * w;
				vertexDataF32[25] = h - vp * h;
				var atlasTextureWidth = 1;
				var atlasTextureHeight = 1;
				var rect = this._rect;
				if (this._sprite && this._sprite.frameKeys[this._spriteFrame] && this._sprite.atlas) {
					var frame = this._sprite.atlas.frames[this._sprite.frameKeys[this._spriteFrame]];
					if (frame) {
						rect = frame.rect;
						atlasTextureWidth = this._sprite.atlas.texture.width;
						atlasTextureHeight = this._sprite.atlas.texture.height;
					}
				}
				vertexDataF32[6] = rect.x / atlasTextureWidth;
				vertexDataF32[7] = rect.y / atlasTextureHeight;
				vertexDataF32[14] = (rect.x + rect.z) / atlasTextureWidth;
				vertexDataF32[15] = rect.y / atlasTextureHeight;
				vertexDataF32[22] = (rect.x + rect.z) / atlasTextureWidth;
				vertexDataF32[23] = (rect.y + rect.w) / atlasTextureHeight;
				vertexDataF32[30] = rect.x / atlasTextureWidth;
				vertexDataF32[31] = (rect.y + rect.w) / atlasTextureHeight;
				vb.unlock();
				var min = new Vec3(0 - hp * w, 0 - vp * h, 0);
				var max = new Vec3(w - hp * w, h - vp * h, 0);
				mesh.aabb.setMinMax(min, max);
				if (this._renderable) {
					this._renderable.node.setLocalScale(1, 1, 1);
					this._renderable.node.setLocalPosition(0, 0, 0);
					this._renderable.setAabbFunc(null);
				}
			}
			this._meshDirty = false;
		},
		_updateSprite: function () {
			var nineSlice = false;
			var mesh = null;
			if (this._sprite && this._sprite.atlas) {
				mesh = this._sprite.meshes[this.spriteFrame];
				nineSlice = this._sprite.renderMode === SPRITE_RENDERMODE_SLICED || this._sprite.renderMode === SPRITE_RENDERMODE_TILED;
			}
			this.mesh = nineSlice ? mesh : this._defaultMesh;
			if (this.mesh) {
				if (! this._element._beingInitialized) {
					this._updateMesh(this.mesh);
				} else {
					this._meshDirty = true;
				}
			}
		},
		_updateAabb: function (aabb) {
			aabb.center.set(0, 0, 0);
			aabb.halfExtents.set(this._outerScale.x * 0.5, this._outerScale.y * 0.5, 0.001);
			aabb.setFromTransformedAabb(aabb, this._renderable.node.getWorldTransform());
			return aabb;
		},
		_toggleMask: function () {
			this._element._dirtifyMask();
			var screenSpace = this._element._isScreenSpace();
			this._updateMaterial(screenSpace);
			this._renderable.setMask(!!this._mask);
		},
		_onMaterialLoad: function (asset) {
			this.material = asset.resource;
		},
		_onMaterialAdded: function (asset) {
			this._system.app.assets.off('add:' + asset.id, this._onMaterialAdded, this);
			if (this._materialAsset === asset.id) {
				this._bindMaterialAsset(asset);
			}
		},
		_bindMaterialAsset: function (asset) {
			if (!this._entity.enabled) return;
			asset.on("load", this._onMaterialLoad, this);
			asset.on("change", this._onMaterialChange, this);
			asset.on("remove", this._onMaterialRemove, this);
			if (asset.resource) {
				this._onMaterialLoad(asset);
			} else {
				this._system.app.assets.load(asset);
			}
		},
		_unbindMaterialAsset: function (asset) {
			asset.off("load", this._onMaterialLoad, this);
			asset.off("change", this._onMaterialChange, this);
			asset.off("remove", this._onMaterialRemove, this);
		},
		_onMaterialChange: function () {
		},
		_onMaterialRemove: function () {
		},
		_onTextureAdded: function (asset) {
			this._system.app.assets.off('add:' + asset.id, this._onTextureAdded, this);
			if (this._textureAsset === asset.id) {
				this._bindTextureAsset(asset);
			}
		},
		_bindTextureAsset: function (asset) {
			if (!this._entity.enabled) return;
			asset.on("load", this._onTextureLoad, this);
			asset.on("change", this._onTextureChange, this);
			asset.on("remove", this._onTextureRemove, this);
			if (asset.resource) {
				this._onTextureLoad(asset);
			} else {
				this._system.app.assets.load(asset);
			}
		},
		_unbindTextureAsset: function (asset) {
			asset.off("load", this._onTextureLoad, this);
			asset.off("change", this._onTextureChange, this);
			asset.off("remove", this._onTextureRemove, this);
		},
		_onTextureLoad: function (asset) {
			this.texture = asset.resource;
		},
		_onTextureChange: function (asset) {
		},
		_onTextureRemove: function (asset) {
		},
		_onSpriteAssetAdded: function (asset) {
			this._system.app.assets.off('add:' + asset.id, this._onSpriteAssetAdded, this);
			if (this._spriteAsset === asset.id) {
				this._bindSpriteAsset(asset);
			}
		},
		_bindSpriteAsset: function (asset) {
			if (!this._entity.enabled) return;
			asset.on("load", this._onSpriteAssetLoad, this);
			asset.on("change", this._onSpriteAssetChange, this);
			asset.on("remove", this._onSpriteAssetRemove, this);
			if (asset.resource) {
				this._onSpriteAssetLoad(asset);
			} else {
				this._system.app.assets.load(asset);
			}
		},
		_unbindSpriteAsset: function (asset) {
			asset.off("load", this._onSpriteAssetLoad, this);
			asset.off("change", this._onSpriteAssetChange, this);
			asset.off("remove", this._onSpriteAssetRemove, this);
			if (asset.data.textureAtlasAsset) {
				this._system.app.assets.off("load:" + asset.data.textureAtlasAsset, this._onTextureAtlasLoad, this);
			}
		},
		_onSpriteAssetLoad: function (asset) {
			if (!asset || !asset.resource) {
				this.sprite = null;
			} else {
				if (!asset.resource.atlas) {
					var atlasAssetId = asset.data.textureAtlasAsset;
					if (atlasAssetId) {
						var assets = this._system.app.assets;
						assets.off('load:' + atlasAssetId, this._onTextureAtlasLoad, this);
						assets.once('load:' + atlasAssetId, this._onTextureAtlasLoad, this);
					}
				} else {
					this.sprite = asset.resource;
				}
			}
		},
		_onSpriteAssetChange: function (asset) {
			this._onSpriteAssetLoad(asset);
		},
		_onSpriteAssetRemove: function (asset) {
		},
		_bindSprite: function (sprite) {
			sprite.on('set:meshes', this._onSpriteMeshesChange, this);
			sprite.on('set:pixelsPerUnit', this._onSpritePpuChange, this);
			sprite.on('set:atlas', this._onAtlasTextureChange, this);
			if (sprite.atlas) {
				sprite.atlas.on('set:texture', this._onAtlasTextureChange, this);
			}
		},
		_unbindSprite: function (sprite) {
			sprite.off('set:meshes', this._onSpriteMeshesChange, this);
			sprite.off('set:pixelsPerUnit', this._onSpritePpuChange, this);
			sprite.off('set:atlas', this._onAtlasTextureChange, this);
			if (sprite.atlas) {
				sprite.atlas.off('set:texture', this._onAtlasTextureChange, this);
			}
		},
		_onSpriteMeshesChange: function () {
			if (this._sprite) {
				this._spriteFrame = math.clamp(this._spriteFrame, 0, this._sprite.frameKeys.length - 1);
			}
			this._updateSprite();
		},
		_onSpritePpuChange: function () {
			if (this.sprite.renderMode !== SPRITE_RENDERMODE_SIMPLE && this._pixelsPerUnit === null) {
				this._updateSprite();
			}
		},
		_onAtlasTextureChange: function () {
			if (this.sprite && this.sprite.atlas && this.sprite.atlas.texture) {
				this._renderable.setParameter('texture_emissiveMap', this._sprite.atlas.texture);
				this._renderable.setParameter('texture_opacityMap', this._sprite.atlas.texture);
			} else {
				this._renderable.deleteParameter('texture_emissiveMap');
				this._renderable.deleteParameter('texture_opacityMap');
			}
		},
		_onTextureAtlasLoad: function (atlasAsset) {
			var spriteAsset = this._spriteAsset;
			if (spriteAsset instanceof Asset) {
				this._onSpriteAssetLoad(spriteAsset);
			} else {
				this._onSpriteAssetLoad(this._system.app.assets.get(spriteAsset));
			}
		},
		onEnable: function () {
			var asset;
			if (this._materialAsset) {
				asset = this._system.app.assets.get(this._materialAsset);
				if (asset && asset.resource !== this._material) {
					this._bindMaterialAsset(asset);
				}
			}
			if (this._textureAsset) {
				asset = this._system.app.assets.get(this._textureAsset);
				if (asset && asset.resource !== this._texture) {
					this._bindTextureAsset(asset);
				}
			}
			if (this._spriteAsset) {
				asset = this._system.app.assets.get(this._spriteAsset);
				if (asset && asset.resource !== this._sprite) {
					this._bindSpriteAsset(asset);
				}
			}
			this._element.addModelToLayers(this._renderable.model);
		},
		onDisable: function () {
			this._element.removeModelFromLayers(this._renderable.model);
		},
		_setStencil: function (stencilParams) {
			this._renderable.meshInstance.stencilFront = stencilParams;
			this._renderable.meshInstance.stencilBack = stencilParams;
			var ref = 0;
			if (this._element.maskedBy) {
				ref = this._element.maskedBy.element._image._maskRef;
			}
			if (this._renderable.unmaskMeshInstance) {
				var sp = new StencilParameters({
					ref: ref + 1,
					func: FUNC_EQUAL,
					zpass: STENCILOP_DECREMENT
				});
				this._renderable.unmaskMeshInstance.stencilFront = sp;
				this._renderable.unmaskMeshInstance.stencilBack = sp;
			}
		}
	});
	Object.defineProperty(ImageElement.prototype, "color", {
		get: function () {
			return this._color;
		},
		set: function (value) {
			var r = value.r;
			var g = value.g;
			var b = value.b;
			if (this._color.r === r && this._color.g === g && this._color.b === b) {
				return;
			}
			this._color.r = r;
			this._color.g = g;
			this._color.b = b;
			this._colorUniform[0] = r;
			this._colorUniform[1] = g;
			this._colorUniform[2] = b;
			this._renderable.setParameter('material_emissive', this._colorUniform);
			if (this._element) {
				this._element.fire('set:color', this._color);
			}
		}
	});
	Object.defineProperty(ImageElement.prototype, "opacity", {
		get: function () {
			return this._color.a;
		},
		set: function (value) {
			if (value === this._color.a) return;
			this._color.a = value;
			this._renderable.setParameter('material_opacity', value);
			if (this._element) {
				this._element.fire('set:opacity', value);
			}
		}
	});
	Object.defineProperty(ImageElement.prototype, "rect", {
		get: function () {
			return this._rect;
		},
		set: function (value) {
			var x, y, z, w;
			if (value instanceof Vec4) {
				x = value.x;
				y = value.y;
				z = value.z;
				w = value.w;
			} else {
				x = value[0];
				y = value[1];
				z = value[2];
				w = value[3];
			}
			if (x === this._rect.x &&
				y === this._rect.y &&
				z === this._rect.z &&
				w === this._rect.w
			) {
				return;
			}
			this._rect.set(x, y, z, w);
			if (this._renderable.mesh) {
				if (! this._element._beingInitialized) {
					this._updateMesh(this._renderable.mesh);
				} else {
					this._meshDirty = true;
				}
			}
		}
	});
	Object.defineProperty(ImageElement.prototype, "material", {
		get: function () {
			return this._material;
		},
		set: function (value) {
			if (this._material === value) return;
			if (!value) {
				var screenSpace = this._element._isScreenSpace();
				if (this.mask) {
					value = screenSpace ? this._system.defaultScreenSpaceImageMaskMaterial : this._system.defaultImageMaskMaterial;
				} else {
					value = screenSpace ? this._system.defaultScreenSpaceImageMaterial : this._system.defaultImageMaterial;
				}
			}
			this._material = value;
			if (value) {
				this._renderable.setMaterial(value);
				if (this._hasUserMaterial()) {
					this._renderable.deleteParameter('material_opacity');
					this._renderable.deleteParameter('material_emissive');
				} else {
					this._colorUniform[0] = this._color.r;
					this._colorUniform[1] = this._color.g;
					this._colorUniform[2] = this._color.b;
					this._renderable.setParameter('material_emissive', this._colorUniform);
					this._renderable.setParameter('material_opacity', this._color.a);
				}
			}
		}
	});
	Object.defineProperty(ImageElement.prototype, "materialAsset", {
		get: function () {
			return this._materialAsset;
		},
		set: function (value) {
			var assets = this._system.app.assets;
			var _id = value;
			if (value instanceof Asset) {
				_id = value.id;
			}
			if (this._materialAsset !== _id) {
				if (this._materialAsset) {
					assets.off('add:' + this._materialAsset, this._onMaterialAdded, this);
					var _prev = assets.get(this._materialAsset);
					if (_prev) {
						_prev.off("load", this._onMaterialLoad, this);
						_prev.off("change", this._onMaterialChange, this);
						_prev.off("remove", this._onMaterialRemove, this);
					}
				}
				this._materialAsset = _id;
				if (this._materialAsset) {
					var asset = assets.get(this._materialAsset);
					if (!asset) {
						this.material = null;
						assets.on('add:' + this._materialAsset, this._onMaterialAdded, this);
					} else {
						this._bindMaterialAsset(asset);
					}
				} else {
					this.material = null;
				}
			}
		}
	});
	Object.defineProperty(ImageElement.prototype, "texture", {
		get: function () {
			return this._texture;
		},
		set: function (value) {
			if (this._texture === value) return;
			if (this._textureAsset) {
				var textureAsset = this._system.app.assets.get(this._textureAsset);
				if (textureAsset && textureAsset.resource !== value) {
					this.textureAsset = null;
				}
			}
			this._texture = value;
			if (value) {
				if (this._spriteAsset) {
					this.spriteAsset = null;
				}
				this._renderable.setParameter("texture_emissiveMap", this._texture);
				this._renderable.setParameter("texture_opacityMap", this._texture);
				this._colorUniform[0] = this._color.r;
				this._colorUniform[1] = this._color.g;
				this._colorUniform[2] = this._color.b;
				this._renderable.setParameter("material_emissive", this._colorUniform);
				this._renderable.setParameter("material_opacity", this._color.a);
			} else {
				this._renderable.deleteParameter("texture_emissiveMap");
				this._renderable.deleteParameter("texture_opacityMap");
			}
		}
	});
	Object.defineProperty(ImageElement.prototype, "textureAsset", {
		get: function () {
			return this._textureAsset;
		},
		set: function (value) {
			var assets = this._system.app.assets;
			var _id = value;
			if (value instanceof Asset) {
				_id = value.id;
			}
			if (this._textureAsset !== _id) {
				if (this._textureAsset) {
					assets.off('add:' + this._textureAsset, this._onTextureAdded, this);
					var _prev = assets.get(this._textureAsset);
					if (_prev) {
						_prev.off("load", this._onTextureLoad, this);
						_prev.off("change", this._onTextureChange, this);
						_prev.off("remove", this._onTextureRemove, this);
					}
				}
				this._textureAsset = _id;
				if (this._textureAsset) {
					var asset = assets.get(this._textureAsset);
					if (!asset) {
						this.texture = null;
						assets.on('add:' + this._textureAsset, this._onTextureAdded, this);
					} else {
						this._bindTextureAsset(asset);
					}
				} else {
					this.texture = null;
				}
			}
		}
	});
	Object.defineProperty(ImageElement.prototype, "spriteAsset", {
		get: function () {
			return this._spriteAsset;
		},
		set: function (value) {
			var assets = this._system.app.assets;
			var _id = value;
			if (value instanceof Asset) {
				_id = value.id;
			}
			if (this._spriteAsset !== _id) {
				if (this._spriteAsset) {
					assets.off('add:' + this._spriteAsset, this._onSpriteAssetAdded, this);
					var _prev = assets.get(this._spriteAsset);
					if (_prev) {
						this._unbindSpriteAsset(_prev);
					}
				}
				this._spriteAsset = _id;
				if (this._spriteAsset) {
					var asset = assets.get(this._spriteAsset);
					if (!asset) {
						this.sprite = null;
						assets.on('add:' + this._spriteAsset, this._onSpriteAssetAdded, this);
					} else {
						this._bindSpriteAsset(asset);
					}
				} else {
					this.sprite = null;
				}
				if (this._element) {
					this._element.fire('set:spriteAsset', _id);
				}
			}
		}
	});
	Object.defineProperty(ImageElement.prototype, "sprite", {
		get: function () {
			return this._sprite;
		},
		set: function (value) {
			if (this._sprite === value) return;
			if (this._sprite) {
				this._unbindSprite(this._sprite);
			}
			if (this._spriteAsset) {
				var spriteAsset = this._system.app.assets.get(this._spriteAsset);
				if (spriteAsset && spriteAsset.resource !== value) {
					this.spriteAsset = null;
				}
			}
			this._sprite = value;
			if (this._sprite) {
				this._bindSprite(this._sprite);
				if (this._textureAsset) {
					this.textureAsset = null;
				}
			}
			if (this._sprite && this._sprite.atlas && this._sprite.atlas.texture) {
				this._renderable.setParameter("texture_emissiveMap", this._sprite.atlas.texture);
				this._renderable.setParameter("texture_opacityMap", this._sprite.atlas.texture);
			} else {
				this._renderable.deleteParameter("texture_emissiveMap");
				this._renderable.deleteParameter("texture_opacityMap");
			}
			if (this._sprite) {
				this._spriteFrame = math.clamp(this._spriteFrame, 0, this._sprite.frameKeys.length - 1);
			}
			this._updateSprite();
		}
	});
	Object.defineProperty(ImageElement.prototype, "spriteFrame", {
		get: function () {
			return this._spriteFrame;
		},
		set: function (value) {
			var oldValue = this._spriteFrame;
			if (this._sprite) {
				this._spriteFrame = math.clamp(value, 0, this._sprite.frameKeys.length - 1);
			} else {
				this._spriteFrame = value;
			}
			if (this._spriteFrame === oldValue) return;
			this._updateSprite();
			if (this._element) {
				this._element.fire('set:spriteFrame', value);
			}
		}
	});
	Object.defineProperty(ImageElement.prototype, "mesh", {
		get: function () {
			return this._renderable.mesh;
		},
		set: function (value) {
			this._renderable.setMesh(value);
			if (this._defaultMesh === value) {
				this._renderable.setAabbFunc(null);
			} else {
				this._renderable.setAabbFunc(this._updateAabbFunc);
			}
		}
	});
	Object.defineProperty(ImageElement.prototype, "mask", {
		get: function () {
			return this._mask;
		},
		set: function (value) {
			if (this._mask !== value) {
				this._mask = value;
				this._toggleMask();
			}
		}
	});
	Object.defineProperty(ImageElement.prototype, "pixelsPerUnit", {
		get: function () {
			return this._pixelsPerUnit;
		},
		set: function (value) {
			if (this._pixelsPerUnit === value) return;
			this._pixelsPerUnit = value;
			if (this._sprite && (this._sprite.renderMode === SPRITE_RENDERMODE_SLICED || this._sprite.renderMode === SPRITE_RENDERMODE_TILED)) {
				this._updateSprite();
			}
		}
	});
	Object.defineProperty(ImageElement.prototype, "aabb", {
		get: function () {
			if (this._renderable.meshInstance) {
				return this._renderable.meshInstance.aabb;
			}
			return null;
		}
	});

	function LocalizedAsset(app) {
		EventHandler.call(this);
		this._app = app;
		app.i18n.on('set:locale', this._onSetLocale, this);
		this._autoLoad = false;
		this._disableLocalization = false;
		this._defaultAsset = null;
		this._localizedAsset = null;
	}
	LocalizedAsset.prototype = Object.create(EventHandler.prototype);
	LocalizedAsset.prototype.constructor = LocalizedAsset;
	LocalizedAsset.prototype._bindDefaultAsset = function () {
		var asset = this._app.assets.get(this._defaultAsset);
		if (!asset) {
			this._app.assets.once('add:' + this._defaultAsset, this._onDefaultAssetAdd, this);
		} else {
			this._onDefaultAssetAdd(asset);
		}
	};
	LocalizedAsset.prototype._unbindDefaultAsset = function () {
		if (!this._defaultAsset) return;
		this._app.assets.off('add:' + this._defaultAsset, this._onDefaultAssetAdd, this);
		var asset = this._app.assets.get(this._defaultAsset);
		if (!asset) return;
		asset.off('add:localized', this._onLocaleAdd, this);
		asset.off('remove:localized', this._onLocaleRemove, this);
		asset.off('remove', this._onDefaultAssetRemove, this);
	};
	LocalizedAsset.prototype._onDefaultAssetAdd = function (asset) {
		if (this._defaultAsset !== asset.id) return;
		asset.on('add:localized', this._onLocaleAdd, this);
		asset.on('remove:localized', this._onLocaleRemove, this);
		asset.once('remove', this._onDefaultAssetRemove, this);
	};
	LocalizedAsset.prototype._onDefaultAssetRemove = function (asset) {
		if (this._defaultAsset !== asset.id) return;
		asset.off('add:localized', this._onLocaleAdd, this);
		asset.off('remove:localized', this._onLocaleAdd, this);
		this._app.assets.once('add:' + this._defaultAsset, this._onDefaultAssetAdd, this);
	};
	LocalizedAsset.prototype._bindLocalizedAsset = function () {
		if (!this._autoLoad) return;
		var asset = this._app.assets.get(this._localizedAsset);
		if (!asset) return;
		asset.on("load", this._onLocalizedAssetLoad, this);
		asset.on("change", this._onLocalizedAssetChange, this);
		asset.on("remove", this._onLocalizedAssetRemove, this);
		if (asset.resource) {
			this._onLocalizedAssetLoad(asset);
		} else {
			this._app.assets.load(asset);
		}
	};
	LocalizedAsset.prototype._unbindLocalizedAsset = function () {
		var asset = this._app.assets.get(this._localizedAsset);
		if (!asset) return;
		asset.off("load", this._onLocalizedAssetLoad, this);
		asset.off("change", this._onLocalizedAssetChange, this);
		asset.off("remove", this._onLocalizedAssetRemove, this);
	};
	LocalizedAsset.prototype._onLocalizedAssetAdd = function (asset) {
		if (this._localizedAsset !== asset.id) return;
		this._bindLocalizedAsset();
	};
	LocalizedAsset.prototype._onLocalizedAssetLoad = function (asset) {
		this.fire('load', asset);
	};
	LocalizedAsset.prototype._onLocalizedAssetChange = function (asset, name, newValue, oldValue) {
		this.fire('change', asset, name, newValue, oldValue);
	};
	LocalizedAsset.prototype._onLocalizedAssetRemove = function (asset) {
		if (this._localizedAsset === asset.id) {
			this.localizedAsset = this._defaultAsset;
		}
		this.fire('remove', asset);
	};
	LocalizedAsset.prototype._onLocaleAdd = function (locale, assetId) {
		if (this._app.i18n.locale !== locale) return;
		this._onSetLocale(locale);
	};
	LocalizedAsset.prototype._onLocaleRemove = function (locale, assetId) {
		if (this._app.i18n.locale !== locale) return;
		this._onSetLocale(locale);
	};
	LocalizedAsset.prototype._onSetLocale = function (locale) {
		if (!this._defaultAsset) {
			this.localizedAsset = null;
			return;
		}
		var asset = this._app.assets.get(this._defaultAsset);
		if (!asset || this._disableLocalization) {
			this.localizedAsset = this._defaultAsset;
			return;
		}
		var localizedAssetId = asset.getLocalizedAssetId(locale);
		if (!localizedAssetId) {
			this.localizedAsset = this._defaultAsset;
			return;
		}
		this.localizedAsset = localizedAssetId;
	};
	LocalizedAsset.prototype.destroy = function () {
		this.defaultAsset = null;
		this._app.i18n.off('set:locale', this._onSetLocale, this);
		this.off();
	};
	Object.defineProperty(LocalizedAsset.prototype, 'defaultAsset', {
		get: function () {
			return this._defaultAsset;
		},
		set: function (value) {
			var id = value instanceof Asset ? value.id : value;
			if (this._defaultAsset === id) return;
			if (this._defaultAsset) {
				this._unbindDefaultAsset();
			}
			this._defaultAsset = id;
			if (this._defaultAsset) {
				this._bindDefaultAsset();
			}
			this._onSetLocale(this._app.i18n.locale);
		}
	});
	Object.defineProperty(LocalizedAsset.prototype, 'localizedAsset', {
		get: function () {
			return this._localizedAsset;
		},
		set: function (value) {
			var id = value instanceof Asset ? value.id : value;
			if (this._localizedAsset === id) {
				return;
			}
			if (this._localizedAsset) {
				this._app.assets.off('add:' + this._localizedAsset, this._onLocalizedAssetAdd, this);
				this._unbindLocalizedAsset();
				this._localizedAsset = null;
			}
			this._localizedAsset = id;
			if (this._localizedAsset) {
				var asset = this._app.assets.get(this._localizedAsset);
				if (!asset) {
					this._app.assets.once('add:' + this._localizedAsset, this._onLocalizedAssetAdd, this);
				} else {
					this._bindLocalizedAsset();
				}
			}
		}
	});
	Object.defineProperty(LocalizedAsset.prototype, 'autoLoad', {
		get: function () {
			return this._autoLoad;
		},
		set: function (value) {
			if (this._autoLoad === value) return;
			this._autoLoad = value;
			if (this._autoLoad && this._localizedAsset) {
				this._unbindLocalizedAsset();
				this._bindLocalizedAsset();
			}
		}
	});
	Object.defineProperty(LocalizedAsset.prototype, 'disableLocalization', {
		get: function () {
			return this._disableLocalization;
		},
		set: function (value) {
			if (this._disableLocalization === value) return;
			this._disableLocalization = value;
			this._onSetLocale(this._app.i18n.locale);
		}
	});

	function Scanner(symbols) {
		this._symbols = symbols;
		this._index = 0;
		this._last = 0;
		this._cur = (this._symbols.length > 0) ? this._symbols[0] : null;
		this._buf = [];
		this._mode = "text";
		this._error = null;
	}
	Object.assign(Scanner.prototype, {
		EOF_TOKEN: 0,
		ERROR_TOKEN: 1,
		TEXT_TOKEN: 2,
		OPEN_BRACKET_TOKEN: 3,
		CLOSE_BRACKET_TOKEN: 4,
		EQUALS_TOKEN: 5,
		STRING_TOKEN: 6,
		IDENTIFIER_TOKEN: 7,
		WHITESPACE_TOKEN: 8,
		WHITESPACE_CHARS: " \t\n\r\v\f",
		IDENTIFIER_REGEX: /[A-Z|a-z|0-9|_|-|/]/,
		read: function () {
			var token = this._read();
			while (token === this.WHITESPACE_TOKEN) {
				token = this._read();
			}
			if (token !== this.EOF_TOKEN && token !== this.ERROR_TOKEN) {
				this._last = this._index;
			}
			return token;
		},
		buf: function () {
			return this._buf;
		},
		last: function () {
			return this._last;
		},
		error: function () {
			return this._error;
		},
		debugPrint: function () {
			var tokenStrings = ["EOF", "ERROR", "TEXT", "OPEN_BRACKET", "CLOSE_BRACKET", "EQUALS", "STRING", "IDENTIFIER", "WHITESPACE"];
			var token = this.read();
			var result = "";
			while (true) {
				result += (result.length > 0 ? "\n" : "") +
							tokenStrings[token] +
							" '" + this.buf().join("") + "'";
				if (token === this.EOF_TOKEN || token === this.ERROR_TOKEN) {
					break;
				}
				token = this.read();
			}
			return result;
		},
		_read: function () {
			this._buf = [];
			if (this._eof()) {
				return this.EOF_TOKEN;
			}
			return (this._mode === "text") ? this._text() : this._tag();
		},
		_text: function () {
			while (true) {
				switch (this._cur) {
					case null:
						return (this._buf.length > 0) ? this.TEXT_TOKEN : this.EOF_TOKEN;
					case "[":
						this._mode = "tag";
						return (this._buf.length > 0) ? this.TEXT_TOKEN : this._tag();
					case "\\":
						this._next();
						switch (this._cur) {
							case "[":
								this._store();
								break;
							default:
								this._output("\\");
								break;
						}
						break;
					default:
						this._store();
						break;
				}
			}
		},
		_tag: function () {
			while (true) {
				switch (this._cur) {
					case null:
						this._error = "unexpected end of input reading tag";
						return this.ERROR_TOKEN;
					case "[":
						this._store();
						return this.OPEN_BRACKET_TOKEN;
					case "]":
						this._store();
						this._mode = "text";
						return this.CLOSE_BRACKET_TOKEN;
					case "=":
						this._store();
						return this.EQUALS_TOKEN;
					case " ":
					case "\t":
					case "\n":
					case "\r":
					case "\v":
					case "\f":
						return this._whitespace();
					case "\"":
						return this._string();
					default:
						if (!this._isIdentifierSymbol(this._cur)) {
							this._error = "unrecognized character";
							return this.ERROR_TOKEN;
						}
						return this._identifier();
				}
			}
		},
		_whitespace: function () {
			this._store();
			while (this.WHITESPACE_CHARS.indexOf(this._cur) !== -1) {
				this._store();
			}
			return this.WHITESPACE_TOKEN;
		},
		_string: function () {
			this._next();
			while (true) {
				switch (this._cur) {
					case null:
						this._error = "unexpected end of input reading string";
						return this.ERROR_TOKEN;
					case "\"":
						this._next();
						return this.STRING_TOKEN;
					default:
						this._store();
						break;
				}
			}
		},
		_identifier: function () {
			this._store();
			while (this._cur !== null &&
					this._isIdentifierSymbol(this._cur)) {
				this._store();
			}
			return this.IDENTIFIER_TOKEN;
		},
		_isIdentifierSymbol: function (s) {
			return s.length === 1 && (s.match(this.IDENTIFIER_REGEX) !== null);
		},
		_eof: function () {
			return this._cur === null;
		},
		_next: function () {
			if (!this._eof()) {
				this._index++;
				this._cur = (this._index < this._symbols.length) ? this._symbols[this._index] : null;
			}
			return this._cur;
		},
		_store: function () {
			this._buf.push(this._cur);
			return this._next();
		},
		_output: function (c) {
			this._buf.push(c);
		}
	});
	var Parser = function (symbols) {
		this._scanner = new Scanner(symbols);
		this._error = null;
	};
	Object.assign(Parser.prototype, {
		parse: function (symbols, tags) {
			while (true) {
				var token = this._scanner.read();
				switch (token) {
					case this._scanner.EOF_TOKEN:
						return true;
					case this._scanner.ERROR_TOKEN:
						return false;
					case this._scanner.TEXT_TOKEN:
						Array.prototype.push.apply(symbols, this._scanner.buf());
						break;
					case this._scanner.OPEN_BRACKET_TOKEN:
						if (!this._parseTag(symbols, tags)) {
							return false;
						}
						break;
					default:
						return false;
				}
			}
		},
		error: function () {
			return "Error evaluating markup at #" + this._scanner.last().toString() +
					" (" + (this._scanner.error() || this._error) + ")";
		},
		_parseTag: function (symbols, tags) {
			var token = this._scanner.read();
			if (token !== this._scanner.IDENTIFIER_TOKEN) {
				this._error = "expected identifier";
				return false;
			}
			var name = this._scanner.buf().join("");
			if (name[0] === "/") {
				for (var index = tags.length - 1; index >= 0; --index) {
					if (name === "/" + tags[index].name && tags[index].end === null) {
						tags[index].end = symbols.length;
						token = this._scanner.read();
						if (token !== this._scanner.CLOSE_BRACKET_TOKEN) {
							this._error = "expected close bracket";
							return false;
						}
						return true;
					}
				}
				this._error = "failed to find matching tag";
				return false;
			}
			var tag = {
				name: name,
				value: null,
				attributes: { },
				start: symbols.length,
				end: null
			};
			token = this._scanner.read();
			if (token === this._scanner.EQUALS_TOKEN) {
				token = this._scanner.read();
				if (token !== this._scanner.STRING_TOKEN) {
					this._error = "expected string";
					return false;
				}
				tag.value = this._scanner.buf().join("");
				token = this._scanner.read();
			}
			while (true) {
				switch (token) {
					case this._scanner.CLOSE_BRACKET_TOKEN:
						tags.push(tag);
						return true;
					case this._scanner.IDENTIFIER_TOKEN:
						var identifier = this._scanner.buf().join("");
						token = this._scanner.read();
						if (token !== this._scanner.EQUALS_TOKEN) {
							this._error = "expected equals";
							return false;
						}
						token = this._scanner.read();
						if (token !== this._scanner.STRING_TOKEN) {
							this._error = "expected string";
							return false;
						}
						var value = this._scanner.buf().join("");
						tag.attributes[identifier] = value;
						break;
					default:
						this._error = "expected close bracket or identifier";
						return false;
				}
				token = this._scanner.read();
			}
		}
	});
	function merge(target, source) {
		for (var key in source) {
			if (!source.hasOwnProperty(key)) {
				continue;
			}
			var value = source[key];
			if (value instanceof Object) {
				if (!target.hasOwnProperty(key)) {
					target[key] = { };
				}
				merge(target[key], source[key]);
			} else {
				target[key] = value;
			}
		}
	}
	function combineTags(tags) {
		if (tags.length === 0) {
			return null;
		}
		var result = { };
		for (var index = 0; index < tags.length; ++index) {
			var tag = tags[index];
			var tmp = { };
			tmp[tag.name] = { value: tag.value, attributes: tag.attributes };
			merge(result, tmp);
		}
		return result;
	}
	function resolveMarkupTags(tags, numSymbols) {
		var index;
		if (tags.length === 0) {
			return null;
		}
		var edges = { };
		for (index = 0; index < tags.length; ++index) {
			var tag = tags[index];
			if (!edges.hasOwnProperty(tag.start)) {
				edges[tag.start] = { open: [tag], close: null };
			} else {
				if (edges[tag.start].open === null) {
					edges[tag.start].open = [tag];
				} else {
					edges[tag.start].open.push(tag);
				}
			}
			if (!edges.hasOwnProperty(tag.end)) {
				edges[tag.end] = { open: null, close: [tag] };
			} else {
				if (edges[tag.end].close === null) {
					edges[tag.end].close = [tag];
				} else {
					edges[tag.end].close.push(tag);
				}
			}
		}
		var tagStack = [];
		function removeTags(tags) {
			tagStack = tagStack.filter( function (tag) {
				return tags.find(function (t) {
					return t === tag;
				}) === undefined;
			});
		}
		function addTags(tags) {
			for (var index = 0; index < tags.length; ++index) {
				tagStack.push(tags[index]);
			}
		}
		var edgeKeys = Object.keys(edges).sort( function (a, b) {
			return a - b;
		});
		var resolvedTags = [];
		for (index = 0; index < edgeKeys.length; ++index) {
			var edge = edges[edgeKeys[index]];
			if (edge.close !== null) {
				removeTags(edge.close);
			}
			if (edge.open !== null) {
				addTags(edge.open);
			}
			resolvedTags.push( {
				start: edgeKeys[index],
				tags: combineTags(tagStack)
			} );
		}
		var result = [];
		var prevTag = null;
		for (index = 0; index < resolvedTags.length; ++index) {
			var resolvedTag = resolvedTags[index];
			while (result.length < resolvedTag.start) {
				result.push(prevTag ? prevTag.tags : null);
			}
			prevTag = resolvedTag;
		}
		while (result.length < numSymbols) {
			result.push(null);
		}
		return result;
	}
	function evaluateMarkup(symbols) {
		var parser = new Parser(symbols);
		var stripped_symbols = [];
		var tags = [];
		if (!parser.parse(stripped_symbols, tags)) {
			console.warn(parser.error());
			return {
				symbols: symbols,
				tags: null
			};
		}
		var invalidTag = tags.find(function (t) {
			return t.end === null;
		});
		if (invalidTag) {
			console.warn("Markup error: found unclosed tag='" + invalidTag.name + "'");
			return {
				symbols: symbols,
				tags: null
			};
		}
		var resolved_tags = resolveMarkupTags(tags, stripped_symbols.length);
		return {
			symbols: stripped_symbols,
			tags: resolved_tags
		};
	}
	function Markup() {}
	Markup.evaluate = function (symbols) {
		return evaluateMarkup(symbols);
	};

	function MeshInfo() {
		this.count = 0;
		this.quad = 0;
		this.lines = {};
		this.positions = [];
		this.normals = [];
		this.uvs = [];
		this.colors = [];
		this.indices = [];
		this.meshInstance = null;
	}
	function TextElement(element) {
		this._element = element;
		this._system = element.system;
		this._entity = element.entity;
		this._text = "";
		this._symbols = [];
		this._colorPalette = [];
		this._symbolColors = null;
		this._i18nKey = null;
		this._fontAsset = new LocalizedAsset(this._system.app);
		this._fontAsset.disableLocalization = true;
		this._fontAsset.on('load', this._onFontLoad, this);
		this._fontAsset.on('change', this._onFontChange, this);
		this._fontAsset.on('remove', this._onFontRemove, this);
		this._font = null;
		this._color = new Color(1, 1, 1, 1);
		this._colorUniform = new Float32Array(3);
		this._spacing = 1;
		this._fontSize = 32;
		this._fontMinY = 0;
		this._fontMaxY = 0;
		this._originalFontSize = 32;
		this._maxFontSize = 32;
		this._minFontSize = 8;
		this._autoFitWidth = false;
		this._autoFitHeight = false;
		this._maxLines = -1;
		this._lineHeight = 32;
		this._scaledLineHeight = 32;
		this._wrapLines = false;
		this._drawOrder = 0;
		this._alignment = new Vec2(0.5, 0.5);
		this._autoWidth = true;
		this._autoHeight = true;
		this.width = 0;
		this.height = 0;
		this._node = new GraphNode();
		this._model = new Model();
		this._model.graph = this._node;
		this._entity.addChild(this._node);
		this._meshInfo = [];
		this._material = null;
		this._aabbDirty = true;
		this._aabb = new BoundingBox();
		this._noResize = false;
		this._currentMaterialType = null;
		this._maskedMaterialSrc = null;
		this._rtlReorder = false;
		this._unicodeConverter = false;
		this._rtl = false;
		this._outlineColor = new Color(0, 0, 0, 1);
		this._outlineColorUniform = new Float32Array(4);
		this._outlineThicknessScale = 0.2;
		this._outlineThickness = 0.0;
		this._shadowColor = new Color(0, 0, 0, 1);
		this._shadowColorUniform = new Float32Array(4);
		this._shadowOffsetScale = 0.005;
		this._shadowOffset = new Vec2(0, 0);
		this._shadowOffsetUniform = new Float32Array(2);
		this._enableMarkup = false;
		this._onScreenChange(this._element.screen);
		element.on('resize', this._onParentResize, this);
		element.on('set:screen', this._onScreenChange, this);
		element.on('screen:set:screenspace', this._onScreenSpaceChange, this);
		element.on('set:draworder', this._onDrawOrderChange, this);
		element.on('set:pivot', this._onPivotChange, this);
		this._system.app.i18n.on('set:locale', this._onLocaleSet, this);
		this._system.app.i18n.on('data:add', this._onLocalizationData, this);
		this._system.app.i18n.on('data:remove', this._onLocalizationData, this);
		this._rangeStart = 0;
		this._rangeEnd = 0;
	}
	var LINE_BREAK_CHAR = /^[\r\n]$/;
	var WHITESPACE_CHAR = /^[ \t]$/;
	var WORD_BOUNDARY_CHAR = /^[ \t\-]$/;
	Object.assign(TextElement.prototype, {
		destroy: function () {
			this._setMaterial(null);
			if (this._model) {
				this._element.removeModelFromLayers(this._model);
				this._model.destroy();
				this._model = null;
			}
			this._fontAsset.destroy();
			this.font = null;
			this._element.off('resize', this._onParentResize, this);
			this._element.off('set:screen', this._onScreenChange, this);
			this._element.off('screen:set:screenspace', this._onScreenSpaceChange, this);
			this._element.off('set:draworder', this._onDrawOrderChange, this);
			this._element.off('set:pivot', this._onPivotChange, this);
			this._system.app.i18n.off('set:locale', this._onLocaleSet, this);
			this._system.app.i18n.off('data:add', this._onLocalizationData, this);
			this._system.app.i18n.off('data:remove', this._onLocalizationData, this);
		},
		_onParentResize: function (width, height) {
			if (this._noResize) return;
			if (this._font) this._updateText();
		},
		_onScreenChange: function (screen) {
			if (screen) {
				this._updateMaterial(screen.screen.screenSpace);
			} else {
				this._updateMaterial(false);
			}
		},
		_onScreenSpaceChange: function (value) {
			this._updateMaterial(value);
		},
		_onDrawOrderChange: function (order) {
			this._drawOrder = order;
			if (this._model) {
				var i;
				var len;
				for (i = 0, len = this._model.meshInstances.length; i < len; i++) {
					this._model.meshInstances[i].drawOrder = order;
				}
			}
		},
		_onPivotChange: function (pivot) {
			if (this._font)
				this._updateText();
		},
		_onLocaleSet: function (locale) {
			if (!this._i18nKey) return;
			if (this.fontAsset) {
				var asset = this._system.app.assets.get(this.fontAsset);
				if (!asset || !asset.resource || asset.resource !== this._font) {
					this.font = null;
				}
			}
			this._resetLocalizedText();
		},
		_onLocalizationData: function (locale, messages) {
			if (this._i18nKey && messages[this._i18nKey]) {
				this._resetLocalizedText();
			}
		},
		_resetLocalizedText: function () {
			this._setText(this._system.app.i18n.getText(this._i18nKey));
		},
		_setText: function (text) {
			if (this.unicodeConverter) {
				var unicodeConverterFunc = this._system.getUnicodeConverter();
				if (unicodeConverterFunc) {
					text = unicodeConverterFunc(text);
				} else {
					console.warn('Element created with unicodeConverter option but no unicodeConverter function registered');
				}
			}
			if (this._text !== text) {
				if (this._font) {
					this._updateText(text);
				}
				this._text = text;
			}
		},
		_updateText: function (text) {
			var i;
			var len;
			var results;
			var tags;
			if (text === undefined) text = this._text;
			this._symbols = string.getSymbols(text);
			if (this._symbols.length === 0) {
				this._symbols = [" "];
			}
			if (this._enableMarkup) {
				results = Markup.evaluate(this._symbols);
				this._symbols = results.symbols;
				tags = results.tags;
			}
			if (this._rtlReorder) {
				var rtlReorderFunc = this._system.app.systems.element.getRtlReorder();
				if (rtlReorderFunc) {
					results = rtlReorderFunc(this._symbols);
					this._rtl = results.rtl;
					this._symbols = results.mapping.map(function (v) {
						return this._symbols[v];
					}, this);
					if (tags) {
						tags = results.mapping.map(function (v) {
							return tags[v];
						});
					}
				} else {
					console.warn('Element created with rtlReorder option but no rtlReorder function registered');
				}
			} else {
				this._rtl = false;
			}
			if (tags) {
				var paletteMap = { };
				this._colorPalette = [
					Math.round(this._color.r * 255),
					Math.round(this._color.g * 255),
					Math.round(this._color.b * 255)
				];
				this._symbolColors = [];
				paletteMap[this._color.toString(false).toLowerCase()] = 0;
				for (i = 0, len = this._symbols.length; i < len; ++i) {
					var tag = tags[i];
					var color = 0;
					if (tag && tag.color && tag.color.value) {
						var c = tag.color.value;
						if (c.length === 7 && c[0] === "#") {
							var hex = c.substring(1).toLowerCase();
							if (paletteMap.hasOwnProperty(hex)) {
								color = paletteMap[hex];
							} else {
								if (/^([0-9a-f]{2}){3}$/.test(hex)) {
									color = this._colorPalette.length / 3;
									paletteMap[hex] = color;
									this._colorPalette.push(parseInt(hex.substring(0, 2), 16));
									this._colorPalette.push(parseInt(hex.substring(2, 4), 16));
									this._colorPalette.push(parseInt(hex.substring(4, 6), 16));
								}
							}
						}
					}
					this._symbolColors.push(color);
				}
			} else {
				this._colorPalette = [];
				this._symbolColors = null;
			}
			var charactersPerTexture = this._calculateCharsPerTexture();
			var removedModel = false;
			var element = this._element;
			var screenSpace = element._isScreenSpace();
			var screenCulled = element._isScreenCulled();
			var visibleFn = function (camera) {
				return element.isVisibleForCamera(camera);
			};
			for (i = 0, len = this._meshInfo.length; i < len; i++) {
				var l = charactersPerTexture[i] || 0;
				var meshInfo = this._meshInfo[i];
				if (meshInfo.count !== l) {
					if (!removedModel) {
						element.removeModelFromLayers(this._model);
						removedModel = true;
					}
					meshInfo.count = l;
					meshInfo.positions.length = meshInfo.normals.length = l * 3 * 4;
					meshInfo.indices.length = l * 3 * 2;
					meshInfo.uvs.length = l * 2 * 4;
					meshInfo.colors.length = l * 4 * 4;
					if (meshInfo.meshInstance) {
						this._removeMeshInstance(meshInfo.meshInstance);
					}
					if (l === 0) {
						meshInfo.meshInstance = null;
						continue;
					}
					for (var v = 0; v < l; v++) {
						meshInfo.indices[v * 3 * 2 + 0] = v * 4;
						meshInfo.indices[v * 3 * 2 + 1] = v * 4 + 1;
						meshInfo.indices[v * 3 * 2 + 2] = v * 4 + 3;
						meshInfo.indices[v * 3 * 2 + 3] = v * 4 + 2;
						meshInfo.indices[v * 3 * 2 + 4] = v * 4 + 3;
						meshInfo.indices[v * 3 * 2 + 5] = v * 4 + 1;
						meshInfo.normals[v * 4 * 3 + 0] = 0;
						meshInfo.normals[v * 4 * 3 + 1] = 0;
						meshInfo.normals[v * 4 * 3 + 2] = -1;
						meshInfo.normals[v * 4 * 3 + 3] = 0;
						meshInfo.normals[v * 4 * 3 + 4] = 0;
						meshInfo.normals[v * 4 * 3 + 5] = -1;
						meshInfo.normals[v * 4 * 3 + 6] = 0;
						meshInfo.normals[v * 4 * 3 + 7] = 0;
						meshInfo.normals[v * 4 * 3 + 8] = -1;
						meshInfo.normals[v * 4 * 3 + 9] = 0;
						meshInfo.normals[v * 4 * 3 + 10] = 0;
						meshInfo.normals[v * 4 * 3 + 11] = -1;
					}
					var mesh = createMesh(this._system.app.graphicsDevice,
										  meshInfo.positions,
										  {
											  uvs: meshInfo.uvs,
											  normals: meshInfo.normals,
											  colors: meshInfo.colors,
											  indices: meshInfo.indices
										  });
					var mi = new MeshInstance(this._node, mesh, this._material);
					mi.name = "Text Element: " + this._entity.name;
					mi.castShadow = false;
					mi.receiveShadow = false;
					mi.cull = !screenSpace;
					mi.screenSpace = screenSpace;
					mi.drawOrder = this._drawOrder;
					if (screenCulled) {
						mi.cull = true;
						mi.isVisibleFunc = visibleFn;
					}
					this._setTextureParams(mi, this._font.textures[i]);
					if (this._symbolColors) {
						this._colorUniform[0] = 1;
						this._colorUniform[1] = 1;
						this._colorUniform[2] = 1;
					} else {
						this._colorUniform[0] = this._color.r;
						this._colorUniform[1] = this._color.g;
						this._colorUniform[2] = this._color.b;
					}
					mi.setParameter("material_emissive", this._colorUniform);
					mi.setParameter("material_opacity", this._color.a);
					mi.setParameter("font_sdfIntensity", this._font.intensity);
					mi.setParameter("font_pxrange", this._getPxRange(this._font));
					mi.setParameter("font_textureWidth", this._font.data.info.maps[i].width);
					this._outlineColorUniform[0] = this._outlineColor.r;
					this._outlineColorUniform[1] = this._outlineColor.g;
					this._outlineColorUniform[2] = this._outlineColor.b;
					this._outlineColorUniform[3] = this._outlineColor.a;
					mi.setParameter("outline_color", this._outlineColorUniform);
					mi.setParameter("outline_thickness", this._outlineThicknessScale * this._outlineThickness);
					this._shadowColorUniform[0] = this._shadowColor.r;
					this._shadowColorUniform[1] = this._shadowColor.g;
					this._shadowColorUniform[2] = this._shadowColor.b;
					this._shadowColorUniform[3] = this._shadowColor.a;
					mi.setParameter("shadow_color", this._shadowColorUniform);
					var ratio = this._font.data.info.maps[i].width / this._font.data.info.maps[i].height;
					this._shadowOffsetUniform[0] = this._shadowOffsetScale * this._shadowOffset.x;
					this._shadowOffsetUniform[1] = ratio * this._shadowOffsetScale * this._shadowOffset.y;
					mi.setParameter("shadow_offset", this._shadowOffsetUniform);
					meshInfo.meshInstance = mi;
					this._model.meshInstances.push(mi);
				}
			}
			if (this._element.maskedBy) {
				this._element._setMaskedBy(this._element.maskedBy);
			}
			if (removedModel && this._element.enabled && this._entity.enabled) {
				this._element.addModelToLayers(this._model);
			}
			this._updateMeshes();
			this._rangeStart = 0;
			this._rangeEnd = this._symbols.length;
			this._updateRenderRange();
		},
		_removeMeshInstance: function (meshInstance) {
			meshInstance.material = null;
			var oldMesh = meshInstance.mesh;
			if (oldMesh) {
				oldMesh.destroy();
			}
			var idx = this._model.meshInstances.indexOf(meshInstance);
			if (idx !== -1)
				this._model.meshInstances.splice(idx, 1);
		},
		_setMaterial: function (material) {
			var i;
			var len;
			this._material = material;
			if (this._model) {
				for (i = 0, len = this._model.meshInstances.length; i < len; i++) {
					var mi = this._model.meshInstances[i];
					mi.material = material;
				}
			}
		},
		_updateMaterial: function (screenSpace) {
			var element = this._element;
			var screenCulled = element._isScreenCulled();
			var visibleFn = function (camera) {
				return element.isVisibleForCamera(camera);
			};
			var msdf = this._font && this._font.type === FONT_MSDF;
			this._material = this._system.getTextElementMaterial(screenSpace, msdf);
			if (this._model) {
				for (var i = 0, len = this._model.meshInstances.length; i < len; i++) {
					var mi = this._model.meshInstances[i];
					mi.cull = !screenSpace;
					mi.material = this._material;
					mi.screenSpace = screenSpace;
					if (screenCulled) {
						mi.cull = true;
						mi.isVisibleFunc = visibleFn;
					} else {
						mi.isVisibleFunc = null;
					}
				}
			}
		},
		_updateMeshes: function () {
			var json = this._font.data;
			var self = this;
			var minFont = Math.min(this._minFontSize, this._maxFontSize);
			var maxFont = this._maxFontSize;
			var autoFit = this._shouldAutoFit();
			if (autoFit) {
				this._fontSize = this._maxFontSize;
			}
			var MAGIC = 32;
			var l = this._symbols.length;
			var _x = 0;
			var _y = 0;
			var _z = 0;
			var _xMinusTrailingWhitespace = 0;
			var lines = 1;
			var wordStartX = 0;
			var wordStartIndex = 0;
			var lineStartIndex = 0;
			var numWordsThisLine = 0;
			var numCharsThisLine = 0;
			var numBreaksThisLine = 0;
			var splitHorizontalAnchors = Math.abs(this._element.anchor.x - this._element.anchor.z) >= 0.0001;
			var maxLineWidth = this._element.calculatedWidth;
			if ((this.autoWidth && !splitHorizontalAnchors) || !this._wrapLines) {
				maxLineWidth = Number.POSITIVE_INFINITY;
			}
			var fontMinY = 0;
			var fontMaxY = 0;
			var scale = 1;
			var char, data, i, j, quad;
			function breakLine(symbols, lineBreakIndex, lineBreakX) {
				self._lineWidths.push(Math.abs(lineBreakX));
				var sliceStart = lineStartIndex > lineBreakIndex ? lineBreakIndex + 1 : lineStartIndex;
				var sliceEnd = lineStartIndex > lineBreakIndex ? lineStartIndex + 1 : lineBreakIndex;
				var chars = symbols.slice(sliceStart, sliceEnd);
				if (numBreaksThisLine) {
					var i = chars.length;
					while (i-- && numBreaksThisLine > 0)  {
						if (LINE_BREAK_CHAR.test(chars[i])) {
							chars.splice(i, 1);
							numBreaksThisLine--;
						}
					}
				}
				self._lineContents.push(chars.join(''));
				_x = 0;
				_y -= self._scaledLineHeight;
				lines++;
				numWordsThisLine = 0;
				numCharsThisLine = 0;
				numBreaksThisLine = 0;
				wordStartX = 0;
				lineStartIndex = lineBreakIndex;
			}
			var retryUpdateMeshes = true;
			while (retryUpdateMeshes) {
				retryUpdateMeshes = false;
				if (autoFit) {
					this._scaledLineHeight = this._lineHeight * this._fontSize / (this._maxFontSize || 0.0001);
				} else {
					this._scaledLineHeight = this._lineHeight;
				}
				this.width = 0;
				this.height = 0;
				this._lineWidths = [];
				this._lineContents = [];
				_x = 0;
				_y = 0;
				_z = 0;
				_xMinusTrailingWhitespace = 0;
				lines = 1;
				wordStartX = 0;
				wordStartIndex = 0;
				lineStartIndex = 0;
				numWordsThisLine = 0;
				numCharsThisLine = 0;
				numBreaksThisLine = 0;
				scale = this._fontSize / MAGIC;
				fontMinY = this._fontMinY * scale;
				fontMaxY = this._fontMaxY * scale;
				for (i = 0; i < this._meshInfo.length; i++) {
					this._meshInfo[i].quad = 0;
					this._meshInfo[i].lines = {};
				}
				var color_r = 255;
				var color_g = 255;
				var color_b = 255;
				for (i = 0; i < l; i++) {
					char = this._symbols[i];
					var x = 0;
					var y = 0;
					var advance = 0;
					var quadsize = 1;
					var dataScale, size;
					data = json.chars[char];
					if (!data) {
						if (json.chars[' ']) {
							data = json.chars[' '];
						} else {
							for (var key in json.chars) {
								data = json.chars[key];
								break;
							}
						}
					}
					if (data) {
						var kerning = 0;
						if (numCharsThisLine > 0) {
							var kernTable = this._font.data.kerning;
							if (kernTable) {
								var kernLeft = kernTable[string.getCodePoint(this._symbols[i - 1]) || 0];
								if (kernLeft) {
									kerning = kernLeft[string.getCodePoint(this._symbols[i]) || 0] || 0;
								}
							}
						}
						dataScale = data.scale || 1;
						size = (data.width + data.height) / 2;
						quadsize = scale * size / dataScale;
						advance = (data.xadvance + kerning) * scale;
						x = (data.xoffset - kerning) * scale;
						y = data.yoffset * scale;
					} else {
						console.error("Couldn't substitute missing character: '" + char + "'");
					}
					var isLineBreak = LINE_BREAK_CHAR.test(char);
					if (isLineBreak) {
						numBreaksThisLine++;
						if (this._maxLines < 0 || lines < this._maxLines) {
							breakLine(this._symbols, i, _xMinusTrailingWhitespace);
							wordStartIndex = i + 1;
							lineStartIndex = i + 1;
						}
						continue;
					}
					var isWhitespace = WHITESPACE_CHAR.test(char);
					var meshInfo = this._meshInfo[(data && data.map) || 0];
					var candidateLineWidth = _x + this._spacing * advance;
					if (candidateLineWidth > maxLineWidth && numCharsThisLine > 0 && !isWhitespace) {
						if (this._maxLines < 0 || lines < this._maxLines) {
							if (numWordsThisLine === 0) {
								wordStartIndex = i;
								breakLine(this._symbols, i, _xMinusTrailingWhitespace);
							} else {
								var backtrack = Math.max(i - wordStartIndex, 0);
								if (this._meshInfo.length <= 1) {
									meshInfo.lines[lines - 1] -= backtrack;
									meshInfo.quad -= backtrack;
								} else {
									var backtrackStart = wordStartIndex;
									var backtrackEnd = i;
									for (j = backtrackStart; j < backtrackEnd; j++) {
										var backChar = this._symbols[j];
										var backCharData = json.chars[backChar];
										var backMeshInfo = this._meshInfo[(backCharData && backCharData.map) || 0];
										backMeshInfo.lines[lines - 1] -= 1;
										backMeshInfo.quad -= 1;
									}
								}
								i -= backtrack + 1;
								breakLine(this._symbols, wordStartIndex, wordStartX);
								continue;
							}
						}
					}
					quad = meshInfo.quad;
					meshInfo.lines[lines - 1] = quad;
					var left = _x - x;
					var right = left + quadsize;
					var bottom = _y - y;
					var top = bottom + quadsize;
					if (this._rtl) {
						var shift = quadsize - x - this._spacing * advance - x;
						left -= shift;
						right -= shift;
					}
					meshInfo.positions[quad * 4 * 3 + 0] = left;
					meshInfo.positions[quad * 4 * 3 + 1] = bottom;
					meshInfo.positions[quad * 4 * 3 + 2] = _z;
					meshInfo.positions[quad * 4 * 3 + 3] = right;
					meshInfo.positions[quad * 4 * 3 + 4] = bottom;
					meshInfo.positions[quad * 4 * 3 + 5] = _z;
					meshInfo.positions[quad * 4 * 3 + 6] = right;
					meshInfo.positions[quad * 4 * 3 + 7] = top;
					meshInfo.positions[quad * 4 * 3 + 8] = _z;
					meshInfo.positions[quad * 4 * 3 + 9]  = left;
					meshInfo.positions[quad * 4 * 3 + 10] = top;
					meshInfo.positions[quad * 4 * 3 + 11] = _z;
					this.width = Math.max(this.width, candidateLineWidth);
					var fontSize;
					if (this._shouldAutoFitWidth() && this.width > this._element.calculatedWidth) {
						fontSize = Math.floor(this._element.fontSize * this._element.calculatedWidth / (this.width || 0.0001));
						fontSize = math.clamp(fontSize, minFont, maxFont);
						if (fontSize !== this._element.fontSize) {
							this._fontSize = fontSize;
							retryUpdateMeshes = true;
							break;
						}
					}
					this.height = Math.max(this.height, fontMaxY - (_y + fontMinY));
					if (this._shouldAutoFitHeight() && this.height > this._element.calculatedHeight) {
						fontSize = math.clamp(this._fontSize - 1, minFont, maxFont);
						if (fontSize !== this._element.fontSize) {
							this._fontSize = fontSize;
							retryUpdateMeshes = true;
							break;
						}
					}
					_x += this._spacing * advance;
					if (!isWhitespace && !isLineBreak) {
						_xMinusTrailingWhitespace = _x;
					}
					var isWordBoundary = WORD_BOUNDARY_CHAR.test(char);
					if (isWordBoundary) {
						numWordsThisLine++;
						wordStartX = _xMinusTrailingWhitespace;
						wordStartIndex = i + 1;
					}
					numCharsThisLine++;
					var uv = this._getUv(char);
					meshInfo.uvs[quad * 4 * 2 + 0] = uv[0];
					meshInfo.uvs[quad * 4 * 2 + 1] = uv[1];
					meshInfo.uvs[quad * 4 * 2 + 2] = uv[2];
					meshInfo.uvs[quad * 4 * 2 + 3] = uv[1];
					meshInfo.uvs[quad * 4 * 2 + 4] = uv[2];
					meshInfo.uvs[quad * 4 * 2 + 5] = uv[3];
					meshInfo.uvs[quad * 4 * 2 + 6] = uv[0];
					meshInfo.uvs[quad * 4 * 2 + 7] = uv[3];
					if (this._symbolColors) {
						var colorIdx = this._symbolColors[i] * 3;
						color_r = this._colorPalette[colorIdx];
						color_g = this._colorPalette[colorIdx + 1];
						color_b = this._colorPalette[colorIdx + 2];
					}
					meshInfo.colors[quad * 4 * 4 + 0] = color_r;
					meshInfo.colors[quad * 4 * 4 + 1] = color_g;
					meshInfo.colors[quad * 4 * 4 + 2] = color_b;
					meshInfo.colors[quad * 4 * 4 + 3] = 255;
					meshInfo.colors[quad * 4 * 4 + 4] = color_r;
					meshInfo.colors[quad * 4 * 4 + 5] = color_g;
					meshInfo.colors[quad * 4 * 4 + 6] = color_b;
					meshInfo.colors[quad * 4 * 4 + 7] = 255;
					meshInfo.colors[quad * 4 * 4 + 8] = color_r;
					meshInfo.colors[quad * 4 * 4 + 9] = color_g;
					meshInfo.colors[quad * 4 * 4 + 10] = color_b;
					meshInfo.colors[quad * 4 * 4 + 11] = 255;
					meshInfo.colors[quad * 4 * 4 + 12] = color_r;
					meshInfo.colors[quad * 4 * 4 + 13] = color_g;
					meshInfo.colors[quad * 4 * 4 + 14] = color_b;
					meshInfo.colors[quad * 4 * 4 + 15] = 255;
					meshInfo.quad++;
				}
				if (retryUpdateMeshes) {
					continue;
				}
				if (lineStartIndex < l) {
					breakLine(this._symbols, l, _x);
				}
			}
			this._noResize = true;
			this.autoWidth = this._autoWidth;
			this.autoHeight = this._autoHeight;
			this._noResize = false;
			var hp = this._element.pivot.x;
			var vp = this._element.pivot.y;
			var ha = this._alignment.x;
			var va = this._alignment.y;
			for (i = 0; i < this._meshInfo.length; i++) {
				if (this._meshInfo[i].count === 0) continue;
				var prevQuad = 0;
				for (var line in this._meshInfo[i].lines) {
					var index = this._meshInfo[i].lines[line];
					var lw = this._lineWidths[parseInt(line, 10)];
					var hoffset = -hp * this._element.calculatedWidth + ha * (this._element.calculatedWidth - lw) * (this._rtl ? -1 : 1);
					var voffset = (1 - vp) * this._element.calculatedHeight - fontMaxY - (1 - va) * (this._element.calculatedHeight - this.height);
					for (quad = prevQuad; quad <= index; quad++) {
						this._meshInfo[i].positions[quad * 4 * 3] += hoffset;
						this._meshInfo[i].positions[quad * 4 * 3 + 3] += hoffset;
						this._meshInfo[i].positions[quad * 4 * 3 + 6] += hoffset;
						this._meshInfo[i].positions[quad * 4 * 3 + 9] += hoffset;
						this._meshInfo[i].positions[quad * 4 * 3 + 1] += voffset;
						this._meshInfo[i].positions[quad * 4 * 3 + 4] += voffset;
						this._meshInfo[i].positions[quad * 4 * 3 + 7] += voffset;
						this._meshInfo[i].positions[quad * 4 * 3 + 10] += voffset;
					}
					if (this._rtl) {
						for (quad = prevQuad; quad <= index; quad++) {
							var idx = quad * 4 * 3;
							for (var vert = 0; vert < 4; ++vert) {
								this._meshInfo[i].positions[idx + vert * 3] =
									this._element.calculatedWidth - this._meshInfo[i].positions[idx + vert * 3] + hoffset * 2;
							}
							var tmp0 = this._meshInfo[i].positions[idx + 3];
							var tmp1 = this._meshInfo[i].positions[idx + 6];
							this._meshInfo[i].positions[idx + 3] = this._meshInfo[i].positions[idx + 0];
							this._meshInfo[i].positions[idx + 6] = this._meshInfo[i].positions[idx + 9];
							this._meshInfo[i].positions[idx + 0] = tmp0;
							this._meshInfo[i].positions[idx + 9] = tmp1;
						}
					}
					prevQuad = index + 1;
				}
				var numVertices = this._meshInfo[i].count * 4;
				var vertMax = this._meshInfo[i].quad * 4;
				var it = new VertexIterator(this._meshInfo[i].meshInstance.mesh.vertexBuffer);
				for (var v = 0; v < numVertices; v++) {
					if (v >= vertMax) {
						it.element[SEMANTIC_POSITION].set(0, 0, 0);
						it.element[SEMANTIC_TEXCOORD0].set(0, 0);
						it.element[SEMANTIC_COLOR].set(0, 0, 0, 0);
					} else {
						it.element[SEMANTIC_POSITION].set(this._meshInfo[i].positions[v * 3 + 0], this._meshInfo[i].positions[v * 3 + 1], this._meshInfo[i].positions[v * 3 + 2]);
						it.element[SEMANTIC_TEXCOORD0].set(this._meshInfo[i].uvs[v * 2 + 0], this._meshInfo[i].uvs[v * 2 + 1]);
						it.element[SEMANTIC_COLOR].set(this._meshInfo[i].colors[v * 4 + 0],
													   this._meshInfo[i].colors[v * 4 + 1],
													   this._meshInfo[i].colors[v * 4 + 2],
													   this._meshInfo[i].colors[v * 4 + 3]);
					}
					it.next();
				}
				it.end();
				this._meshInfo[i].meshInstance.mesh.aabb.compute(this._meshInfo[i].positions);
				this._meshInfo[i].meshInstance._aabbVer = -1;
			}
			this._aabbDirty = true;
		},
		_onFontRender: function () {
			this.font = this._font;
		},
		_onFontLoad: function (asset) {
			if (this.font !== asset.resource) {
				this.font = asset.resource;
			}
		},
		_onFontChange: function (asset, name, _new, _old) {
			if (name === 'data') {
				this._font.data = _new;
				var maps = this._font.data.info.maps.length;
				for (var i = 0; i < maps; i++) {
					if (!this._meshInfo[i]) continue;
					var mi = this._meshInfo[i].meshInstance;
					if (mi) {
						mi.setParameter("font_sdfIntensity", this._font.intensity);
						mi.setParameter("font_pxrange", this._getPxRange(this._font));
						mi.setParameter("font_textureWidth", this._font.data.info.maps[i].width);
					}
				}
			}
		},
		_onFontRemove: function (asset) {
		},
		_setTextureParams: function (mi, texture) {
			if (this._font) {
				if (this._font.type === FONT_MSDF) {
					mi.deleteParameter("texture_emissiveMap");
					mi.deleteParameter("texture_opacityMap");
					mi.setParameter("texture_msdfMap", texture);
				} else if (this._font.type === FONT_BITMAP) {
					mi.deleteParameter("texture_msdfMap");
					mi.setParameter("texture_emissiveMap", texture);
					mi.setParameter("texture_opacityMap", texture);
				}
			}
		},
		_getPxRange: function (font) {
			var keys = Object.keys(this._font.data.chars);
			for (var i = 0; i < keys.length; i++) {
				var char = this._font.data.chars[keys[i]];
				if (char.range) {
					return (char.scale || 1) * char.range;
				}
			}
			return 2;
		},
		_getUv: function (char) {
			var data = this._font.data;
			if (!data.chars[char]) {
				var space = ' ';
				if (data.chars[space]) {
					return this._getUv(space);
				}
				return [0, 0, 0, 0];
			}
			var map = data.chars[char].map;
			var width = data.info.maps[map].width;
			var height = data.info.maps[map].height;
			var x = data.chars[char].x;
			var y =  data.chars[char].y;
			var x1 = x;
			var y1 = y;
			var x2 = (x + data.chars[char].width);
			var y2 = (y - data.chars[char].height);
			var edge = 1 - (data.chars[char].height / height);
			return [
				x1 / width,
				edge - (y1 / height),
				(x2 / width),
				edge - (y2 / height)
			];
		},
		onEnable: function () {
			this._fontAsset.autoLoad = true;
			if (this._model) {
				this._element.addModelToLayers(this._model);
			}
		},
		onDisable: function () {
			this._fontAsset.autoLoad = false;
			if (this._model) {
				this._element.removeModelFromLayers(this._model);
			}
		},
		_setStencil: function (stencilParams) {
			if (this._model) {
				var instances = this._model.meshInstances;
				for (var i = 0; i < instances.length; i++) {
					instances[i].stencilFront = stencilParams;
					instances[i].stencilBack = stencilParams;
				}
			}
		},
		_shouldAutoFitWidth: function () {
			return this._autoFitWidth && !this._autoWidth;
		},
		_shouldAutoFitHeight: function () {
			return this._autoFitHeight && !this._autoHeight;
		},
		_shouldAutoFit: function () {
			return this._autoFitWidth && !this._autoWidth ||
				   this._autoFitHeight && !this._autoHeight;
		},
		_calculateCharsPerTexture: function (symbolIndex) {
			var charactersPerTexture = {};
			if (symbolIndex === undefined) {
				symbolIndex = this._symbols.length;
			}
			var i, len, char, info, map;
			for (i = 0, len = symbolIndex; i < len; i++) {
				char = this._symbols[i];
				info = this._font.data.chars[char];
				if (!info) {
					info = this._font.data.chars[' '];
					if (!info) {
						info = this._font.data.chars[Object.keys(this._font.data.chars)[0]];
					}
				}
				map = info.map;
				if (!charactersPerTexture[map]) {
					charactersPerTexture[map] = 1;
				} else {
					charactersPerTexture[map]++;
				}
			}
			return charactersPerTexture;
		},
		_updateRenderRange: function () {
			var startChars = this._rangeStart === 0 ? 0 : this._calculateCharsPerTexture(this._rangeStart);
			var endChars = this._rangeEnd === 0 ? 0 : this._calculateCharsPerTexture(this._rangeEnd);
			var i, len;
			for (i = 0, len = this._meshInfo.length; i < len; i++) {
				var start = startChars[i] || 0;
				var end = endChars[i] || 0;
				var instance = this._meshInfo[i].meshInstance;
				if (instance) {
					var mesh = instance.mesh;
					if (mesh) {
						mesh.primitive[0].base = start * 3 * 2;
						mesh.primitive[0].count = (end - start) * 3 * 2;
					}
				}
			}
		}
	});
	Object.defineProperty(TextElement.prototype, "text", {
		get: function () {
			return this._text;
		},
		set: function (value) {
			this._i18nKey = null;
			var str = value != null && value.toString() || "";
			this._setText(str);
		}
	});
	Object.defineProperty(TextElement.prototype, "key", {
		get: function () {
			return this._i18nKey;
		},
		set: function (value) {
			var str = value !== null ? value.toString() : null;
			if (this._i18nKey === str) {
				return;
			}
			this._i18nKey = str;
			if (str) {
				this._fontAsset.disableLocalization = false;
				this._resetLocalizedText();
			} else {
				this._fontAsset.disableLocalization = true;
			}
		}
	});
	Object.defineProperty(TextElement.prototype, "color", {
		get: function () {
			return this._color;
		},
		set: function (value) {
			var r = value.r;
			var g = value.g;
			var b = value.b;
			if (this._color.r === r && this._color.g === g && this._color.b === b) {
				return;
			}
			this._color.r = r;
			this._color.g = g;
			this._color.b = b;
			if (this._symbolColors) {
				if (this._font) {
					this._updateText();
				}
			} else {
				this._colorUniform[0] = this._color.r;
				this._colorUniform[1] = this._color.g;
				this._colorUniform[2] = this._color.b;
				for (var i = 0, len = this._model.meshInstances.length; i < len; i++) {
					var mi = this._model.meshInstances[i];
					mi.setParameter('material_emissive', this._colorUniform);
				}
			}
		}
	});
	Object.defineProperty(TextElement.prototype, "opacity", {
		get: function () {
			return this._color.a;
		},
		set: function (value) {
			if (this._color.a === value) return;
			this._color.a = value;
			if (this._model) {
				for (var i = 0, len = this._model.meshInstances.length; i < len; i++) {
					var mi = this._model.meshInstances[i];
					mi.setParameter('material_opacity', value);
				}
			}
		}
	});
	Object.defineProperty(TextElement.prototype, "lineHeight", {
		get: function () {
			return this._lineHeight;
		},
		set: function (value) {
			var _prev = this._lineHeight;
			this._lineHeight = value;
			this._scaledLineHeight = value;
			if (_prev !== value && this._font) {
				this._updateText();
			}
		}
	});
	Object.defineProperty(TextElement.prototype, "wrapLines", {
		get: function () {
			return this._wrapLines;
		},
		set: function (value) {
			var _prev = this._wrapLines;
			this._wrapLines = value;
			if (_prev !== value && this._font) {
				this._updateText();
			}
		}
	});
	Object.defineProperty(TextElement.prototype, "lines", {
		get: function () {
			return this._lineContents;
		}
	});
	Object.defineProperty(TextElement.prototype, "spacing", {
		get: function () {
			return this._spacing;
		},
		set: function (value) {
			var _prev = this._spacing;
			this._spacing = value;
			if (_prev !== value && this._font) {
				this._updateText();
			}
		}
	});
	Object.defineProperty(TextElement.prototype, "fontSize", {
		get: function () {
			return this._fontSize;
		},
		set: function (value) {
			var _prev = this._fontSize;
			this._fontSize = value;
			this._originalFontSize = value;
			if (_prev !== value && this._font) {
				this._updateText();
			}
		}
	});
	Object.defineProperty(TextElement.prototype, "fontAsset", {
		get: function () {
			return this._fontAsset.localizedAsset;
		},
		set: function (value) {
			this._fontAsset.defaultAsset = value;
		}
	});
	Object.defineProperty(TextElement.prototype, "font", {
		get: function () {
			return this._font;
		},
		set: function (value) {
			var i;
			var len;
			var previousFontType;
			if (this._font) {
				previousFontType = this._font.type;
				if (this._font.off) this._font.off('render', this._onFontRender, this);
			}
			this._font = value;
			this._fontMinY = 0;
			this._fontMaxY = 0;
			if (!value) return;
			var json = this._font.data;
			for (var charId in json.chars) {
				var data = json.chars[charId];
				if (data.bounds) {
					this._fontMinY = Math.min(this._fontMinY, data.bounds[1]);
					this._fontMaxY = Math.max(this._fontMaxY, data.bounds[3]);
				}
			}
			if (this._font.on) this._font.on('render', this._onFontRender, this);
			if (this._fontAsset.localizedAsset) {
				var asset = this._system.app.assets.get(this._fontAsset.localizedAsset);
				if (asset.resource !== this._font) {
					this._fontAsset.defaultAsset = null;
				}
			}
			if (value.type !== previousFontType) {
				var screenSpace = this._element._isScreenSpace();
				this._updateMaterial(screenSpace);
			}
			for (i = 0, len = this._font.textures.length; i < len; i++) {
				if (!this._meshInfo[i]) {
					this._meshInfo[i] = new MeshInfo();
				} else {
					var mi = this._meshInfo[i].meshInstance;
					if (mi) {
						mi.setParameter("font_sdfIntensity", this._font.intensity);
						mi.setParameter("font_pxrange", this._getPxRange(this._font));
						mi.setParameter("font_textureWidth", this._font.data.info.maps[i].width);
						this._setTextureParams(mi, this._font.textures[i]);
					}
				}
			}
			var removedModel = false;
			for (i = this._font.textures.length; i < this._meshInfo.length; i++) {
				if (this._meshInfo[i].meshInstance) {
					if (!removedModel) {
						this._element.removeModelFromLayers(this._model);
						removedModel = true;
					}
					this._removeMeshInstance(this._meshInfo[i].meshInstance);
				}
			}
			if (this._meshInfo.length > this._font.textures.length)
				this._meshInfo.length = this._font.textures.length;
			this._updateText();
		}
	});
	Object.defineProperty(TextElement.prototype, "alignment", {
		get: function () {
			return this._alignment;
		},
		set: function (value) {
			if (value instanceof Vec2) {
				this._alignment.set(value.x, value.y);
			} else {
				this._alignment.set(value[0], value[1]);
			}
			if (this._font)
				this._updateText();
		}
	});
	Object.defineProperty(TextElement.prototype, "autoWidth", {
		get: function () {
			return this._autoWidth;
		},
		set: function (value) {
			var old = this._autoWidth;
			this._autoWidth = value;
			if (value && Math.abs(this._element.anchor.x - this._element.anchor.z) < 0.0001) {
				this._element.width = this.width;
			}
			if (old !== value) {
				var newFontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize;
				if (newFontSize !== this._fontSize) {
					this._fontSize = newFontSize;
					if (this._font) {
						this._updateText();
					}
				}
			}
		}
	});
	Object.defineProperty(TextElement.prototype, "autoHeight", {
		get: function () {
			return this._autoHeight;
		},
		set: function (value) {
			var old = this._autoHeight;
			this._autoHeight = value;
			if (value && Math.abs(this._element.anchor.y - this._element.anchor.w) < 0.0001) {
				this._element.height = this.height;
			}
			if (old !== value) {
				var newFontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize;
				if (newFontSize !== this._fontSize) {
					this._fontSize = newFontSize;
					if (this._font) {
						this._updateText();
					}
				}
			}
		}
	});
	Object.defineProperty(TextElement.prototype, "rtlReorder", {
		get: function () {
			return this._rtlReorder;
		},
		set: function (value) {
			if (this._rtlReorder !== value) {
				this._rtlReorder = value;
				if (this._font) {
					this._updateText();
				}
			}
		}
	});
	Object.defineProperty(TextElement.prototype, "unicodeConverter", {
		get: function () {
			return this._unicodeConverter;
		},
		set: function (value) {
			if (this._unicodeConverter !== value) {
				this._unicodeConverter = value;
				this._setText(this._text);
			}
		}
	});
	Object.defineProperty(TextElement.prototype, "aabb", {
		get: function () {
			if (this._aabbDirty) {
				var initialized = false;
				for (var i = 0; i < this._meshInfo.length; i++) {
					if (! this._meshInfo[i].meshInstance) continue;
					if (! initialized) {
						this._aabb.copy(this._meshInfo[i].meshInstance.aabb);
						initialized = true;
					} else {
						this._aabb.add(this._meshInfo[i].meshInstance.aabb);
					}
				}
				this._aabbDirty = false;
			}
			return this._aabb;
		}
	});
	Object.defineProperty(TextElement.prototype, "outlineColor", {
		get: function () {
			return this._outlineColor;
		},
		set: function (value) {
			var r = (value instanceof Color) ? value.r : value[0];
			var g = (value instanceof Color) ? value.g : value[1];
			var b = (value instanceof Color) ? value.b : value[2];
			var a = (value instanceof Color) ? value.a : value[3];
			if (this._outlineColor.r === r &&
				this._outlineColor.g === g &&
				this._outlineColor.b === b &&
				this._outlineColor.a === a) {
				return;
			}
			this._outlineColor.r = r;
			this._outlineColor.g = g;
			this._outlineColor.b = b;
			this._outlineColor.a = a;
			if (this._model) {
				this._outlineColorUniform[0] = this._outlineColor.r;
				this._outlineColorUniform[1] = this._outlineColor.g;
				this._outlineColorUniform[2] = this._outlineColor.b;
				this._outlineColorUniform[3] = this._outlineColor.a;
				for (var i = 0, len = this._model.meshInstances.length; i < len; i++) {
					var mi = this._model.meshInstances[i];
					mi.setParameter("outline_color", this._outlineColorUniform);
				}
			}
		}
	});
	Object.defineProperty(TextElement.prototype, "outlineThickness", {
		get: function () {
			return this._outlineThickness;
		},
		set: function (value) {
			var _prev = this._outlineThickness;
			this._outlineThickness = value;
			if (_prev !== value && this._font) {
				if (this._model) {
					for (var i = 0, len = this._model.meshInstances.length; i < len; i++) {
						var mi = this._model.meshInstances[i];
						mi.setParameter("outline_thickness", this._outlineThicknessScale * this._outlineThickness);
					}
				}
			}
		}
	});
	Object.defineProperty(TextElement.prototype, "shadowColor", {
		get: function () {
			return this._shadowColor;
		},
		set: function (value) {
			var r = (value instanceof Color) ? value.r : value[0];
			var g = (value instanceof Color) ? value.g : value[1];
			var b = (value instanceof Color) ? value.b : value[2];
			var a = (value instanceof Color) ? value.a : value[3];
			if (this._shadowColor.r === r &&
				this._shadowColor.g === g &&
				this._shadowColor.b === b &&
				this._shadowColor.a === a) {
				return;
			}
			this._shadowColor.r = r;
			this._shadowColor.g = g;
			this._shadowColor.b = b;
			this._shadowColor.a = a;
			if (this._model) {
				this._shadowColorUniform[0] = this._shadowColor.r;
				this._shadowColorUniform[1] = this._shadowColor.g;
				this._shadowColorUniform[2] = this._shadowColor.b;
				this._shadowColorUniform[3] = this._shadowColor.a;
				for (var i = 0, len = this._model.meshInstances.length; i < len; i++) {
					var mi = this._model.meshInstances[i];
					mi.setParameter("shadow_color", this._shadowColorUniform);
				}
			}
		}
	});
	Object.defineProperty(TextElement.prototype, "shadowOffset", {
		get: function () {
			return this._shadowOffset;
		},
		set: function (value) {
			var x = (value instanceof Vec2) ? value.x : value[0],
				y = (value instanceof Vec2) ? value.y : value[1];
			if (this._shadowOffset.x === x && this._shadowOffset.y === y) {
				return;
			}
			this._shadowOffset.set(x, y);
			if (this._font && this._model) {
				for (var i = 0, len = this._model.meshInstances.length; i < len; i++) {
					var ratio = this._font.data.info.maps[i].width / this._font.data.info.maps[i].height;
					this._shadowOffsetUniform[0] = this._shadowOffsetScale * this._shadowOffset.x;
					this._shadowOffsetUniform[1] = ratio * this._shadowOffsetScale * this._shadowOffset.y;
					var mi = this._model.meshInstances[i];
					mi.setParameter("shadow_offset", this._shadowOffsetUniform);
				}
			}
		}
	});
	Object.defineProperty(TextElement.prototype, 'minFontSize', {
		get: function () {
			return this._minFontSize;
		},
		set: function (value) {
			if (this._minFontSize === value) return;
			this._minFontSize = value;
			if (this.font && this._shouldAutoFit()) {
				this._updateText();
			}
		}
	});
	Object.defineProperty(TextElement.prototype, 'maxFontSize', {
		get: function () {
			return this._maxFontSize;
		},
		set: function (value) {
			if (this._maxFontSize === value) return;
			this._maxFontSize = value;
			if (this.font && this._shouldAutoFit()) {
				this._updateText();
			}
		}
	});
	Object.defineProperty(TextElement.prototype, 'autoFitWidth', {
		get: function () {
			return this._autoFitWidth;
		},
		set: function (value) {
			if (this._autoFitWidth === value) return;
			this._autoFitWidth = value;
			this._fontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize;
			if (this.font) {
				this._updateText();
			}
		}
	});
	Object.defineProperty(TextElement.prototype, 'autoFitHeight', {
		get: function () {
			return this._autoFitHeight;
		},
		set: function (value) {
			if (this._autoFitHeight === value) return;
			this._autoFitHeight = value;
			this._fontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize;
			if (this.font) {
				this._updateText();
			}
		}
	});
	Object.defineProperty(TextElement.prototype, 'maxLines', {
		get: function () {
			return this._maxLines;
		},
		set: function (value) {
			if (this._maxLines === value) return;
			if (value === null && this._maxLines === -1) return;
			this._maxLines = (value === null ? -1 : value);
			if (this.font && this._wrapLines) {
				this._updateText();
			}
		}
	});
	Object.defineProperty(TextElement.prototype, 'enableMarkup', {
		get: function () {
			return this._enableMarkup;
		},
		set: function (value) {
			value = !!value;
			if (this._enableMarkup === value) return;
			this._enableMarkup = value;
			if (this.font) {
				this._updateText();
			}
		}
	});
	Object.defineProperty(TextElement.prototype, 'symbols', {
		get: function () {
			return this._symbols;
		}
	});
	Object.defineProperty(TextElement.prototype, 'symbolColors', {
		get: function () {
			if (this._symbolColors === null) {
				return null;
			}
			return this._symbolColors.map(function (c) {
				return this._colorPalette.slice(c * 3, c * 3 + 3);
			}, this);
		}
	});
	Object.defineProperty(TextElement.prototype, 'rtl', {
		get: function () {
			return this._rtl;
		}
	});
	Object.defineProperty(TextElement.prototype, 'rangeStart', {
		get: function () {
			return this._rangeStart;
		},
		set: function (rangeStart) {
			rangeStart = Math.max(0, Math.min(rangeStart, this._symbols.length));
			if (rangeStart !== this._rangeStart) {
				this._rangeStart = rangeStart;
				this._updateRenderRange();
			}
		}
	});
	Object.defineProperty(TextElement.prototype, 'rangeEnd', {
		get: function () {
			return this._rangeEnd;
		},
		set: function (rangeEnd) {
			rangeEnd = Math.max(this._rangeStart, Math.min(rangeEnd, this._symbols.length));
			if (rangeEnd !== this._rangeEnd) {
				this._rangeEnd = rangeEnd;
				this._updateRenderRange();
			}
		}
	});

	var vecA$1 = new Vec3();
	var vecB$1 = new Vec3();
	var matA = new Mat4();
	var matB = new Mat4();
	var matC = new Mat4();
	var matD = new Mat4();
	function ElementComponent(system, entity) {
		Component.call(this, system, entity);
		this._beingInitialized = false;
		this._anchor = new Vec4();
		this._localAnchor = new Vec4();
		this._pivot = new Vec2();
		this._width = this._calculatedWidth = 32;
		this._height = this._calculatedHeight = 32;
		this._margin = new Vec4(0, 0, -32, -32);
		this._modelTransform = new Mat4();
		this._screenToWorld = new Mat4();
		this._anchorTransform = new Mat4();
		this._anchorDirty = true;
		this._parentWorldTransform = new Mat4();
		this._screenTransform = new Mat4();
		this._screenCorners = [new Vec3(), new Vec3(), new Vec3(), new Vec3()];
		this._canvasCorners = [new Vec2(), new Vec2(), new Vec2(), new Vec2()];
		this._worldCorners = [new Vec3(), new Vec3(), new Vec3(), new Vec3()];
		this._cornersDirty = true;
		this._canvasCornersDirty = true;
		this._worldCornersDirty = true;
		this.entity.on('insert', this._onInsert, this);
		this._patch();
		this.screen = null;
		this._type = ELEMENTTYPE_GROUP;
		this._image = null;
		this._text = null;
		this._group = null;
		this._drawOrder = 0;
		this._useInput = false;
		this._layers = [LAYERID_UI];
		this._addedModels = [];
		this._batchGroupId = -1;
		this._offsetReadAt = 0;
		this._maskOffset = 0.5;
		this._maskedBy = null;
	}
	ElementComponent.prototype = Object.create(Component.prototype);
	ElementComponent.prototype.constructor = ElementComponent;
	Object.assign(ElementComponent.prototype, {
		_patch: function () {
			this.entity._sync = this._sync;
			this.entity.setPosition = this._setPosition;
			this.entity.setLocalPosition = this._setLocalPosition;
		},
		_unpatch: function () {
			this.entity._sync = Entity.prototype._sync;
			this.entity.setPosition = Entity.prototype.setPosition;
			this.entity.setLocalPosition = Entity.prototype.setLocalPosition;
		},
		_setPosition: function () {
			var position = new Vec3();
			var invParentWtm = new Mat4();
			return function (x, y, z) {
				if (!this.element.screen)
					return Entity.prototype.setPosition.call(this, x, y, z);
				if (x instanceof Vec3) {
					position.copy(x);
				} else {
					position.set(x, y, z);
				}
				this.getWorldTransform();
				invParentWtm.copy(this.element._screenToWorld).invert();
				invParentWtm.transformPoint(position, this.localPosition);
				if (!this._dirtyLocal)
					this._dirtifyLocal();
			};
		}(),
		_setLocalPosition: function (x, y, z) {
			if (x instanceof Vec3) {
				this.localPosition.copy(x);
			} else {
				this.localPosition.set(x, y, z);
			}
			var element = this.element;
			var p = this.localPosition;
			var pvt = element._pivot;
			element._margin.x = p.x - element._calculatedWidth * pvt.x;
			element._margin.z = (element._localAnchor.z - element._localAnchor.x) - element._calculatedWidth - element._margin.x;
			element._margin.y = p.y - element._calculatedHeight * pvt.y;
			element._margin.w = (element._localAnchor.w - element._localAnchor.y) - element._calculatedHeight - element._margin.y;
			if (!this._dirtyLocal)
				this._dirtifyLocal();
		},
		_sync: function () {
			var element = this.element;
			var screen = element.screen;
			if (screen) {
				if (element._anchorDirty) {
					var resx = 0;
					var resy = 0;
					var px = 0;
					var py = 1;
					if (this._parent && this._parent.element) {
						resx = this._parent.element.calculatedWidth;
						resy = this._parent.element.calculatedHeight;
						px = this._parent.element.pivot.x;
						py = this._parent.element.pivot.y;
					} else {
						var resolution = screen.screen.resolution;
						resx = resolution.x / screen.screen.scale;
						resy = resolution.y / screen.screen.scale;
					}
					element._anchorTransform.setTranslate((resx * (element.anchor.x - px)), -(resy * (py - element.anchor.y)), 0);
					element._anchorDirty = false;
					element._calculateLocalAnchors();
				}
				if (element._sizeDirty) {
					element._calculateSize(false, false);
				}
			}
			if (this._dirtyLocal) {
				this.localTransform.setTRS(this.localPosition, this.localRotation, this.localScale);
				var p = this.localPosition;
				var pvt = element._pivot;
				element._margin.x = p.x - element._calculatedWidth * pvt.x;
				element._margin.z = (element._localAnchor.z - element._localAnchor.x) - element._calculatedWidth - element._margin.x;
				element._margin.y = p.y - element._calculatedHeight * pvt.y;
				element._margin.w = (element._localAnchor.w - element._localAnchor.y) - element._calculatedHeight - element._margin.y;
				this._dirtyLocal = false;
			}
			if (!screen) {
				if (this._dirtyWorld) {
					element._cornersDirty = true;
					element._canvasCornersDirty = true;
					element._worldCornersDirty = true;
				}
				return Entity.prototype._sync.call(this);
			}
			if (this._dirtyWorld) {
				if (this._parent === null) {
					this.worldTransform.copy(this.localTransform);
				} else {
					if (this._parent.element) {
						element._screenToWorld.mul2(this._parent.element._modelTransform, element._anchorTransform);
					} else {
						element._screenToWorld.copy(element._anchorTransform);
					}
					element._modelTransform.mul2(element._screenToWorld, this.localTransform);
					if (screen) {
						element._screenToWorld.mul2(screen.screen._screenMatrix, element._screenToWorld);
						if (!screen.screen.screenSpace) {
							element._screenToWorld.mul2(screen.worldTransform, element._screenToWorld);
						}
						this.worldTransform.mul2(element._screenToWorld, this.localTransform);
						var parentWorldTransform = element._parentWorldTransform;
						parentWorldTransform.setIdentity();
						var parent = this._parent;
						if (parent && parent.element && parent !== screen) {
							matA.setTRS(Vec3.ZERO, parent.getLocalRotation(), parent.getLocalScale());
							parentWorldTransform.mul2(parent.element._parentWorldTransform, matA);
						}
						var depthOffset = vecA$1;
						depthOffset.set(0, 0, this.localPosition.z);
						var pivotOffset = vecB$1;
						pivotOffset.set(element._absLeft + element._pivot.x * element.calculatedWidth, element._absBottom + element._pivot.y * element.calculatedHeight, 0);
						matA.setTranslate(-pivotOffset.x, -pivotOffset.y, -pivotOffset.z);
						matB.setTRS(depthOffset, this.getLocalRotation(), this.getLocalScale());
						matC.setTranslate(pivotOffset.x, pivotOffset.y, pivotOffset.z);
						element._screenTransform.mul2(element._parentWorldTransform, matC).mul(matB).mul(matA);
						element._cornersDirty = true;
						element._canvasCornersDirty = true;
						element._worldCornersDirty = true;
					} else {
						this.worldTransform.copy(element._modelTransform);
					}
				}
				this._dirtyWorld = false;
			}
		},
		_onInsert: function (parent) {
			var result = this._parseUpToScreen();
			this.entity._dirtifyWorld();
			this._updateScreen(result.screen);
			this._dirtifyMask();
		},
		_dirtifyMask: function () {
			var current = this.entity;
			while (current) {
				var next = current.parent;
				if ((next === null || next.screen) && current.element) {
					if (!this.system._prerender || !this.system._prerender.length) {
						this.system._prerender = [];
						this.system.app.once('prerender', this._onPrerender, this);
					}
					var i = this.system._prerender.indexOf(this.entity);
					if (i >= 0) {
						this.system._prerender.splice(i, 1);
					}
					var j = this.system._prerender.indexOf(current);
					if (j < 0) {
						this.system._prerender.push(current);
					}
				}
				current = next;
			}
		},
		_onPrerender: function () {
			for (var i = 0; i < this.system._prerender.length; i++) {
				var mask = this.system._prerender[i];
				if (mask.element) {
					var depth = 1;
					mask.element.syncMask(depth);
				}
			}
			this.system._prerender.length = 0;
		},
		_bindScreen: function (screen) {
			screen.on('set:resolution', this._onScreenResize, this);
			screen.on('set:referenceresolution', this._onScreenResize, this);
			screen.on('set:scaleblend', this._onScreenResize, this);
			screen.on('set:screenspace', this._onScreenSpaceChange, this);
			screen.on('remove', this._onScreenRemove, this);
		},
		_unbindScreen: function (screen) {
			screen.off('set:resolution', this._onScreenResize, this);
			screen.off('set:referenceresolution', this._onScreenResize, this);
			screen.off('set:scaleblend', this._onScreenResize, this);
			screen.off('set:screenspace', this._onScreenSpaceChange, this);
			screen.off('remove', this._onScreenRemove, this);
		},
		_updateScreen: function (screen) {
			if (this.screen && this.screen !== screen) {
				this._unbindScreen(this.screen.screen);
			}
			var previousScreen = this.screen;
			this.screen = screen;
			if (this.screen) {
				this._bindScreen(this.screen.screen);
			}
			this._calculateSize(this._hasSplitAnchorsX, this._hasSplitAnchorsY);
			this.fire('set:screen', this.screen, previousScreen);
			this._anchorDirty = true;
			var children = this.entity.children;
			for (var i = 0, l = children.length; i < l; i++) {
				if (children[i].element) children[i].element._updateScreen(screen);
			}
			if (this.screen) this.screen.screen.syncDrawOrder();
		},
		syncMask: function (depth) {
			var result = this._parseUpToScreen();
			this._updateMask(result.mask, depth);
		},
		_setMaskedBy: function (mask) {
			var renderableElement = this._image || this._text;
			if (mask) {
				var ref = mask.element._image._maskRef;
				var sp = new StencilParameters({
					ref: ref,
					func: FUNC_EQUAL
				});
				if (renderableElement && renderableElement._setStencil) {
					renderableElement._setStencil(sp);
				}
				this._maskedBy = mask;
			} else {
				if (renderableElement && renderableElement._setStencil) {
					renderableElement._setStencil(null);
				}
				this._maskedBy = null;
			}
		},
		_updateMask: function (currentMask, depth) {
			var i, l, sp, children;
			if (currentMask) {
				this._setMaskedBy(currentMask);
				if (this.mask) {
					var ref = currentMask.element._image._maskRef;
					sp = new StencilParameters({
						ref: ref,
						func: FUNC_EQUAL,
						zpass: STENCILOP_INCREMENT
					});
					this._image._setStencil(sp);
					this._image._maskRef = depth;
					depth++;
					currentMask = this.entity;
				}
				children = this.entity.children;
				for (i = 0, l = children.length; i < l; i++) {
					if (children[i].element) {
						children[i].element._updateMask(currentMask, depth);
					}
				}
				if (this.mask) depth--;
			} else {
				this._setMaskedBy(null);
				if (this.mask) {
					sp = new StencilParameters({
						ref: depth,
						func: FUNC_ALWAYS,
						zpass: STENCILOP_REPLACE
					});
					this._image._setStencil(sp);
					this._image._maskRef = depth;
					depth++;
					currentMask = this.entity;
				}
				children = this.entity.children;
				for (i = 0, l = children.length; i < l; i++) {
					if (children[i].element) {
						children[i].element._updateMask(currentMask, depth);
					}
				}
				if (this.mask) depth--;
			}
		},
		_parseUpToScreen: function () {
			var result = {
				screen: null,
				mask: null
			};
			var parent = this.entity._parent;
			while (parent && !parent.screen) {
				if (parent.element && parent.element.mask) {
					if (!result.mask) result.mask = parent;
				}
				parent = parent.parent;
			}
			if (parent && parent.screen) result.screen = parent;
			return result;
		},
		_onScreenResize: function (res) {
			this._anchorDirty = true;
			this._cornersDirty = true;
			this._worldCornersDirty = true;
			this._calculateSize(this._hasSplitAnchorsX, this._hasSplitAnchorsY);
			this.fire('screen:set:resolution', res);
		},
		_onScreenSpaceChange: function () {
			this.fire('screen:set:screenspace', this.screen.screen.screenSpace);
		},
		_onScreenRemove: function () {
			if (this.screen && !this.screen._destroying) {
				this._updateScreen(null);
			}
		},
		_calculateLocalAnchors: function () {
			var resx = 1000;
			var resy = 1000;
			var parent = this.entity._parent;
			if (parent && parent.element) {
				resx = parent.element.calculatedWidth;
				resy = parent.element.calculatedHeight;
			} else if (this.screen) {
				var res = this.screen.screen.resolution;
				var scale = this.screen.screen.scale;
				resx = res.x / scale;
				resy = res.y / scale;
			}
			this._localAnchor.set(
				this._anchor.x * resx,
				this._anchor.y * resy,
				this._anchor.z * resx,
				this._anchor.w * resy
			);
		},
		getOffsetPosition: function (x, y) {
			var p = this.entity.getLocalPosition().clone();
			p.x += x;
			p.y += y;
			this._screenToWorld.transformPoint(p, p);
			return p;
		},
		onLayersChanged: function (oldComp, newComp) {
			this.addModelToLayers(this._image ? this._image._model : this._text._model);
			oldComp.off("add", this.onLayerAdded, this);
			oldComp.off("remove", this.onLayerRemoved, this);
			newComp.on("add", this.onLayerAdded, this);
			newComp.on("remove", this.onLayerRemoved, this);
		},
		onLayerAdded: function (layer) {
			var index = this.layers.indexOf(layer.id);
			if (index < 0) return;
			if (this._image) {
				layer.addMeshInstances(this._image._model.meshInstances);
			} else if (this._text) {
				layer.addMeshInstances(this._text._model.meshInstances);
			}
		},
		onLayerRemoved: function (layer) {
			var index = this.layers.indexOf(layer.id);
			if (index < 0) return;
			if (this._image) {
				layer.removeMeshInstances(this._image._model.meshInstances);
			} else if (this._text) {
				layer.removeMeshInstances(this._text._model.meshInstances);
			}
		},
		onEnable: function () {
			if (this._image) this._image.onEnable();
			if (this._text) this._text.onEnable();
			if (this._group) this._group.onEnable();
			if (this.useInput && this.system.app.elementInput) {
				this.system.app.elementInput.addElement(this);
			}
			this.system.app.scene.on("set:layers", this.onLayersChanged, this);
			if (this.system.app.scene.layers) {
				this.system.app.scene.layers.on("add", this.onLayerAdded, this);
				this.system.app.scene.layers.on("remove", this.onLayerRemoved, this);
			}
			if (this._batchGroupId >= 0) {
				this.system.app.batcher.insert(BatchGroup.ELEMENT, this.batchGroupId, this.entity);
			}
			this.fire("enableelement");
		},
		onDisable: function () {
			this.system.app.scene.off("set:layers", this.onLayersChanged, this);
			if (this.system.app.scene.layers) {
				this.system.app.scene.layers.off("add", this.onLayerAdded, this);
				this.system.app.scene.layers.off("remove", this.onLayerRemoved, this);
			}
			if (this._image) this._image.onDisable();
			if (this._text) this._text.onDisable();
			if (this._group) this._group.onDisable();
			if (this.system.app.elementInput && this.useInput) {
				this.system.app.elementInput.removeElement(this);
			}
			if (this._batchGroupId >= 0) {
				this.system.app.batcher.remove(BatchGroup.ELEMENT, this.batchGroupId, this.entity);
			}
			this.fire("disableelement");
		},
		onRemove: function () {
			this.entity.off('insert', this._onInsert, this);
			this._unpatch();
			if (this._image) this._image.destroy();
			if (this._text) this._text.destroy();
			if (this.system.app.elementInput && this.useInput) {
				this.system.app.elementInput.removeElement(this);
			}
			if (this.screen && this.screen.screen) {
				this._unbindScreen(this.screen.screen);
				this.screen.screen.syncDrawOrder();
			}
			this.off();
		},
		_calculateSize: function (propagateCalculatedWidth, propagateCalculatedHeight) {
			if (!this.entity._parent && !this.screen) return;
			this._calculateLocalAnchors();
			var newWidth = this._absRight - this._absLeft;
			var newHeight = this._absTop - this._absBottom;
			if (propagateCalculatedWidth) {
				this._setWidth(newWidth);
			} else {
				this._setCalculatedWidth(newWidth, false);
			}
			if (propagateCalculatedHeight) {
				this._setHeight(newHeight);
			} else {
				this._setCalculatedHeight(newHeight, false);
			}
			var p = this.entity.getLocalPosition();
			p.x = this._margin.x + this._calculatedWidth * this._pivot.x;
			p.y = this._margin.y + this._calculatedHeight * this._pivot.y;
			this.entity.setLocalPosition(p);
			this._sizeDirty = false;
		},
		_setWidth: function (w) {
			this._width = w;
			this._setCalculatedWidth(w, false);
			this.fire('set:width', this._width);
		},
		_setHeight: function (h) {
			this._height = h;
			this._setCalculatedHeight(h, false);
			this.fire('set:height', this._height);
		},
		_setCalculatedWidth: function (value, updateMargins) {
			if (Math.abs(value - this._calculatedWidth) <= 1e-4)
				return;
			this._calculatedWidth = value;
			this.entity._dirtifyLocal();
			if (updateMargins) {
				var p = this.entity.getLocalPosition();
				var pvt = this._pivot;
				this._margin.x = p.x - this._calculatedWidth * pvt.x;
				this._margin.z = (this._localAnchor.z - this._localAnchor.x) - this._calculatedWidth - this._margin.x;
			}
			this._flagChildrenAsDirty();
			this.fire('set:calculatedWidth', this._calculatedWidth);
			this.fire('resize', this._calculatedWidth, this._calculatedHeight);
		},
		_setCalculatedHeight: function (value, updateMargins) {
			if (Math.abs(value - this._calculatedHeight) <= 1e-4)
				return;
			this._calculatedHeight = value;
			this.entity._dirtifyLocal();
			if (updateMargins) {
				var p = this.entity.getLocalPosition();
				var pvt = this._pivot;
				this._margin.y = p.y - this._calculatedHeight * pvt.y;
				this._margin.w = (this._localAnchor.w - this._localAnchor.y) - this._calculatedHeight - this._margin.y;
			}
			this._flagChildrenAsDirty();
			this.fire('set:calculatedHeight', this._calculatedHeight);
			this.fire('resize', this._calculatedWidth, this._calculatedHeight);
		},
		_flagChildrenAsDirty: function () {
			var i, l;
			var c = this.entity._children;
			for (i = 0, l = c.length; i < l; i++) {
				if (c[i].element) {
					c[i].element._anchorDirty = true;
					c[i].element._sizeDirty = true;
				}
			}
		},
		addModelToLayers: function (model) {
			var layer;
			this._addedModels.push(model);
			for (var i = 0; i < this.layers.length; i++) {
				layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
				if (!layer) continue;
				layer.addMeshInstances(model.meshInstances);
			}
		},
		removeModelFromLayers: function (model) {
			var layer;
			var idx = this._addedModels.indexOf(model);
			if (idx >= 0) {
				this._addedModels.splice(idx, 1);
			}
			for (var i = 0; i < this.layers.length; i++) {
				layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
				if (!layer) continue;
				layer.removeMeshInstances(model.meshInstances);
			}
		},
		getMaskOffset: function () {
			var frame = this.system.app.frame;
			if (this._offsetReadAt !== frame) {
				this._maskOffset = 0.5;
				this._offsetReadAt = frame;
			}
			var mo = this._maskOffset;
			this._maskOffset -= 0.001;
			return mo;
		},
		isVisibleForCamera: function (camera) {
			var clipL, clipR, clipT, clipB;
			if (this.maskedBy) {
				var corners = this.maskedBy.element.screenCorners;
				clipL = Math.min(Math.min(corners[0].x, corners[1].x), Math.min(corners[2].x, corners[3].x));
				clipR = Math.max(Math.max(corners[0].x, corners[1].x), Math.max(corners[2].x, corners[3].x));
				clipB = Math.min(Math.min(corners[0].y, corners[1].y), Math.min(corners[2].y, corners[3].y));
				clipT = Math.max(Math.max(corners[0].y, corners[1].y), Math.max(corners[2].y, corners[3].y));
			} else {
				var sw = this.system.app.graphicsDevice.width;
				var sh = this.system.app.graphicsDevice.height;
				var cameraWidth = camera._rect.z * sw;
				var cameraHeight = camera._rect.w * sh;
				clipL = camera._rect.x * sw;
				clipR = clipL + cameraWidth;
				clipT = (1 - camera._rect.y) * sh;
				clipB = clipT - cameraHeight;
			}
			var hitCorners = this.screenCorners;
			var left = Math.min(Math.min(hitCorners[0].x, hitCorners[1].x), Math.min(hitCorners[2].x, hitCorners[3].x));
			var right = Math.max(Math.max(hitCorners[0].x, hitCorners[1].x), Math.max(hitCorners[2].x, hitCorners[3].x));
			var bottom = Math.min(Math.min(hitCorners[0].y, hitCorners[1].y), Math.min(hitCorners[2].y, hitCorners[3].y));
			var top = Math.max(Math.max(hitCorners[0].y, hitCorners[1].y), Math.max(hitCorners[2].y, hitCorners[3].y));
			if (right < clipL ||
				left > clipR ||
				bottom > clipT ||
				top < clipB) {
				return false;
			}
			return true;
		},
		_isScreenSpace: function () {
			if (this.screen && this.screen.screen) {
				return this.screen.screen.screenSpace;
			}
			return false;
		},
		_isScreenCulled: function () {
			if (this.screen && this.screen.screen) {
				return this.screen.screen.cull;
			}
			return false;
		}
	});
	Object.defineProperty(ElementComponent.prototype, "type", {
		get: function () {
			return this._type;
		},
		set: function (value) {
			if (value !== this._type) {
				this._type = value;
				if (this._image) {
					this._image.destroy();
					this._image = null;
				}
				if (this._text) {
					this._text.destroy();
					this._text = null;
				}
				if (value === ELEMENTTYPE_IMAGE) {
					this._image = new ImageElement(this);
				} else if (value === ELEMENTTYPE_TEXT) {
					this._text = new TextElement(this);
				}
			}
		}
	});
	Object.defineProperty(ElementComponent.prototype, "layers", {
		get: function () {
			return this._layers;
		},
		set: function (value) {
			var i, j, layer;
			if (this._addedModels.length) {
				for (i = 0; i < this._layers.length; i++) {
					layer = this.system.app.scene.layers.getLayerById(this._layers[i]);
					if (layer) {
						for (j = 0; j < this._addedModels.length; j++) {
							layer.removeMeshInstances(this._addedModels[j].meshInstances);
						}
					}
				}
			}
			this._layers = value;
			if (!this.enabled || !this.entity.enabled || !this._addedModels.length) return;
			for (i = 0; i < this._layers.length; i++) {
				layer = this.system.app.scene.layers.getLayerById(this._layers[i]);
				if (layer) {
					for (j = 0; j < this._addedModels.length; j++) {
						layer.addMeshInstances(this._addedModels[j].meshInstances);
					}
				}
			}
		}
	});
	Object.defineProperty(ElementComponent.prototype, "drawOrder", {
		get: function () {
			return this._drawOrder;
		},
		set: function (value) {
			var priority = 0;
			if (this.screen) {
				priority = this.screen.screen.priority;
			}
			if (value > 0xFFFFFF) {
				value = 0xFFFFFF;
			}
			this._drawOrder = (priority << 24) + value;
			this.fire('set:draworder', this._drawOrder);
		}
	});
	Object.defineProperty(ElementComponent.prototype, "_absLeft", {
		get: function () {
			return this._localAnchor.x + this._margin.x;
		}
	});
	Object.defineProperty(ElementComponent.prototype, "_absRight", {
		get: function () {
			return this._localAnchor.z - this._margin.z;
		}
	});
	Object.defineProperty(ElementComponent.prototype, "_absTop", {
		get: function () {
			return this._localAnchor.w - this._margin.w;
		}
	});
	Object.defineProperty(ElementComponent.prototype, "_absBottom", {
		get: function () {
			return this._localAnchor.y + this._margin.y;
		}
	});
	Object.defineProperty(ElementComponent.prototype, "margin", {
		get: function () {
			return this._margin;
		},
		set: function (value) {
			this._margin.copy(value);
			this._calculateSize(true, true);
			this.fire('set:margin', this._margin);
		}
	});
	Object.defineProperty(ElementComponent.prototype, "left", {
		get: function () {
			return this._margin.x;
		},
		set: function (value) {
			this._margin.x = value;
			var p = this.entity.getLocalPosition();
			var wr = this._absRight;
			var wl = this._localAnchor.x + value;
			this._setWidth(wr - wl);
			p.x = value + this._calculatedWidth * this._pivot.x;
			this.entity.setLocalPosition(p);
		}
	});
	Object.defineProperty(ElementComponent.prototype, "right", {
		get: function () {
			return this._margin.z;
		},
		set: function (value) {
			this._margin.z = value;
			var p = this.entity.getLocalPosition();
			var wl = this._absLeft;
			var wr = this._localAnchor.z - value;
			this._setWidth(wr - wl);
			p.x = (this._localAnchor.z - this._localAnchor.x) - value - (this._calculatedWidth * (1 - this._pivot.x));
			this.entity.setLocalPosition(p);
		}
	});
	Object.defineProperty(ElementComponent.prototype, "top", {
		get: function () {
			return this._margin.w;
		},
		set: function (value) {
			this._margin.w = value;
			var p = this.entity.getLocalPosition();
			var wb = this._absBottom;
			var wt = this._localAnchor.w - value;
			this._setHeight(wt - wb);
			p.y = (this._localAnchor.w - this._localAnchor.y) - value - this._calculatedHeight * (1 - this._pivot.y);
			this.entity.setLocalPosition(p);
		}
	});
	Object.defineProperty(ElementComponent.prototype, "bottom", {
		get: function () {
			return this._margin.y;
		},
		set: function (value) {
			this._margin.y = value;
			var p = this.entity.getLocalPosition();
			var wt = this._absTop;
			var wb = this._localAnchor.y + value;
			this._setHeight(wt - wb);
			p.y = value + this._calculatedHeight * this._pivot.y;
			this.entity.setLocalPosition(p);
		}
	});
	Object.defineProperty(ElementComponent.prototype, "width", {
		get: function () {
			return this._width;
		},
		set: function (value) {
			this._width = value;
			if (!this._hasSplitAnchorsX) {
				this._setCalculatedWidth(value, true);
			}
			this.fire('set:width', this._width);
		}
	});
	Object.defineProperty(ElementComponent.prototype, "height", {
		get: function () {
			return this._height;
		},
		set: function (value) {
			this._height = value;
			if (!this._hasSplitAnchorsY) {
				this._setCalculatedHeight(value, true);
			}
			this.fire('set:height', this._height);
		}
	});
	Object.defineProperty(ElementComponent.prototype, "calculatedWidth", {
		get: function () {
			return this._calculatedWidth;
		},
		set: function (value) {
			this._setCalculatedWidth(value, true);
		}
	});
	Object.defineProperty(ElementComponent.prototype, "calculatedHeight", {
		get: function () {
			return this._calculatedHeight;
		},
		set: function (value) {
			this._setCalculatedHeight(value, true);
		}
	});
	Object.defineProperty(ElementComponent.prototype, "pivot", {
		get: function () {
			return this._pivot;
		},
		set: function (value) {
			var prevX = this._pivot.x;
			var prevY = this._pivot.y;
			if (value instanceof Vec2) {
				this._pivot.set(value.x, value.y);
			} else {
				this._pivot.set(value[0], value[1]);
			}
			var mx = this._margin.x + this._margin.z;
			var dx = this._pivot.x - prevX;
			this._margin.x += mx * dx;
			this._margin.z -= mx * dx;
			var my = this._margin.y + this._margin.w;
			var dy = this._pivot.y - prevY;
			this._margin.y += my * dy;
			this._margin.w -= my * dy;
			this._anchorDirty = true;
			this._cornersDirty = true;
			this._worldCornersDirty = true;
			this._calculateSize(false, false);
			this._flagChildrenAsDirty();
			this.fire('set:pivot', this._pivot);
		}
	});
	Object.defineProperty(ElementComponent.prototype, "anchor", {
		get: function () {
			return this._anchor;
		},
		set: function (value) {
			if (value instanceof Vec4) {
				this._anchor.set(value.x, value.y, value.z, value.w);
			} else {
				this._anchor.set(value[0], value[1], value[2], value[3]);
			}
			if (!this.entity._parent && !this.screen) {
				this._calculateLocalAnchors();
			} else {
				this._calculateSize(this._hasSplitAnchorsX, this._hasSplitAnchorsY);
			}
			this._anchorDirty = true;
			if (!this.entity._dirtyLocal)
				this.entity._dirtifyLocal();
			this.fire('set:anchor', this._anchor);
		}
	});
	Object.defineProperty(ElementComponent.prototype, "_hasSplitAnchorsX", {
		get: function () {
			return Math.abs(this._anchor.x - this._anchor.z) > 0.001;
		}
	});
	Object.defineProperty(ElementComponent.prototype, "_hasSplitAnchorsY", {
		get: function () {
			return Math.abs(this._anchor.y - this._anchor.w) > 0.001;
		}
	});
	Object.defineProperty(ElementComponent.prototype, "aabb", {
		get: function () {
			if (this._image) return this._image.aabb;
			if (this._text) return this._text.aabb;
			return null;
		}
	});
	Object.defineProperty(ElementComponent.prototype, 'screenCorners', {
		get: function () {
			if (!this._cornersDirty || !this.screen)
				return this._screenCorners;
			var parentBottomLeft = this.entity.parent && this.entity.parent.element && this.entity.parent.element.screenCorners[0];
			this._screenCorners[0].set(this._absLeft, this._absBottom, 0);
			this._screenCorners[1].set(this._absRight, this._absBottom, 0);
			this._screenCorners[2].set(this._absRight, this._absTop, 0);
			this._screenCorners[3].set(this._absLeft, this._absTop, 0);
			var screenSpace = this.screen.screen.screenSpace;
			for (var i = 0; i < 4; i++) {
				this._screenTransform.transformPoint(this._screenCorners[i], this._screenCorners[i]);
				if (screenSpace)
					this._screenCorners[i].scale(this.screen.screen.scale);
				if (parentBottomLeft) {
					this._screenCorners[i].add(parentBottomLeft);
				}
			}
			this._cornersDirty = false;
			this._canvasCornersDirty = true;
			this._worldCornersDirty = true;
			return this._screenCorners;
		}
	});
	Object.defineProperty(ElementComponent.prototype, 'canvasCorners', {
		get: function () {
			if (!this._canvasCornersDirty || !this.screen || !this.screen.screen.screenSpace)
				return this._canvasCorners;
			var device = this.system.app.graphicsDevice;
			var screenCorners = this.screenCorners;
			var sx = device.canvas.clientWidth / device.width;
			var sy = device.canvas.clientHeight / device.height;
			for (var i = 0; i < 4; i++) {
				this._canvasCorners[i].set(screenCorners[i].x * sx, (device.height - screenCorners[i].y) * sy);
			}
			this._canvasCornersDirty = false;
			return this._canvasCorners;
		}
	});
	Object.defineProperty(ElementComponent.prototype, 'worldCorners', {
		get: function () {
			if (!this._worldCornersDirty) {
				return this._worldCorners;
			}
			if (this.screen) {
				var screenCorners = this.screenCorners;
				if (!this.screen.screen.screenSpace) {
					matA.copy(this.screen.screen._screenMatrix);
					matA.data[13] = -matA.data[13];
					matA.mul2(this.screen.getWorldTransform(), matA);
					for (var i = 0; i < 4; i++) {
						matA.transformPoint(screenCorners[i], this._worldCorners[i]);
					}
				}
			} else {
				var localPos = this.entity.getLocalPosition();
				matA.setTranslate(-localPos.x, -localPos.y, -localPos.z);
				matB.setTRS(Vec3.ZERO, this.entity.getLocalRotation(), this.entity.getLocalScale());
				matC.setTranslate(localPos.x, localPos.y, localPos.z);
				matD.copy(this.entity.parent.getWorldTransform());
				matD.mul(matC).mul(matB).mul(matA);
				vecA$1.set(localPos.x - this.pivot.x * this.calculatedWidth, localPos.y - this.pivot.y * this.calculatedHeight, localPos.z);
				matD.transformPoint(vecA$1, this._worldCorners[0]);
				vecA$1.set(localPos.x + (1 - this.pivot.x) * this.calculatedWidth, localPos.y - this.pivot.y * this.calculatedHeight, localPos.z);
				matD.transformPoint(vecA$1, this._worldCorners[1]);
				vecA$1.set(localPos.x + (1 - this.pivot.x) * this.calculatedWidth, localPos.y + (1 - this.pivot.y) * this.calculatedHeight, localPos.z);
				matD.transformPoint(vecA$1, this._worldCorners[2]);
				vecA$1.set(localPos.x - this.pivot.x * this.calculatedWidth, localPos.y + (1 - this.pivot.y) * this.calculatedHeight, localPos.z);
				matD.transformPoint(vecA$1, this._worldCorners[3]);
			}
			this._worldCornersDirty = false;
			return this._worldCorners;
		}
	});
	Object.defineProperty(ElementComponent.prototype, "textWidth", {
		get: function () {
			return this._text ? this._text.width : 0;
		}
	});
	Object.defineProperty(ElementComponent.prototype, "textHeight", {
		get: function () {
			return this._text ? this._text.height : 0;
		}
	});
	Object.defineProperty(ElementComponent.prototype, "useInput", {
		get: function () {
			return this._useInput;
		},
		set: function (value) {
			if (this._useInput === value)
				return;
			this._useInput = value;
			if (this.system.app.elementInput) {
				if (value) {
					if (this.enabled && this.entity.enabled) {
						this.system.app.elementInput.addElement(this);
					}
				} else {
					this.system.app.elementInput.removeElement(this);
				}
			}
			this.fire('set:useInput', value);
		}
	});
	Object.defineProperty(ElementComponent.prototype, "batchGroupId", {
		get: function () {
			return this._batchGroupId;
		},
		set: function (value) {
			if (this._batchGroupId === value)
				return;
			if (this.entity.enabled && this._batchGroupId >= 0) {
				this.system.app.batcher.remove(BatchGroup.ELEMENT, this.batchGroupId, this.entity);
			}
			if (this.entity.enabled && value >= 0) {
				this.system.app.batcher.insert(BatchGroup.ELEMENT, value, this.entity);
			}
			if (value < 0 && this._batchGroupId >= 0 && this.enabled && this.entity.enabled) {
				if (this._image && this._image._renderable.model) {
					this.addModelToLayers(this._image._renderable.model);
				} else if (this._text && this._text._model) {
					this.addModelToLayers(this._text._model);
				}
			}
			this._batchGroupId = value;
		}
	});
	Object.defineProperty(ElementComponent.prototype, "maskedBy", {
		get: function () {
			return this._maskedBy;
		}
	});
	var _define = function (name) {
		Object.defineProperty(ElementComponent.prototype, name, {
			get: function () {
				if (this._text) {
					return this._text[name];
				} else if (this._image) {
					return this._image[name];
				}
				return null;
			},
			set: function (value) {
				if (this._text) {
					this._text[name] = value;
				} else if (this._image) {
					this._image[name] = value;
				}
			}
		});
	};
	_define("fontSize");
	_define("minFontSize");
	_define("maxFontSize");
	_define("maxLines");
	_define("autoFitWidth");
	_define("autoFitHeight");
	_define("color");
	_define("font");
	_define("fontAsset");
	_define("spacing");
	_define("lineHeight");
	_define("wrapLines");
	_define("lines");
	_define("alignment");
	_define("autoWidth");
	_define("autoHeight");
	_define("rtlReorder");
	_define("unicodeConverter");
	_define("text");
	_define("key");
	_define("texture");
	_define("textureAsset");
	_define("material");
	_define("materialAsset");
	_define("sprite");
	_define("spriteAsset");
	_define("spriteFrame");
	_define("pixelsPerUnit");
	_define("opacity");
	_define("rect");
	_define("mask");
	_define("outlineColor");
	_define("outlineThickness");
	_define("shadowColor");
	_define("shadowOffset");
	_define("enableMarkup");
	_define("rangeStart");
	_define("rangeEnd");

	function ElementComponentData() {
		this.enabled = true;
	}

	var _schema$7 = ['enabled'];
	function ElementComponentSystem(app) {
		ComponentSystem.call(this, app);
		this.id = 'element';
		this.ComponentType = ElementComponent;
		this.DataType = ElementComponentData;
		this.schema = _schema$7;
		this._unicodeConverter = null;
		this._rtlReorder = null;
		this._defaultTexture = new Texture(app.graphicsDevice, { width: 1, height: 1, format: PIXELFORMAT_R8_G8_B8_A8 });
		this._defaultTexture.name = 'element-system';
		var pixels = this._defaultTexture.lock();
		var pixelData = new Uint8Array(4);
		pixelData[0] = 255.0;
		pixelData[1] = 255.0;
		pixelData[2] = 255.0;
		pixelData[3] = 255.0;
		pixels.set(pixelData);
		this._defaultTexture.unlock();
		this.defaultImageMaterial = null;
		this.defaultImage9SlicedMaterial = null;
		this.defaultImage9TiledMaterial = null;
		this.defaultImageMaskMaterial = null;
		this.defaultImage9SlicedMaskMaterial = null;
		this.defaultImage9TiledMaskMaterial = null;
		this.defaultScreenSpaceImageMaterial = null;
		this.defaultScreenSpaceImage9SlicedMaterial = null;
		this.defaultScreenSpaceImage9TiledMaterial = null;
		this.defaultScreenSpaceImageMask9SlicedMaterial = null;
		this.defaultScreenSpaceImageMask9TiledMaterial = null;
		this.defaultScreenSpaceImageMaskMaterial = null;
		this.defaultTextMaterial = null;
		this.defaultBitmapTextMaterial = null;
		this.defaultScreenSpaceTextMaterial = null;
		this.defaultScreenSpaceBitmapTextMaterial = null;
		this.defaultImageMaterials = [];
		this.on('beforeremove', this.onRemoveComponent, this);
	}
	ElementComponentSystem.prototype = Object.create(ComponentSystem.prototype);
	ElementComponentSystem.prototype.constructor = ElementComponentSystem;
	Component._buildAccessors(ElementComponent.prototype, _schema$7);
	Object.assign(ElementComponentSystem.prototype, {
		destroy: function () {
			this._defaultTexture.destroy();
		},
		initializeComponentData: function (component, data, properties) {
			component._beingInitialized = true;
			if (data.anchor !== undefined) {
				if (data.anchor instanceof Vec4) {
					component.anchor.copy(data.anchor);
				} else {
					component.anchor.set(data.anchor[0], data.anchor[1], data.anchor[2], data.anchor[3]);
				}
			}
			if (data.pivot !== undefined) {
				if (data.pivot instanceof Vec2) {
					component.pivot.copy(data.pivot);
				} else {
					component.pivot.set(data.pivot[0], data.pivot[1]);
				}
			}
			var splitHorAnchors = Math.abs(component.anchor.x - component.anchor.z) > 0.001;
			var splitVerAnchors = Math.abs(component.anchor.y - component.anchor.w) > 0.001;
			var _marginChange = false;
			var color;
			if (data.margin !== undefined) {
				if (data.margin instanceof Vec4) {
					component.margin.copy(data.margin);
				} else {
					component._margin.set(data.margin[0], data.margin[1], data.margin[2], data.margin[3]);
				}
				_marginChange = true;
			}
			if (data.left !== undefined) {
				component._margin.x = data.left;
				_marginChange = true;
			}
			if (data.bottom !== undefined) {
				component._margin.y = data.bottom;
				_marginChange = true;
			}
			if (data.right !== undefined) {
				component._margin.z = data.right;
				_marginChange = true;
			}
			if (data.top !== undefined) {
				component._margin.w = data.top;
				_marginChange = true;
			}
			if (_marginChange) {
				component.margin = component._margin;
			}
			var shouldForceSetAnchor = false;
			if (data.width !== undefined && !splitHorAnchors) {
				component.width = data.width;
			} else if (splitHorAnchors) {
				shouldForceSetAnchor = true;
			}
			if (data.height !== undefined && !splitVerAnchors) {
				component.height = data.height;
			} else if (splitVerAnchors) {
				shouldForceSetAnchor = true;
			}
			if (shouldForceSetAnchor) {
				component.anchor = component.anchor;
			}
			if (data.enabled !== undefined) {
				component.enabled = data.enabled;
			}
			if (data.useInput !== undefined) {
				component.useInput = data.useInput;
			}
			component.batchGroupId = data.batchGroupId === undefined || data.batchGroupId === null ? -1 : data.batchGroupId;
			if (data.layers && Array.isArray(data.layers)) {
				component.layers = data.layers.slice(0);
			}
			component.type = data.type;
			if (component.type === ELEMENTTYPE_IMAGE) {
				if (data.rect !== undefined) {
					component.rect = data.rect;
				}
				if (data.color !== undefined) {
					color = data.color;
					if (! (color instanceof Color)) {
						color = new Color(data.color[0], data.color[1], data.color[2]);
					}
					component.color = color;
				}
				if (data.opacity !== undefined) component.opacity = data.opacity;
				if (data.textureAsset !== undefined) component.textureAsset = data.textureAsset;
				if (data.texture) component.texture = data.texture;
				if (data.spriteAsset !== undefined) component.spriteAsset = data.spriteAsset;
				if (data.sprite) component.sprite = data.sprite;
				if (data.spriteFrame !== undefined) component.spriteFrame = data.spriteFrame;
				if (data.pixelsPerUnit !== undefined && data.pixelsPerUnit !== null) component.pixelsPerUnit = data.pixelsPerUnit;
				if (data.materialAsset !== undefined) component.materialAsset = data.materialAsset;
				if (data.material) component.material = data.material;
				if (data.mask !== undefined) {
					component.mask = data.mask;
				}
			} else if (component.type === ELEMENTTYPE_TEXT) {
				if (data.autoWidth !== undefined) component.autoWidth = data.autoWidth;
				if (data.autoHeight !== undefined) component.autoHeight = data.autoHeight;
				if (data.rtlReorder !== undefined) component.rtlReorder = data.rtlReorder;
				if (data.unicodeConverter !== undefined) component.unicodeConverter = data.unicodeConverter;
				if (data.text !== null && data.text !== undefined) {
					component.text = data.text;
				} else if (data.key !== null && data.key !== undefined) {
					component.key = data.key;
				}
				if (data.color !== undefined) {
					color = data.color;
					if (! (color instanceof Color)) {
						color = new Color(color[0], color[1], color[2]);
					}
					component.color = color;
				}
				if (data.opacity !== undefined) {
					component.opacity = data.opacity;
				}
				if (data.spacing !== undefined) component.spacing = data.spacing;
				if (data.fontSize !== undefined) {
					component.fontSize = data.fontSize;
					if (!data.lineHeight) component.lineHeight = data.fontSize;
				}
				if (data.lineHeight !== undefined) component.lineHeight = data.lineHeight;
				if (data.maxLines !== undefined) component.maxLines = data.maxLines;
				if (data.wrapLines !== undefined) component.wrapLines = data.wrapLines;
				if (data.minFontSize !== undefined) component.minFontSize = data.minFontSize;
				if (data.maxFontSize !== undefined) component.maxFontSize = data.maxFontSize;
				if (data.autoFitWidth) component.autoFitWidth = data.autoFitWidth;
				if (data.autoFitHeight) component.autoFitHeight = data.autoFitHeight;
				if (data.fontAsset !== undefined) component.fontAsset = data.fontAsset;
				if (data.font !== undefined) component.font = data.font;
				if (data.alignment !== undefined) component.alignment = data.alignment;
				if (data.outlineColor !== undefined) component.outlineColor = data.outlineColor;
				if (data.outlineThickness !== undefined) component.outlineThickness = data.outlineThickness;
				if (data.shadowColor !== undefined) component.shadowColor = data.shadowColor;
				if (data.shadowOffset !== undefined) component.shadowOffset = data.shadowOffset;
				if (data.enableMarkup !== undefined) component.enableMarkup = data.enableMarkup;
			}
			var result = component._parseUpToScreen();
			if (result.screen) {
				component._updateScreen(result.screen);
			}
			ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
			component._beingInitialized = false;
			if (component.type === ELEMENTTYPE_IMAGE && component._image._meshDirty) {
				component._image._updateMesh(component._image.mesh);
			}
		},
		onRemoveComponent: function (entity, component) {
			component.onRemove();
		},
		cloneComponent: function (entity, clone) {
			var source = entity.element;
			var data = {
				enabled: source.enabled,
				width: source.width,
				height: source.height,
				anchor: source.anchor.clone(),
				pivot: source.pivot.clone(),
				margin: source.margin.clone(),
				alignment: source.alignment && source.alignment.clone() || source.alignment,
				autoWidth: source.autoWidth,
				autoHeight: source.autoHeight,
				type: source.type,
				rect: source.rect && source.rect.clone() || source.rect,
				rtlReorder: source.rtlReorder,
				unicodeConverter: source.unicodeConverter,
				materialAsset: source.materialAsset,
				material: source.material,
				color: source.color && source.color.clone() || source.color,
				opacity: source.opacity,
				textureAsset: source.textureAsset,
				texture: source.texture,
				spriteAsset: source.spriteAsset,
				sprite: source.sprite,
				spriteFrame: source.spriteFrame,
				pixelsPerUnit: source.pixelsPerUnit,
				spacing: source.spacing,
				lineHeight: source.lineHeight,
				wrapLines: source.wrapLines,
				layers: source.layers,
				fontSize: source.fontSize,
				minFontSize: source.minFontSize,
				maxFontSize: source.maxFontSize,
				autoFitWidth: source.autoFitWidth,
				autoFitHeight: source.autoFitHeight,
				maxLines: source.maxLines,
				fontAsset: source.fontAsset,
				font: source.font,
				useInput: source.useInput,
				batchGroupId: source.batchGroupId,
				mask: source.mask,
				outlineColor: source.outlineColor && source.outlineColor.clone() || source.outlineColor,
				outlineThickness: source.outlineThickness,
				shadowColor: source.shadowColor && source.shadowColor.clone() || source.shadowColor,
				shadowOffset: source.shadowOffset && source.shadowOffset.clone() || source.shadowOffset,
				enableMarkup: source.enableMarkup
			};
			if (source.key !== undefined && source.key !== null) {
				data.key = source.key;
			} else {
				data.text = source.text;
			}
			return this.addComponent(clone, data);
		},
		getTextElementMaterial: function (screenSpace, msdf) {
			if (screenSpace) {
				if (msdf) {
					if (!this.defaultScreenSpaceTextMaterial) {
						this.defaultScreenSpaceTextMaterial = new StandardMaterial();
						this.defaultScreenSpaceTextMaterial.name = "defaultScreenSpaceTextMaterial";
						this.defaultScreenSpaceTextMaterial.msdfMap = this._defaultTexture;
						this.defaultScreenSpaceTextMaterial.useLighting = false;
						this.defaultScreenSpaceTextMaterial.useGammaTonemap = false;
						this.defaultScreenSpaceTextMaterial.useFog = false;
						this.defaultScreenSpaceTextMaterial.useSkybox = false;
						this.defaultScreenSpaceTextMaterial.diffuse.set(0, 0, 0);
						this.defaultScreenSpaceTextMaterial.emissive.set(1, 1, 1);
						this.defaultScreenSpaceTextMaterial.opacity = 0.5;
						this.defaultScreenSpaceTextMaterial.blendType = BLEND_PREMULTIPLIED;
						this.defaultScreenSpaceTextMaterial.depthWrite = false;
						this.defaultScreenSpaceTextMaterial.depthTest = false;
						this.defaultScreenSpaceTextMaterial.emissiveVertexColor = true;
						this.defaultScreenSpaceTextMaterial.update();
					}
					return this.defaultScreenSpaceTextMaterial;
				}
				if (!this.defaultScreenSpaceBitmapTextMaterial) {
					this.defaultScreenSpaceBitmapTextMaterial = new StandardMaterial();
					this.defaultScreenSpaceBitmapTextMaterial.name = "defaultScreenSpaceBitmapTextMaterial";
					this.defaultScreenSpaceBitmapTextMaterial.emissive.set(0.5, 0.5, 0.5);
					this.defaultScreenSpaceBitmapTextMaterial.emissiveMap = this._defaultTexture;
					this.defaultScreenSpaceBitmapTextMaterial.emissiveTint = true;
					this.defaultScreenSpaceBitmapTextMaterial.opacity = 0.5;
					this.defaultScreenSpaceBitmapTextMaterial.opacityMap = this._defaultTexture;
					this.defaultScreenSpaceBitmapTextMaterial.opacityMapChannel = 'a';
					this.defaultScreenSpaceBitmapTextMaterial.useLighting = false;
					this.defaultScreenSpaceBitmapTextMaterial.useGammaTonemap = false;
					this.defaultScreenSpaceBitmapTextMaterial.useFog = false;
					this.defaultScreenSpaceBitmapTextMaterial.useSkybox = false;
					this.defaultScreenSpaceBitmapTextMaterial.diffuse.set(0, 0, 0);
					this.defaultScreenSpaceBitmapTextMaterial.blendType = BLEND_PREMULTIPLIED;
					this.defaultScreenSpaceBitmapTextMaterial.depthWrite = false;
					this.defaultScreenSpaceBitmapTextMaterial.depthTest = false;
					this.defaultScreenSpaceBitmapTextMaterial.emissiveVertexColor = true;
					this.defaultScreenSpaceBitmapTextMaterial.update();
				}
				return this.defaultScreenSpaceBitmapTextMaterial;
			}
			if (msdf) {
				if (!this.defaultTextMaterial) {
					this.defaultTextMaterial = new StandardMaterial();
					this.defaultTextMaterial.name = "defaultTextMaterial";
					this.defaultTextMaterial.msdfMap = this._defaultTexture;
					this.defaultTextMaterial.useLighting = false;
					this.defaultTextMaterial.useGammaTonemap = false;
					this.defaultTextMaterial.useFog = false;
					this.defaultTextMaterial.useSkybox = false;
					this.defaultTextMaterial.diffuse.set(0, 0, 0);
					this.defaultTextMaterial.emissive.set(1, 1, 1);
					this.defaultTextMaterial.opacity = 0.5;
					this.defaultTextMaterial.blendType = BLEND_PREMULTIPLIED;
					this.defaultTextMaterial.depthWrite = false;
					this.defaultTextMaterial.emissiveVertexColor = true;
					this.defaultTextMaterial.update();
				}
				return this.defaultTextMaterial;
			}
			if (!this.defaultBitmapTextMaterial) {
				this.defaultBitmapTextMaterial = new StandardMaterial();
				this.defaultBitmapTextMaterial.name = "defaultBitmapTextMaterial";
				this.defaultBitmapTextMaterial.emissive.set(0.5, 0.5, 0.5);
				this.defaultBitmapTextMaterial.emissiveTint = true;
				this.defaultBitmapTextMaterial.emissiveMap = this._defaultTexture;
				this.defaultBitmapTextMaterial.opacity = 0.5;
				this.defaultBitmapTextMaterial.opacityMap = this._defaultTexture;
				this.defaultBitmapTextMaterial.opacityMapChannel = 'a';
				this.defaultBitmapTextMaterial.useLighting = false;
				this.defaultBitmapTextMaterial.useGammaTonemap = false;
				this.defaultBitmapTextMaterial.useFog = false;
				this.defaultBitmapTextMaterial.useSkybox = false;
				this.defaultBitmapTextMaterial.diffuse.set(0, 0, 0);
				this.defaultBitmapTextMaterial.blendType = BLEND_PREMULTIPLIED;
				this.defaultBitmapTextMaterial.depthWrite = false;
				this.defaultBitmapTextMaterial.emissiveVertexColor = true;
				this.defaultBitmapTextMaterial.update();
			}
			return this.defaultBitmapTextMaterial;
		},
		_createBaseImageMaterial: function () {
			var material = new StandardMaterial();
			material.diffuse.set(0, 0, 0);
			material.emissive.set(0.5, 0.5, 0.5);
			material.emissiveMap = this._defaultTexture;
			material.emissiveTint = true;
			material.opacityMap = this._defaultTexture;
			material.opacityMapChannel = "a";
			material.opacityTint = true;
			material.opacity = 0;
			material.useLighting = false;
			material.useGammaTonemap = false;
			material.useFog = false;
			material.useSkybox = false;
			material.blendType = BLEND_PREMULTIPLIED;
			material.depthWrite = false;
			return material;
		},
		getImageElementMaterial: function (screenSpace, mask, nineSliced, nineSliceTiled) {
			if (screenSpace) {
				if (mask) {
					if (nineSliced) {
						if (!this.defaultScreenSpaceImageMask9SlicedMaterial) {
							this.defaultScreenSpaceImageMask9SlicedMaterial = this._createBaseImageMaterial();
							this.defaultScreenSpaceImageMask9SlicedMaterial.name = "defaultScreenSpaceImageMask9SlicedMaterial";
							this.defaultScreenSpaceImageMask9SlicedMaterial.nineSlicedMode = SPRITE_RENDERMODE_SLICED;
							this.defaultScreenSpaceImageMask9SlicedMaterial.depthTest = false;
							this.defaultScreenSpaceImageMask9SlicedMaterial.alphaTest = 1;
							this.defaultScreenSpaceImageMask9SlicedMaterial.redWrite = false;
							this.defaultScreenSpaceImageMask9SlicedMaterial.greenWrite = false;
							this.defaultScreenSpaceImageMask9SlicedMaterial.blueWrite = false;
							this.defaultScreenSpaceImageMask9SlicedMaterial.alphaWrite = false;
							this.defaultScreenSpaceImageMask9SlicedMaterial.update();
							this.defaultImageMaterials.push(this.defaultScreenSpaceImageMask9SlicedMaterial);
						}
						return this.defaultScreenSpaceImageMask9SlicedMaterial;
					} else if (nineSliceTiled) {
						if (!this.defaultScreenSpaceImageMask9TiledMaterial) {
							this.defaultScreenSpaceImageMask9TiledMaterial = this.defaultScreenSpaceImage9TiledMaterial.clone();
							this.defaultScreenSpaceImageMask9TiledMaterial.name = "defaultScreenSpaceImageMask9TiledMaterial";
							this.defaultScreenSpaceImageMask9TiledMaterial.nineSlicedMode = SPRITE_RENDERMODE_TILED;
							this.defaultScreenSpaceImageMask9TiledMaterial.depthTest = false;
							this.defaultScreenSpaceImageMask9TiledMaterial.alphaTest = 1;
							this.defaultScreenSpaceImageMask9TiledMaterial.redWrite = false;
							this.defaultScreenSpaceImageMask9TiledMaterial.greenWrite = false;
							this.defaultScreenSpaceImageMask9TiledMaterial.blueWrite = false;
							this.defaultScreenSpaceImageMask9TiledMaterial.alphaWrite = false;
							this.defaultScreenSpaceImageMask9TiledMaterial.update();
							this.defaultImageMaterials.push(this.defaultScreenSpaceImageMask9TiledMaterial);
						}
						return this.defaultScreenSpaceImageMask9TiledMaterial;
					} else {
						if (!this.defaultScreenSpaceImageMaskMaterial) {
							this.defaultScreenSpaceImageMaskMaterial = this._createBaseImageMaterial();
							this.defaultScreenSpaceImageMaskMaterial.name = "defaultScreenSpaceImageMaskMaterial";
							this.defaultScreenSpaceImageMaskMaterial.depthTest = false;
							this.defaultScreenSpaceImageMaskMaterial.alphaTest = 1;
							this.defaultScreenSpaceImageMaskMaterial.redWrite = false;
							this.defaultScreenSpaceImageMaskMaterial.greenWrite = false;
							this.defaultScreenSpaceImageMaskMaterial.blueWrite = false;
							this.defaultScreenSpaceImageMaskMaterial.alphaWrite = false;
							this.defaultScreenSpaceImageMaskMaterial.update();
							this.defaultImageMaterials.push(this.defaultScreenSpaceImageMaskMaterial);
						}
						return this.defaultScreenSpaceImageMaskMaterial;
					}
				} else {
					if (nineSliced) {
						if (!this.defaultScreenSpaceImage9SlicedMaterial) {
							this.defaultScreenSpaceImage9SlicedMaterial = this._createBaseImageMaterial();
							this.defaultScreenSpaceImage9SlicedMaterial.name = "defaultScreenSpaceImage9SlicedMaterial";
							this.defaultScreenSpaceImage9SlicedMaterial.nineSlicedMode = SPRITE_RENDERMODE_SLICED;
							this.defaultScreenSpaceImage9SlicedMaterial.depthTest = false;
							this.defaultScreenSpaceImage9SlicedMaterial.update();
							this.defaultImageMaterials.push(this.defaultScreenSpaceImage9SlicedMaterial);
						}
						return this.defaultScreenSpaceImage9SlicedMaterial;
					} else if (nineSliceTiled) {
						if (!this.defaultScreenSpaceImage9TiledMaterial) {
							this.defaultScreenSpaceImage9TiledMaterial = this._createBaseImageMaterial();
							this.defaultScreenSpaceImage9TiledMaterial.name = "defaultScreenSpaceImage9TiledMaterial";
							this.defaultScreenSpaceImage9TiledMaterial.nineSlicedMode = SPRITE_RENDERMODE_TILED;
							this.defaultScreenSpaceImage9TiledMaterial.depthTest = false;
							this.defaultScreenSpaceImage9TiledMaterial.update();
							this.defaultImageMaterials.push(this.defaultScreenSpaceImage9TiledMaterial);
						}
						return this.defaultScreenSpaceImage9TiledMaterial;
					} else {
						if (!this.defaultScreenSpaceImageMaterial) {
							this.defaultScreenSpaceImageMaterial = this._createBaseImageMaterial();
							this.defaultScreenSpaceImageMaterial.name = "defaultScreenSpaceImageMaterial";
							this.defaultScreenSpaceImageMaterial.depthTest = false;
							this.defaultScreenSpaceImageMaterial.update();
							this.defaultImageMaterials.push(this.defaultScreenSpaceImageMaterial);
						}
						return this.defaultScreenSpaceImageMaterial;
					}
				}
			} else {
				if (mask) {
					if (nineSliced) {
						if (!this.defaultImage9SlicedMaskMaterial) {
							this.defaultImage9SlicedMaskMaterial = this._createBaseImageMaterial();
							this.defaultImage9SlicedMaskMaterial.name = "defaultImage9SlicedMaskMaterial";
							this.defaultImage9SlicedMaskMaterial.nineSlicedMode = SPRITE_RENDERMODE_SLICED;
							this.defaultImage9SlicedMaskMaterial.alphaTest = 1;
							this.defaultImage9SlicedMaskMaterial.redWrite = false;
							this.defaultImage9SlicedMaskMaterial.greenWrite = false;
							this.defaultImage9SlicedMaskMaterial.blueWrite = false;
							this.defaultImage9SlicedMaskMaterial.alphaWrite = false;
							this.defaultImage9SlicedMaskMaterial.update();
							this.defaultImageMaterials.push(this.defaultImage9SlicedMaskMaterial);
						}
						return this.defaultImage9SlicedMaskMaterial;
					} else if (nineSliceTiled) {
						if (!this.defaultImage9TiledMaskMaterial) {
							this.defaultImage9TiledMaskMaterial = this._createBaseImageMaterial();
							this.defaultImage9TiledMaskMaterial.name = "defaultImage9TiledMaskMaterial";
							this.defaultImage9TiledMaskMaterial.nineSlicedMode = SPRITE_RENDERMODE_TILED;
							this.defaultImage9TiledMaskMaterial.alphaTest = 1;
							this.defaultImage9TiledMaskMaterial.redWrite = false;
							this.defaultImage9TiledMaskMaterial.greenWrite = false;
							this.defaultImage9TiledMaskMaterial.blueWrite = false;
							this.defaultImage9TiledMaskMaterial.alphaWrite = false;
							this.defaultImage9TiledMaskMaterial.update();
							this.defaultImageMaterials.push(this.defaultImage9TiledMaskMaterial);
						}
						return this.defaultImage9TiledMaskMaterial;
					} else {
						if (!this.defaultImageMaskMaterial) {
							this.defaultImageMaskMaterial = this._createBaseImageMaterial();
							this.defaultImageMaskMaterial.name = "defaultImageMaskMaterial";
							this.defaultImageMaskMaterial.alphaTest = 1;
							this.defaultImageMaskMaterial.redWrite = false;
							this.defaultImageMaskMaterial.greenWrite = false;
							this.defaultImageMaskMaterial.blueWrite = false;
							this.defaultImageMaskMaterial.alphaWrite = false;
							this.defaultImageMaskMaterial.update();
							this.defaultImageMaterials.push(this.defaultImageMaskMaterial);
						}
						return this.defaultImageMaskMaterial;
					}
				} else {
					if (nineSliced) {
						if (!this.defaultImage9SlicedMaterial) {
							this.defaultImage9SlicedMaterial = this._createBaseImageMaterial();
							this.defaultImage9SlicedMaterial.name = "defaultImage9SlicedMaterial";
							this.defaultImage9SlicedMaterial.nineSlicedMode = SPRITE_RENDERMODE_SLICED;
							this.defaultImage9SlicedMaterial.update();
							this.defaultImageMaterials.push(this.defaultImage9SlicedMaterial);
						}
						return this.defaultImage9SlicedMaterial;
					} else if (nineSliceTiled) {
						if (!this.defaultImage9TiledMaterial) {
							this.defaultImage9TiledMaterial = this._createBaseImageMaterial();
							this.defaultImage9TiledMaterial.name = "defaultImage9TiledMaterial";
							this.defaultImage9TiledMaterial.nineSlicedMode = SPRITE_RENDERMODE_TILED;
							this.defaultImage9TiledMaterial.update();
							this.defaultImageMaterials.push(this.defaultImage9TiledMaterial);
						}
						return this.defaultImage9TiledMaterial;
					} else {
						if (!this.defaultImageMaterial) {
							this.defaultImageMaterial = this._createBaseImageMaterial();
							this.defaultImageMaterial.name = "defaultImageMaterial";
							this.defaultImageMaterial.update();
							this.defaultImageMaterials.push(this.defaultImageMaterial);
						}
						return this.defaultImageMaterial;
					}
				}
			}
		},
		registerUnicodeConverter: function (func) {
			this._unicodeConverter = func;
		},
		registerRtlReorder: function (func) {
			this._rtlReorder = func;
		},
		getUnicodeConverter: function () {
			return this._unicodeConverter;
		},
		getRtlReorder: function () {
			return this._rtlReorder;
		}
	});

	function LayoutChildComponent(system, entity) {
		Component.call(this, system, entity);
		this._minWidth = 0;
		this._minHeight = 0;
		this._maxWidth = null;
		this._maxHeight = null;
		this._fitWidthProportion = 0;
		this._fitHeightProportion = 0;
		this._excludeFromLayout = false;
	}
	LayoutChildComponent.prototype = Object.create(Component.prototype);
	LayoutChildComponent.prototype.constructor = LayoutChildComponent;
	function defineResizeProperty(name) {
		var _name = '_' + name;
		Object.defineProperty(LayoutChildComponent.prototype, name, {
			get: function () {
				return this[_name];
			},
			set: function (value) {
				if (this[_name] !== value) {
					this[_name] = value;
					this.fire('resize');
				}
			}
		});
	}
	defineResizeProperty('minWidth');
	defineResizeProperty('minHeight');
	defineResizeProperty('maxWidth');
	defineResizeProperty('maxHeight');
	defineResizeProperty('fitWidthProportion');
	defineResizeProperty('fitHeightProportion');
	defineResizeProperty('excludeFromLayout');

	function LayoutChildComponentData() {
		this.enabled = true;
	}

	var _schema$8 = ['enabled'];
	var LayoutChildComponentSystem = function LayoutChildComponentSystem(app) {
		ComponentSystem.call(this, app);
		this.id = 'layoutchild';
		this.ComponentType = LayoutChildComponent;
		this.DataType = LayoutChildComponentData;
		this.schema = _schema$8;
	};
	LayoutChildComponentSystem.prototype = Object.create(ComponentSystem.prototype);
	LayoutChildComponentSystem.prototype.constructor = LayoutChildComponentSystem;
	Component._buildAccessors(LayoutChildComponent.prototype, _schema$8);
	Object.assign(LayoutChildComponentSystem.prototype, {
		initializeComponentData: function (component, data, properties) {
			if (data.enabled !== undefined) component.enabled = data.enabled;
			if (data.minWidth !== undefined) component.minWidth = data.minWidth;
			if (data.minHeight !== undefined) component.minHeight = data.minHeight;
			if (data.maxWidth !== undefined) component.maxWidth = data.maxWidth;
			if (data.maxHeight !== undefined) component.maxHeight = data.maxHeight;
			if (data.fitWidthProportion !== undefined) component.fitWidthProportion = data.fitWidthProportion;
			if (data.fitHeightProportion !== undefined) component.fitHeightProportion = data.fitHeightProportion;
			if (data.excludeFromLayout !== undefined) component.excludeFromLayout = data.excludeFromLayout;
			ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
		},
		cloneComponent: function (entity, clone) {
			var layoutChild = entity.layoutchild;
			return this.addComponent(clone, {
				enabled: layoutChild.enabled,
				minWidth: layoutChild.minWidth,
				minHeight: layoutChild.minHeight,
				maxWidth: layoutChild.maxWidth,
				maxHeight: layoutChild.maxHeight,
				fitWidthProportion: layoutChild.fitWidthProportion,
				fitHeightProportion: layoutChild.fitHeightProportion,
				excludeFromLayout: layoutChild.excludeFromLayout
			});
		}
	});

	var FITTING_NONE = 0;
	var FITTING_STRETCH = 1;
	var FITTING_SHRINK = 2;
	var FITTING_BOTH = 3;

	function LayoutCalculator() {}
	var AXIS_MAPPINGS = {};
	AXIS_MAPPINGS[ORIENTATION_HORIZONTAL] = {
		axis: 'x',
		size: 'width',
		calculatedSize: 'calculatedWidth',
		minSize: 'minWidth',
		maxSize: 'maxWidth',
		fitting: 'widthFitting',
		fittingProportion: 'fitWidthProportion'
	};
	AXIS_MAPPINGS[ORIENTATION_VERTICAL] = {
		axis: 'y',
		size: 'height',
		calculatedSize: 'calculatedHeight',
		minSize: 'minHeight',
		maxSize: 'maxHeight',
		fitting: 'heightFitting',
		fittingProportion: 'fitHeightProportion'
	};
	var OPPOSITE_ORIENTATION = {};
	OPPOSITE_ORIENTATION[ORIENTATION_HORIZONTAL] = ORIENTATION_VERTICAL;
	OPPOSITE_ORIENTATION[ORIENTATION_VERTICAL] = ORIENTATION_HORIZONTAL;
	var PROPERTY_DEFAULTS = {
		minWidth: 0,
		minHeight: 0,
		maxWidth: Number.POSITIVE_INFINITY,
		maxHeight: Number.POSITIVE_INFINITY,
		width: null,
		height: null,
		fitWidthProportion: 0,
		fitHeightProportion: 0
	};
	var FITTING_ACTION = {
		NONE: 'NONE',
		APPLY_STRETCHING: 'APPLY_STRETCHING',
		APPLY_SHRINKING: 'APPLY_SHRINKING'
	};
	var availableSpace = new Vec2();
	function createCalculator(orientation) {
		var options;
		var a = AXIS_MAPPINGS[orientation];
		var b = AXIS_MAPPINGS[OPPOSITE_ORIENTATION[orientation]];
		function minExtentA(element, size) {return -size[a.size] * element.pivot[a.axis]; }
		function minExtentB(element, size) { return -size[b.size] * element.pivot[b.axis]; }
		function maxExtentA(element, size) { return  size[a.size] * (1 - element.pivot[a.axis]); }
		function calculateAll(allElements, layoutOptions) {
			allElements = allElements.filter(shouldIncludeInLayout);
			options = layoutOptions;
			availableSpace.x = options.containerSize.x - options.padding.x - options.padding.z;
			availableSpace.y = options.containerSize.y - options.padding.y - options.padding.w;
			resetAnchors(allElements);
			var lines = reverseLinesIfRequired(splitLines(allElements));
			var sizes = calculateSizesOnAxisB(lines, calculateSizesOnAxisA(lines));
			var positions = calculateBasePositions(lines, sizes);
			applyAlignmentAndPadding(lines, sizes, positions);
			applySizesAndPositions(lines, sizes, positions);
			return createLayoutInfo(lines);
		}
		function shouldIncludeInLayout(element) {
			var layoutChildComponent = element.entity.layoutchild;
			return !layoutChildComponent || !layoutChildComponent.enabled || !layoutChildComponent.excludeFromLayout;
		}
		function resetAnchors(allElements) {
			for (var i = 0; i < allElements.length; ++i) {
				var element = allElements[i];
				var anchor = element.anchor;
				if (anchor.x !== 0 || anchor.y !== 0 || anchor.z !== 0 || anchor.w !== 0) {
					element.anchor = Vec4.ZERO;
				}
			}
		}
		function splitLines(allElements) {
			if (!options.wrap) {
				return [allElements];
			}
			var lines = [[]];
			var sizes = getElementSizeProperties(allElements);
			var runningSize = 0;
			var allowOverrun = (options[a.fitting] === FITTING_SHRINK);
			for (var i = 0; i < allElements.length; ++i) {
				if (lines[lines.length - 1].length > 0) {
					runningSize += options.spacing[a.axis];
				}
				var idealElementSize = sizes[i][a.size];
				runningSize += idealElementSize;
				if (!allowOverrun && runningSize > availableSpace[a.axis] && lines[lines.length - 1].length !== 0) {
					runningSize = idealElementSize;
					lines.push([]);
				}
				lines[lines.length - 1].push(allElements[i]);
				if (allowOverrun && runningSize > availableSpace[a.axis] && i !== allElements.length - 1) {
					runningSize = 0;
					lines.push([]);
				}
			}
			return lines;
		}
		function reverseLinesIfRequired(lines) {
			var reverseAxisA = (options.orientation === ORIENTATION_HORIZONTAL && options.reverseX) ||
							   (options.orientation === ORIENTATION_VERTICAL   && options.reverseY);
			var reverseAxisB = (options.orientation === ORIENTATION_HORIZONTAL && options.reverseY) ||
							   (options.orientation === ORIENTATION_VERTICAL   && options.reverseX);
			if (reverseAxisA) {
				for (var lineIndex = 0; lineIndex < lines.length; ++lineIndex) {
					if (reverseAxisA) {
						lines[lineIndex].reverse();
					}
				}
			}
			if (reverseAxisB) {
				lines.reverse();
			}
			return lines;
		}
		function calculateSizesOnAxisA(lines) {
			var sizesAllLines = [];
			for (var lineIndex = 0; lineIndex < lines.length; ++lineIndex) {
				var line = lines[lineIndex];
				var sizesThisLine = getElementSizeProperties(line);
				var idealRequiredSpace = calculateTotalSpace(sizesThisLine, a);
				var fittingAction = determineFittingAction(options[a.fitting], idealRequiredSpace, availableSpace[a.axis]);
				if (fittingAction === FITTING_ACTION.APPLY_STRETCHING) {
					stretchSizesToFitContainer(sizesThisLine, idealRequiredSpace, a);
				} else if (fittingAction === FITTING_ACTION.APPLY_SHRINKING) {
					shrinkSizesToFitContainer(sizesThisLine, idealRequiredSpace, a);
				}
				sizesAllLines.push(sizesThisLine);
			}
			return sizesAllLines;
		}
		function calculateSizesOnAxisB(lines, sizesAllLines) {
			var largestElementsForEachLine = [];
			var largestSizesForEachLine = [];
			var elementIndex;
			var lineIndex;
			var line;
			for (lineIndex = 0; lineIndex < lines.length; ++lineIndex) {
				line = lines[lineIndex];
				line.largestElement = null;
				line.largestSize = { width: Number.NEGATIVE_INFINITY, height: Number.NEGATIVE_INFINITY };
				for (elementIndex = 0; elementIndex < line.length; ++elementIndex) {
					var sizesThisElement = sizesAllLines[lineIndex][elementIndex];
					if (sizesThisElement[b.size] > line.largestSize[b.size]) {
						line.largestElement = line[elementIndex];
						line.largestSize = sizesThisElement;
					}
				}
				largestElementsForEachLine.push(line.largestElement);
				largestSizesForEachLine.push(line.largestSize);
			}
			var idealRequiredSpace = calculateTotalSpace(largestSizesForEachLine, b);
			var fittingAction = determineFittingAction(options[b.fitting], idealRequiredSpace, availableSpace[b.axis]);
			if (fittingAction === FITTING_ACTION.APPLY_STRETCHING) {
				stretchSizesToFitContainer(largestSizesForEachLine, idealRequiredSpace, b);
			} else if (fittingAction === FITTING_ACTION.APPLY_SHRINKING) {
				shrinkSizesToFitContainer(largestSizesForEachLine, idealRequiredSpace, b);
			}
			for (lineIndex = 0; lineIndex < lines.length; ++lineIndex) {
				line = lines[lineIndex];
				for (elementIndex = 0; elementIndex < line.length; ++elementIndex) {
					var sizesForThisElement = sizesAllLines[lineIndex][elementIndex];
					var currentSize = sizesForThisElement[b.size];
					var availableSize = lines.length === 1 ? availableSpace[b.axis] : line.largestSize[b.size];
					var elementFittingAction = determineFittingAction(options[b.fitting], currentSize, availableSize);
					if (elementFittingAction === FITTING_ACTION.APPLY_STRETCHING) {
						sizesForThisElement[b.size] = Math.min(availableSize, sizesForThisElement[b.maxSize]);
					} else if (elementFittingAction === FITTING_ACTION.APPLY_SHRINKING) {
						sizesForThisElement[b.size] = Math.max(availableSize, sizesForThisElement[b.minSize]);
					}
				}
			}
			return sizesAllLines;
		}
		function determineFittingAction(fittingMode, currentSize, availableSize) {
			switch (fittingMode) {
				case FITTING_NONE:
					return FITTING_ACTION.NONE;
				case FITTING_STRETCH:
					if (currentSize < availableSize) {
						return FITTING_ACTION.APPLY_STRETCHING;
					}
					return FITTING_ACTION.NONE;
				case FITTING_SHRINK:
					if (currentSize >= availableSize) {
						return FITTING_ACTION.APPLY_SHRINKING;
					}
					return FITTING_ACTION.NONE;
				case FITTING_BOTH:
					if (currentSize < availableSize) {
						return FITTING_ACTION.APPLY_STRETCHING;
					} else if (currentSize >= availableSize) {
						return FITTING_ACTION.APPLY_SHRINKING;
					}
					return FITTING_ACTION.NONE;
				default:
					throw new Error('Unrecognized fitting mode: ' + fittingMode);
			}
		}
		function calculateTotalSpace(sizes, axis) {
			var totalSizes = sumValues(sizes, axis.size);
			var totalSpacing = (sizes.length - 1) * options.spacing[axis.axis];
			return totalSizes + totalSpacing;
		}
		function stretchSizesToFitContainer(sizesThisLine, idealRequiredSpace, axis) {
			var ascendingMaxSizeOrder = getTraversalOrder(sizesThisLine, axis.maxSize);
			var fittingProportions = getNormalizedValues(sizesThisLine, axis.fittingProportion);
			var fittingProportionSums = createSumArray(fittingProportions, ascendingMaxSizeOrder);
			var remainingUndershoot = availableSpace[axis.axis] - idealRequiredSpace;
			for (var i = 0; i < sizesThisLine.length; ++i) {
				var index = ascendingMaxSizeOrder[i];
				var targetIncrease = calculateAdjustment(index, remainingUndershoot, fittingProportions, fittingProportionSums);
				var targetSize = sizesThisLine[index][axis.size] + targetIncrease;
				var maxSize = sizesThisLine[index][axis.maxSize];
				var actualSize = Math.min(targetSize, maxSize);
				sizesThisLine[index][axis.size] = actualSize;
				var actualIncrease = Math.max(targetSize - actualSize, 0);
				var appliedIncrease = targetIncrease - actualIncrease;
				remainingUndershoot -= appliedIncrease;
			}
		}
		function shrinkSizesToFitContainer(sizesThisLine, idealRequiredSpace, axis) {
			var descendingMinSizeOrder = getTraversalOrder(sizesThisLine, axis.minSize, true);
			var fittingProportions = getNormalizedValues(sizesThisLine, axis.fittingProportion);
			var inverseFittingProportions = invertNormalizedValues(fittingProportions);
			var inverseFittingProportionSums = createSumArray(inverseFittingProportions, descendingMinSizeOrder);
			var remainingOvershoot = idealRequiredSpace - availableSpace[axis.axis];
			for (var i = 0; i < sizesThisLine.length; ++i) {
				var index = descendingMinSizeOrder[i];
				var targetReduction = calculateAdjustment(index, remainingOvershoot, inverseFittingProportions, inverseFittingProportionSums);
				var targetSize = sizesThisLine[index][axis.size] - targetReduction;
				var minSize = sizesThisLine[index][axis.minSize];
				var actualSize = Math.max(targetSize, minSize);
				sizesThisLine[index][axis.size] = actualSize;
				var actualReduction = Math.max(actualSize - targetSize, 0);
				var appliedReduction = targetReduction - actualReduction;
				remainingOvershoot -= appliedReduction;
			}
		}
		function calculateAdjustment(index, remainingAdjustment, fittingProportions, fittingProportionSums) {
			var proportion = fittingProportions[index];
			var sumOfRemainingProportions = fittingProportionSums[index];
			if (Math.abs(proportion) < 1e-5 && Math.abs(sumOfRemainingProportions) < 1e-5) {
				return remainingAdjustment;
			}
			return remainingAdjustment * proportion / sumOfRemainingProportions;
		}
		function calculateBasePositions(lines, sizes) {
			var cursor = {};
			cursor[a.axis] = 0;
			cursor[b.axis] = 0;
			lines[a.size] = Number.NEGATIVE_INFINITY;
			var positionsAllLines = [];
			for (var lineIndex = 0; lineIndex < lines.length; ++lineIndex) {
				var line = lines[lineIndex];
				if (line.length === 0) {
					return;
				}
				var positionsThisLine = [];
				var sizesThisLine = sizes[lineIndex];
				for (var elementIndex = 0; elementIndex < line.length; ++elementIndex) {
					var element = line[elementIndex];
					var sizesThisElement = sizesThisLine[elementIndex];
					cursor[b.axis] -= minExtentB(element, sizesThisElement);
					cursor[a.axis] -= minExtentA(element, sizesThisElement);
					positionsThisLine[elementIndex] = {};
					positionsThisLine[elementIndex][a.axis] = cursor[a.axis];
					positionsThisLine[elementIndex][b.axis] = cursor[b.axis];
					cursor[b.axis] += minExtentB(element, sizesThisElement);
					cursor[a.axis] += maxExtentA(element, sizesThisElement) + options.spacing[a.axis];
				}
				line[a.size] = cursor[a.axis] - options.spacing[a.axis];
				line[b.size] = line.largestSize[b.size];
				lines[a.size] = Math.max(lines[a.size], line[a.size]);
				cursor[a.axis] = 0;
				cursor[b.axis] += line[b.size] + options.spacing[b.axis];
				positionsAllLines.push(positionsThisLine);
			}
			lines[b.size] = cursor[b.axis] - options.spacing[b.axis];
			return positionsAllLines;
		}
		function applyAlignmentAndPadding(lines, sizes, positions) {
			var alignmentA = options.alignment[a.axis];
			var alignmentB = options.alignment[b.axis];
			var paddingA = options.padding[a.axis];
			var paddingB = options.padding[b.axis];
			for (var lineIndex = 0; lineIndex < lines.length; ++lineIndex) {
				var line = lines[lineIndex];
				var sizesThisLine = sizes[lineIndex];
				var positionsThisLine = positions[lineIndex];
				var axisAOffset = (availableSpace[a.axis] - line[a.size])  * alignmentA + paddingA;
				var axisBOffset = (availableSpace[b.axis] - lines[b.size]) * alignmentB + paddingB;
				for (var elementIndex = 0; elementIndex < line.length; ++elementIndex) {
					var withinLineAxisBOffset = (line[b.size] - sizesThisLine[elementIndex][b.size]) * options.alignment[b.axis];
					positionsThisLine[elementIndex][a.axis] += axisAOffset;
					positionsThisLine[elementIndex][b.axis] += axisBOffset + withinLineAxisBOffset;
				}
			}
		}
		function applySizesAndPositions(lines, sizes, positions) {
			for (var lineIndex = 0; lineIndex < lines.length; ++lineIndex) {
				var line = lines[lineIndex];
				var sizesThisLine = sizes[lineIndex];
				var positionsThisLine = positions[lineIndex];
				for (var elementIndex = 0; elementIndex < line.length; ++elementIndex) {
					var element = line[elementIndex];
					element[a.calculatedSize] = sizesThisLine[elementIndex][a.size];
					element[b.calculatedSize] = sizesThisLine[elementIndex][b.size];
					if (options.orientation === ORIENTATION_HORIZONTAL) {
						element.entity.setLocalPosition(
							positionsThisLine[elementIndex][a.axis],
							positionsThisLine[elementIndex][b.axis],
							element.entity.getLocalPosition().z
						);
					} else {
						element.entity.setLocalPosition(
							positionsThisLine[elementIndex][b.axis],
							positionsThisLine[elementIndex][a.axis],
							element.entity.getLocalPosition().z
						);
					}
				}
			}
		}
		function createLayoutInfo(lines) {
			var layoutWidth = lines.width;
			var layoutHeight = lines.height;
			var xOffset = (availableSpace.x - layoutWidth) * options.alignment.x + options.padding.x;
			var yOffset = (availableSpace.y - layoutHeight) * options.alignment.y + options.padding.y;
			return {
				bounds: new Vec4(
					xOffset,
					yOffset,
					layoutWidth,
					layoutHeight
				)
			};
		}
		function getElementSizeProperties(elements) {
			var sizeProperties = [];
			for (var i = 0; i < elements.length; ++i) {
				var element = elements[i];
				var minWidth  = Math.max(getProperty(element, 'minWidth'), 0);
				var minHeight = Math.max(getProperty(element, 'minHeight'), 0);
				var maxWidth  = Math.max(getProperty(element, 'maxWidth'), minWidth);
				var maxHeight = Math.max(getProperty(element, 'maxHeight'), minHeight);
				var width  = clamp(getProperty(element, 'width'), minWidth, maxWidth);
				var height = clamp(getProperty(element, 'height'), minHeight, maxHeight);
				var fitWidthProportion  = getProperty(element, 'fitWidthProportion');
				var fitHeightProportion = getProperty(element, 'fitHeightProportion');
				sizeProperties.push({
					minWidth: minWidth,
					minHeight: minHeight,
					maxWidth: maxWidth,
					maxHeight: maxHeight,
					width: width,
					height: height,
					fitWidthProportion: fitWidthProportion,
					fitHeightProportion: fitHeightProportion
				});
			}
			return sizeProperties;
		}
		function getProperty(element, propertyName) {
			var layoutChildComponent = element.entity.layoutchild;
			if (layoutChildComponent && layoutChildComponent.enabled && layoutChildComponent[propertyName] !== undefined && layoutChildComponent[propertyName] !== null) {
				return layoutChildComponent[propertyName];
			} else if (element[propertyName] !== undefined) {
				return element[propertyName];
			}
			return PROPERTY_DEFAULTS[propertyName];
		}
		function clamp(value, min, max) {
			return Math.min(Math.max(value, min), max);
		}
		function sumValues(items, propertyName) {
			return items.reduce(function (accumulator, current) {
				return accumulator + current[propertyName];
			}, 0);
		}
		function getNormalizedValues(items, propertyName) {
			var sum = sumValues(items, propertyName);
			var normalizedValues = [];
			var numItems = items.length;
			var i;
			if (sum === 0) {
				for (i = 0; i < numItems; ++i) {
					normalizedValues.push(1 / numItems);
				}
			} else {
				for (i = 0; i < numItems; ++i) {
					normalizedValues.push(items[i][propertyName] / sum);
				}
			}
			return normalizedValues;
		}
		function invertNormalizedValues(values) {
			if (values.length === 1) {
				return [1];
			}
			var invertedValues = [];
			var numValues = values.length;
			for (var i = 0; i < numValues; ++i) {
				invertedValues.push((1 - values[i]) / (numValues - 1));
			}
			return invertedValues;
		}
		function getTraversalOrder(items, orderBy, descending) {
			items.forEach(assignIndex);
			return items
				.slice()
				.sort(function (itemA, itemB) {
					return descending ? itemB[orderBy] - itemA[orderBy] : itemA[orderBy] - itemB[orderBy];
				})
				.map(getIndex);
		}
		function assignIndex(item, index) {
			item.index = index;
		}
		function getIndex(item) {
			return item.index;
		}
		function createSumArray(values, order) {
			var sumArray = [];
			sumArray[order[values.length - 1]] = values[order[values.length - 1]];
			for (var i = values.length - 2; i >= 0; --i) {
				sumArray[order[i]] = sumArray[order[i + 1]] + values[order[i]];
			}
			return sumArray;
		}
		return calculateAll;
	}
	var CALCULATE_FNS = {};
	CALCULATE_FNS[ORIENTATION_HORIZONTAL] = createCalculator(ORIENTATION_HORIZONTAL);
	CALCULATE_FNS[ORIENTATION_VERTICAL] = createCalculator(ORIENTATION_VERTICAL);
	Object.assign(LayoutCalculator.prototype, {
		calculateLayout: function (elements, options) {
			var calculateFn = CALCULATE_FNS[options.orientation];
			if (!calculateFn) {
				throw new Error('Unrecognized orientation value: ' + options.orientation);
			} else {
				return calculateFn(elements, options);
			}
		}
	});

	function LayoutGroupComponent(system, entity) {
		Component.call(this, system, entity);
		this._orientation = ORIENTATION_HORIZONTAL;
		this._reverseX = false;
		this._reverseY = true;
		this._alignment = new Vec2(0, 1);
		this._padding = new Vec4();
		this._spacing = new Vec2();
		this._widthFitting = FITTING_NONE;
		this._heightFitting = FITTING_NONE;
		this._wrap = false;
		this._layoutCalculator = new LayoutCalculator();
		this._listenForReflowEvents(this.entity, 'on');
		this.entity.children.forEach(function (child) {
			this._listenForReflowEvents(child, 'on');
		}.bind(this));
		this.entity.on('childinsert', this._onChildInsert, this);
		this.entity.on('childremove', this._onChildRemove, this);
		system.app.systems.element.on('add', this._onElementOrLayoutComponentAdd, this);
		system.app.systems.element.on('beforeremove', this._onElementOrLayoutComponentRemove, this);
		system.app.systems.layoutchild.on('add', this._onElementOrLayoutComponentAdd, this);
		system.app.systems.layoutchild.on('beforeremove', this._onElementOrLayoutComponentRemove, this);
	}
	LayoutGroupComponent.prototype = Object.create(Component.prototype);
	LayoutGroupComponent.prototype.constructor = LayoutGroupComponent;
	Object.assign(LayoutGroupComponent.prototype, {
		_isSelfOrChild: function (entity) {
			return (entity === this.entity) || (this.entity.children.indexOf(entity) !== -1);
		},
		_listenForReflowEvents: function (target, onOff) {
			if (target.element) {
				target.element[onOff]('enableelement', this._scheduleReflow, this);
				target.element[onOff]('disableelement', this._scheduleReflow, this);
				target.element[onOff]('resize', this._scheduleReflow, this);
				target.element[onOff]('set:pivot', this._scheduleReflow, this);
			}
			if (target.layoutchild) {
				target.layoutchild[onOff]('set_enabled', this._scheduleReflow, this);
				target.layoutchild[onOff]('resize', this._scheduleReflow, this);
			}
		},
		_onElementOrLayoutComponentAdd: function (entity) {
			if (this._isSelfOrChild(entity)) {
				this._listenForReflowEvents(entity, 'on');
				this._scheduleReflow();
			}
		},
		_onElementOrLayoutComponentRemove: function (entity) {
			if (this._isSelfOrChild(entity)) {
				this._listenForReflowEvents(entity, 'off');
				this._scheduleReflow();
			}
		},
		_onChildInsert: function (child) {
			this._listenForReflowEvents(child, 'on');
			this._scheduleReflow();
		},
		_onChildRemove: function (child) {
			this._listenForReflowEvents(child, 'off');
			this._scheduleReflow();
		},
		_scheduleReflow: function () {
			if (this.enabled && this.entity && this.entity.enabled && !this._isPerformingReflow) {
				this.system.scheduleReflow(this);
			}
		},
		reflow: function () {
			var container = getElement(this.entity);
			var elements = this.entity.children.filter(isEnabledAndHasEnabledElement).map(getElement);
			if (!container || elements.length === 0) {
				return;
			}
			var containerWidth = Math.max(container.calculatedWidth, 0);
			var containerHeight = Math.max(container.calculatedHeight, 0);
			var options = {
				orientation: this._orientation,
				reverseX: this._reverseX,
				reverseY: this._reverseY,
				alignment: this._alignment,
				padding: this._padding,
				spacing: this._spacing,
				widthFitting: this._widthFitting,
				heightFitting: this._heightFitting,
				wrap: this._wrap,
				containerSize: new Vec2(containerWidth, containerHeight)
			};
			this._isPerformingReflow = true;
			var layoutInfo = this._layoutCalculator.calculateLayout(elements, options);
			this._isPerformingReflow = false;
			this.fire('reflow', layoutInfo);
		},
		onEnable: function () {
			this._scheduleReflow();
		},
		onRemove: function () {
			this.entity.off('childinsert', this._onChildInsert, this);
			this.entity.off('childremove', this._onChildRemove, this);
			this._listenForReflowEvents(this.entity, 'off');
			this.entity.children.forEach(function (child) {
				this._listenForReflowEvents(child, 'off');
			}.bind(this));
			this.system.app.systems.element.off('add', this._onElementOrLayoutComponentAdd, this);
			this.system.app.systems.element.off('beforeremove', this._onElementOrLayoutComponentRemove, this);
			this.system.app.systems.layoutchild.off('add', this._onElementOrLayoutComponentAdd, this);
			this.system.app.systems.layoutchild.off('beforeremove', this._onElementOrLayoutComponentRemove, this);
		}
	});
	function getElement(entity) {
		return entity.element;
	}
	function isEnabledAndHasEnabledElement(entity) {
		return entity.enabled && entity.element && entity.element.enabled;
	}
	function defineReflowSchedulingProperty(name) {
		var _name = '_' + name;
		Object.defineProperty(LayoutGroupComponent.prototype, name, {
			get: function () {
				return this[_name];
			},
			set: function (value) {
				if (this[_name] !== value) {
					this[_name] = value;
					this._scheduleReflow();
				}
			}
		});
	}
	defineReflowSchedulingProperty('orientation');
	defineReflowSchedulingProperty('reverseX');
	defineReflowSchedulingProperty('reverseY');
	defineReflowSchedulingProperty('alignment');
	defineReflowSchedulingProperty('padding');
	defineReflowSchedulingProperty('spacing');
	defineReflowSchedulingProperty('widthFitting');
	defineReflowSchedulingProperty('heightFitting');
	defineReflowSchedulingProperty('wrap');

	function LayoutGroupComponentData() {
		this.enabled = true;
	}

	var _schema$9 = ['enabled'];
	var MAX_ITERATIONS = 100;
	function LayoutGroupComponentSystem(app) {
		ComponentSystem.call(this, app);
		this.id = 'layoutgroup';
		this.ComponentType = LayoutGroupComponent;
		this.DataType = LayoutGroupComponentData;
		this.schema = _schema$9;
		this._reflowQueue = [];
		this.on('beforeremove', this._onRemoveComponent, this);
		ComponentSystem.bind('postUpdate', this._onPostUpdate, this);
	}
	LayoutGroupComponentSystem.prototype = Object.create(ComponentSystem.prototype);
	LayoutGroupComponentSystem.prototype.constructor = LayoutGroupComponentSystem;
	Component._buildAccessors(LayoutGroupComponent.prototype, _schema$9);
	Object.assign(LayoutGroupComponentSystem.prototype, {
		initializeComponentData: function (component, data, properties) {
			if (data.enabled !== undefined) component.enabled = data.enabled;
			if (data.orientation !== undefined) component.orientation = data.orientation;
			if (data.reverseX !== undefined) component.reverseX = data.reverseX;
			if (data.reverseY !== undefined) component.reverseY = data.reverseY;
			if (data.alignment !== undefined) {
				if (data.alignment instanceof Vec2){
					component.alignment.copy(data.alignment);
				} else {
					component.alignment.set(data.alignment[0], data.alignment[1]);
				}
				component.alignment = component.alignment;
			}
			if (data.padding !== undefined) {
				if (data.padding instanceof Vec4){
					component.padding.copy(data.padding);
				} else {
					component.padding.set(data.padding[0], data.padding[1], data.padding[2], data.padding[3]);
				}
				component.padding = component.padding;
			}
			if (data.spacing !== undefined) {
				if (data.spacing instanceof Vec2){
					component.spacing.copy(data.spacing);
				} else {
					component.spacing.set(data.spacing[0], data.spacing[1]);
				}
				component.spacing = component.spacing;
			}
			if (data.widthFitting !== undefined) component.widthFitting = data.widthFitting;
			if (data.heightFitting !== undefined) component.heightFitting = data.heightFitting;
			if (data.wrap !== undefined) component.wrap = data.wrap;
			ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
		},
		cloneComponent: function (entity, clone) {
			var layoutGroup = entity.layoutgroup;
			return this.addComponent(clone, {
				enabled: layoutGroup.enabled,
				orientation: layoutGroup.orientation,
				reverseX: layoutGroup.reverseX,
				reverseY: layoutGroup.reverseY,
				alignment: layoutGroup.alignment,
				padding: layoutGroup.padding,
				spacing: layoutGroup.spacing,
				widthFitting: layoutGroup.widthFitting,
				heightFitting: layoutGroup.heightFitting,
				wrap: layoutGroup.wrap
			});
		},
		scheduleReflow: function (component) {
			if (this._reflowQueue.indexOf(component) === -1) {
				this._reflowQueue.push(component);
			}
		},
		_onPostUpdate: function () {
			this._processReflowQueue();
		},
		_processReflowQueue: function () {
			if (this._reflowQueue.length === 0) {
				return;
			}
			var iterationCount = 0;
			while (this._reflowQueue.length > 0) {
				var queue = this._reflowQueue.slice();
				this._reflowQueue.length = 0;
				queue.sort(function (componentA, componentB) {
					return (componentA.entity.graphDepth - componentB.entity.graphDepth);
				});
				for (var i = 0; i < queue.length; ++i) {
					queue[i].reflow();
				}
				if (++iterationCount >= MAX_ITERATIONS) {
					console.warn('Max reflow iterations limit reached, bailing.');
					break;
				}
			}
		},
		_onRemoveComponent: function (entity, component) {
			component.onRemove();
		}
	});

	var spotCenter = new Vec3();
	var spotEndPoint = new Vec3();
	var tmpVec = new Vec3();
	var chanId = { r: 0, g: 1, b: 2, a: 3 };
	var Light = function Light() {
		this._type = LIGHTTYPE_DIRECTIONAL;
		this._color = new Color(0.8, 0.8, 0.8);
		this._intensity = 1;
		this._castShadows = false;
		this.enabled = false;
		this.mask = 1;
		this.isStatic = false;
		this.key = 0;
		this.bakeDir = true;
		this.attenuationStart = 10;
		this.attenuationEnd = 10;
		this._falloffMode = 0;
		this._shadowType = SHADOW_PCF3;
		this._vsmBlurSize = 11;
		this.vsmBlurMode = BLUR_GAUSSIAN;
		this.vsmBias = 0.01 * 0.25;
		this._cookie = null;
		this.cookieIntensity = 1;
		this._cookieFalloff = true;
		this._cookieChannel = "rgb";
		this._cookieTransform = null;
		this._cookieTransformUniform = new Float32Array(4);
		this._cookieOffset = null;
		this._cookieOffsetUniform = new Float32Array(2);
		this._cookieTransformSet = false;
		this._cookieOffsetSet = false;
		this._innerConeAngle = 40;
		this._outerConeAngle = 45;
		this._finalColor = new Float32Array([0.8, 0.8, 0.8]);
		var c = Math.pow(this._finalColor[0], 2.2);
		this._linearFinalColor = new Float32Array([c, c, c]);
		this._position = new Vec3(0, 0, 0);
		this._direction = new Vec3(0, 0, 0);
		this._innerConeAngleCos = Math.cos(this._innerConeAngle * Math.PI / 180);
		this._outerConeAngleCos = Math.cos(this._outerConeAngle * Math.PI / 180);
		this._shadowCamera = null;
		this._shadowMatrix = new Mat4();
		this.shadowDistance = 40;
		this._shadowResolution = 1024;
		this.shadowBias = -0.0005;
		this._normalOffsetBias = 0.0;
		this.shadowUpdateMode = SHADOWUPDATE_REALTIME;
		this._scene = null;
		this._node = null;
		this._rendererParams = [];
		this._isVsm = false;
		this._isPcf = true;
		this._cacheShadowMap = false;
		this._isCachedShadowMap = false;
		this._visibleLength = [0];
		this._visibleList = [[]];
		this._visibleCameraSettings = [];
	};
	Object.assign(Light.prototype, {
		destroy: function () {
			this._destroyShadowMap();
		},
		clone: function () {
			var clone = new Light();
			clone.type = this._type;
			clone.setColor(this._color);
			clone.intensity = this._intensity;
			clone.castShadows = this.castShadows;
			clone.enabled = this.enabled;
			clone.attenuationStart = this.attenuationStart;
			clone.attenuationEnd = this.attenuationEnd;
			clone.falloffMode = this._falloffMode;
			clone.shadowType = this._shadowType;
			clone.vsmBlurSize = this._vsmBlurSize;
			clone.vsmBlurMode = this.vsmBlurMode;
			clone.vsmBias = this.vsmBias;
			clone.shadowUpdateMode = this.shadowUpdateMode;
			clone.mask = this.mask;
			clone.innerConeAngle = this._innerConeAngle;
			clone.outerConeAngle = this._outerConeAngle;
			clone.shadowBias = this.shadowBias;
			clone.normalOffsetBias = this._normalOffsetBias;
			clone.shadowResolution = this._shadowResolution;
			clone.shadowDistance = this.shadowDistance;
			return clone;
		},
		getColor: function () {
			return this._color;
		},
		getBoundingSphere: function (sphere) {
			if (this._type === LIGHTTYPE_SPOT) {
				var range = this.attenuationEnd;
				var angle = this._outerConeAngle;
				var f = Math.cos(angle * math.DEG_TO_RAD);
				var node = this._node;
				spotCenter.copy(node.up);
				spotCenter.scale(-range * 0.5 * f);
				spotCenter.add(node.getPosition());
				sphere.center = spotCenter;
				spotEndPoint.copy(node.up);
				spotEndPoint.scale(-range);
				tmpVec.copy(node.right);
				tmpVec.scale(Math.sin(angle * math.DEG_TO_RAD) * range);
				spotEndPoint.add(tmpVec);
				sphere.radius = spotEndPoint.length() * 0.5;
			} else if (this._type === LIGHTTYPE_POINT) {
				sphere.center = this._node.getPosition();
				sphere.radius = this.attenuationEnd;
			}
		},
		getBoundingBox: function (box) {
			if (this._type === LIGHTTYPE_SPOT) {
				var range = this.attenuationEnd;
				var angle = this._outerConeAngle;
				var node = this._node;
				var scl = Math.abs( Math.sin(angle * math.DEG_TO_RAD) * range );
				box.center.set(0, -range * 0.5, 0);
				box.halfExtents.set(scl, range * 0.5, scl);
				box.setFromTransformedAabb(box, node.getWorldTransform());
			} else if (this._type === LIGHTTYPE_POINT) {
				box.center.copy(this._node.getPosition());
				box.halfExtents.set(this.attenuationEnd, this.attenuationEnd, this.attenuationEnd);
			}
		},
		_updateFinalColor: function () {
			var color = this._color;
			var r = color.r;
			var g = color.g;
			var b = color.b;
			var i = this._intensity;
			var finalColor = this._finalColor;
			var linearFinalColor = this._linearFinalColor;
			finalColor[0] = r * i;
			finalColor[1] = g * i;
			finalColor[2] = b * i;
			if (i >= 1) {
				linearFinalColor[0] = Math.pow(r, 2.2) * i;
				linearFinalColor[1] = Math.pow(g, 2.2) * i;
				linearFinalColor[2] = Math.pow(b, 2.2) * i;
			} else {
				linearFinalColor[0] = Math.pow(finalColor[0], 2.2);
				linearFinalColor[1] = Math.pow(finalColor[1], 2.2);
				linearFinalColor[2] = Math.pow(finalColor[2], 2.2);
			}
		},
		setColor: function () {
			var r, g, b;
			if (arguments.length === 1) {
				r = arguments[0].r;
				g = arguments[0].g;
				b = arguments[0].b;
			} else if (arguments.length === 3) {
				r = arguments[0];
				g = arguments[1];
				b = arguments[2];
			}
			this._color.set(r, g, b);
			this._updateFinalColor();
		},
		_destroyShadowMap: function () {
			if (this._shadowCamera) {
				if (!this._isCachedShadowMap) {
					var rt = this._shadowCamera.renderTarget;
					var i;
					if (rt) {
						if (rt.length) {
							for (i = 0; i < rt.length; i++) {
								if (rt[i].colorBuffer) rt[i].colorBuffer.destroy();
								rt[i].destroy();
							}
						} else {
							if (rt.colorBuffer) rt.colorBuffer.destroy();
							if (rt.depthBuffer) rt.depthBuffer.destroy();
							rt.destroy();
						}
					}
				}
				this._shadowCamera.renderTarget = null;
				this._shadowCamera = null;
				this._shadowCubeMap = null;
				if (this.shadowUpdateMode === SHADOWUPDATE_NONE) {
					this.shadowUpdateMode = SHADOWUPDATE_THISFRAME;
				}
			}
		},
		updateShadow: function () {
			if (this.shadowUpdateMode !== SHADOWUPDATE_REALTIME) {
				this.shadowUpdateMode = SHADOWUPDATE_THISFRAME;
			}
		},
		updateKey: function () {
			var key =
				   (this._type								<< 29) |
				   ((this._castShadows ? 1 : 0)			   << 28) |
				   (this._shadowType						  << 25) |
				   (this._falloffMode						 << 23) |
				   ((this._normalOffsetBias !== 0.0 ? 1 : 0)  << 22) |
				   ((this._cookie ? 1 : 0)					<< 21) |
				   ((this._cookieFalloff ? 1 : 0)			 << 20) |
				   (chanId[this._cookieChannel.charAt(0)]	 << 18) |
				   ((this._cookieTransform ? 1 : 0)		   << 12);
			if (this._cookieChannel.length === 3) {
				key |= (chanId[this._cookieChannel.charAt(1)] << 16);
				key |= (chanId[this._cookieChannel.charAt(2)] << 14);
			}
			if (key !== this.key && this._scene !== null) {
				this._scene.layers._dirtyLights = true;
			}
			this.key = key;
		}
	});
	Object.defineProperty(Light.prototype, 'type', {
		get: function () {
			return this._type;
		},
		set: function (value) {
			if (this._type === value)
				return;
			this._type = value;
			this._destroyShadowMap();
			this.updateKey();
			var stype = this._shadowType;
			this._shadowType = null;
			this.shadowType = stype;
		}
	});
	Object.defineProperty(Light.prototype, 'shadowType', {
		get: function () {
			return this._shadowType;
		},
		set: function (value) {
			if (this._shadowType === value)
				return;
			var device = Application.getApplication().graphicsDevice;
			if (this._type === LIGHTTYPE_POINT)
				value = SHADOW_PCF3;
			if (value === SHADOW_PCF5 && !device.webgl2) {
				value = SHADOW_PCF3;
			}
			if (value === SHADOW_VSM32 && !device.textureFloatRenderable)
				value = SHADOW_VSM16;
			if (value === SHADOW_VSM16 && !device.textureHalfFloatRenderable)
				value = SHADOW_VSM8;
			this._isVsm = value >= SHADOW_VSM8 && value <= SHADOW_VSM32;
			this._isPcf = value === SHADOW_PCF5 || value === SHADOW_PCF3;
			this._shadowType = value;
			this._destroyShadowMap();
			this.updateKey();
		}
	});
	Object.defineProperty(Light.prototype, 'castShadows', {
		get: function () {
			return this._castShadows && this.mask !== MASK_LIGHTMAP && this.mask !== 0;
		},
		set: function (value) {
			if (this._castShadows === value)
				return;
			this._castShadows = value;
			this.updateKey();
		}
	});
	Object.defineProperty(Light.prototype, 'shadowResolution', {
		get: function () {
			return this._shadowResolution;
		},
		set: function (value) {
			if (this._shadowResolution === value)
				return;
			var device = Application.getApplication().graphicsDevice;
			if (this._type === LIGHTTYPE_POINT) {
				value = Math.min(value, device.maxCubeMapSize);
			} else {
				value = Math.min(value, device.maxTextureSize);
			}
			this._shadowResolution = value;
		}
	});
	Object.defineProperty(Light.prototype, 'vsmBlurSize', {
		get: function () {
			return this._vsmBlurSize;
		},
		set: function (value) {
			if (this._vsmBlurSize === value)
				return;
			if (value % 2 === 0) value++;
			this._vsmBlurSize = value;
		}
	});
	Object.defineProperty(Light.prototype, 'normalOffsetBias', {
		get: function () {
			return this._normalOffsetBias;
		},
		set: function (value) {
			if (this._normalOffsetBias === value)
				return;
			if ((!this._normalOffsetBias && value) || (this._normalOffsetBias && !value)) {
				this.updateKey();
			}
			this._normalOffsetBias = value;
		}
	});
	Object.defineProperty(Light.prototype, 'falloffMode', {
		get: function () {
			return this._falloffMode;
		},
		set: function (value) {
			if (this._falloffMode === value)
				return;
			this._falloffMode = value;
			this.updateKey();
		}
	});
	Object.defineProperty(Light.prototype, 'innerConeAngle', {
		get: function () {
			return this._innerConeAngle;
		},
		set: function (value) {
			if (this._innerConeAngle === value)
				return;
			this._innerConeAngle = value;
			this._innerConeAngleCos = Math.cos(value * Math.PI / 180);
		}
	});
	Object.defineProperty(Light.prototype, 'outerConeAngle', {
		get: function () {
			return this._outerConeAngle;
		},
		set: function (value) {
			if (this._outerConeAngle === value)
				return;
			this._outerConeAngle = value;
			this._outerConeAngleCos = Math.cos(value * Math.PI / 180);
		}
	});
	Object.defineProperty(Light.prototype, 'intensity', {
		get: function () {
			return this._intensity;
		},
		set: function (value) {
			if (this._intensity !== value) {
				this._intensity = value;
				this._updateFinalColor();
			}
		}
	});
	Object.defineProperty(Light.prototype, 'cookie', {
		get: function () {
			return this._cookie;
		},
		set: function (value) {
			if (this._cookie === value)
				return;
			this._cookie = value;
			this.updateKey();
		}
	});
	Object.defineProperty(Light.prototype, 'cookieFalloff', {
		get: function () {
			return this._cookieFalloff;
		},
		set: function (value) {
			if (this._cookieFalloff === value)
				return;
			this._cookieFalloff = value;
			this.updateKey();
		}
	});
	Object.defineProperty(Light.prototype, 'cookieChannel', {
		get: function () {
			return this._cookieChannel;
		},
		set: function (value) {
			if (this._cookieChannel === value)
				return;
			if (value.length < 3) {
				var chr = value.charAt(value.length - 1);
				var addLen = 3 - value.length;
				for (var i = 0; i < addLen; i++)
					value += chr;
			}
			this._cookieChannel = value;
			this.updateKey();
		}
	});
	Object.defineProperty(Light.prototype, 'cookieTransform', {
		get: function () {
			return this._cookieTransform;
		},
		set: function (value) {
			if (this._cookieTransform === value)
				return;
			this._cookieTransform = value;
			this._cookieTransformSet = !!value;
			if (value && !this._cookieOffset) {
				this.cookieOffset = new Vec2();
				this._cookieOffsetSet = false;
			}
			this.updateKey();
		}
	});
	Object.defineProperty(Light.prototype, 'cookieOffset', {
		get: function () {
			return this._cookieOffset;
		},
		set: function (value) {
			if (this._cookieOffset === value)
				return;
			var xformNew = !!(this._cookieTransformSet || value);
			if (xformNew && !value && this._cookieOffset) {
				this._cookieOffset.set(0, 0);
			} else {
				this._cookieOffset = value;
			}
			this._cookieOffsetSet = !!value;
			if (value && !this._cookieTransform) {
				this.cookieTransform = new Vec4(1, 1, 0, 0);
				this._cookieTransformSet = false;
			}
			this.updateKey();
		}
	});

	function LightComponent(system, entity) {
		Component.call(this, system, entity);
		this._cookieAsset = null;
		this._cookieAssetId = null;
		this._cookieAssetAdd = false;
		this._cookieMatrix = null;
	}
	LightComponent.prototype = Object.create(Component.prototype);
	LightComponent.prototype.constructor = LightComponent;
	var _props = [];
	var _propsDefault = [];
	var _defineProperty = function (name, defaultValue, setFunc, skipEqualsCheck) {
		var c = LightComponent.prototype;
		_props.push(name);
		_propsDefault.push(defaultValue);
		Object.defineProperty(c, name, {
			get: function () {
				return this.data[name];
			},
			set: function (value) {
				var data = this.data;
				var oldValue = data[name];
				if (!skipEqualsCheck && oldValue === value) return;
				data[name] = value;
				if (setFunc) setFunc.call(this, value, oldValue);
			},
			configurable: true
		});
	};
	var _defineProps = function () {
		_defineProperty("enabled", true, function (newValue, oldValue) {
			this.onSetEnabled(null, oldValue, newValue);
		});
		_defineProperty("light", null);
		_defineProperty("type", 'directional', function (newValue, oldValue) {
			this.system.changeType(this, oldValue, newValue);
			this.refreshProperties();
		});
		_defineProperty("color", new Color(1, 1, 1), function (newValue, oldValue) {
			this.light.setColor(newValue);
		}, true);
		_defineProperty("intensity", 1, function (newValue, oldValue) {
			this.light.intensity = newValue;
		});
		_defineProperty("castShadows", false, function (newValue, oldValue) {
			this.light.castShadows = newValue;
		});
		_defineProperty("shadowDistance", 40, function (newValue, oldValue) {
			this.light.shadowDistance = newValue;
		});
		_defineProperty("shadowResolution", 1024, function (newValue, oldValue) {
			this.light.shadowResolution = newValue;
		});
		_defineProperty("shadowBias", 0.05, function (newValue, oldValue) {
			this.light.shadowBias = -0.01 * newValue;
		});
		_defineProperty("normalOffsetBias", 0, function (newValue, oldValue) {
			this.light.normalOffsetBias = newValue;
		});
		_defineProperty("range", 10, function (newValue, oldValue) {
			this.light.attenuationEnd = newValue;
		});
		_defineProperty("innerConeAngle", 40, function (newValue, oldValue) {
			this.light.innerConeAngle = newValue;
		});
		_defineProperty("outerConeAngle", 45, function (newValue, oldValue) {
			this.light.outerConeAngle = newValue;
		});
		_defineProperty("falloffMode", LIGHTFALLOFF_LINEAR, function (newValue, oldValue) {
			this.light.falloffMode = newValue;
		});
		_defineProperty("shadowType", SHADOW_PCF3, function (newValue, oldValue) {
			this.light.shadowType = newValue;
		});
		_defineProperty("vsmBlurSize", 11, function (newValue, oldValue) {
			this.light.vsmBlurSize = newValue;
		});
		_defineProperty("vsmBlurMode", BLUR_GAUSSIAN, function (newValue, oldValue) {
			this.light.vsmBlurMode = newValue;
		});
		_defineProperty("vsmBias", 0.01 * 0.25, function (newValue, oldValue) {
			this.light.vsmBias = newValue;
		});
		_defineProperty("cookieAsset", null, function (newValue, oldValue) {
			if (this._cookieAssetId && ((newValue instanceof Asset && newValue.id === this._cookieAssetId) || newValue === this._cookieAssetId))
				return;
			this.onCookieAssetRemove();
			this._cookieAssetId = null;
			if (newValue instanceof Asset) {
				this.data.cookieAsset = newValue.id;
				this._cookieAssetId = newValue.id;
				this.onCookieAssetAdd(newValue);
			} else if (typeof newValue === 'number') {
				this._cookieAssetId = newValue;
				var asset = this.system.app.assets.get(newValue);
				if (asset) {
					this.onCookieAssetAdd(asset);
				} else {
					this._cookieAssetAdd = true;
					this.system.app.assets.on('add:' + this._cookieAssetId, this.onCookieAssetAdd, this);
				}
			}
		});
		_defineProperty("cookie", null, function (newValue, oldValue) {
			this.light.cookie = newValue;
		});
		_defineProperty("cookieIntensity", 1, function (newValue, oldValue) {
			this.light.cookieIntensity = newValue;
		});
		_defineProperty("cookieFalloff", true, function (newValue, oldValue) {
			this.light.cookieFalloff = newValue;
		});
		_defineProperty("cookieChannel", "rgb", function (newValue, oldValue) {
			this.light.cookieChannel = newValue;
		});
		_defineProperty("cookieAngle", 0, function (newValue, oldValue) {
			if (newValue !== 0 || this.cookieScale !== null) {
				if (!this._cookieMatrix) this._cookieMatrix = new Vec4();
				var scx = 1;
				var scy = 1;
				if (this.cookieScale) {
					scx = this.cookieScale.x;
					scy = this.cookieScale.y;
				}
				var c = Math.cos(newValue * math.DEG_TO_RAD);
				var s = Math.sin(newValue * math.DEG_TO_RAD);
				this._cookieMatrix.set(c / scx, -s / scx, s / scy, c / scy);
				this.light.cookieTransform = this._cookieMatrix;
			} else {
				this.light.cookieTransform = null;
			}
		});
		_defineProperty("cookieScale", null, function (newValue, oldValue) {
			if (newValue !== null || this.cookieAngle !== 0) {
				if (!this._cookieMatrix) this._cookieMatrix = new Vec4();
				var scx = newValue.x;
				var scy = newValue.y;
				var c = Math.cos(this.cookieAngle * math.DEG_TO_RAD);
				var s = Math.sin(this.cookieAngle * math.DEG_TO_RAD);
				this._cookieMatrix.set(c / scx, -s / scx, s / scy, c / scy);
				this.light.cookieTransform = this._cookieMatrix;
			} else {
				this.light.cookieTransform = null;
			}
		}, true);
		_defineProperty("cookieOffset", null, function (newValue, oldValue) {
			this.light.cookieOffset = newValue;
		}, true);
		_defineProperty("shadowUpdateMode", SHADOWUPDATE_REALTIME, function (newValue, oldValue) {
			this.light.shadowUpdateMode = newValue;
		});
		_defineProperty("mask", 1, function (newValue, oldValue) {
			this.light.mask = newValue;
		});
		_defineProperty("affectDynamic", true, function (newValue, oldValue) {
			if (newValue) {
				this.light.mask |= MASK_DYNAMIC;
			} else {
				this.light.mask &= ~MASK_DYNAMIC;
			}
		});
		_defineProperty("affectLightmapped", false, function (newValue, oldValue) {
			if (newValue) {
				this.light.mask |= MASK_BAKED;
				if (this.bake) this.light.mask &= ~MASK_LIGHTMAP;
			} else {
				this.light.mask &= ~MASK_BAKED;
				if (this.bake) this.light.mask |= MASK_LIGHTMAP;
			}
		});
		_defineProperty("bake", false, function (newValue, oldValue) {
			if (newValue) {
				this.light.mask |= MASK_LIGHTMAP;
				if (this.affectLightmapped) this.light.mask &= ~MASK_BAKED;
			} else {
				this.light.mask &= ~MASK_LIGHTMAP;
				if (this.affectLightmapped) this.light.mask |= MASK_BAKED;
			}
		});
		_defineProperty("bakeDir", true, function (newValue, oldValue) {
			this.light.bakeDir = newValue;
		});
		_defineProperty("isStatic", false, function (newValue, oldValue) {
			this.light.isStatic = newValue;
		});
		_defineProperty("layers", [LAYERID_WORLD], function (newValue, oldValue) {
			var i, layer;
			for (i = 0; i < oldValue.length; i++) {
				layer = this.system.app.scene.layers.getLayerById(oldValue[i]);
				if (!layer) continue;
				layer.removeLight(this);
			}
			for (i = 0; i < newValue.length; i++) {
				layer = this.system.app.scene.layers.getLayerById(newValue[i]);
				if (!layer) continue;
				if (this.enabled && this.entity.enabled) {
					layer.addLight(this);
				}
			}
		});
	};
	_defineProps();
	Object.assign(LightComponent.prototype, {
		addLightToLayers: function () {
			var layer;
			for (var i = 0; i < this.layers.length; i++) {
				layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
				if (!layer) continue;
				layer.addLight(this);
			}
		},
		removeLightFromLayers: function () {
			var layer;
			for (var i = 0; i < this.layers.length; i++) {
				layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
				if (!layer) continue;
				layer.removeLight(this);
			}
		},
		onLayersChanged: function (oldComp, newComp) {
			if (this.enabled && this.entity.enabled) {
				this.addLightToLayers();
			}
			oldComp.off("add", this.onLayerAdded, this);
			oldComp.off("remove", this.onLayerRemoved, this);
			newComp.on("add", this.onLayerAdded, this);
			newComp.on("remove", this.onLayerRemoved, this);
		},
		onLayerAdded: function (layer) {
			var index = this.layers.indexOf(layer.id);
			if (index < 0) return;
			if (this.enabled && this.entity.enabled) {
				layer.addLight(this);
			}
		},
		onLayerRemoved: function (layer) {
			var index = this.layers.indexOf(layer.id);
			if (index < 0) return;
			layer.removeLight(this);
		},
		refreshProperties: function () {
			var name;
			for (var i = 0; i < _props.length; i++) {
				name = _props[i];
				this[name] = this[name];
			}
			if (this.enabled && this.entity.enabled)
				this.onEnable();
		},
		updateShadow: function () {
			this.light.updateShadow();
		},
		onCookieAssetSet: function () {
			var forceLoad = false;
			if (this._cookieAsset.type === 'cubemap' && !this._cookieAsset.loadFaces) {
				this._cookieAsset.loadFaces = true;
				forceLoad = true;
			}
			if (!this._cookieAsset.resource || forceLoad)
				this.system.app.assets.load(this._cookieAsset);
			if (this._cookieAsset.resource)
				this.onCookieAssetLoad();
		},
		onCookieAssetAdd: function (asset) {
			if (this._cookieAssetId !== asset.id)
				return;
			this._cookieAsset = asset;
			if (this.light.enabled)
				this.onCookieAssetSet();
			this._cookieAsset.on('load', this.onCookieAssetLoad, this);
			this._cookieAsset.on('remove', this.onCookieAssetRemove, this);
		},
		onCookieAssetLoad: function () {
			if (!this._cookieAsset || !this._cookieAsset.resource)
				return;
			this.cookie = this._cookieAsset.resource;
		},
		onCookieAssetRemove: function () {
			if (!this._cookieAssetId)
				return;
			if (this._cookieAssetAdd) {
				this.system.app.assets.off('add:' + this._cookieAssetId, this.onCookieAssetAdd, this);
				this._cookieAssetAdd = false;
			}
			if (this._cookieAsset) {
				this._cookieAsset.off('load', this.onCookieAssetLoad, this);
				this._cookieAsset.off('remove', this.onCookieAssetRemove, this);
				this._cookieAsset = null;
			}
			this.cookie = null;
		},
		onEnable: function () {
			this.light.enabled = true;
			this.system.app.scene.on("set:layers", this.onLayersChanged, this);
			if (this.system.app.scene.layers) {
				this.system.app.scene.layers.on("add", this.onLayerAdded, this);
				this.system.app.scene.layers.on("remove", this.onLayerRemoved, this);
			}
			if (this.enabled && this.entity.enabled) {
				this.addLightToLayers();
			}
			if (this._cookieAsset && !this.cookie)
				this.onCookieAssetSet();
		},
		onDisable: function () {
			this.light.enabled = false;
			this.system.app.scene.off("set:layers", this.onLayersChanged, this);
			if (this.system.app.scene.layers) {
				this.system.app.scene.layers.off("add", this.onLayerAdded, this);
				this.system.app.scene.layers.off("remove", this.onLayerRemoved, this);
			}
			this.removeLightFromLayers();
		},
		onRemove: function () {
			this.light.destroy();
			this.cookieAsset = null;
		}
	});
	var _lightProps = _props;
	var _lightPropsDefault = _propsDefault;

	function LightComponentData() {
		var _props = _lightProps;
		var _propsDefault = _lightPropsDefault;
		var value;
		for (var i = 0; i < _props.length; i++) {
			value = _propsDefault[i];
			if (value && value.clone) {
				this[_props[i]] = value.clone();
			} else {
				this[_props[i]] = value;
			}
		}
	}

	var lightTypes = {
		'directional': LIGHTTYPE_DIRECTIONAL,
		'point': LIGHTTYPE_POINT,
		'spot': LIGHTTYPE_SPOT
	};
	function LightComponentSystem(app) {
		ComponentSystem.call(this, app);
		this.id = 'light';
		this.ComponentType = LightComponent;
		this.DataType = LightComponentData;
		this.on('beforeremove', this._onRemoveComponent, this);
	}
	LightComponentSystem.prototype = Object.create(ComponentSystem.prototype);
	LightComponentSystem.prototype.constructor = LightComponentSystem;
	Object.assign(LightComponentSystem.prototype, {
		initializeComponentData: function (component, _data) {
			var properties = _lightProps;
			var data = {};
			for (var i = 0, len = properties.length; i < len; i++) {
				var property = properties[i];
				data[property] = _data[property];
			}
			if (!data.type)
				data.type = component.data.type;
			component.data.type = data.type;
			if (data.layers && Array.isArray(data.layers)) {
				data.layers = data.layers.slice(0);
			}
			if (data.color && Array.isArray(data.color))
				data.color = new Color(data.color[0], data.color[1], data.color[2]);
			if (data.cookieOffset && data.cookieOffset instanceof Array)
				data.cookieOffset = new Vec2(data.cookieOffset[0], data.cookieOffset[1]);
			if (data.cookieScale && data.cookieScale instanceof Array)
				data.cookieScale = new Vec2(data.cookieScale[0], data.cookieScale[1]);
			if (data.enable) {
				console.warn("WARNING: enable: Property is deprecated. Set enabled property instead.");
				data.enabled = data.enable;
			}
			var light = new Light();
			light.type = lightTypes[data.type];
			light._node = component.entity;
			light._scene = this.app.scene;
			component.data.light = light;
			ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
		},
		_onRemoveComponent: function (entity, component) {
			component.onRemove();
		},
		cloneComponent: function (entity, clone) {
			var light = entity.light;
			var data = [];
			var name;
			var _props = _lightProps;
			for (var i = 0; i < _props.length; i++) {
				name = _props[i];
				if (name === "light") continue;
				if (light[name] && light[name].clone) {
					data[name] = light[name].clone();
				} else {
					data[name] = light[name];
				}
			}
			this.addComponent(clone, data);
		},
		changeType: function (component, oldValue, newValue) {
			if (oldValue !== newValue) {
				component.light.type = lightTypes[newValue];
			}
		}
	});

	function ModelComponent(system, entity)   {
		Component.call(this, system, entity);
		this._type = 'asset';
		this._asset = null;
		this._model = null;
		this._mapping = {};
		this._castShadows = true;
		this._receiveShadows = true;
		this._materialAsset = null;
		this._material = system.defaultMaterial;
		this._castShadowsLightmap = true;
		this._lightmapped = false;
		this._lightmapSizeMultiplier = 1;
		this._isStatic = false;
		this._layers = [LAYERID_WORLD];
		this._batchGroupId = -1;
		this._area = null;
		this._assetOld = 0;
		this._materialEvents = null;
		this._dirtyModelAsset = false;
		this._dirtyMaterialAsset = false;
		this._clonedModel = false;
		entity.on('remove', this.onRemoveChild, this);
		entity.on('insert', this.onInsertChild, this);
	}
	ModelComponent.prototype = Object.create(Component.prototype);
	ModelComponent.prototype.constructor = ModelComponent;
	Object.assign(ModelComponent.prototype, {
		addModelToLayers: function () {
			var layer;
			var layers = this.system.app.scene.layers;
			for (var i = 0; i < this._layers.length; i++) {
				layer = layers.getLayerById(this._layers[i]);
				if (!layer) continue;
				layer.addMeshInstances(this.meshInstances);
			}
		},
		removeModelFromLayers: function () {
			var layer;
			var layers = this.system.app.scene.layers;
			for (var i = 0; i < this._layers.length; i++) {
				layer = layers.getLayerById(this._layers[i]);
				if (!layer) continue;
				layer.removeMeshInstances(this.meshInstances);
			}
		},
		onRemoveChild: function () {
			if (this._model)
				this.removeModelFromLayers();
		},
		onInsertChild: function () {
			if (this._model && this.enabled && this.entity.enabled)
				this.addModelToLayers();
		},
		onRemove: function () {
			if (this.type === 'asset') {
				this.asset = null;
			} else {
				this.model = null;
			}
			this.materialAsset = null;
			this._unsetMaterialEvents();
			this.entity.off('remove', this.onRemoveChild, this);
			this.entity.off('insert', this.onInsertChild, this);
		},
		onLayersChanged: function (oldComp, newComp) {
			this.addModelToLayers();
			oldComp.off("add", this.onLayerAdded, this);
			oldComp.off("remove", this.onLayerRemoved, this);
			newComp.on("add", this.onLayerAdded, this);
			newComp.on("remove", this.onLayerRemoved, this);
		},
		onLayerAdded: function (layer) {
			var index = this.layers.indexOf(layer.id);
			if (index < 0) return;
			layer.addMeshInstances(this.meshInstances);
		},
		onLayerRemoved: function (layer) {
			var index = this.layers.indexOf(layer.id);
			if (index < 0) return;
			layer.removeMeshInstances(this.meshInstances);
		},
		_setMaterialEvent: function (index, event, id, handler) {
			var evt = event + ':' + id;
			this.system.app.assets.on(evt, handler, this);
			if (!this._materialEvents)
				this._materialEvents = [];
			if (!this._materialEvents[index])
				this._materialEvents[index] = { };
			this._materialEvents[index][evt] = {
				id: id,
				handler: handler
			};
		},
		_unsetMaterialEvents: function () {
			var assets = this.system.app.assets;
			var events = this._materialEvents;
			if (!events)
				return;
			for (var i = 0, len = events.length; i < len; i++) {
				if (!events[i]) continue;
				var evt = events[i];
				for (var key in evt) {
					assets.off(key, evt[key].handler, this);
				}
			}
			this._materialEvents = null;
		},
		_getAssetByIdOrPath: function (idOrPath) {
			var asset = null;
			var isPath = isNaN(parseInt(idOrPath, 10));
			if (!isPath) {
				asset = this.system.app.assets.get(idOrPath);
			} else if (this.asset) {
				var url = this._getMaterialAssetUrl(idOrPath);
				if (url)
					asset = this.system.app.assets.getByUrl(url);
			}
			return asset;
		},
		_getMaterialAssetUrl: function (path) {
			if (!this.asset) return null;
			var modelAsset = this.system.app.assets.get(this.asset);
			return modelAsset ? modelAsset.getAbsoluteUrl(path) : null;
		},
		_loadAndSetMeshInstanceMaterial: function (materialAsset, meshInstance, index) {
			var assets = this.system.app.assets;
			if (!materialAsset)
				return;
			if (materialAsset.resource) {
				meshInstance.material = materialAsset.resource;
				this._setMaterialEvent(index, 'remove', materialAsset.id, function () {
					meshInstance.material = this.system.defaultMaterial;
				});
			} else {
				this._setMaterialEvent(index, 'load', materialAsset.id, function (asset) {
					meshInstance.material = asset.resource;
					this._setMaterialEvent(index, 'remove', materialAsset.id, function () {
						meshInstance.material = this.system.defaultMaterial;
					});
				});
				if (this.enabled && this.entity.enabled)
					assets.load(materialAsset);
			}
		},
		onEnable: function () {
			var app = this.system.app;
			var scene = app.scene;
			scene.on("set:layers", this.onLayersChanged, this);
			if (scene.layers) {
				scene.layers.on("add", this.onLayerAdded, this);
				scene.layers.on("remove", this.onLayerRemoved, this);
			}
			var isAsset = (this._type === 'asset');
			var asset;
			if (this._model) {
				this.addModelToLayers();
			} else if (isAsset && this._asset) {
				asset = app.assets.get(this._asset);
				if (asset && asset.resource !== this._model) {
					this._bindModelAsset(asset);
				}
			}
			if (this._materialAsset) {
				asset = app.assets.get(this._materialAsset);
				if (asset && asset.resource !== this._material) {
					this._bindMaterialAsset(asset);
				}
			}
			if (isAsset) {
				if (this._mapping) {
					for (var index in this._mapping) {
						if (this._mapping[index]) {
							asset = this._getAssetByIdOrPath(this._mapping[index]);
							if (asset && !asset.resource) {
								app.assets.load(asset);
							}
						}
					}
				}
			}
			if (this._batchGroupId >= 0) {
				app.batcher.insert(BatchGroup.MODEL, this.batchGroupId, this.entity);
			}
		},
		onDisable: function () {
			var app = this.system.app;
			var scene = app.scene;
			scene.off("set:layers", this.onLayersChanged, this);
			if (scene.layers) {
				scene.layers.off("add", this.onLayerAdded, this);
				scene.layers.off("remove", this.onLayerRemoved, this);
			}
			if (this._batchGroupId >= 0) {
				app.batcher.remove(BatchGroup.MODEL, this.batchGroupId, this.entity);
			}
			if (this._model) {
				this.removeModelFromLayers();
			}
		},
		hide: function () {
			if (this._model) {
				var i, l;
				var instances = this._model.meshInstances;
				for (i = 0, l = instances.length; i < l; i++) {
					instances[i].visible = false;
				}
			}
		},
		show: function () {
			if (this._model) {
				var i, l;
				var instances = this._model.meshInstances;
				for (i = 0, l = instances.length; i < l; i++) {
					instances[i].visible = true;
				}
			}
		},
		_bindMaterialAsset: function (asset) {
			asset.on('load', this._onMaterialAssetLoad, this);
			asset.on('unload', this._onMaterialAssetUnload, this);
			asset.on('remove', this._onMaterialAssetRemove, this);
			asset.on('change', this._onMaterialAssetChange, this);
			if (asset.resource) {
				this._onMaterialAssetLoad(asset);
			} else {
				if (!this.enabled || !this.entity.enabled) return;
				this.system.app.assets.load(asset);
			}
		},
		_unbindMaterialAsset: function (asset) {
			asset.off('load', this._onMaterialAssetLoad, this);
			asset.off('unload', this._onMaterialAssetUnload, this);
			asset.off('remove', this._onMaterialAssetRemove, this);
			asset.off('change', this._onMaterialAssetChange, this);
		},
		_onMaterialAssetAdd: function (asset) {
			this.system.app.assets.off('add:' + asset.id, this._onMaterialAssetAdd, this);
			if (this._materialAsset === asset.id) {
				this._bindMaterialAsset(asset);
			}
		},
		_onMaterialAssetLoad: function (asset) {
			this._setMaterial(asset.resource);
		},
		_onMaterialAssetUnload: function (asset) {
			this._setMaterial(this.system.defaultMaterial);
		},
		_onMaterialAssetRemove: function (asset) {
			this._onMaterialAssetUnload(asset);
		},
		_onMaterialAssetChange: function (asset) {
		},
		_bindModelAsset: function (asset) {
			this._unbindModelAsset(asset);
			asset.on('load', this._onModelAssetLoad, this);
			asset.on('unload', this._onModelAssetUnload, this);
			asset.on('change', this._onModelAssetChange, this);
			asset.on('remove', this._onModelAssetRemove, this);
			if (asset.resource) {
				this._onModelAssetLoad(asset);
			} else {
				if (!this.enabled || !this.entity.enabled) return;
				this.system.app.assets.load(asset);
			}
		},
		_unbindModelAsset: function (asset) {
			asset.off('load', this._onModelAssetLoad, this);
			asset.off('unload', this._onModelAssetUnload, this);
			asset.off('change', this._onModelAssetChange, this);
			asset.off('remove', this._onModelAssetRemove, this);
		},
		_onModelAssetAdded: function (asset) {
			this.system.app.assets.off('add:' + asset.id, this._onModelAssetAdd, this);
			if (asset.id === this._asset) {
				this._bindModelAsset(asset);
			}
		},
		_onModelAssetLoad: function (asset) {
			this.model = asset.resource.clone();
			this._clonedModel = true;
		},
		_onModelAssetUnload: function (asset) {
			this.model = null;
		},
		_onModelAssetChange: function (asset, attr, _new, _old) {
			if (attr === 'data') {
				this.mapping = this._mapping;
			}
		},
		_onModelAssetRemove: function (asset) {
			this.model = null;
		},
		_setMaterial: function (material) {
			if (this._material === material)
				return;
			this._material = material;
			var model = this._model;
			if (model && this._type !== 'asset') {
				var meshInstances = model.meshInstances;
				for (var i = 0, len = meshInstances.length; i < len; i++) {
					meshInstances[i].material = material;
				}
			}
		}
	});
	Object.defineProperty(ModelComponent.prototype, "meshInstances", {
		get: function () {
			if (!this._model)
				return null;
			return this._model.meshInstances;
		},
		set: function (value) {
			if (!this._model)
				return;
			this._model.meshInstances = value;
		}
	});
	Object.defineProperty(ModelComponent.prototype, "type", {
		get: function () {
			return this._type;
		},
		set: function (value) {
			if (this._type === value) return;
			var mesh = null;
			this._area = null;
			this._type = value;
			if (value === 'asset') {
				if (this._asset !== null) {
					this._bindModelAsset(this._asset);
				} else {
					this.model = null;
				}
			} else {
				var system = this.system;
				var gd = system.app.graphicsDevice;
				switch (value) {
					case 'box':
						if (!system.box) {
							system.box = createBox(gd, {
								halfExtents: new Vec3(0.5, 0.5, 0.5)
							});
						}
						mesh = system.box;
						this._area = { x: 2, y: 2, z: 2, uv: (2.0 / 3) };
						break;
					case 'capsule':
						if (!system.capsule) {
							system.capsule = createCapsule(gd, {
								radius: 0.5,
								height: 2
							});
						}
						mesh = system.capsule;
						this._area = { x: (Math.PI * 2), y: Math.PI, z: (Math.PI * 2), uv: (1.0 / 3 + ((1.0 / 3) / 3) * 2) };
						break;
					case 'cone':
						if (!system.cone) {
							system.cone = createCone(gd, {
								baseRadius: 0.5,
								peakRadius: 0,
								height: 1
							});
						}
						mesh = system.cone;
						this._area = { x: 2.54, y: 2.54, z: 2.54, uv: (1.0 / 3 + (1.0 / 3) / 3) };
						break;
					case 'cylinder':
						if (!system.cylinder) {
							system.cylinder = createCylinder(gd, {
								radius: 0.5,
								height: 1
							});
						}
						mesh = system.cylinder;
						this._area = { x: Math.PI, y: (0.79 * 2), z: Math.PI, uv: (1.0 / 3 + ((1.0 / 3) / 3) * 2) };
						break;
					case 'plane':
						if (!system.plane) {
							system.plane = createPlane(gd, {
								halfExtents: new Vec2(0.5, 0.5),
								widthSegments: 1,
								lengthSegments: 1
							});
						}
						mesh = system.plane;
						this._area = { x: 0, y: 1, z: 0, uv: 1 };
						break;
					case 'sphere':
						if (!system.sphere) {
							system.sphere = createSphere(gd, {
								radius: 0.5
							});
						}
						mesh = system.sphere;
						this._area = { x: Math.PI, y: Math.PI, z: Math.PI, uv: 1 };
						break;
					default:
						throw new Error("Invalid model type: " + value);
				}
				var node = new GraphNode();
				var model = new Model();
				model.graph = node;
				model.meshInstances = [new MeshInstance(node, mesh, this._material)];
				if (system._inTools)
					model.generateWireframe();
				this.model = model;
				this._asset = null;
			}
		}
	});
	Object.defineProperty(ModelComponent.prototype, "asset", {
		get: function () {
			return this._asset;
		},
		set: function (value) {
			var assets = this.system.app.assets;
			var _id = value;
			if (value instanceof Asset) {
				_id = value.id;
			}
			if (this._asset !== _id) {
				if (this._asset) {
					assets.off('add:' + this._asset, this._onModelAssetAdded, this);
					var _prev = assets.get(this._asset);
					if (_prev) {
						this._unbindModelAsset(_prev);
					}
				}
				this._asset = _id;
				if (this._asset) {
					var asset = assets.get(this._asset);
					if (!asset) {
						this.model = null;
						assets.on('add:' + this._asset, this._onModelAssetAdded, this);
					} else {
						this._bindModelAsset(asset);
					}
				} else {
					this.model = null;
				}
			}
		}
	});
	Object.defineProperty(ModelComponent.prototype, "model", {
		get: function () {
			return this._model;
		},
		set: function (value) {
			var i;
			if (this._model === value)
				return;
			if (value && value._immutable) {
				return;
			}
			if (this._model) {
				this._model._immutable = false;
				this.removeModelFromLayers();
				this.entity.removeChild(this._model.getGraph());
				delete this._model._entity;
				if (this._clonedModel) {
					this._model.destroy();
					this._clonedModel = false;
				}
			}
			this._model = value;
			if (this._model) {
				this._model._immutable = true;
				var meshInstances = this._model.meshInstances;
				for (i = 0; i < meshInstances.length; i++) {
					meshInstances[i].castShadow = this._castShadows;
					meshInstances[i].receiveShadow = this._receiveShadows;
					meshInstances[i].isStatic = this._isStatic;
				}
				this.lightmapped = this._lightmapped;
				this.entity.addChild(this._model.graph);
				if (this.enabled && this.entity.enabled) {
					this.addModelToLayers();
				}
				this._model._entity = this.entity;
				if (this.entity.animation)
					this.entity.animation.setModel(this._model);
				if (this.entity.anim) {
					this.entity.anim.resetStateGraph();
				}
				if (this.type === 'asset') {
					this.mapping = this._mapping;
				} else {
					this._unsetMaterialEvents();
				}
			}
		}
	});
	Object.defineProperty(ModelComponent.prototype, "lightmapped", {
		get: function () {
			return this._lightmapped;
		},
		set: function (value) {
			if (value === this._lightmapped) return;
			var i, m, mask;
			this._lightmapped = value;
			if (this._model) {
				var rcv = this._model.meshInstances;
				if (value) {
					for (i = 0; i < rcv.length; i++) {
						m = rcv[i];
						mask = m.mask;
						m.mask = (mask | MASK_BAKED) & ~(MASK_DYNAMIC | MASK_LIGHTMAP);
					}
				} else {
					for (i = 0; i < rcv.length; i++) {
						m = rcv[i];
						m.deleteParameter("texture_lightMap");
						m.deleteParameter("texture_dirLightMap");
						m._shaderDefs &= ~SHADERDEF_LM;
						mask = m.mask;
						m.mask = (mask | MASK_DYNAMIC) & ~(MASK_BAKED | MASK_LIGHTMAP);
					}
				}
			}
		}
	});
	Object.defineProperty(ModelComponent.prototype, "castShadows", {
		get: function () {
			return this._castShadows;
		},
		set: function (value) {
			if (this._castShadows === value) return;
			var layer;
			var i;
			var model = this._model;
			if (model) {
				var layers = this.layers;
				var scene = this.system.app.scene;
				if (this._castShadows && !value) {
					for (i = 0; i < layers.length; i++) {
						layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
						if (!layer) continue;
						layer.removeShadowCasters(model.meshInstances);
					}
				}
				var meshInstances = model.meshInstances;
				for (i = 0; i < meshInstances.length; i++) {
					meshInstances[i].castShadow = value;
				}
				if (!this._castShadows && value) {
					for (i = 0; i < layers.length; i++) {
						layer = scene.layers.getLayerById(layers[i]);
						if (!layer) continue;
						layer.addShadowCasters(model.meshInstances);
					}
				}
			}
			this._castShadows = value;
		}
	});
	Object.defineProperty(ModelComponent.prototype, 'receiveShadows', {
		get: function () {
			return this._receiveShadows;
		},
		set: function (value) {
			if (this._receiveShadows === value) return;
			this._receiveShadows = value;
			if (this._model) {
				var meshInstances = this._model.meshInstances;
				for (var i = 0, len = meshInstances.length; i < len; i++) {
					meshInstances[i].receiveShadow = value;
				}
			}
		}
	});
	Object.defineProperty(ModelComponent.prototype, "castShadowsLightmap", {
		get: function () {
			return this._castShadowsLightmap;
		},
		set: function (value) {
			this._castShadowsLightmap = value;
		}
	});
	Object.defineProperty(ModelComponent.prototype, "lightmapSizeMultiplier", {
		get: function () {
			return this._lightmapSizeMultiplier;
		},
		set: function (value) {
			this._lightmapSizeMultiplier = value;
		}
	});
	Object.defineProperty(ModelComponent.prototype, "isStatic", {
		get: function () {
			return this._isStatic;
		},
		set: function (value) {
			if (this._isStatic === value) return;
			this._isStatic = value;
			var i, m;
			if (this._model) {
				var rcv = this._model.meshInstances;
				for (i = 0; i < rcv.length; i++) {
					m = rcv[i];
					m.isStatic = value;
				}
			}
		}
	});
	Object.defineProperty(ModelComponent.prototype, "layers", {
		get: function () {
			return this._layers;
		},
		set: function (value) {
			var i, layer;
			var layers = this.system.app.scene.layers;
			if (this.meshInstances) {
				for (i = 0; i < this._layers.length; i++) {
					layer = layers.getLayerById(this._layers[i]);
					if (!layer) continue;
					layer.removeMeshInstances(this.meshInstances);
				}
			}
			this._layers.length = 0;
			for (i = 0; i < value.length; i++) {
				this._layers[i] = value[i];
			}
			if (!this.enabled || !this.entity.enabled || !this.meshInstances) return;
			for (i = 0; i < this._layers.length; i++) {
				layer = layers.getLayerById(this._layers[i]);
				if (!layer) continue;
				layer.addMeshInstances(this.meshInstances);
			}
		}
	});
	Object.defineProperty(ModelComponent.prototype, "batchGroupId", {
		get: function () {
			return this._batchGroupId;
		},
		set: function (value) {
			if (this._batchGroupId === value) return;
			var batcher = this.system.app.batcher;
			if (this.entity.enabled && this._batchGroupId >= 0) {
				batcher.remove(BatchGroup.MODEL, this.batchGroupId, this.entity);
			}
			if (this.entity.enabled && value >= 0) {
				batcher.insert(BatchGroup.MODEL, value, this.entity);
			}
			if (value < 0 && this._batchGroupId >= 0 && this.enabled && this.entity.enabled) {
				this.addModelToLayers();
			}
			this._batchGroupId = value;
		}
	});
	Object.defineProperty(ModelComponent.prototype, "materialAsset", {
		get: function () {
			return this._materialAsset;
		},
		set: function (value) {
			var _id = value;
			if (value instanceof Asset) {
				_id = value.id;
			}
			var assets = this.system.app.assets;
			if (_id !== this._materialAsset) {
				if (this._materialAsset) {
					assets.off('add:' + this._materialAsset, this._onMaterialAssetAdd, this);
					var _prev = assets.get(this._materialAsset);
					if (_prev) {
						this._unbindMaterialAsset(_prev);
					}
				}
				this._materialAsset = _id;
				if (this._materialAsset) {
					var asset = assets.get(this._materialAsset);
					if (!asset) {
						this._setMaterial(this.system.defaultMaterial);
						assets.on('add:' + this._materialAsset, this._onMaterialAssetAdd, this);
					} else {
						this._bindMaterialAsset(asset);
					}
				} else {
					this._setMaterial(this.system.defaultMaterial);
				}
			}
		}
	});
	Object.defineProperty(ModelComponent.prototype, "material", {
		get: function () {
			return this._material;
		},
		set: function (value) {
			if (this._material === value)
				return;
			this.materialAsset = null;
			this._setMaterial(value);
		}
	});
	Object.defineProperty(ModelComponent.prototype, "mapping", {
		get: function () {
			return this._mapping;
		},
		set: function (value) {
			if (this._type !== 'asset')
				return;
			this._unsetMaterialEvents();
			if (!value)
				value = {};
			this._mapping = value;
			if (!this._model) return;
			var meshInstances = this._model.meshInstances;
			var modelAsset = this.asset ? this.system.app.assets.get(this.asset) : null;
			var assetMapping = modelAsset ? modelAsset.data.mapping : null;
			var asset = null;
			for (var i = 0, len = meshInstances.length; i < len; i++) {
				if (value[i] !== undefined) {
					if (value[i]) {
						asset = this.system.app.assets.get(value[i]);
						this._loadAndSetMeshInstanceMaterial(asset, meshInstances[i], i);
					} else {
						meshInstances[i].material = this.system.defaultMaterial;
					}
				} else if (assetMapping) {
					if (assetMapping[i] && (assetMapping[i].material || assetMapping[i].path)) {
						if (assetMapping[i].material !== undefined) {
							asset = this.system.app.assets.get(assetMapping[i].material);
						} else if (assetMapping[i].path !== undefined) {
							var url = this._getMaterialAssetUrl(assetMapping[i].path);
							if (url) {
								asset = this.system.app.assets.getByUrl(url);
							}
						}
						this._loadAndSetMeshInstanceMaterial(asset, meshInstances[i], i);
					} else {
						meshInstances[i].material = this.system.defaultMaterial;
					}
				}
			}
		}
	});

	function ModelComponentData() {
		this.enabled = true;
	}

	var _schema$a = ['enabled'];
	function ModelComponentSystem(app) {
		ComponentSystem.call(this, app);
		this.id = 'model';
		this.ComponentType = ModelComponent;
		this.DataType = ModelComponentData;
		this.schema = _schema$a;
		this.box = null;
		this.capsule = null;
		this.cone = null;
		this.cylinder = null;
		this.plane = null;
		this.sphere = null;
		this.defaultMaterial = app.scene.defaultMaterial;
		this.on('beforeremove', this.onRemove, this);
	}
	ModelComponentSystem.prototype = Object.create(ComponentSystem.prototype);
	ModelComponentSystem.prototype.constructor = ModelComponentSystem;
	Component._buildAccessors(ModelComponent.prototype, _schema$a);
	Object.assign(ModelComponentSystem.prototype, {
		initializeComponentData: function (component, _data, properties) {
			properties = [
				'material',
				'materialAsset',
				'asset',
				'castShadows',
				'receiveShadows',
				'castShadowsLightmap',
				'lightmapped',
				'lightmapSizeMultiplier',
				'type',
				'mapping',
				'layers',
				'isStatic',
				'batchGroupId'
			];
			if (_data.batchGroupId === null || _data.batchGroupId === undefined) {
				_data.batchGroupId = -1;
			}
			if (_data.layers && _data.layers.length) {
				_data.layers = _data.layers.slice(0);
			}
			for (var i = 0; i < properties.length; i++) {
				if (_data.hasOwnProperty(properties[i])) {
					component[properties[i]] = _data[properties[i]];
				}
			}
			ComponentSystem.prototype.initializeComponentData.call(this, component, _data, ['enabled']);
		},
		cloneComponent: function (entity, clone) {
			var data = {
				type: entity.model.type,
				asset: entity.model.asset,
				castShadows: entity.model.castShadows,
				receiveShadows: entity.model.receiveShadows,
				castShadowsLightmap: entity.model.castShadowsLightmap,
				lightmapped: entity.model.lightmapped,
				lightmapSizeMultiplier: entity.model.lightmapSizeMultiplier,
				isStatic: entity.model.isStatic,
				enabled: entity.model.enabled,
				layers: entity.model.layers,
				batchGroupId: entity.model.batchGroupId,
				mapping: extend({}, entity.model.mapping)
			};
			var materialAsset = entity.model.materialAsset;
			if (!(materialAsset instanceof Asset) && materialAsset != null) {
				materialAsset = this.app.assets.get(materialAsset);
			}
			var material = entity.model.material;
			if (!material ||
				material === this.defaultMaterial ||
				!materialAsset ||
				material === materialAsset.resource) {
				data.materialAsset = materialAsset;
			}
			var component = this.addComponent(clone, data);
			if (entity.model.model && entity.model.type === 'asset' && !entity.model.asset) {
				component.model = entity.model.model.clone();
				component._clonedModel = true;
			}
			if (!data.materialAsset)
				component.material = material;
			if (entity.model.model) {
				var meshInstances = entity.model.model.meshInstances;
				var meshInstancesClone = component.model.meshInstances;
				for (var i = 0; i < meshInstances.length; i++) {
					meshInstancesClone[i].mask = meshInstances[i].mask;
					meshInstancesClone[i].material = meshInstances[i].material;
					meshInstancesClone[i].layer = meshInstances[i].layer;
					meshInstancesClone[i].receiveShadow = meshInstances[i].receiveShadow;
				}
			}
		},
		onRemove: function (entity, component) {
			component.onRemove();
		}
	});

	var SIMPLE_PROPERTIES = [
		'emitterExtents',
		'emitterRadius',
		'emitterExtentsInner',
		'emitterRadiusInner',
		'loop',
		'initialVelocity',
		'animSpeed',
		'normalMap',
		'particleNormal'
	];
	var COMPLEX_PROPERTIES = [
		'numParticles',
		'lifetime',
		'rate',
		'rate2',
		'startAngle',
		'startAngle2',
		'lighting',
		'halfLambert',
		'intensity',
		'wrap',
		'wrapBounds',
		'depthWrite',
		'noFog',
		'sort',
		'stretch',
		'alignToMotion',
		'preWarm',
		'emitterShape',
		'animTilesX',
		'animTilesY',
		'animStartFrame',
		'animNumFrames',
		'animNumAnimations',
		'animIndex',
		'randomizeAnimIndex',
		'animLoop',
		'colorMap',
		'localSpace',
		'screenSpace',
		'orientation'
	];
	var GRAPH_PROPERTIES = [
		'scaleGraph',
		'scaleGraph2',
		'colorGraph',
		'colorGraph2',
		'alphaGraph',
		'alphaGraph2',
		'velocityGraph',
		'velocityGraph2',
		'localVelocityGraph',
		'localVelocityGraph2',
		'rotationSpeedGraph',
		'rotationSpeedGraph2',
		'radialSpeedGraph',
		'radialSpeedGraph2'
	];
	var ASSET_PROPERTIES = [
		'colorMapAsset',
		'normalMapAsset',
		'meshAsset'
	];
	var depthLayer$1;
	var ParticleSystemComponent = function ParticleSystemComponent(system, entity) {
		Component.call(this, system, entity);
		this.on("set_colorMapAsset", this.onSetColorMapAsset, this);
		this.on("set_normalMapAsset", this.onSetNormalMapAsset, this);
		this.on("set_meshAsset", this.onSetMeshAsset, this);
		this.on("set_mesh", this.onSetMesh, this);
		this.on("set_loop", this.onSetLoop, this);
		this.on("set_blendType", this.onSetBlendType, this);
		this.on("set_depthSoftening", this.onSetDepthSoftening, this);
		this.on("set_layers", this.onSetLayers, this);
		SIMPLE_PROPERTIES.forEach(function (prop) {
			this.on('set_' + prop, this.onSetSimpleProperty, this);
		}.bind(this));
		COMPLEX_PROPERTIES.forEach(function (prop) {
			this.on('set_' + prop, this.onSetComplexProperty, this);
		}.bind(this));
		GRAPH_PROPERTIES.forEach(function (prop) {
			this.on('set_' + prop, this.onSetGraphProperty, this);
		}.bind(this));
		this._requestedDepth = false;
		this._drawOrder = 0;
	};
	ParticleSystemComponent.prototype = Object.create(Component.prototype);
	ParticleSystemComponent.prototype.constructor = ParticleSystemComponent;
	Object.defineProperties(ParticleSystemComponent.prototype, {
		drawOrder: {
			get: function () {
				return this._drawOrder;
			},
			set: function (drawOrder) {
				this._drawOrder = drawOrder;
				if (this.emitter) {
					this.emitter.drawOrder = drawOrder;
				}
			}
		}
	});
	Object.assign(ParticleSystemComponent.prototype, {
		addModelToLayers: function () {
			if (!this.data.model) return;
			var layer;
			for (var i = 0; i < this.layers.length; i++) {
				layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
				if (!layer) continue;
				layer.addMeshInstances(this.data.model.meshInstances);
				this.emitter._layer = layer;
			}
		},
		removeModelFromLayers: function (model) {
			if (!this.data.model) return;
			var layer;
			for (var i = 0; i < this.layers.length; i++) {
				layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
				if (!layer) continue;
				layer.removeMeshInstances(this.data.model.meshInstances);
			}
		},
		onSetLayers: function (name, oldValue, newValue) {
			if (!this.data.model) return;
			var i, layer;
			for (i = 0; i < oldValue.length; i++) {
				layer = this.system.app.scene.layers.getLayerById(oldValue[i]);
				if (!layer) continue;
				layer.removeMeshInstances(this.data.model.meshInstances);
			}
			if (!this.enabled || !this.entity.enabled) return;
			for (i = 0; i < newValue.length; i++) {
				layer = this.system.app.scene.layers.getLayerById(newValue[i]);
				if (!layer) continue;
				layer.addMeshInstances(this.data.model.meshInstances);
			}
		},
		onLayersChanged: function (oldComp, newComp) {
			this.addModelToLayers();
			oldComp.off("add", this.onLayerAdded, this);
			oldComp.off("remove", this.onLayerRemoved, this);
			newComp.on("add", this.onLayerAdded, this);
			newComp.on("remove", this.onLayerRemoved, this);
		},
		onLayerAdded: function (layer) {
			if (!this.data.model) return;
			var index = this.layers.indexOf(layer.id);
			if (index < 0) return;
			layer.addMeshInstances(this.data.model.meshInstances);
		},
		onLayerRemoved: function (layer) {
			if (!this.data.model) return;
			var index = this.layers.indexOf(layer.id);
			if (index < 0) return;
			layer.removeMeshInstances(this.data.model.meshInstances);
		},
		_bindColorMapAsset: function (asset) {
			asset.on('load', this._onColorMapAssetLoad, this);
			asset.on('unload', this._onColorMapAssetUnload, this);
			asset.on('remove', this._onColorMapAssetRemove, this);
			asset.on('change', this._onColorMapAssetChange, this);
			if (asset.resource) {
				this._onColorMapAssetLoad(asset);
			} else {
				if (!this.enabled || !this.entity.enabled) return;
				this.system.app.assets.load(asset);
			}
		},
		_unbindColorMapAsset: function (asset) {
			asset.off('load', this._onColorMapAssetLoad, this);
			asset.off('unload', this._onColorMapAssetUnload, this);
			asset.off('remove', this._onColorMapAssetRemove, this);
			asset.off('change', this._onColorMapAssetChange, this);
		},
		_onColorMapAssetLoad: function (asset) {
			this.colorMap = asset.resource;
		},
		_onColorMapAssetUnload: function (asset) {
			this.colorMap = null;
		},
		_onColorMapAssetRemove: function (asset) {
			this._onColorMapAssetUnload(asset);
		},
		_onColorMapAssetChange: function (asset) {
		},
		onSetColorMapAsset: function (name, oldValue, newValue) {
			var self = this;
			var asset;
			var assets = this.system.app.assets;
			if (oldValue) {
				asset = assets.get(oldValue);
				if (asset) {
					this._unbindColorMapAsset(asset);
				}
			}
			if (newValue) {
				if (newValue instanceof Asset) {
					this.data.colorMapAsset = newValue.id;
					newValue = newValue.id;
				}
				asset = assets.get(newValue);
				if (asset) {
					self._bindColorMapAsset(asset);
				} else {
					assets.once("add:" + newValue, function (asset) {
						self._bindColorMapAsset(asset);
					});
				}
			} else {
				this.colorMap = null;
			}
		},
		_bindNormalMapAsset: function (asset) {
			asset.on('load', this._onNormalMapAssetLoad, this);
			asset.on('unload', this._onNormalMapAssetUnload, this);
			asset.on('remove', this._onNormalMapAssetRemove, this);
			asset.on('change', this._onNormalMapAssetChange, this);
			if (asset.resource) {
				this._onNormalMapAssetLoad(asset);
			} else {
				if (!this.enabled || !this.entity.enabled) return;
				this.system.app.assets.load(asset);
			}
		},
		_unbindNormalMapAsset: function (asset) {
			asset.off('load', this._onNormalMapAssetLoad, this);
			asset.off('unload', this._onNormalMapAssetUnload, this);
			asset.off('remove', this._onNormalMapAssetRemove, this);
			asset.off('change', this._onNormalMapAssetChange, this);
		},
		_onNormalMapAssetLoad: function (asset) {
			this.normalMap = asset.resource;
		},
		_onNormalMapAssetUnload: function (asset) {
			this.normalMap = null;
		},
		_onNormalMapAssetRemove: function (asset) {
			this._onNormalMapAssetUnload(asset);
		},
		_onNormalMapAssetChange: function (asset) {
		},
		onSetNormalMapAsset: function (name, oldValue, newValue) {
			var self = this;
			var asset;
			var assets = this.system.app.assets;
			if (oldValue) {
				asset = assets.get(oldValue);
				if (asset) {
					this._unbindNormalMapAsset(asset);
				}
			}
			if (newValue) {
				if (newValue instanceof Asset) {
					this.data.normalMapAsset = newValue.id;
					newValue = newValue.id;
				}
				asset = assets.get(newValue);
				if (asset) {
					self._bindNormalMapAsset(asset);
				} else {
					assets.once("add:" + newValue, function (asset) {
						self._bindNormalMapAsset(asset);
					});
				}
			} else {
				this.normalMap = null;
			}
		},
		_bindMeshAsset: function (asset) {
			asset.on('load', this._onMeshAssetLoad, this);
			asset.on('unload', this._onMeshAssetUnload, this);
			asset.on('remove', this._onMeshAssetRemove, this);
			asset.on('change', this._onMeshAssetChange, this);
			if (asset.resource) {
				this._onMeshAssetLoad(asset);
			} else {
				if (!this.enabled || !this.entity.enabled) return;
				this.system.app.assets.load(asset);
			}
		},
		_unbindMeshAsset: function (asset) {
			asset.off('load', this._onMeshAssetLoad, this);
			asset.off('unload', this._onMeshAssetUnload, this);
			asset.off('remove', this._onMeshAssetRemove, this);
			asset.off('change', this._onMeshAssetChange, this);
		},
		_onMeshAssetLoad: function (asset) {
			this._onMeshChanged(asset.resource);
		},
		_onMeshAssetUnload: function (asset) {
			this.mesh = null;
		},
		_onMeshAssetRemove: function (asset) {
			this._onMeshAssetUnload(asset);
		},
		_onMeshAssetChange: function (asset) {
		},
		onSetMeshAsset: function (name, oldValue, newValue) {
			var asset;
			var assets = this.system.app.assets;
			if (oldValue) {
				asset = assets.get(oldValue);
				if (asset) {
					this._unbindMeshAsset(asset);
				}
			}
			if (newValue) {
				if (newValue instanceof Asset) {
					this.data.meshAsset = newValue.id;
					newValue = newValue.id;
				}
				asset = assets.get(newValue);
				if (asset) {
					this._bindMeshAsset(asset);
					if (asset.resource) {
						this._onMeshChanged(asset.resource);
					} else {
						assets.load(asset);
					}
				}
			} else {
				this._onMeshChanged(null);
			}
		},
		onSetMesh: function (name, oldValue, newValue) {
			if (!newValue || newValue instanceof Asset || typeof newValue === 'number') {
				this.meshAsset = newValue;
			} else {
				this._onMeshChanged(newValue);
			}
		},
		_onMeshChanged: function (mesh) {
			if (mesh && !(mesh instanceof Mesh)) {
				if (mesh.meshInstances[0]) {
					mesh = mesh.meshInstances[0].mesh;
				} else {
					mesh = null;
				}
			}
			this.data.mesh = mesh;
			if (this.emitter) {
				this.emitter.mesh = mesh;
				this.emitter.resetMaterial();
				this.rebuild();
			}
		},
		onSetLoop: function (name, oldValue, newValue) {
			if (this.emitter) {
				this.emitter[name] = newValue;
				this.emitter.resetTime();
			}
		},
		onSetBlendType: function (name, oldValue, newValue) {
			if (this.emitter) {
				this.emitter[name] = newValue;
				this.emitter.material.blendType = newValue;
				this.emitter.resetMaterial();
				this.rebuild();
			}
		},
		_requestDepth: function () {
			if (this._requestedDepth) return;
			if (!depthLayer$1) depthLayer$1 = this.system.app.scene.layers.getLayerById(LAYERID_DEPTH);
			if (depthLayer$1) {
				depthLayer$1.incrementCounter();
				this._requestedDepth = true;
			}
		},
		_releaseDepth: function () {
			if (!this._requestedDepth) return;
			if (depthLayer$1) {
				depthLayer$1.decrementCounter();
				this._requestedDepth = false;
			}
		},
		onSetDepthSoftening: function (name, oldValue, newValue) {
			if (oldValue !== newValue) {
				if (newValue) {
					if (this.enabled && this.entity.enabled) this._requestDepth();
					if (this.emitter) this.emitter[name] = newValue;
				} else {
					if (this.enabled && this.entity.enabled) this._releaseDepth();
					if (this.emitter) this.emitter[name] = newValue;
				}
				if (this.emitter) {
					this.reset();
					this.emitter.resetMaterial();
					this.rebuild();
				}
			}
		},
		onSetSimpleProperty: function (name, oldValue, newValue) {
			if (this.emitter) {
				this.emitter[name] = newValue;
				this.emitter.resetMaterial();
			}
		},
		onSetComplexProperty: function (name, oldValue, newValue) {
			if (this.emitter) {
				this.emitter[name] = newValue;
				this.emitter.resetMaterial();
				this.rebuild();
				this.reset();
			}
		},
		onSetGraphProperty: function (name, oldValue, newValue) {
			if (this.emitter) {
				this.emitter[name] = newValue;
				this.emitter.rebuildGraphs();
				this.emitter.resetMaterial();
			}
		},
		onEnable: function () {
			var data = this.data;
			for (var i = 0, len = ASSET_PROPERTIES.length; i < len; i++) {
				var asset = data[ASSET_PROPERTIES[i]];
				if (asset) {
					if (!(asset instanceof Asset)) {
						var id = parseInt(asset, 10);
						if (id >= 0) {
							asset = this.system.app.assets.get(asset);
						} else {
							continue;
						}
					}
					if (asset && !asset.resource) {
						this.system.app.assets.load(asset);
					}
				}
			}
			if (!this.emitter) {
				var mesh = data.mesh;
				if (!(mesh instanceof Mesh))
					mesh = null;
				this.emitter = new ParticleEmitter(this.system.app.graphicsDevice, {
					numParticles: data.numParticles,
					emitterExtents: data.emitterExtents,
					emitterExtentsInner: data.emitterExtentsInner,
					emitterRadius: data.emitterRadius,
					emitterRadiusInner: data.emitterRadiusInner,
					emitterShape: data.emitterShape,
					initialVelocity: data.initialVelocity,
					wrap: data.wrap,
					localSpace: data.localSpace,
					screenSpace: data.screenSpace,
					wrapBounds: data.wrapBounds,
					lifetime: data.lifetime,
					rate: data.rate,
					rate2: data.rate2,
					orientation: data.orientation,
					particleNormal: data.particleNormal,
					animTilesX: data.animTilesX,
					animTilesY: data.animTilesY,
					animStartFrame: data.animStartFrame,
					animNumFrames: data.animNumFrames,
					animNumAnimations: data.animNumAnimations,
					animIndex: data.animIndex,
					randomizeAnimIndex: data.randomizeAnimIndex,
					animSpeed: data.animSpeed,
					animLoop: data.animLoop,
					startAngle: data.startAngle,
					startAngle2: data.startAngle2,
					scaleGraph: data.scaleGraph,
					scaleGraph2: data.scaleGraph2,
					colorGraph: data.colorGraph,
					colorGraph2: data.colorGraph2,
					alphaGraph: data.alphaGraph,
					alphaGraph2: data.alphaGraph2,
					localVelocityGraph: data.localVelocityGraph,
					localVelocityGraph2: data.localVelocityGraph2,
					velocityGraph: data.velocityGraph,
					velocityGraph2: data.velocityGraph2,
					rotationSpeedGraph: data.rotationSpeedGraph,
					rotationSpeedGraph2: data.rotationSpeedGraph2,
					radialSpeedGraph: data.radialSpeedGraph,
					radialSpeedGraph2: data.radialSpeedGraph2,
					colorMap: data.colorMap,
					normalMap: data.normalMap,
					loop: data.loop,
					preWarm: data.preWarm,
					sort: data.sort,
					stretch: data.stretch,
					alignToMotion: data.alignToMotion,
					lighting: data.lighting,
					halfLambert: data.halfLambert,
					intensity: data.intensity,
					depthSoftening: data.depthSoftening,
					scene: this.system.app.scene,
					mesh: mesh,
					depthWrite: data.depthWrite,
					noFog: data.noFog,
					node: this.entity,
					blendType: data.blendType
				});
				this.emitter.meshInstance.node = this.entity;
				this.emitter.drawOrder = this.drawOrder;
				this.psys = new Model();
				this.psys.graph = this.entity;
				this.psys.emitter = this.emitter;
				this.psys.meshInstances = [this.emitter.meshInstance];
				data.model = this.psys;
				this.emitter.psys = this.psys;
				if (!data.autoPlay) {
					this.pause();
					this.emitter.meshInstance.visible = false;
				}
			}
			if (data.model && this.emitter.colorMap) {
				this.addModelToLayers();
			}
			this.system.app.scene.on("set:layers", this.onLayersChanged, this);
			if (this.system.app.scene.layers) {
				this.system.app.scene.layers.on("add", this.onLayerAdded, this);
				this.system.app.scene.layers.on("remove", this.onLayerRemoved, this);
			}
			if (this.enabled && this.entity.enabled && data.depthSoftening) {
				this._requestDepth();
			}
		},
		onDisable: function () {
			this.system.app.scene.off("set:layers", this.onLayersChanged, this);
			if (this.system.app.scene.layers) {
				this.system.app.scene.layers.off("add", this.onLayerAdded, this);
				this.system.app.scene.layers.off("remove", this.onLayerRemoved, this);
			}
			if (this.data.model) {
				this.removeModelFromLayers();
				if (this.data.depthSoftening) this._releaseDepth();
			}
			if (this.emitter) {
				this.emitter.camera = null;
			}
		},
		onBeforeRemove: function () {
			if (this.enabled) {
				this.enabled = false;
			}
			var data = this.data;
			if (data.model) {
				this.entity.removeChild(data.model.getGraph());
				data.model.destroy();
				data.model = null;
			}
			if (this.emitter) {
				this.emitter.destroy();
				this.emitter = null;
			}
			for (var i = 0; i < ASSET_PROPERTIES.length; i++) {
				var prop = ASSET_PROPERTIES[i];
				if (data[prop]) {
					this[prop] = null;
				}
			}
			this.off();
		},
		reset: function () {
			if (this.emitter) {
				this.emitter.reset();
			}
		},
		stop: function () {
			if (this.emitter) {
				this.emitter.loop = false;
				this.emitter.resetTime();
				this.emitter.addTime(0, true);
			}
		},
		pause: function () {
			this.data.paused = true;
		},
		unpause: function () {
			this.data.paused = false;
		},
		play: function () {
			this.data.paused = false;
			if (this.emitter) {
				this.emitter.meshInstance.visible = true;
				this.emitter.loop = this.data.loop;
				this.emitter.resetTime();
			}
		},
		isPlaying: function () {
			if (this.data.paused) {
				return false;
			}
			if (this.emitter && this.emitter.loop) {
				return true;
			}
			return Date.now() <= this.emitter.endTime;
		},
		rebuild: function () {
			var enabled = this.enabled;
			this.enabled = false;
			if (this.emitter) {
				this.emitter.rebuild();
				this.emitter.meshInstance.node = this.entity;
				this.data.model.meshInstances = [this.emitter.meshInstance];
			}
			this.enabled = enabled;
		}
	});

	function ParticleSystemComponentData() {
		this.numParticles = 1;
		this.rate = 1;
		this.rate2 = null;
		this.startAngle = 0;
		this.startAngle2 = null;
		this.lifetime = 50;
		this.emitterExtents = new Vec3();
		this.emitterExtentsInner = new Vec3();
		this.emitterRadius = 0;
		this.emitterRadiusInner = 0;
		this.emitterShape = EMITTERSHAPE_BOX;
		this.initialVelocity = 0;
		this.wrapBounds = new Vec3();
		this.localSpace = false;
		this.screenSpace = false;
		this.colorMap = null;
		this.colorMapAsset = null;
		this.normalMap = null;
		this.normalMapAsset = null;
		this.loop = true;
		this.preWarm = false;
		this.sort = 0;
		this.mode = PARTICLEMODE_GPU;
		this.scene = null;
		this.lighting = false;
		this.halfLambert = false;
		this.intensity = 1;
		this.stretch = 0.0;
		this.alignToMotion = false;
		this.depthSoftening = 0;
		this.meshAsset = null;
		this.mesh = null;
		this.depthWrite = false;
		this.noFog = false;
		this.orientation = PARTICLEORIENTATION_SCREEN;
		this.particleNormal = new Vec3(0, 1, 0);
		this.animTilesX = 1;
		this.animTilesY = 1;
		this.animStartFrame = 0;
		this.animNumFrames = 1;
		this.animNumAnimations = 1;
		this.animIndex = 0;
		this.randomizeAnimIndex = false;
		this.animSpeed = 1;
		this.animLoop = true;
		this.scaleGraph = null;
		this.scaleGraph2 = null;
		this.colorGraph = null;
		this.colorGraph2 = null;
		this.alphaGraph = null;
		this.alphaGraph2 = null;
		this.localVelocityGraph = null;
		this.localVelocityGraph2 = null;
		this.velocityGraph = null;
		this.velocityGraph2 = null;
		this.rotationSpeedGraph = null;
		this.rotationSpeedGraph2 = null;
		this.radialSpeedGraph = null;
		this.radialSpeedGraph2 = null;
		this.blendType = BLEND_NORMAL;
		this.model = null;
		this.enabled = true;
		this.paused = false;
		this.autoPlay = true;
		this.layers = [LAYERID_WORLD];
	}

	var _schema$b = [
		'enabled',
		'autoPlay',
		'numParticles',
		'lifetime',
		'rate',
		'rate2',
		'startAngle',
		'startAngle2',
		'loop',
		'preWarm',
		'lighting',
		'halfLambert',
		'intensity',
		'depthWrite',
		'noFog',
		'depthSoftening',
		'sort',
		'blendType',
		'stretch',
		'alignToMotion',
		'emitterShape',
		'emitterExtents',
		'emitterExtentsInner',
		'emitterRadius',
		'emitterRadiusInner',
		'initialVelocity',
		'wrap',
		'wrapBounds',
		'localSpace',
		'screenSpace',
		'colorMapAsset',
		'normalMapAsset',
		'mesh',
		'meshAsset',
		'orientation',
		'particleNormal',
		'localVelocityGraph',
		'localVelocityGraph2',
		'velocityGraph',
		'velocityGraph2',
		'rotationSpeedGraph',
		'rotationSpeedGraph2',
		'radialSpeedGraph',
		'radialSpeedGraph2',
		'scaleGraph',
		'scaleGraph2',
		'colorGraph',
		'colorGraph2',
		'alphaGraph',
		'alphaGraph2',
		'colorMap',
		'normalMap',
		'animTilesX',
		'animTilesY',
		'animStartFrame',
		'animNumFrames',
		'animNumAnimations',
		'animIndex',
		'randomizeAnimIndex',
		'animSpeed',
		'animLoop',
		'layers'
	];
	function ParticleSystemComponentSystem(app) {
		ComponentSystem.call(this, app);
		this.id = 'particlesystem';
		this.ComponentType = ParticleSystemComponent;
		this.DataType = ParticleSystemComponentData;
		this.schema = _schema$b;
		this.propertyTypes = {
			emitterExtents: 'vec3',
			emitterExtentsInner: 'vec3',
			particleNormal: 'vec3',
			wrapBounds: 'vec3',
			localVelocityGraph: 'curveset',
			localVelocityGraph2: 'curveset',
			velocityGraph: 'curveset',
			velocityGraph2: 'curveset',
			colorGraph: 'curveset',
			colorGraph2: 'curveset',
			alphaGraph: 'curve',
			alphaGraph2: 'curve',
			rotationSpeedGraph: 'curve',
			rotationSpeedGraph2: 'curve',
			radialSpeedGraph: 'curve',
			radialSpeedGraph2: 'curve',
			scaleGraph: 'curve',
			scaleGraph2: 'curve'
		};
		this.on('beforeremove', this.onBeforeRemove, this);
		ComponentSystem.bind('update', this.onUpdate, this);
	}
	ParticleSystemComponentSystem.prototype = Object.create(ComponentSystem.prototype);
	ParticleSystemComponentSystem.prototype.constructor = ParticleSystemComponentSystem;
	Component._buildAccessors(ParticleSystemComponent.prototype, _schema$b);
	Object.assign(ParticleSystemComponentSystem.prototype, {
		initializeComponentData: function (component, _data, properties) {
			var data = {};
			properties = [];
			var types = this.propertyTypes;
			var t;
			if (_data.mesh instanceof Asset || typeof _data.mesh === 'number') {
				_data.meshAsset = _data.mesh;
				delete _data.mesh;
			}
			for (var prop in _data) {
				if (_data.hasOwnProperty(prop)) {
					properties.push(prop);
					data[prop] = _data[prop];
				}
				if (types[prop] === 'vec3') {
					if (Array.isArray(data[prop])) {
						data[prop] = new Vec3(data[prop][0], data[prop][1], data[prop][2]);
					}
				} else if (types[prop] === 'curve') {
					if (!(data[prop] instanceof Curve)) {
						t = data[prop].type;
						data[prop] = new Curve(data[prop].keys);
						data[prop].type = t;
					}
				} else if (types[prop] === 'curveset') {
					if (!(data[prop] instanceof CurveSet)) {
						t = data[prop].type;
						data[prop] = new CurveSet(data[prop].keys);
						data[prop].type = t;
					}
				}
				if (data.layers && Array.isArray(data.layers)) {
					data.layers = data.layers.slice(0);
				}
			}
			ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
		},
		cloneComponent: function (entity, clone) {
			var source = entity.particlesystem.data;
			var schema = this.schema;
			var data = {};
			for (var i = 0, len = schema.length; i < len; i++) {
				var prop = schema[i];
				var sourceProp = source[prop];
				if (sourceProp instanceof Vec3 ||
					sourceProp instanceof Curve ||
					sourceProp instanceof CurveSet) {
					sourceProp = sourceProp.clone();
					data[prop] = sourceProp;
				} else if (prop === "layers") {
					data.layers = source.layers.slice(0);
				} else {
					if (sourceProp !== null && sourceProp !== undefined) {
						data[prop] = sourceProp;
					}
				}
			}
			return this.addComponent(clone, data);
		},
		onUpdate: function (dt) {
			var components = this.store;
			var numSteps, i, j, c;
			var stats = this.app.stats.particles;
			for (var id in components) {
				if (components.hasOwnProperty(id)) {
					c = components[id];
					var entity = c.entity;
					var data = c.data;
					if (data.enabled && entity.enabled) {
						var emitter = data.model.emitter;
						if (!emitter.meshInstance.visible) continue;
						if (emitter.lighting) {
							var layer, lightCube;
							var layers = data.layers;
							for (i = 0; i < layers.length; i++) {
								layer = this.app.scene.layers.getLayerById(layers[i]);
								if (!layer) continue;
								if (!layer._lightCube) {
									layer._lightCube = new Float32Array(6 * 3);
								}
								lightCube = layer._lightCube;
								for (i = 0; i < 6; i++) {
									lightCube[i * 3] = this.app.scene.ambientLight.r;
									lightCube[i * 3 + 1] = this.app.scene.ambientLight.g;
									lightCube[i * 3 + 2] = this.app.scene.ambientLight.b;
								}
								var dirs = layer._sortedLights[LIGHTTYPE_DIRECTIONAL];
								for (j = 0; j < dirs.length; j++) {
									for (c = 0; c < 6; c++) {
										var weight = Math.max(emitter.lightCubeDir[c].dot(dirs[j]._direction), 0) * dirs[j]._intensity;
										lightCube[c * 3] += dirs[j]._color.r * weight;
										lightCube[c * 3 + 1] += dirs[j]._color.g * weight;
										lightCube[c * 3 + 2] += dirs[j]._color.b * weight;
									}
								}
							}
							emitter.constantLightCube.setValue(lightCube);
						}
						if (!data.paused) {
							emitter.simTime += dt;
							if (emitter.simTime > emitter.fixedTimeStep) {
								numSteps = Math.floor(emitter.simTime / emitter.fixedTimeStep);
								emitter.simTime -= numSteps * emitter.fixedTimeStep;
							}
							if (numSteps) {
								numSteps = Math.min(numSteps, emitter.maxSubSteps);
								for (i = 0; i < numSteps; i++) {
									emitter.addTime(emitter.fixedTimeStep, false);
								}
								stats._updatesPerFrame += numSteps;
								stats._frameTime += emitter._addTimeTime;
								emitter._addTimeTime = 0;
							}
							emitter.finishFrame();
						}
					}
				}
			}
		},
		onBeforeRemove: function (entity, component) {
			component.onBeforeRemove();
		}
	});

	function AllocatePool(constructor, size) {
		this._constructor = constructor;
		this._pool = [];
		this._count = 0;
		this._resize(size);
	}
	Object.assign(AllocatePool.prototype, {
		_resize: function (size) {
			if (size > this._pool.length) {
				for (var i = this._pool.length; i < size; i++) {
					this._pool[i] = new this._constructor();
				}
			}
		},
		allocate: function () {
			if (this._count >= this._pool.length) {
				this._resize(this._pool.length * 2);
			}
			return this._pool[this._count++];
		},
		freeAll: function () {
			this._count = 0;
		}
	});

	var ammoTransform$1;
	var ammoVec1$1, ammoVec2, ammoQuat$1, ammoOrigin;
	function RigidBodyComponent(system, entity) {
		Component.call(this, system, entity);
		if (typeof Ammo !== 'undefined' && !ammoTransform$1) {
			ammoTransform$1 = new Ammo.btTransform();
			ammoVec1$1 = new Ammo.btVector3();
			ammoVec2 = new Ammo.btVector3();
			ammoQuat$1 = new Ammo.btQuaternion();
			ammoOrigin = new Ammo.btVector3(0, 0, 0);
		}
		this.on('set_mass', this.onSetMass, this);
		this.on('set_linearDamping', this.onSetLinearDamping, this);
		this.on('set_angularDamping', this.onSetAngularDamping, this);
		this.on('set_linearFactor', this.onSetLinearFactor, this);
		this.on('set_angularFactor', this.onSetAngularFactor, this);
		this.on('set_friction', this.onSetFriction, this);
		this.on('set_restitution', this.onSetRestitution, this);
		this.on('set_type', this.onSetType, this);
		this.on('set_group', this.onSetGroupOrMask, this);
		this.on('set_mask', this.onSetGroupOrMask, this);
		this.on('set_body', this.onSetBody, this);
		this._linearVelocity = new Vec3(0, 0, 0);
		this._angularVelocity = new Vec3(0, 0, 0);
	}
	RigidBodyComponent.prototype = Object.create(Component.prototype);
	RigidBodyComponent.prototype.constructor = RigidBodyComponent;
	Object.defineProperty(RigidBodyComponent.prototype, "linearVelocity", {
		get: function () {
			var body = this.body;
			if (body && this.type === BODYTYPE_DYNAMIC) {
				var vel = body.getLinearVelocity();
				this._linearVelocity.set(vel.x(), vel.y(), vel.z());
			}
			return this._linearVelocity;
		},
		set: function (lv) {
			var body = this.body;
			if (body && this.type === BODYTYPE_DYNAMIC) {
				body.activate();
				ammoVec1$1.setValue(lv.x, lv.y, lv.z);
				body.setLinearVelocity(ammoVec1$1);
				this._linearVelocity.copy(lv);
			}
		}
	});
	Object.defineProperty(RigidBodyComponent.prototype, "angularVelocity", {
		get: function () {
			var body = this.body;
			if (body && this.type === BODYTYPE_DYNAMIC) {
				var vel = body.getAngularVelocity();
				this._angularVelocity.set(vel.x(), vel.y(), vel.z());
			}
			return this._angularVelocity;
		},
		set: function (av) {
			var body = this.body;
			if (body && this.type === BODYTYPE_DYNAMIC) {
				body.activate();
				ammoVec1$1.setValue(av.x, av.y, av.z);
				body.setAngularVelocity(ammoVec1$1);
				this._angularVelocity.copy(av);
			}
		}
	});
	Object.assign(RigidBodyComponent.prototype, {
		createBody: function () {
			var entity = this.entity;
			var shape;
			if (entity.collision) {
				shape = entity.collision.shape;
				if (entity.trigger) {
					entity.trigger.destroy();
					delete entity.trigger;
				}
			}
			if (shape) {
				if (this.body)
					this.system.onRemove(this.entity, this);
				var mass = this.type === BODYTYPE_DYNAMIC ? this.mass : 0;
				this._getEntityTransform(ammoTransform$1);
				var body = this.system.createBody(mass, shape, ammoTransform$1);
				body.setRestitution(this.restitution);
				body.setFriction(this.friction);
				body.setDamping(this.linearDamping, this.angularDamping);
				if (this.type === BODYTYPE_DYNAMIC) {
					var linearFactor = this.linearFactor;
					ammoVec1$1.setValue(linearFactor.x, linearFactor.y, linearFactor.z);
					body.setLinearFactor(ammoVec1$1);
					var angularFactor = this.angularFactor;
					ammoVec1$1.setValue(angularFactor.x, angularFactor.y, angularFactor.z);
					body.setAngularFactor(ammoVec1$1);
				} else if (this.type === BODYTYPE_KINEMATIC) {
					body.setCollisionFlags(body.getCollisionFlags() | BODYFLAG_KINEMATIC_OBJECT);
					body.setActivationState(BODYSTATE_DISABLE_DEACTIVATION);
				}
				body.entity = entity;
				entity.rigidbody.body = body;
				if (this.enabled && this.entity.enabled) {
					this.enableSimulation();
				}
			}
		},
		isActive: function () {
			var body = this.body;
			return body ? body.isActive() : false;
		},
		activate: function () {
			var body = this.body;
			if (body) {
				body.activate();
			}
		},
		enableSimulation: function () {
			if (this.entity.collision && this.entity.collision.enabled && !this.data.simulationEnabled) {
				var body = this.body;
				if (body) {
					this.system.addBody(body, this.group, this.mask);
					switch (this.type) {
						case BODYTYPE_DYNAMIC:
							this.system._dynamic.push(this);
							body.forceActivationState(BODYSTATE_ACTIVE_TAG);
							this.syncEntityToBody();
							break;
						case BODYTYPE_KINEMATIC:
							this.system._kinematic.push(this);
							body.forceActivationState(BODYSTATE_DISABLE_DEACTIVATION);
							break;
						case BODYTYPE_STATIC:
							body.forceActivationState(BODYSTATE_ACTIVE_TAG);
							this.syncEntityToBody();
							break;
					}
					if (this.entity.collision.type === 'compound') {
						this.system._compounds.push(this.entity.collision);
					}
					body.activate();
					this.data.simulationEnabled = true;
				}
			}
		},
		disableSimulation: function () {
			var body = this.body;
			if (body && this.data.simulationEnabled) {
				var idx;
				idx = this.system._compounds.indexOf(this.entity.collision);
				if (idx > -1) {
					this.system._compounds.splice(idx, 1);
				}
				idx = this.system._dynamic.indexOf(this);
				if (idx > -1) {
					this.system._dynamic.splice(idx, 1);
				}
				idx = this.system._kinematic.indexOf(this);
				if (idx > -1) {
					this.system._kinematic.splice(idx, 1);
				}
				this.system.removeBody(body);
				body.forceActivationState(BODYSTATE_DISABLE_SIMULATION);
				this.data.simulationEnabled = false;
			}
		},
		applyForce: function () {
			var x, y, z;
			var px, py, pz;
			switch (arguments.length) {
				case 1:
					x = arguments[0].x;
					y = arguments[0].y;
					z = arguments[0].z;
					break;
				case 2:
					x = arguments[0].x;
					y = arguments[0].y;
					z = arguments[0].z;
					px = arguments[1].x;
					py = arguments[1].y;
					pz = arguments[1].z;
					break;
				case 3:
					x = arguments[0];
					y = arguments[1];
					z = arguments[2];
					break;
				case 6:
					x = arguments[0];
					y = arguments[1];
					z = arguments[2];
					px = arguments[3];
					py = arguments[4];
					pz = arguments[5];
					break;
			}
			var body = this.body;
			if (body) {
				body.activate();
				ammoVec1$1.setValue(x, y, z);
				if (px !== undefined) {
					ammoVec2.setValue(px, py, pz);
					body.applyForce(ammoVec1$1, ammoVec2);
				} else {
					body.applyForce(ammoVec1$1, ammoOrigin);
				}
			}
		},
		applyTorque: function () {
			var x, y, z;
			switch (arguments.length) {
				case 1:
					x = arguments[0].x;
					y = arguments[0].y;
					z = arguments[0].z;
					break;
				case 3:
					x = arguments[0];
					y = arguments[1];
					z = arguments[2];
					break;
				default:
					return;
			}
			var body = this.body;
			if (body) {
				body.activate();
				ammoVec1$1.setValue(x, y, z);
				body.applyTorque(ammoVec1$1);
			}
		},
		applyImpulse: function () {
			var x, y, z;
			var px, py, pz;
			switch (arguments.length) {
				case 1:
					x = arguments[0].x;
					y = arguments[0].y;
					z = arguments[0].z;
					break;
				case 2:
					x = arguments[0].x;
					y = arguments[0].y;
					z = arguments[0].z;
					px = arguments[1].x;
					py = arguments[1].y;
					pz = arguments[1].z;
					break;
				case 3:
					x = arguments[0];
					y = arguments[1];
					z = arguments[2];
					break;
				case 6:
					x = arguments[0];
					y = arguments[1];
					z = arguments[2];
					px = arguments[3];
					py = arguments[4];
					pz = arguments[5];
					break;
				default:
					return;
			}
			var body = this.body;
			if (body) {
				body.activate();
				ammoVec1$1.setValue(x, y, z);
				if (px !== undefined) {
					ammoVec2.setValue(px, py, pz);
					body.applyImpulse(ammoVec1$1, ammoVec2);
				} else {
					body.applyImpulse(ammoVec1$1, ammoOrigin);
				}
			}
		},
		applyTorqueImpulse: function () {
			var x, y, z;
			switch (arguments.length) {
				case 1:
					x = arguments[0].x;
					y = arguments[0].y;
					z = arguments[0].z;
					break;
				case 3:
					x = arguments[0];
					y = arguments[1];
					z = arguments[2];
					break;
				default:
					return;
			}
			var body = this.body;
			if (body) {
				body.activate();
				ammoVec1$1.setValue(x, y, z);
				body.applyTorqueImpulse(ammoVec1$1);
			}
		},
		isStatic: function () {
			return (this.type === BODYTYPE_STATIC);
		},
		isStaticOrKinematic: function () {
			return (this.type === BODYTYPE_STATIC || this.type === BODYTYPE_KINEMATIC);
		},
		isKinematic: function () {
			return (this.type === BODYTYPE_KINEMATIC);
		},
		_getEntityTransform: function (transform) {
			var pos = this.entity.getPosition();
			var rot = this.entity.getRotation();
			ammoVec1$1.setValue(pos.x, pos.y, pos.z);
			ammoQuat$1.setValue(rot.x, rot.y, rot.z, rot.w);
			transform.setOrigin(ammoVec1$1);
			transform.setRotation(ammoQuat$1);
		},
		syncEntityToBody: function () {
			var body = this.data.body;
			if (body) {
				this._getEntityTransform(ammoTransform$1);
				body.setWorldTransform(ammoTransform$1);
				if (this.type === BODYTYPE_KINEMATIC) {
					var motionState = body.getMotionState();
					if (motionState) {
						motionState.setWorldTransform(ammoTransform$1);
					}
				}
				body.activate();
			}
		},
		_updateDynamic: function () {
			var body = this.data.body;
			if (body.isActive()) {
				var motionState = body.getMotionState();
				if (motionState) {
					motionState.getWorldTransform(ammoTransform$1);
					var p = ammoTransform$1.getOrigin();
					var q = ammoTransform$1.getRotation();
					this.entity.setPosition(p.x(), p.y(), p.z());
					this.entity.setRotation(q.x(), q.y(), q.z(), q.w());
				}
			}
		},
		_updateKinematic: function () {
			var body = this.data.body;
			var motionState = body.getMotionState();
			if (motionState) {
				this._getEntityTransform(ammoTransform$1);
				motionState.setWorldTransform(ammoTransform$1);
			}
		},
		teleport: function () {
			if (arguments.length < 3) {
				if (arguments[0]) {
					this.entity.setPosition(arguments[0]);
				}
				if (arguments[1]) {
					if (arguments[1] instanceof Quat) {
						this.entity.setRotation(arguments[1]);
					} else {
						this.entity.setEulerAngles(arguments[1]);
					}
				}
			} else {
				if (arguments.length === 6) {
					this.entity.setEulerAngles(arguments[3], arguments[4], arguments[5]);
				}
				this.entity.setPosition(arguments[0], arguments[1], arguments[2]);
			}
			this.syncEntityToBody();
		},
		onEnable: function () {
			if (!this.body) {
				this.createBody();
			}
			this.enableSimulation();
		},
		onDisable: function () {
			this.disableSimulation();
		},
		onSetMass: function (name, oldValue, newValue) {
			var body = this.data.body;
			if (body && this.type === BODYTYPE_DYNAMIC) {
				var enabled = this.enabled && this.entity.enabled;
				if (enabled) {
					this.disableSimulation();
				}
				body.getCollisionShape().calculateLocalInertia(newValue, ammoVec1$1);
				body.setMassProps(newValue, ammoVec1$1);
				body.updateInertiaTensor();
				if (enabled) {
					this.enableSimulation();
				}
			}
		},
		onSetLinearDamping: function (name, oldValue, newValue) {
			var body = this.data.body;
			if (body) {
				body.setDamping(newValue, this.data.angularDamping);
			}
		},
		onSetAngularDamping: function (name, oldValue, newValue) {
			var body = this.data.body;
			if (body) {
				body.setDamping(this.data.linearDamping, newValue);
			}
		},
		onSetLinearFactor: function (name, oldValue, newValue) {
			var body = this.data.body;
			if (body && this.type === BODYTYPE_DYNAMIC) {
				ammoVec1$1.setValue(newValue.x, newValue.y, newValue.z);
				body.setLinearFactor(ammoVec1$1);
			}
		},
		onSetAngularFactor: function (name, oldValue, newValue) {
			var body = this.data.body;
			if (body && this.type === BODYTYPE_DYNAMIC) {
				ammoVec1$1.setValue(newValue.x, newValue.y, newValue.z);
				body.setAngularFactor(ammoVec1$1);
			}
		},
		onSetFriction: function (name, oldValue, newValue) {
			var body = this.data.body;
			if (body) {
				body.setFriction(newValue);
			}
		},
		onSetRestitution: function (name, oldValue, newValue) {
			var body = this.data.body;
			if (body) {
				body.setRestitution(newValue);
			}
		},
		onSetType: function (name, oldValue, newValue) {
			if (newValue !== oldValue) {
				this.disableSimulation();
				if (newValue === BODYTYPE_DYNAMIC) {
					this.data.group = BODYGROUP_DYNAMIC;
					this.data.mask = BODYMASK_ALL;
				} else if (newValue === BODYTYPE_KINEMATIC) {
					this.data.group = BODYGROUP_KINEMATIC;
					this.data.mask = BODYMASK_ALL;
				} else {
					this.data.group = BODYGROUP_STATIC;
					this.data.mask = BODYMASK_NOT_STATIC;
				}
				this.createBody();
			}
		},
		onSetGroupOrMask: function (name, oldValue, newValue) {
			if (newValue !== oldValue) {
				var isEnabled = this.enabled && this.entity.enabled;
				if (isEnabled) {
					this.disableSimulation();
					this.enableSimulation();
				}
			}
		},
		onSetBody: function (name, oldValue, newValue) {
			if (this.body && this.data.simulationEnabled) {
				this.body.activate();
			}
		}
	});

	function RigidBodyComponentData() {
		this.enabled = true;
		this.mass = 1;
		this.linearDamping = 0;
		this.angularDamping = 0;
		this.linearFactor = new Vec3(1, 1, 1);
		this.angularFactor = new Vec3(1, 1, 1);
		this.friction = 0.5;
		this.restitution = 0;
		this.type = BODYTYPE_STATIC;
		this.group = BODYGROUP_STATIC;
		this.mask = BODYMASK_NOT_STATIC;
		this.body = null;
		this.simulationEnabled = false;
	}

	var ammoRayStart, ammoRayEnd;
	var collisions = {};
	var frameCollisions = {};
	function RaycastResult(entity, point, normal) {
		this.entity = entity;
		this.point = point;
		this.normal = normal;
	}
	function SingleContactResult(a, b, contactPoint) {
		if (arguments.length === 0) {
			this.a = null;
			this.b = null;
			this.localPointA = new Vec3();
			this.localPointB = new Vec3();
			this.pointA = new Vec3();
			this.pointB = new Vec3();
			this.normal = new Vec3();
		} else {
			this.a = a;
			this.b = b;
			this.localPointA = contactPoint.localPoint;
			this.localPointB = contactPoint.localPointOther;
			this.pointA = contactPoint.point;
			this.pointB = contactPoint.pointOther;
			this.normal = contactPoint.normal;
		}
	}
	function ContactPoint(localPoint, localPointOther, point, pointOther, normal) {
		if (arguments.length === 0) {
			this.localPoint = new Vec3();
			this.localPointOther = new Vec3();
			this.point = new Vec3();
			this.pointOther = new Vec3();
			this.normal = new Vec3();
		} else {
			this.localPoint = localPoint;
			this.localPointOther = localPointOther;
			this.point = point;
			this.pointOther = pointOther;
			this.normal = normal;
		}
	}
	function ContactResult(other, contacts) {
		this.other = other;
		this.contacts = contacts;
	}
	var _schema$c = [
		'enabled',
		'type',
		'mass',
		'linearDamping',
		'angularDamping',
		'linearFactor',
		'angularFactor',
		'friction',
		'restitution',
		'group',
		'mask',
		'body'
	];
	function RigidBodyComponentSystem(app) {
		ComponentSystem.call(this, app);
		this.id = 'rigidbody';
		this._stats = app.stats.frame;
		this.ComponentType = RigidBodyComponent;
		this.DataType = RigidBodyComponentData;
		this.contactPointPool = null;
		this.contactResultPool = null;
		this.singleContactResultPool = null;
		this.schema = _schema$c;
		this.maxSubSteps = 10;
		this.fixedTimeStep = 1 / 60;
		this.gravity = new Vec3(0, -9.81, 0);
		this._dynamic = [];
		this._kinematic = [];
		this._triggers = [];
		this._compounds = [];
		this.on('beforeremove', this.onBeforeRemove, this);
		this.on('remove', this.onRemove, this);
	}
	RigidBodyComponentSystem.prototype = Object.create(ComponentSystem.prototype);
	RigidBodyComponentSystem.prototype.constructor = RigidBodyComponentSystem;
	Component._buildAccessors(RigidBodyComponent.prototype, _schema$c);
	Object.assign(RigidBodyComponentSystem.prototype, {
		onLibraryLoaded: function () {
			if (typeof Ammo !== 'undefined') {
				this.collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
				this.dispatcher = new Ammo.btCollisionDispatcher(this.collisionConfiguration);
				this.overlappingPairCache = new Ammo.btDbvtBroadphase();
				this.solver = new Ammo.btSequentialImpulseConstraintSolver();
				this.dynamicsWorld = new Ammo.btDiscreteDynamicsWorld(this.dispatcher, this.overlappingPairCache, this.solver, this.collisionConfiguration);
				if (this.dynamicsWorld.setInternalTickCallback) {
					var checkForCollisionsPointer = Ammo.addFunction(this._checkForCollisions.bind(this), 'vif');
					this.dynamicsWorld.setInternalTickCallback(checkForCollisionsPointer);
				}
				ammoRayStart = new Ammo.btVector3();
				ammoRayEnd = new Ammo.btVector3();
				this.contactPointPool = new AllocatePool(ContactPoint, 1);
				this.contactResultPool = new AllocatePool(ContactResult, 1);
				this.singleContactResultPool = new AllocatePool(SingleContactResult, 1);
				ComponentSystem.bind('update', this.onUpdate, this);
			} else {
				ComponentSystem.unbind('update', this.onUpdate, this);
			}
		},
		initializeComponentData: function (component, _data, properties) {
			properties = ['enabled', 'mass', 'linearDamping', 'angularDamping', 'linearFactor', 'angularFactor', 'friction', 'restitution', 'type', 'group', 'mask'];
			var data = {};
			for (var i = 0, len = properties.length; i < len; i++) {
				var property = properties[i];
				data[property] = _data[property];
			}
			if (_data.bodyType) {
				data.type = _data.bodyType;
			}
			if (data.linearFactor && Array.isArray(data.linearFactor)) {
				data.linearFactor = new Vec3(data.linearFactor[0], data.linearFactor[1], data.linearFactor[2]);
			}
			if (data.angularFactor && Array.isArray(data.angularFactor)) {
				data.angularFactor = new Vec3(data.angularFactor[0], data.angularFactor[1], data.angularFactor[2]);
			}
			ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
		},
		cloneComponent: function (entity, clone) {
			var data = {
				enabled: entity.rigidbody.enabled,
				mass: entity.rigidbody.mass,
				linearDamping: entity.rigidbody.linearDamping,
				angularDamping: entity.rigidbody.angularDamping,
				linearFactor: [entity.rigidbody.linearFactor.x, entity.rigidbody.linearFactor.y, entity.rigidbody.linearFactor.z],
				angularFactor: [entity.rigidbody.angularFactor.x, entity.rigidbody.angularFactor.y, entity.rigidbody.angularFactor.z],
				friction: entity.rigidbody.friction,
				restitution: entity.rigidbody.restitution,
				type: entity.rigidbody.type,
				group: entity.rigidbody.group,
				mask: entity.rigidbody.mask
			};
			this.addComponent(clone, data);
		},
		onBeforeRemove: function (entity, component) {
			if (component.enabled) {
				component.enabled = false;
			}
		},
		onRemove: function (entity, data) {
			var body = data.body;
			if (body) {
				this.removeBody(body);
				this.destroyBody(body);
				data.body = null;
			}
		},
		addBody: function (body, group, mask) {
			if (group !== undefined && mask !== undefined) {
				this.dynamicsWorld.addRigidBody(body, group, mask);
			} else {
				this.dynamicsWorld.addRigidBody(body);
			}
		},
		removeBody: function (body) {
			this.dynamicsWorld.removeRigidBody(body);
		},
		createBody: function (mass, shape, transform) {
			var localInertia = new Ammo.btVector3(0, 0, 0);
			if (mass !== 0) {
				shape.calculateLocalInertia(mass, localInertia);
			}
			var motionState = new Ammo.btDefaultMotionState(transform);
			var bodyInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, shape, localInertia);
			var body = new Ammo.btRigidBody(bodyInfo);
			Ammo.destroy(bodyInfo);
			Ammo.destroy(localInertia);
			return body;
		},
		destroyBody: function (body) {
			var motionState = body.getMotionState();
			if (motionState) {
				Ammo.destroy(motionState);
			}
			Ammo.destroy(body);
		},
		raycastFirst: function (start, end) {
			var result = null;
			ammoRayStart.setValue(start.x, start.y, start.z);
			ammoRayEnd.setValue(end.x, end.y, end.z);
			var rayCallback = new Ammo.ClosestRayResultCallback(ammoRayStart, ammoRayEnd);
			this.dynamicsWorld.rayTest(ammoRayStart, ammoRayEnd, rayCallback);
			if (rayCallback.hasHit()) {
				var collisionObj = rayCallback.get_m_collisionObject();
				var body = Ammo.castObject(collisionObj, Ammo.btRigidBody);
				if (body) {
					var point = rayCallback.get_m_hitPointWorld();
					var normal = rayCallback.get_m_hitNormalWorld();
					result = new RaycastResult(
						body.entity,
						new Vec3(point.x(), point.y(), point.z()),
						new Vec3(normal.x(), normal.y(), normal.z())
					);
					if (arguments.length > 2) {
						var callback = arguments[2];
						callback(result);
					}
				}
			}
			Ammo.destroy(rayCallback);
			return result;
		},
		raycastAll: function (start, end) {
			var results = [];
			ammoRayStart.setValue(start.x, start.y, start.z);
			ammoRayEnd.setValue(end.x, end.y, end.z);
			var rayCallback = new Ammo.AllHitsRayResultCallback(ammoRayStart, ammoRayEnd);
			this.dynamicsWorld.rayTest(ammoRayStart, ammoRayEnd, rayCallback);
			if (rayCallback.hasHit()) {
				var collisionObjs = rayCallback.get_m_collisionObjects();
				var points = rayCallback.get_m_hitPointWorld();
				var normals = rayCallback.get_m_hitNormalWorld();
				var numHits = collisionObjs.size();
				for (var i = 0; i < numHits; i++) {
					var body = Ammo.castObject(collisionObjs.at(i), Ammo.btRigidBody);
					if (body) {
						var point = points.at(i);
						var normal = normals.at(i);
						var result = new RaycastResult(
							body.entity,
							new Vec3(point.x(), point.y(), point.z()),
							new Vec3(normal.x(), normal.y(), normal.z())
						);
						results.push(result);
					}
				}
			}
			Ammo.destroy(rayCallback);
			return results;
		},
		_storeCollision: function (entity, other) {
			var isNewCollision = false;
			var guid = entity.getGuid();
			collisions[guid] = collisions[guid] || { others: [], entity: entity };
			if (collisions[guid].others.indexOf(other) < 0) {
				collisions[guid].others.push(other);
				isNewCollision = true;
			}
			frameCollisions[guid] = frameCollisions[guid] || { others: [], entity: entity };
			frameCollisions[guid].others.push(other);
			return isNewCollision;
		},
		_createContactPointFromAmmo: function (contactPoint) {
			var localPointA = contactPoint.get_m_localPointA();
			var localPointB = contactPoint.get_m_localPointB();
			var positionWorldOnA = contactPoint.getPositionWorldOnA();
			var positionWorldOnB = contactPoint.getPositionWorldOnB();
			var normalWorldOnB = contactPoint.get_m_normalWorldOnB();
			var contact = this.contactPointPool.allocate();
			contact.localPoint.set(localPointA.x(), localPointA.y(), localPointA.z());
			contact.localPointOther.set(localPointB.x(), localPointB.y(), localPointB.z());
			contact.point.set(positionWorldOnA.x(), positionWorldOnA.y(), positionWorldOnA.z());
			contact.pointOther.set(positionWorldOnB.x(), positionWorldOnB.y(), positionWorldOnB.z());
			contact.normal.set(normalWorldOnB.x(), normalWorldOnB.y(), normalWorldOnB.z());
			return contact;
		},
		_createReverseContactPointFromAmmo: function (contactPoint) {
			var localPointA = contactPoint.get_m_localPointA();
			var localPointB = contactPoint.get_m_localPointB();
			var positionWorldOnA = contactPoint.getPositionWorldOnA();
			var positionWorldOnB = contactPoint.getPositionWorldOnB();
			var normalWorldOnB = contactPoint.get_m_normalWorldOnB();
			var contact = this.contactPointPool.allocate();
			contact.localPointOther.set(localPointA.x(), localPointA.y(), localPointA.z());
			contact.localPoint.set(localPointB.x(), localPointB.y(), localPointB.z());
			contact.pointOther.set(positionWorldOnA.x(), positionWorldOnA.y(), positionWorldOnA.z());
			contact.point.set(positionWorldOnB.x(), positionWorldOnB.y(), positionWorldOnB.z());
			contact.normal.set(normalWorldOnB.x(), normalWorldOnB.y(), normalWorldOnB.z());
			return contact;
		},
		_createSingleContactResult: function (a, b, contactPoint) {
			var result = this.singleContactResultPool.allocate();
			result.a = a;
			result.b = b;
			result.localPointA = contactPoint.localPoint;
			result.localPointB = contactPoint.localPointOther;
			result.pointA = contactPoint.point;
			result.pointB = contactPoint.pointOther;
			result.normal = contactPoint.normal;
			return result;
		},
		_createContactResult: function (other, contacts) {
			var result = this.contactResultPool.allocate();
			result.other = other;
			result.contacts = contacts;
			return result;
		},
		_cleanOldCollisions: function () {
			for (var guid in collisions) {
				if (collisions.hasOwnProperty(guid)) {
					var frameCollision = frameCollisions[guid];
					var collision = collisions[guid];
					var entity = collision.entity;
					var entityCollision = entity.collision;
					var entityRigidbody = entity.rigidbody;
					var others = collision.others;
					var length = others.length;
					var i = length;
					while (i--) {
						var other = others[i];
						if (!frameCollision || frameCollision.others.indexOf(other) < 0) {
							others.splice(i, 1);
							if (entity.trigger) {
								if (entityCollision) {
									entityCollision.fire("triggerleave", other);
								}
								if (other.rigidbody) {
									other.rigidbody.fire('triggerleave', entity);
								}
							} else if (!other.trigger) {
								if (entityRigidbody) {
									entityRigidbody.fire("collisionend", other);
								}
								if (entityCollision) {
									entityCollision.fire("collisionend", other);
								}
							}
						}
					}
					if (others.length === 0) {
						delete collisions[guid];
					}
				}
			}
		},
		_hasContactEvent: function (entity) {
			var c = entity.collision;
			if (c && (c.hasEvent("collisionstart") || c.hasEvent("collisionend") || c.hasEvent("contact"))) {
				return true;
			}
			var r = entity.rigidbody;
			return r && (r.hasEvent("collisionstart") || r.hasEvent("collisionend") || r.hasEvent("contact"));
		},
		_checkForCollisions: function (world, timeStep) {
			var dynamicsWorld = Ammo.wrapPointer(world, Ammo.btDynamicsWorld);
			var dispatcher = dynamicsWorld.getDispatcher();
			var numManifolds = dispatcher.getNumManifolds();
			frameCollisions = {};
			for (var i = 0; i < numManifolds; i++) {
				var manifold = dispatcher.getManifoldByIndexInternal(i);
				var body0 = manifold.getBody0();
				var body1 = manifold.getBody1();
				var wb0 = Ammo.castObject(body0, Ammo.btRigidBody);
				var wb1 = Ammo.castObject(body1, Ammo.btRigidBody);
				var e0 = wb0.entity;
				var e1 = wb1.entity;
				if (!e0 || !e1) {
					continue;
				}
				var flags0 = wb0.getCollisionFlags();
				var flags1 = wb1.getCollisionFlags();
				var numContacts = manifold.getNumContacts();
				var forwardContacts = [];
				var reverseContacts = [];
				var newCollision, e0Events, e1Events, e0BodyEvents, e1BodyEvents;
				if (numContacts > 0) {
					if ((flags0 & BODYFLAG_NORESPONSE_OBJECT) ||
						(flags1 & BODYFLAG_NORESPONSE_OBJECT)) {
						e0Events = e0.collision && (e0.collision.hasEvent("triggerenter") || e0.collision.hasEvent("triggerleave"));
						e1Events = e1.collision && (e1.collision.hasEvent("triggerenter") || e1.collision.hasEvent("triggerleave"));
						e0BodyEvents = e0.rigidbody && (e0.rigidbody.hasEvent("triggerenter") || e0.rigidbody.hasEvent("triggerleave"));
						e1BodyEvents = e1.rigidbody && (e1.rigidbody.hasEvent("triggerenter") || e1.rigidbody.hasEvent("triggerleave"));
						if (e0Events) {
							newCollision = this._storeCollision(e0, e1);
							if (newCollision && !(flags1 & BODYFLAG_NORESPONSE_OBJECT)) {
								e0.collision.fire("triggerenter", e1);
							}
						}
						if (e1Events) {
							newCollision = this._storeCollision(e1, e0);
							if (newCollision && !(flags0 & BODYFLAG_NORESPONSE_OBJECT)) {
								e1.collision.fire("triggerenter", e0);
							}
						}
						if (e0BodyEvents) {
							if (! newCollision) {
								newCollision = this._storeCollision(e1, e0);
							}
							if (newCollision) {
								e0.rigidbody.fire("triggerenter", e1);
							}
						}
						if (e1BodyEvents) {
							if (! newCollision) {
								newCollision = this._storeCollision(e0, e1);
							}
							if (newCollision) {
								e1.rigidbody.fire("triggerenter", e0);
							}
						}
					} else {
						e0Events = this._hasContactEvent(e0);
						e1Events = this._hasContactEvent(e1);
						var globalEvents = this.hasEvent("contact");
						if (globalEvents || e0Events || e1Events) {
							for (var j = 0; j < numContacts; j++) {
								var btContactPoint = manifold.getContactPoint(j);
								var contactPoint = this._createContactPointFromAmmo(btContactPoint);
								var reverseContactPoint = null;
								if (e0Events || e1Events) {
									reverseContactPoint = this._createReverseContactPointFromAmmo(btContactPoint);
									forwardContacts.push(contactPoint);
									reverseContacts.push(reverseContactPoint);
								}
								if (globalEvents) {
									var result = this._createSingleContactResult(e0, e1, contactPoint);
									this.fire("contact", result);
								}
							}
							if (e0Events) {
								var forwardResult = this._createContactResult(e1, forwardContacts);
								newCollision = this._storeCollision(e0, e1);
								if (e0.collision) {
									e0.collision.fire("contact", forwardResult);
									if (newCollision) {
										e0.collision.fire("collisionstart", forwardResult);
									}
								}
								if (e0.rigidbody) {
									e0.rigidbody.fire("contact", forwardResult);
									if (newCollision) {
										e0.rigidbody.fire("collisionstart", forwardResult);
									}
								}
							}
							if (e1Events) {
								var reverseResult = this._createContactResult(e0, reverseContacts);
								newCollision = this._storeCollision(e1, e0);
								if (e1.collision) {
									e1.collision.fire("contact", reverseResult);
									if (newCollision) {
										e1.collision.fire("collisionstart", reverseResult);
									}
								}
								if (e1.rigidbody) {
									e1.rigidbody.fire("contact", reverseResult);
									if (newCollision) {
										e1.rigidbody.fire("collisionstart", reverseResult);
									}
								}
							}
						}
					}
				}
			}
			this._cleanOldCollisions();
			this.contactPointPool.freeAll();
			this.contactResultPool.freeAll();
			this.singleContactResultPool.freeAll();
		},
		onUpdate: function (dt) {
			var i, len;
			var gravity = this.dynamicsWorld.getGravity();
			if (gravity.x() !== this.gravity.x || gravity.y() !== this.gravity.y || gravity.z() !== this.gravity.z) {
				gravity.setValue(this.gravity.x, this.gravity.y, this.gravity.z);
				this.dynamicsWorld.setGravity(gravity);
			}
			var triggers = this._triggers;
			for (i = 0, len = triggers.length; i < len; i++) {
				triggers[i].updateTransform();
			}
			var compounds = this._compounds;
			for (i = 0, len = compounds.length; i < len; i++) {
				compounds[i]._updateCompound();
			}
			var kinematic = this._kinematic;
			for (i = 0, len = kinematic.length; i < len; i++) {
				kinematic[i]._updateKinematic();
			}
			this.dynamicsWorld.stepSimulation(dt, this.maxSubSteps, this.fixedTimeStep);
			var dynamic = this._dynamic;
			for (i = 0, len = dynamic.length; i < len; i++) {
				dynamic[i]._updateDynamic();
			}
			if (!this.dynamicsWorld.setInternalTickCallback)
				this._checkForCollisions(Ammo.getPointer(this.dynamicsWorld), dt);
		},
		destroy: function () {
			if (typeof Ammo !== 'undefined') {
				Ammo.destroy(this.dynamicsWorld);
				Ammo.destroy(this.solver);
				Ammo.destroy(this.overlappingPairCache);
				Ammo.destroy(this.dispatcher);
				Ammo.destroy(this.collisionConfiguration);
				this.dynamicsWorld = null;
				this.solver = null;
				this.overlappingPairCache = null;
				this.dispatcher = null;
				this.collisionConfiguration = null;
			}
		}
	});

	var SCALEMODE_NONE = "none";
	var SCALEMODE_BLEND = "blend";

	function ScreenComponent(system, entity) {
		Component.call(this, system, entity);
		this._resolution = new Vec2(640, 320);
		this._referenceResolution = new Vec2(640, 320);
		this._scaleMode = SCALEMODE_NONE;
		this.scale = 1;
		this._scaleBlend = 0.5;
		this._priority = 0;
		this._screenSpace = false;
		this.cull = this._screenSpace;
		this._screenMatrix = new Mat4();
		system.app.graphicsDevice.on("resizecanvas", this._onResize, this);
	}
	ScreenComponent.prototype = Object.create(Component.prototype);
	ScreenComponent.prototype.constructor = ScreenComponent;
	var _transform = new Mat4();
	Object.assign(ScreenComponent.prototype, {
		syncDrawOrder: function () {
			this.system.queueDrawOrderSync(this.entity.getGuid(), this._processDrawOrderSync, this);
		},
		_recurseDrawOrderSync: function (e, i) {
			if (!(e instanceof Entity)) {
				return i;
			}
			if (e.element) {
				var prevDrawOrder = e.element.drawOrder;
				e.element.drawOrder = i++;
				if (e.element._batchGroupId >= 0 && prevDrawOrder != e.element.drawOrder) {
					this.system.app.batcher.markGroupDirty(e.element._batchGroupId);
				}
			}
			if (e.particlesystem) {
				e.particlesystem.drawOrder = i++;
			}
			var children = e.children;
			for (var j = 0; j < children.length; j++) {
				i = this._recurseDrawOrderSync(children[j], i);
			}
			return i;
		},
		_processDrawOrderSync: function () {
			var i = 1;
			this._recurseDrawOrderSync(this.entity, i);
			this.fire('syncdraworder');
		},
		_calcProjectionMatrix: function () {
			var left;
			var right;
			var bottom;
			var top;
			var near = 1;
			var far = -1;
			var w = this._resolution.x / this.scale;
			var h = this._resolution.y / this.scale;
			left = 0;
			right = w;
			bottom = -h;
			top = 0;
			this._screenMatrix.setOrtho(left, right, bottom, top, near, far);
			if (!this._screenSpace) {
				_transform.setScale(0.5 * w, 0.5 * h, 1);
				this._screenMatrix.mul2(_transform, this._screenMatrix);
			}
		},
		_updateScale: function () {
			this.scale = this._calcScale(this._resolution, this.referenceResolution);
		},
		_calcScale: function (resolution, referenceResolution) {
			var lx = Math.log2(resolution.x / referenceResolution.x);
			var ly = Math.log2(resolution.y / referenceResolution.y);
			return Math.pow(2, (lx * (1 - this._scaleBlend) + ly * this._scaleBlend));
		},
		_onResize: function (width, height) {
			if (this._screenSpace) {
				this._resolution.set(width, height);
				this.resolution = this._resolution;
			}
		},
		onRemove: function () {
			this.system.app.graphicsDevice.off("resizecanvas", this._onResize, this);
			this.fire('remove');
			this.off();
		}
	});
	Object.defineProperty(ScreenComponent.prototype, "resolution", {
		set: function (value) {
			if (!this._screenSpace) {
				this._resolution.set(value.x, value.y);
			} else {
				this._resolution.set(this.system.app.graphicsDevice.width, this.system.app.graphicsDevice.height);
			}
			this._updateScale();
			this._calcProjectionMatrix();
			if (!this.entity._dirtyLocal)
				this.entity._dirtifyLocal();
			this.fire("set:resolution", this._resolution);
		},
		get: function () {
			return this._resolution;
		}
	});
	Object.defineProperty(ScreenComponent.prototype, "referenceResolution", {
		set: function (value) {
			this._referenceResolution.set(value.x, value.y);
			this._updateScale();
			this._calcProjectionMatrix();
			if (!this.entity._dirtyLocal)
				this.entity._dirtifyLocal();
			this.fire("set:referenceresolution", this._resolution);
		},
		get: function () {
			if (this._scaleMode === SCALEMODE_NONE) {
				return this._resolution;
			}
			return this._referenceResolution;
		}
	});
	Object.defineProperty(ScreenComponent.prototype, "screenSpace", {
		set: function (value) {
			this._screenSpace = value;
			if (this._screenSpace) {
				this._resolution.set(this.system.app.graphicsDevice.width, this.system.app.graphicsDevice.height);
			}
			this.resolution = this._resolution;
			if (!this.entity._dirtyLocal)
				this.entity._dirtifyLocal();
			this.fire('set:screenspace', this._screenSpace);
		},
		get: function () {
			return this._screenSpace;
		}
	});
	Object.defineProperty(ScreenComponent.prototype, "scaleMode", {
		set: function (value) {
			if (value !== SCALEMODE_NONE && value !== SCALEMODE_BLEND) {
				value = SCALEMODE_NONE;
			}
			if (!this._screenSpace && value !== SCALEMODE_NONE) {
				value = SCALEMODE_NONE;
			}
			this._scaleMode = value;
			this.resolution = this._resolution;
			this.fire("set:scalemode", this._scaleMode);
		},
		get: function () {
			return this._scaleMode;
		}
	});
	Object.defineProperty(ScreenComponent.prototype, "scaleBlend", {
		set: function (value) {
			this._scaleBlend = value;
			this._updateScale();
			this._calcProjectionMatrix();
			if (!this.entity._dirtyLocal)
				this.entity._dirtifyLocal();
			this.fire("set:scaleblend", this._scaleBlend);
		},
		get: function () {
			return this._scaleBlend;
		}
	});
	Object.defineProperty(ScreenComponent.prototype, "priority", {
		get: function () {
			return this._priority;
		},
		set: function (value) {
			if (value > 0xFF) {
				value = 0xFF;
			}
			this._priority = value;
		}
	});

	function ScreenComponentData() {
		this.enabled = true;
	}

	var _schema$d = ['enabled'];
	function ScreenComponentSystem(app) {
		ComponentSystem.call(this, app);
		this.id = 'screen';
		this.ComponentType = ScreenComponent;
		this.DataType = ScreenComponentData;
		this.schema = _schema$d;
		this.windowResolution = new Vec2();
		this._drawOrderSyncQueue = new IndexedList();
		this.app.graphicsDevice.on("resizecanvas", this._onResize, this);
		ComponentSystem.bind('update', this._onUpdate, this);
		this.on('beforeremove', this.onRemoveComponent, this);
	}
	ScreenComponentSystem.prototype = Object.create(ComponentSystem.prototype);
	ScreenComponentSystem.prototype.constructor = ScreenComponentSystem;
	Component._buildAccessors(ScreenComponent.prototype, _schema$d);
	Object.assign(ScreenComponentSystem.prototype, {
		initializeComponentData: function (component, data, properties) {
			if (data.priority !== undefined) component.priority = data.priority;
			if (data.screenSpace !== undefined) component.screenSpace = data.screenSpace;
			component.cull = component.screenSpace;
			if (data.scaleMode !== undefined) component.scaleMode = data.scaleMode;
			if (data.scaleBlend !== undefined) component.scaleBlend = data.scaleBlend;
			if (data.resolution !== undefined) {
				if (data.resolution instanceof Vec2){
					component._resolution.copy(data.resolution);
				} else {
					component._resolution.set(data.resolution[0], data.resolution[1]);
				}
				component.resolution = component._resolution;
			}
			if (data.referenceResolution !== undefined) {
				if (data.referenceResolution instanceof Vec2){
					component._referenceResolution.copy(data.referenceResolution);
				} else {
					component._referenceResolution.set(data.referenceResolution[0], data.referenceResolution[1]);
				}
				component.referenceResolution = component._referenceResolution;
			}
			component.syncDrawOrder();
			ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
		},
		destroy: function () {
			this.off();
			this.app.graphicsDevice.off("resizecanvas", this._onResize, this);
		},
		_onUpdate: function (dt) {
			var components = this.store;
			for (var id in components) {
				if (components[id].entity.screen.update) components[id].entity.screen.update(dt);
			}
		},
		_onResize: function (width, height) {
			this.windowResolution.x = width;
			this.windowResolution.y = height;
		},
		cloneComponent: function (entity, clone) {
			var screen = entity.screen;
			return this.addComponent(clone, {
				enabled: screen.enabled,
				screenSpace: screen.screenSpace,
				scaleMode: screen.scaleMode,
				resolution: screen.resolution.clone(),
				referenceResolution: screen.referenceResolution.clone()
			});
		},
		onRemoveComponent: function (entity, component) {
			component.onRemove();
		},
		processDrawOrderSyncQueue: function () {
			var list = this._drawOrderSyncQueue.list();
			for (var i = 0; i < list.length; i++) {
				var item = list[i];
				item.callback.call(item.scope);
			}
			this._drawOrderSyncQueue.clear();
		},
		queueDrawOrderSync: function (id, fn, scope) {
			if (!this._drawOrderSyncQueue.list().length) {
				this.app.once('prerender', this.processDrawOrderSyncQueue, this);
			}
			if (!this._drawOrderSyncQueue.has(id)) {
				this._drawOrderSyncQueue.push(id, {
					callback: fn,
					scope: scope
				});
			}
		}
	});

	var components = ['x', 'y', 'z', 'w'];
	var vecLookup = [undefined, undefined, Vec2, Vec3, Vec4];
	var rawToValue = function (app, args, value, old) {
		var i;
		switch (args.type) {
			case 'boolean':
				return !!value;
			case 'number':
				if (typeof value === 'number') {
					return value;
				} else if (typeof value === 'string') {
					var v = parseInt(value, 10);
					if (isNaN(v)) return null;
					return v;
				} else if (typeof value === 'boolean') {
					return 0 + value;
				}
				return null;
			case 'json':
				if (typeof value === 'object') {
					return value;
				}
				try {
					return JSON.parse(value);
				} catch (ex) {
					return null;
				}
			case 'asset':
				if (value instanceof Asset) {
					return value;
				} else if (typeof value === 'number') {
					return app.assets.get(value) || null;
				} else if (typeof value === 'string') {
					return app.assets.get(parseInt(value, 10)) || null;
				}
				return null;
			case 'entity':
				if (value instanceof GraphNode) {
					return value;
				} else if (typeof value === 'string') {
					return app.getEntityFromIndex(value);
				}
				return null;
			case 'rgb':
			case 'rgba':
				if (value instanceof Color) {
					if (old instanceof Color) {
						old.copy(value);
						return old;
					}
					return value.clone();
				} else if (value instanceof Array && value.length >= 3 && value.length <= 4) {
					for (i = 0; i < value.length; i++) {
						if (typeof value[i] !== 'number')
							return null;
					}
					if (!old) old = new Color();
					old.r = value[0];
					old.g = value[1];
					old.b = value[2];
					old.a = (value.length === 3) ? 1 : value[3];
					return old;
				} else if (typeof value === 'string' && /#([0-9abcdef]{2}){3,4}/i.test(value)) {
					if (!old)
						old = new Color();
					old.fromString(value);
					return old;
				}
				return null;
			case 'vec2':
			case 'vec3':
			case 'vec4':
				var len = parseInt(args.type.slice(3), 10);
				var vecType = vecLookup[len];
				if (value instanceof vecType) {
					if (old instanceof vecType) {
						old.copy(value);
						return old;
					}
					return value.clone();
				} else if (value instanceof Array && value.length === len) {
					for (i = 0; i < value.length; i++) {
						if (typeof value[i] !== 'number')
							return null;
					}
					if (!old) old = new vecType();
					for (i = 0; i < len; i++)
						old[components[i]] = value[i];
					return old;
				}
				return null;
			case 'curve':
				if (value) {
					var curve;
					if (value instanceof Curve || value instanceof CurveSet) {
						curve = value.clone();
					} else {
						var CurveType = value.keys[0] instanceof Array ? CurveSet : Curve;
						curve = new CurveType(value.keys);
						curve.type = value.type;
					}
					return curve;
				}
				break;
		}
		return value;
	};
	function ScriptAttributes(scriptType) {
		this.scriptType = scriptType;
		this.index = { };
	}
	ScriptAttributes.prototype.add = function (name, args) {
		if (this.index[name]) {
			return;
		} else if (createScript.reservedAttributes[name]) {
			return;
		}
		this.index[name] = args;
		Object.defineProperty(this.scriptType.prototype, name, {
			get: function () {
				return this.__attributes[name];
			},
			set: function (raw) {
				var old = this.__attributes[name];
				if (args.array) {
					this.__attributes[name] = [];
					if (raw) {
						var i;
						var len;
						for (i = 0, len = raw.length; i < len; i++) {
							this.__attributes[name].push(rawToValue(this.app, args, raw[i], old ? old[i] : null));
						}
					}
				} else {
					this.__attributes[name] = rawToValue(this.app, args, raw, old);
				}
				this.fire('attr', name, this.__attributes[name], old);
				this.fire('attr:' + name, this.__attributes[name], old);
			}
		});
	};
	ScriptAttributes.prototype.remove = function (name) {
		if (!this.index[name])
			return false;
		delete this.index[name];
		delete this.scriptType.prototype[name];
		return true;
	};
	ScriptAttributes.prototype.has = function (name) {
		return !!this.index[name];
	};
	ScriptAttributes.prototype.get = function (name) {
		return this.index[name] || null;
	};

	var funcNameRegex = new RegExp('^\\s*function(?:\\s|\\s*\\/\\*.*\\*\\/\\s*)+([^\\(\\s\\/]*)\\s*');
	function ScriptType(args) {
		EventHandler.call(this);
		var script = this.constructor;
		this.app = args.app;
		this.entity = args.entity;
		this._enabled = typeof args.enabled === 'boolean' ? args.enabled : true;
		this._enabledOld = this.enabled;
		this.__destroyed = false;
		this.__attributes = { };
		this.__attributesRaw = args.attributes || { };
		this.__scriptType = script;
		this.__executionOrder = -1;
	}
	ScriptType.prototype = Object.create(EventHandler.prototype);
	ScriptType.prototype.constructor = ScriptType;
	ScriptType.__name = null;
	ScriptType.__getScriptName = function (constructorFn) {
		if (typeof constructorFn !== 'function') return undefined;
		if ('name' in Function.prototype) return constructorFn.name;
		if (constructorFn === Function || constructorFn === Function.prototype.constructor) return 'Function';
		var match = ("" + constructorFn).match(funcNameRegex);
		return match ? match[1] : undefined;
	};
	Object.defineProperty(ScriptType, 'scriptName', {
		get: function () {
			return this.__name;
		}
	});
	Object.defineProperty(ScriptType, 'attributes', {
		get: function () {
			if (!this.hasOwnProperty('__attributes')) this.__attributes = new ScriptAttributes(this);
			return this.__attributes;
		}
	});
	ScriptType.prototype.__initializeAttributes = function (force) {
		if (!force && !this.__attributesRaw)
			return;
		for (var key in this.__scriptType.attributes.index) {
			if (this.__attributesRaw && this.__attributesRaw.hasOwnProperty(key)) {
				this[key] = this.__attributesRaw[key];
			} else if (!this.__attributes.hasOwnProperty(key)) {
				if (this.__scriptType.attributes.index[key].hasOwnProperty('default')) {
					this[key] = this.__scriptType.attributes.index[key].default;
				} else {
					this[key] = null;
				}
			}
		}
		this.__attributesRaw = null;
	};
	ScriptType.extend = function (methods) {
		for (var key in methods) {
			if (!methods.hasOwnProperty(key))
				continue;
			this.prototype[key] = methods[key];
		}
	};
	Object.defineProperty(ScriptType.prototype, 'enabled', {
		get: function () {
			return this._enabled && !this._destroyed && this.entity.script.enabled && this.entity.enabled;
		},
		set: function (value) {
			this._enabled = !!value;
			if (this.enabled === this._enabledOld) return;
			this._enabledOld = this.enabled;
			this.fire(this.enabled ? 'enable' : 'disable');
			this.fire('state', this.enabled);
			if (!this._initialized && this.enabled) {
				this._initialized = true;
				this.__initializeAttributes(true);
				if (this.initialize)
					this.entity.script._scriptMethod(this, ScriptComponent.scriptMethods.initialize);
			}
			if (this._initialized && !this._postInitialized && this.enabled && !this.entity.script._beingEnabled) {
				this._postInitialized = true;
				if (this.postInitialize)
					this.entity.script._scriptMethod(this, ScriptComponent.scriptMethods.postInitialize);
			}
		}
	});

	function createScript(name, app) {
		if (script.legacy) {
			return null;
		}
		if (createScript.reservedScripts[name])
			throw new Error('script name: \'' + name + '\' is reserved, please change script name');
		var scriptType = function (args) {
			ScriptType.call(this, args);
		};
		scriptType.prototype = Object.create(ScriptType.prototype);
		scriptType.prototype.constructor = scriptType;
		scriptType.extend = ScriptType.extend;
		scriptType.attributes = new ScriptAttributes(scriptType);
		registerScript(scriptType, name, app);
		return scriptType;
	}
	function registerScript(script, name, app) {
		if (script.legacy) {
			return;
		}
		if (typeof script !== 'function')
			throw new Error('script class: \'' + script + '\' must be a constructor function (i.e. class).');
		if (!(script.prototype instanceof ScriptType))
			throw new Error('script class: \'' + ScriptType.__getScriptName(script) + '\' does not extend pc.ScriptType.');
		name = name || script.__name || ScriptType.__getScriptName(script);
		if (createScript.reservedScripts[name])
			throw new Error('script name: \'' + name + '\' is reserved, please change script name');
		script.__name = name;
		var registry = app ? app.scripts : Application.getApplication().scripts;
		registry.add(script);
		ScriptHandler._push(script);
	}
	createScript.reservedScripts = [
		'system', 'entity', 'create', 'destroy', 'swap', 'move',
		'scripts', '_scripts', '_scriptsIndex', '_scriptsData',
		'enabled', '_oldState', 'onEnable', 'onDisable', 'onPostStateChange',
		'_onSetEnabled', '_checkState', '_onBeforeRemove',
		'_onInitializeAttributes', '_onInitialize', '_onPostInitialize',
		'_onUpdate', '_onPostUpdate',
		'_callbacks', 'has', 'get', 'on', 'off', 'fire', 'once', 'hasEvent'
	];
	var reservedScripts = { };
	var i$1;
	for (i$1 = 0; i$1 < createScript.reservedScripts.length; i$1++)
		reservedScripts[createScript.reservedScripts[i$1]] = 1;
	createScript.reservedScripts = reservedScripts;
	createScript.reservedAttributes = [
		'app', 'entity', 'enabled', '_enabled', '_enabledOld', '_destroyed',
		'__attributes', '__attributesRaw', '__scriptType', '__executionOrder',
		'_callbacks', 'has', 'get', 'on', 'off', 'fire', 'once', 'hasEvent'
	];
	var reservedAttributes = { };
	for (i$1 = 0; i$1 < createScript.reservedAttributes.length; i$1++)
		reservedAttributes[createScript.reservedAttributes[i$1]] = 1;
	createScript.reservedAttributes = reservedAttributes;

	function SortedLoopArray(args) {
		this._sortBy = args.sortBy;
		this.items = [];
		this.length = 0;
		this.loopIndex = -1;
		this._sortHandler = this._doSort.bind(this);
	}
	SortedLoopArray.prototype._binarySearch = function (item) {
		var left = 0;
		var right = this.items.length - 1;
		var search = item[this._sortBy];
		var middle;
		var current;
		while (left <= right) {
			middle = Math.floor((left + right) / 2);
			current = this.items[middle][this._sortBy];
			if (current <= search) {
				left = middle + 1;
			} else if (current > search) {
				right = middle - 1;
			}
		}
		return left;
	};
	SortedLoopArray.prototype._doSort = function (a, b) {
		var sortBy = this._sortBy;
		return a[sortBy] - b[sortBy];
	};
	SortedLoopArray.prototype.insert = function (item) {
		var index = this._binarySearch(item);
		this.items.splice(index, 0, item);
		this.length++;
		if (this.loopIndex >= index) {
			this.loopIndex++;
		}
	};
	SortedLoopArray.prototype.append = function (item) {
		this.items.push(item);
		this.length++;
	};
	SortedLoopArray.prototype.remove = function (item) {
		var idx = this.items.indexOf(item);
		if (idx < 0) return;
		this.items.splice(idx, 1);
		this.length--;
		if (this.loopIndex >= idx) {
			this.loopIndex--;
		}
	};
	SortedLoopArray.prototype.sort = function () {
		var current = (this.loopIndex >= 0 ? this.items[this.loopIndex] : null);
		this.items.sort(this._sortHandler);
		if (current !== null) {
			this.loopIndex = this.items.indexOf(current);
		}
	};

	function ScriptComponent(system, entity) {
		Component.call(this, system, entity);
		this._scripts = [];
		this._updateList = new SortedLoopArray({ sortBy: '__executionOrder' });
		this._postUpdateList = new SortedLoopArray({ sortBy: '__executionOrder' });
		this._scriptsIndex = {};
		this._destroyedScripts = [];
		this._destroyed = false;
		this._scriptsData = null;
		this._oldState = true;
		this._enabled = true;
		this._beingEnabled = false;
		this._isLoopingThroughScripts = false;
		this._executionOrder = -1;
		this.on('set_enabled', this._onSetEnabled, this);
	}
	ScriptComponent.prototype = Object.create(Component.prototype);
	ScriptComponent.prototype.constructor = ScriptComponent;
	ScriptComponent.scriptMethods = {
		initialize: 'initialize',
		postInitialize: 'postInitialize',
		update: 'update',
		postUpdate: 'postUpdate',
		swap: 'swap'
	};
	Object.assign(ScriptComponent.prototype, {
		onEnable: function () {
			this._beingEnabled = true;
			this._checkState();
			if (!this.entity._beingEnabled) {
				this.onPostStateChange();
			}
			this._beingEnabled = false;
		},
		onDisable: function () {
			this._checkState();
		},
		onPostStateChange: function () {
			var script;
			var wasLooping = this._beginLooping();
			for (var i = 0, len = this.scripts.length; i < len; i++) {
				script = this.scripts[i];
				if (script._initialized && !script._postInitialized && script.enabled) {
					script._postInitialized = true;
					if (script.postInitialize)
						this._scriptMethod(script, ScriptComponent.scriptMethods.postInitialize);
				}
			}
			this._endLooping(wasLooping);
		},
		_beginLooping: function () {
			var looping = this._isLoopingThroughScripts;
			this._isLoopingThroughScripts = true;
			return looping;
		},
		_endLooping: function (wasLoopingBefore) {
			this._isLoopingThroughScripts = wasLoopingBefore;
			if (!this._isLoopingThroughScripts) {
				this._removeDestroyedScripts();
			}
		},
		_onSetEnabled: function (prop, old, value) {
			this._beingEnabled = true;
			this._checkState();
			this._beingEnabled = false;
		},
		_checkState: function () {
			var state = this.enabled && this.entity.enabled;
			if (state === this._oldState)
				return;
			this._oldState = state;
			this.fire(state ? 'enable' : 'disable');
			this.fire('state', state);
			if (state) {
				this.system._addComponentToEnabled(this);
			} else {
				this.system._removeComponentFromEnabled(this);
			}
			var wasLooping = this._beginLooping();
			var script;
			for (var i = 0, len = this.scripts.length; i < len; i++) {
				script = this.scripts[i];
				script.enabled = script._enabled;
			}
			this._endLooping(wasLooping);
		},
		_onBeforeRemove: function () {
			this.fire('remove');
			var wasLooping = this._beginLooping();
			for (var i = 0; i < this.scripts.length; i++) {
				var script = this.scripts[i];
				if (!script) continue;
				this.destroy(script.__scriptType.__name);
			}
			this._endLooping(wasLooping);
		},
		_removeDestroyedScripts: function () {
			var len = this._destroyedScripts.length;
			if (!len) return;
			var i;
			for (i = 0; i < len; i++) {
				var script = this._destroyedScripts[i];
				this._removeScriptInstance(script);
			}
			this._destroyedScripts.length = 0;
			this._resetExecutionOrder(0, this._scripts.length);
		},
		_onInitializeAttributes: function () {
			for (var i = 0, len = this.scripts.length; i < len; i++)
				this.scripts[i].__initializeAttributes();
		},
		_scriptMethod: function (script, method, arg) {
				script[method](arg);
		},
		_onInitialize: function () {
			var script, scripts = this._scripts;
			var wasLooping = this._beginLooping();
			for (var i = 0, len = scripts.length; i < len; i++) {
				script = scripts[i];
				if (!script._initialized && script.enabled) {
					script._initialized = true;
					if (script.initialize)
						this._scriptMethod(script, ScriptComponent.scriptMethods.initialize);
				}
			}
			this._endLooping(wasLooping);
		},
		_onPostInitialize: function () {
			this.onPostStateChange();
		},
		_onUpdate: function (dt) {
			var self = this;
			var list = self._updateList;
			if (! list.length) return;
			var script;
			var wasLooping = self._beginLooping();
			for (list.loopIndex = 0; list.loopIndex < list.length; list.loopIndex++) {
				script = list.items[list.loopIndex];
				if (script.enabled) {
					self._scriptMethod(script, ScriptComponent.scriptMethods.update, dt);
				}
			}
			self._endLooping(wasLooping);
		},
		_onPostUpdate: function (dt) {
			var self = this;
			var list = self._postUpdateList;
			if (! list.length) return;
			var wasLooping = self._beginLooping();
			var script;
			for (list.loopIndex = 0; list.loopIndex < list.length; list.loopIndex++) {
				script = list.items[list.loopIndex];
				if (script.enabled) {
					self._scriptMethod(script, ScriptComponent.scriptMethods.postUpdate, dt);
				}
			}
			self._endLooping(wasLooping);
		},
		_insertScriptInstance: function (scriptInstance, index, scriptsLength) {
			if (index === -1) {
				this._scripts.push(scriptInstance);
				scriptInstance.__executionOrder = scriptsLength;
				if (scriptInstance.update) {
					this._updateList.append(scriptInstance);
				}
				if (scriptInstance.postUpdate) {
					this._postUpdateList.append(scriptInstance);
				}
			} else {
				this._scripts.splice(index, 0, scriptInstance);
				scriptInstance.__executionOrder = index;
				this._resetExecutionOrder(index + 1, scriptsLength + 1);
				if (scriptInstance.update) {
					this._updateList.insert(scriptInstance);
				}
				if (scriptInstance.postUpdate) {
					this._postUpdateList.insert(scriptInstance);
				}
			}
		},
		_removeScriptInstance: function (scriptInstance) {
			var idx = this._scripts.indexOf(scriptInstance);
			if (idx === -1) return idx;
			this._scripts.splice(idx, 1);
			if (scriptInstance.update) {
				this._updateList.remove(scriptInstance);
			}
			if (scriptInstance.postUpdate) {
				this._postUpdateList.remove(scriptInstance);
			}
			return idx;
		},
		_resetExecutionOrder: function (startIndex, scriptsLength) {
			for (var i = startIndex; i < scriptsLength; i++) {
				this._scripts[i].__executionOrder = i;
			}
		},
		has: function (nameOrType) {
			if (typeof nameOrType === 'string') {
				return !!this._scriptsIndex[nameOrType];
			}
			if (!nameOrType) return false;
			var scriptType = nameOrType;
			var scriptName = scriptType.__name;
			var scriptData = this._scriptsIndex[scriptName];
			var scriptInstance = scriptData && scriptData.instance;
			return scriptInstance instanceof scriptType;
		},
		get: function (nameOrType) {
			if (typeof nameOrType === 'string') {
				var data = this._scriptsIndex[nameOrType];
				return data ? data.instance : null;
			}
			if (!nameOrType) return null;
			var scriptType = nameOrType;
			var scriptName = scriptType.__name;
			var scriptData = this._scriptsIndex[scriptName];
			var scriptInstance = scriptData && scriptData.instance;
			return scriptInstance instanceof scriptType ? scriptInstance : null;
		},
		create: function (nameOrType, args) {
			var self = this;
			args = args || { };
			var scriptType = nameOrType;
			var scriptName = nameOrType;
			if (typeof scriptType === 'string') {
				scriptType = this.system.app.scripts.get(scriptType);
			} else if (scriptType) {
				scriptName = scriptType.__name;
			}
			if (scriptType) {
				if (!this._scriptsIndex[scriptName] || !this._scriptsIndex[scriptName].instance) {
					var scriptInstance = new scriptType({
						app: this.system.app,
						entity: this.entity,
						enabled: args.hasOwnProperty('enabled') ? args.enabled : true,
						attributes: args.attributes
					});
					var len = this._scripts.length;
					var ind = -1;
					if (typeof args.ind === 'number' && args.ind !== -1 && len > args.ind)
						ind = args.ind;
					this._insertScriptInstance(scriptInstance, ind, len);
					this._scriptsIndex[scriptName] = {
						instance: scriptInstance,
						onSwap: function () {
							self.swap(scriptName);
						}
					};
					this[scriptName] = scriptInstance;
					if (!args.preloading)
						scriptInstance.__initializeAttributes();
					this.fire('create', scriptName, scriptInstance);
					this.fire('create:' + scriptName, scriptInstance);
					this.system.app.scripts.on('swap:' + scriptName, this._scriptsIndex[scriptName].onSwap);
					if (!args.preloading) {
						if (scriptInstance.enabled && !scriptInstance._initialized) {
							scriptInstance._initialized = true;
							if (scriptInstance.initialize)
								this._scriptMethod(scriptInstance, ScriptComponent.scriptMethods.initialize);
						}
						if (scriptInstance.enabled && !scriptInstance._postInitialized) {
							scriptInstance._postInitialized = true;
							if (scriptInstance.postInitialize)
								this._scriptMethod(scriptInstance, ScriptComponent.scriptMethods.postInitialize);
						}
					}
					return scriptInstance;
				}
				console.warn('script \'' + scriptName + '\' is already added to entity \'' + this.entity.name + '\'');
			} else {
				this._scriptsIndex[scriptName] = {
					awaiting: true,
					ind: this._scripts.length
				};
				console.warn('script \'' + scriptName + '\' is not found, awaiting it to be added to registry');
			}
			return null;
		},
		destroy: function (nameOrType) {
			var scriptName = nameOrType;
			var scriptType = nameOrType;
			if (typeof scriptType === 'string') {
				scriptType = this.system.app.scripts.get(scriptType);
			} else if (scriptType) {
				scriptName = scriptType.__name;
			}
			var scriptData = this._scriptsIndex[scriptName];
			delete this._scriptsIndex[scriptName];
			if (!scriptData) return false;
			var scriptInstance = scriptData.instance;
			if (scriptInstance && !scriptInstance._destroyed) {
				scriptInstance.enabled = false;
				scriptInstance._destroyed = true;
				if (!this._isLoopingThroughScripts) {
					var ind = this._removeScriptInstance(scriptInstance);
					if (ind >= 0) {
						this._resetExecutionOrder(ind, this._scripts.length);
					}
				} else {
					this._destroyedScripts.push(scriptInstance);
				}
			}
			this.system.app.scripts.off('swap:' + scriptName, scriptData.onSwap);
			delete this[scriptName];
			this.fire('destroy', scriptName, scriptInstance || null);
			this.fire('destroy:' + scriptName, scriptInstance || null);
			if (scriptInstance)
				scriptInstance.fire('destroy');
			return true;
		},
		swap: function (nameOrType) {
			var scriptName = nameOrType;
			var scriptType = nameOrType;
			if (typeof scriptType === 'string') {
				scriptType = this.system.app.scripts.get(scriptType);
			} else if (scriptType) {
				scriptName = scriptType.__name;
			}
			var old = this._scriptsIndex[scriptName];
			if (!old || !old.instance) return false;
			var scriptInstanceOld = old.instance;
			var ind = this._scripts.indexOf(scriptInstanceOld);
			var scriptInstance = new scriptType({
				app: this.system.app,
				entity: this.entity,
				enabled: scriptInstanceOld.enabled,
				attributes: scriptInstanceOld.__attributes
			});
			if (!scriptInstance.swap)
				return false;
			scriptInstance.__initializeAttributes();
			this._scripts[ind] = scriptInstance;
			this._scriptsIndex[scriptName].instance = scriptInstance;
			this[scriptName] = scriptInstance;
			scriptInstance.__executionOrder = ind;
			if (scriptInstanceOld.update) {
				this._updateList.remove(scriptInstanceOld);
			}
			if (scriptInstanceOld.postUpdate) {
				this._postUpdateList.remove(scriptInstanceOld);
			}
			if (scriptInstance.update) {
				this._updateList.insert(scriptInstance);
			}
			if (scriptInstance.postUpdate) {
				this._postUpdateList.insert(scriptInstance);
			}
			this._scriptMethod(scriptInstance, ScriptComponent.scriptMethods.swap, scriptInstanceOld);
			this.fire('swap', scriptName, scriptInstance);
			this.fire('swap:' + scriptName, scriptInstance);
			return true;
		},
		resolveDuplicatedEntityReferenceProperties: function (oldScriptComponent, duplicatedIdsMap) {
			var newScriptComponent = this.entity.script;
			for (var scriptName in oldScriptComponent._scriptsIndex) {
				var scriptType = this.system.app.scripts.get(scriptName);
				if (! scriptType) {
					continue;
				}
				var script = oldScriptComponent._scriptsIndex[scriptName];
				if (! script || ! script.instance) {
					continue;
				}
				var newAttributesRaw = newScriptComponent[scriptName].__attributesRaw;
				var newAttributes = newScriptComponent[scriptName].__attributes;
				if (! newAttributesRaw && ! newAttributes) {
					continue;
				}
				var oldAttributes = script.instance.__attributes;
				for (var attributeName in oldAttributes) {
					if (! oldAttributes[attributeName]) {
						continue;
					}
					var attribute = scriptType.attributes.get(attributeName);
					if (! attribute || attribute.type !== 'entity') {
						continue;
					}
					if (attribute.array) {
						var oldGuidArray = oldAttributes[attributeName];
						var len = oldGuidArray.length;
						if (! len) {
							continue;
						}
						var newGuidArray = oldGuidArray.slice();
						for (var i = 0; i < len; i++) {
							var guid = newGuidArray[i] instanceof Entity ? newGuidArray[i].getGuid() : newGuidArray[i];
							if (duplicatedIdsMap[guid]) {
								newGuidArray[i] = newAttributesRaw ? duplicatedIdsMap[guid].getGuid() : duplicatedIdsMap[guid];
							}
						}
						if (newAttributesRaw) {
							newAttributesRaw[attributeName] = newGuidArray;
						} else {
							newAttributes[attributeName] = newGuidArray;
						}
					} else {
						var oldGuid = oldAttributes[attributeName];
						if (oldGuid instanceof Entity) {
							oldGuid = oldGuid.getGuid();
						} else if (typeof oldGuid !== 'string') {
							continue;
						}
						if (duplicatedIdsMap[oldGuid]) {
							if (newAttributesRaw) {
								newAttributesRaw[attributeName] = duplicatedIdsMap[oldGuid].getGuid();
							} else {
								newAttributes[attributeName] = duplicatedIdsMap[oldGuid];
							}
						}
					}
				}
			}
		},
		move: function (nameOrType, ind) {
			var len = this._scripts.length;
			if (ind >= len || ind < 0)
				return false;
			var scriptType = nameOrType;
			var scriptName = nameOrType;
			if (typeof scriptName !== 'string') {
				scriptName = nameOrType.__name;
			} else {
				scriptType = null;
			}
			var scriptData = this._scriptsIndex[scriptName];
			if (!scriptData || !scriptData.instance)
				return false;
			var scriptInstance = scriptData.instance;
			if (scriptType && !(scriptInstance instanceof scriptType))
				return false;
			var indOld = this._scripts.indexOf(scriptInstance);
			if (indOld === -1 || indOld === ind)
				return false;
			this._scripts.splice(ind, 0, this._scripts.splice(indOld, 1)[0]);
			this._resetExecutionOrder(0, len);
			this._updateList.sort();
			this._postUpdateList.sort();
			this.fire('move', scriptName, scriptInstance, ind, indOld);
			this.fire('move:' + scriptName, scriptInstance, ind, indOld);
			return true;
		}
	});
	Object.defineProperty(ScriptComponent.prototype, 'enabled', {
		get: function () {
			return this._enabled;
		},
		set: function (value) {
			var oldValue = this._enabled;
			this._enabled = value;
			this.fire('set', 'enabled', oldValue, value);
		}
	});
	Object.defineProperty(ScriptComponent.prototype, 'scripts', {
		get: function () {
			return this._scripts;
		},
		set: function (value) {
			this._scriptsData = value;
			for (var key in value) {
				if (!value.hasOwnProperty(key))
					continue;
				var script = this._scriptsIndex[key];
				if (script) {
					if (typeof value[key].enabled === 'boolean')
						script.enabled = !!value[key].enabled;
					if (typeof value[key].attributes === 'object') {
						for (var attr in value[key].attributes) {
							if (createScript.reservedAttributes[attr])
								continue;
							if (!script.__attributes.hasOwnProperty(attr)) {
								var scriptType = this.system.app.scripts.get(key);
								if (scriptType)
									scriptType.attributes.add(attr, { });
							}
							script[attr] = value[key].attributes[attr];
						}
					}
				} else {
					console.log(this.order);
				}
			}
		}
	});

	function ScriptComponentData() {
		this.enabled = true;
	}

	var METHOD_INITIALIZE_ATTRIBUTES = '_onInitializeAttributes';
	var METHOD_INITIALIZE = '_onInitialize';
	var METHOD_POST_INITIALIZE = '_onPostInitialize';
	var METHOD_UPDATE = '_onUpdate';
	var METHOD_POST_UPDATE = '_onPostUpdate';
	var executionOrderCounter = 0;
	function ScriptComponentSystem(app) {
		ComponentSystem.call(this, app);
		this.id = 'script';
		this.ComponentType = ScriptComponent;
		this.DataType = ScriptComponentData;
		this._components = new SortedLoopArray({
			sortBy: '_executionOrder'
		});
		this._enabledComponents = new SortedLoopArray({
			sortBy: '_executionOrder'
		});
		this.preloading = true;
		this.on('beforeremove', this._onBeforeRemove, this);
		ComponentSystem.bind('initialize', this._onInitialize, this);
		ComponentSystem.bind('postInitialize', this._onPostInitialize, this);
		ComponentSystem.bind('update', this._onUpdate, this);
		ComponentSystem.bind('postUpdate', this._onPostUpdate, this);
	}
	ScriptComponentSystem.prototype = Object.create(ComponentSystem.prototype);
	ScriptComponentSystem.prototype.constructor = ScriptComponentSystem;
	Object.assign(ScriptComponentSystem.prototype, {
		initializeComponentData: function (component, data) {
			component._executionOrder = executionOrderCounter++;
			this._components.append(component);
			if (executionOrderCounter > Number.MAX_SAFE_INTEGER) {
				this._resetExecutionOrder();
			}
			component.enabled = data.hasOwnProperty('enabled') ? !!data.enabled : true;
			if (component.enabled && component.entity.enabled) {
				this._enabledComponents.append(component);
			}
			if (data.hasOwnProperty('order') && data.hasOwnProperty('scripts')) {
				component._scriptsData = data.scripts;
				for (var i = 0; i < data.order.length; i++) {
					component.create(data.order[i], {
						enabled: data.scripts[data.order[i]].enabled,
						attributes: data.scripts[data.order[i]].attributes,
						preloading: this.preloading
					});
				}
			}
		},
		cloneComponent: function (entity, clone) {
			var i, key;
			var order = [];
			var scripts = { };
			for (i = 0; i < entity.script._scripts.length; i++) {
				var scriptInstance = entity.script._scripts[i];
				var scriptName = scriptInstance.__scriptType.__name;
				order.push(scriptName);
				var attributes = { };
				for (key in scriptInstance.__attributes)
					attributes[key] = scriptInstance.__attributes[key];
				scripts[scriptName] = {
					enabled: scriptInstance._enabled,
					attributes: attributes
				};
			}
			for (key in entity.script._scriptsIndex) {
				if (key.awaiting) {
					order.splice(key.ind, 0, key);
				}
			}
			var data = {
				enabled: entity.script.enabled,
				order: order,
				scripts: scripts
			};
			return this.addComponent(clone, data);
		},
		_resetExecutionOrder: function () {
			executionOrderCounter = 0;
			for (var i = 0, len = this._components.length; i < len; i++) {
				this._components.items[i]._executionOrder = executionOrderCounter++;
			}
		},
		_callComponentMethod: function (components, name, dt) {
			for (components.loopIndex = 0; components.loopIndex < components.length; components.loopIndex++) {
				components.items[components.loopIndex][name](dt);
			}
		},
		_onInitialize: function () {
			this.preloading = false;
			this._callComponentMethod(this._components, METHOD_INITIALIZE_ATTRIBUTES);
			this._callComponentMethod(this._enabledComponents, METHOD_INITIALIZE);
		},
		_onPostInitialize: function () {
			this._callComponentMethod(this._enabledComponents, METHOD_POST_INITIALIZE);
		},
		_onUpdate: function (dt) {
			this._callComponentMethod(this._enabledComponents, METHOD_UPDATE, dt);
		},
		_onPostUpdate: function (dt) {
			this._callComponentMethod(this._enabledComponents, METHOD_POST_UPDATE, dt);
		},
		_addComponentToEnabled: function (component)  {
			this._enabledComponents.insert(component);
		},
		_removeComponentFromEnabled: function (component) {
			this._enabledComponents.remove(component);
		},
		_onBeforeRemove: function (entity, component) {
			var ind = this._components.items.indexOf(component);
			if (ind >= 0) {
				component._onBeforeRemove();
			}
			this._removeComponentFromEnabled(component);
			this._components.remove(component);
		}
	});

	function ScriptLegacyComponent(system, entity) {
		Component.call(this, system, entity);
		this.on("set_scripts", this.onSetScripts, this);
	}
	ScriptLegacyComponent.prototype = Object.create(Component.prototype);
	ScriptLegacyComponent.prototype.constructor = ScriptLegacyComponent;
	Object.assign(ScriptLegacyComponent.prototype, {
		send: function (name, functionName) {
			var args = Array.prototype.slice.call(arguments, 2);
			var instances = this.entity.script.instances;
			var fn;
			if (instances && instances[name]) {
				fn = instances[name].instance[functionName];
				if (fn) {
					return fn.apply(instances[name].instance, args);
				}
			}
		},
		onEnable: function () {
			if (this.data.areScriptsLoaded && !this.system.preloading) {
				if (!this.data.initialized) {
					this.system._initializeScriptComponent(this);
				} else {
					this.system._enableScriptComponent(this);
				}
				if (!this.data.postInitialized) {
					this.system._postInitializeScriptComponent(this);
				}
			}
		},
		onDisable: function () {
			this.system._disableScriptComponent(this);
		},
		onSetScripts: function (name, oldValue, newValue) {
			if (!this.system._inTools || this.runInTools) {
				if (this._updateScriptAttributes(oldValue, newValue)) {
					return;
				}
				if (this.enabled) {
					this.system._disableScriptComponent(this);
				}
				this.system._destroyScriptComponent(this);
				this.data.areScriptsLoaded = false;
				var scripts = newValue;
				var urls = scripts.map(function (s) {
					return s.url;
				});
				if (this._loadFromCache(urls)) {
					return;
				}
				this._loadScripts(urls);
			}
		},
		_updateScriptAttributes: function (oldValue, newValue) {
			var onlyUpdateAttributes = true;
			if (oldValue.length !== newValue.length) {
				onlyUpdateAttributes = false;
			} else {
				var i, len = newValue.length;
				for (i = 0; i < len; i++) {
					if (oldValue[i].url !== newValue[i].url) {
						onlyUpdateAttributes = false;
						break;
					}
				}
			}
			if (onlyUpdateAttributes) {
				for (var key in this.instances) {
					if (this.instances.hasOwnProperty(key)) {
						this.system._updateAccessors(this.entity, this.instances[key]);
					}
				}
			}
			return onlyUpdateAttributes;
		},
		_loadFromCache: function (urls) {
			var i, len;
			var cached = [];
			var prefix = this.system.app._scriptPrefix || "";
			var regex = /^http(s)?:\/\//i;
			for (i = 0, len = urls.length; i < len; i++) {
				var url = urls[i];
				if (!regex.test(url)) {
					url = path.join(prefix, url);
				}
				var type = this.system.app.loader.getFromCache(url, 'script');
				if (!type) {
					return false;
				}
				cached.push(type);
			}
			for (i = 0, len = cached.length; i < len; i++) {
				var ScriptType = cached[i];
				if (ScriptType === true) {
					continue;
				}
				if (ScriptType && this.entity.script) {
					if (!this.entity.script.instances[ScriptType._pcScriptName]) {
						var instance = new ScriptType(this.entity);
						this.system._preRegisterInstance(this.entity, urls[i], ScriptType._pcScriptName, instance);
					}
				}
			}
			if (this.data) {
				this.data.areScriptsLoaded = true;
			}
			if (!this.system.preloading) {
				this.system.onInitialize(this.entity);
				this.system.onPostInitialize(this.entity);
			}
			return true;
		},
		_loadScripts: function (urls) {
			var count = urls.length;
			var prefix = this.system.app._scriptPrefix || "";
			urls.forEach(function (url) {
				var _url = null;
				var _unprefixed = null;
				if (url.toLowerCase().startsWith("http://") || url.toLowerCase().startsWith("https://")) {
					_unprefixed = url;
					_url = url;
				} else {
					_unprefixed = url;
					_url = path.join(prefix, url);
				}
				this.system.app.loader.load(_url, "script", function (err, ScriptType) {
					count--;
					if (!err) {
						if (ScriptType && this.entity.script) {
							if (!this.entity.script.instances[ScriptType._pcScriptName]) {
								var instance = new ScriptType(this.entity);
								this.system._preRegisterInstance(this.entity, _unprefixed, ScriptType._pcScriptName, instance);
							}
						}
					} else {
						console.error(err);
					}
					if (count === 0) {
						this.data.areScriptsLoaded = true;
						if (!this.system.preloading) {
							this.system.onInitialize(this.entity);
							this.system.onPostInitialize(this.entity);
						}
					}
				}.bind(this));
			}.bind(this));
		}
	});

	function ScriptLegacyComponentData() {
		this.scripts = [];
		this.enabled = true;
		this.instances = {};
		this._instances = {};
		this.runInTools = false;
		this.attributes = {};
		this.initialized = false;
		this.postInitialized = false;
		this.areScriptsLoaded = false;
	}

	var _schema$e = [
		'enabled',
		'scripts',
		'instances',
		'runInTools'
	];
	var INITIALIZE = "initialize";
	var POST_INITIALIZE = "postInitialize";
	var UPDATE = "update";
	var POST_UPDATE = "postUpdate";
	var FIXED_UPDATE = "fixedUpdate";
	var TOOLS_UPDATE = "toolsUpdate";
	var ON_ENABLE = 'onEnable';
	var ON_DISABLE = 'onDisable';
	var ScriptLegacyComponentSystem = function ScriptLegacyComponentSystem(app) {
		ComponentSystem.call(this, app);
		this.id = 'script';
		this.ComponentType = ScriptLegacyComponent;
		this.DataType = ScriptLegacyComponentData;
		this.schema = _schema$e;
		this.preloading = false;
		this.instancesWithUpdate = [];
		this.instancesWithFixedUpdate = [];
		this.instancesWithPostUpdate = [];
		this.instancesWithToolsUpdate = [];
		this.on('beforeremove', this.onBeforeRemove, this);
		ComponentSystem.bind(INITIALIZE, this.onInitialize, this);
		ComponentSystem.bind(POST_INITIALIZE, this.onPostInitialize, this);
		ComponentSystem.bind(UPDATE, this.onUpdate, this);
		ComponentSystem.bind(FIXED_UPDATE, this.onFixedUpdate, this);
		ComponentSystem.bind(POST_UPDATE, this.onPostUpdate, this);
		ComponentSystem.bind(TOOLS_UPDATE, this.onToolsUpdate, this);
	};
	ScriptLegacyComponentSystem.prototype = Object.create(ComponentSystem.prototype);
	ScriptLegacyComponentSystem.prototype.constructor = ScriptLegacyComponentSystem;
	Component._buildAccessors(ScriptLegacyComponent.prototype, _schema$e);
	Object.assign(ScriptLegacyComponentSystem.prototype, {
		initializeComponentData: function (component, data, properties) {
			properties = ['runInTools', 'enabled', 'scripts'];
			if (data.scripts && data.scripts.length) {
				data.scripts.forEach(function (script) {
					if (script.attributes && Array.isArray(script.attributes)) {
						var dict = {};
						for (var i = 0; i < script.attributes.length; i++) {
							dict[script.attributes[i].name] = script.attributes[i];
						}
						script.attributes = dict;
					}
				});
			}
			ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
		},
		cloneComponent: function (entity, clone) {
			var src = this.store[entity.getGuid()];
			var data = {
				runInTools: src.data.runInTools,
				scripts: [],
				enabled: src.data.enabled
			};
			var scripts = src.data.scripts;
			for (var i = 0, len = scripts.length; i < len; i++) {
				var attributes = scripts[i].attributes;
				if (attributes) {
					delete scripts[i].attributes;
				}
				data.scripts.push(extend({}, scripts[i]));
				if (attributes) {
					data.scripts[i].attributes = this._cloneAttributes(attributes);
					scripts[i].attributes = attributes;
				}
			}
			return this.addComponent(clone, data);
		},
		onBeforeRemove: function (entity, component) {
			if (component.enabled) {
				this._disableScriptComponent(component);
			}
			this._destroyScriptComponent(component);
		},
		onInitialize: function (root) {
			this._registerInstances(root);
			if (root.enabled) {
				if (root.script && root.script.enabled) {
					this._initializeScriptComponent(root.script);
				}
				var children = root._children;
				var i, len = children.length;
				for (i = 0; i < len; i++) {
					if (children[i] instanceof Entity) {
						this.onInitialize(children[i]);
					}
				}
			}
		},
		onPostInitialize: function (root) {
			if (root.enabled) {
				if (root.script && root.script.enabled) {
					this._postInitializeScriptComponent(root.script);
				}
				var children = root._children;
				var i, len = children.length;
				for (i = 0; i < len; i++) {
					if (children[i] instanceof Entity) {
						this.onPostInitialize(children[i]);
					}
				}
			}
		},
		_callInstancesMethod: function (script, method) {
			var instances = script.data.instances;
			for (var name in instances) {
				if (instances.hasOwnProperty(name)) {
					var instance = instances[name].instance;
					if (instance[method]) {
						instance[method]();
					}
				}
			}
		},
		_initializeScriptComponent: function (script) {
			this._callInstancesMethod(script, INITIALIZE);
			script.data.initialized = true;
			if (script.enabled && script.entity.enabled) {
				this._enableScriptComponent(script);
			}
		},
		_enableScriptComponent: function (script) {
			this._callInstancesMethod(script, ON_ENABLE);
		},
		_disableScriptComponent: function (script) {
			this._callInstancesMethod(script, ON_DISABLE);
		},
		_destroyScriptComponent: function (script) {
			var index;
			var instances = script.data.instances;
			for (var name in instances) {
				if (instances.hasOwnProperty(name)) {
					var instance = instances[name].instance;
					if (instance.destroy) {
						instance.destroy();
					}
					if (instance.update) {
						index = this.instancesWithUpdate.indexOf(instance);
						if (index >= 0) {
							this.instancesWithUpdate.splice(index, 1);
						}
					}
					if (instance.fixedUpdate) {
						index = this.instancesWithFixedUpdate.indexOf(instance);
						if (index >= 0) {
							this.instancesWithFixedUpdate.splice(index, 1);
						}
					}
					if (instance.postUpdate) {
						index = this.instancesWithPostUpdate.indexOf(instance);
						if (index >= 0) {
							this.instancesWithPostUpdate.splice(index, 1);
						}
					}
					if (instance.toolsUpdate) {
						index = this.instancesWithToolsUpdate.indexOf(instance);
						if (index >= 0) {
							this.instancesWithToolsUpdate.splice(index, 1);
						}
					}
					if (script.instances[name].instance === script[name]) {
						delete script[name];
					}
					delete script.instances[name];
				}
			}
		},
		_postInitializeScriptComponent: function (script) {
			this._callInstancesMethod(script, POST_INITIALIZE);
			script.data.postInitialized = true;
		},
		_updateInstances: function (method, updateList, dt) {
			var item;
			for (var i = 0, len = updateList.length; i < len; i++) {
				item = updateList[i];
				if (item && item.entity && item.entity.enabled && item.entity.script.enabled) {
					item[method](dt);
				}
			}
		},
		onUpdate: function (dt) {
			this._updateInstances(UPDATE, this.instancesWithUpdate, dt);
		},
		onFixedUpdate: function (dt) {
			this._updateInstances(FIXED_UPDATE, this.instancesWithFixedUpdate, dt);
		},
		onPostUpdate: function (dt) {
			this._updateInstances(POST_UPDATE, this.instancesWithPostUpdate, dt);
		},
		onToolsUpdate: function (dt) {
			this._updateInstances(TOOLS_UPDATE, this.instancesWithToolsUpdate, dt);
		},
		broadcast: function (name, functionName) {
			var args = Array.prototype.slice.call(arguments, 2);
			var id, data, fn;
			var dataStore = this.store;
			for (id in dataStore) {
				if (dataStore.hasOwnProperty(id)) {
					data = dataStore[id].data;
					if (data.instances[name]) {
						fn = data.instances[name].instance[functionName];
						if (fn) {
							fn.apply(data.instances[name].instance, args);
						}
					}
				}
			}
		},
		_preRegisterInstance: function (entity, url, name, instance) {
			if (entity.script) {
				entity.script.data._instances = entity.script.data._instances || {};
				if (entity.script.data._instances[name]) {
					throw Error("Script name collision '" + name + "'. Scripts from '" + url + "' and '" + entity.script.data._instances[name].url + "' {" + entity.getGuid() + "}");
				}
				entity.script.data._instances[name] = {
					url: url,
					name: name,
					instance: instance
				};
			}
		},
		_registerInstances: function (entity) {
			var preRegistered, instance, instanceName;
			if (entity.script) {
				if (entity.script.data._instances) {
					entity.script.instances = entity.script.data._instances;
					for (instanceName in entity.script.instances) {
						preRegistered = entity.script.instances[instanceName];
						instance = preRegistered.instance;
						events.attach(instance);
						if (instance.update) {
							this.instancesWithUpdate.push(instance);
						}
						if (instance.fixedUpdate) {
							this.instancesWithFixedUpdate.push(instance);
						}
						if (instance.postUpdate) {
							this.instancesWithPostUpdate.push(instance);
						}
						if (instance.toolsUpdate) {
							this.instancesWithToolsUpdate.push(instance);
						}
						if (entity.script.scripts) {
							this._createAccessors(entity, preRegistered);
						}
						if (entity.script[instanceName]) {
							throw Error("Script with name '" + instanceName + "' is already attached to Script Component");
						} else {
							entity.script[instanceName] = instance;
						}
					}
					delete entity.script.data._instances;
				}
			}
			var children = entity._children;
			var i, len = children.length;
			for (i = 0; i < len; i++) {
				if (children[i] instanceof Entity) {
					this._registerInstances(children[i]);
				}
			}
		},
		_cloneAttributes: function (attributes) {
			var result = {};
			for (var key in attributes) {
				if (!attributes.hasOwnProperty(key))
					continue;
				if (attributes[key].type !== 'entity') {
					result[key] = extend({}, attributes[key]);
				} else {
					var val = attributes[key].value;
					delete attributes[key].value;
					result[key] = extend({}, attributes[key]);
					result[key].value = val;
					attributes[key].value = val;
				}
			}
			return result;
		},
		_createAccessors: function (entity, instance) {
			var self = this;
			var i;
			var len = entity.script.scripts.length;
			var url = instance.url;
			for (i = 0; i < len; i++) {
				var script = entity.script.scripts[i];
				if (script.url === url) {
					var attributes = script.attributes;
					if (script.name && attributes) {
						for (var key in attributes) {
							if (attributes.hasOwnProperty(key)) {
								self._createAccessor(attributes[key], instance);
							}
						}
						entity.script.data.attributes[script.name] = self._cloneAttributes(attributes);
					}
					break;
				}
			}
		},
		_createAccessor: function (attribute, instance) {
			var self = this;
			attribute = {
				name: attribute.name,
				value: attribute.value,
				type: attribute.type
			};
			self._convertAttributeValue(attribute);
			Object.defineProperty(instance.instance, attribute.name, {
				get: function () {
					return attribute.value;
				},
				set: function (value) {
					var oldValue = attribute.value;
					attribute.value = value;
					self._convertAttributeValue(attribute);
					instance.instance.fire("set", attribute.name, oldValue, attribute.value);
				},
				configurable: true
			});
		},
		_updateAccessors: function (entity, instance) {
			var self = this;
			var i;
			var len = entity.script.scripts.length;
			var key;
			var url = instance.url;
			var scriptComponent, script, name, attributes;
			var previousAttributes;
			var oldAttribute;
			for (i = 0; i < len; i++) {
				scriptComponent = entity.script;
				script = scriptComponent.scripts[i];
				if (script.url === url) {
					name = script.name;
					attributes = script.attributes;
					if (name) {
						if (attributes) {
							for (key in attributes) {
								if (attributes.hasOwnProperty(key)) {
									self._createAccessor(attributes[key], instance);
								}
							}
						}
						previousAttributes = scriptComponent.data.attributes[name];
						if (previousAttributes) {
							for (key in previousAttributes) {
								oldAttribute = previousAttributes[key];
								if (!(key in attributes)) {
									delete instance.instance[oldAttribute.name];
								} else {
									if (attributes[key].value !== oldAttribute.value) {
										if (instance.instance.onAttributeChanged) {
											instance.instance.onAttributeChanged(oldAttribute.name, oldAttribute.value, attributes[key].value);
										}
									}
								}
							}
						}
						if (attributes) {
							scriptComponent.data.attributes[name] = self._cloneAttributes(attributes);
						} else {
							delete scriptComponent.data.attributes[name];
						}
					}
					break;
				}
			}
		},
		_convertAttributeValue: function (attribute) {
			if (attribute.type === 'rgb' || attribute.type === 'rgba') {
				if (Array.isArray(attribute.value)) {
					attribute.value = attribute.value.length === 3 ?
						new Color(attribute.value[0], attribute.value[1], attribute.value[2]) :
						new Color(attribute.value[0], attribute.value[1], attribute.value[2], attribute.value[3]);
				}
			} else if (attribute.type === 'vec2') {
				if (Array.isArray(attribute.value))
					attribute.value = new Vec2(attribute.value[0], attribute.value[1]);
			} else if (attribute.type === 'vec3' || attribute.type === 'vector') {
				if (Array.isArray(attribute.value))
					attribute.value = new Vec3(attribute.value[0], attribute.value[1], attribute.value[2]);
			} else if (attribute.type === 'vec4') {
				if (Array.isArray(attribute.value))
					attribute.value = new Vec4(attribute.value[0], attribute.value[1], attribute.value[2], attribute.value[3]);
			} else if (attribute.type === 'entity') {
				if (attribute.value !== null && typeof attribute.value === 'string')
					attribute.value = this.app.root.findByGuid(attribute.value);
			} else if (attribute.type === 'curve' || attribute.type === 'colorcurve') {
				var curveType = attribute.value.keys[0] instanceof Array ? CurveSet : Curve;
				attribute.value = new curveType(attribute.value.keys);
				attribute.value.type = attribute.value.type;
			}
		}
	});

	var _inputScreenPosition = new Vec2();
	var _inputWorldPosition = new Vec3();
	var _rayOrigin = new Vec3();
	var _rayDirection = new Vec3();
	var _planeOrigin = new Vec3();
	var _planeNormal = new Vec3();
	var _entityRotation = new Quat();
	var OPPOSITE_AXIS = {
		x: 'y',
		y: 'x'
	};
	function ElementDragHelper(element, axis) {
		EventHandler.call(this);
		if (!element || !(element instanceof ElementComponent)) {
			throw new Error('Element was null or not an ElementComponent');
		}
		if (axis && axis !== 'x' && axis !== 'y') {
			throw new Error('Unrecognized axis: ' + axis);
		}
		this._element = element;
		this._app = element.system.app;
		this._axis = axis || null;
		this._enabled = true;
		this._dragScale = new Vec3();
		this._dragStartMousePosition = new Vec3();
		this._dragStartHandlePosition = new Vec3();
		this._deltaMousePosition = new Vec3();
		this._deltaHandlePosition = new Vec3();
		this._isDragging = false;
		this._toggleLifecycleListeners('on');
	}
	ElementDragHelper.prototype = Object.create(EventHandler.prototype);
	ElementDragHelper.prototype.constructor = ElementDragHelper;
	Object.assign(ElementDragHelper.prototype, {
		_toggleLifecycleListeners: function (onOrOff) {
			this._element[onOrOff]('mousedown', this._onMouseDownOrTouchStart, this);
			this._element[onOrOff]('touchstart', this._onMouseDownOrTouchStart, this);
		},
		_toggleDragListeners: function (onOrOff) {
			var isOn = onOrOff === 'on';
			var addOrRemoveEventListener = isOn ? 'addEventListener' : 'removeEventListener';
			if (this._hasDragListeners && isOn) {
				return;
			}
			if (!this._handleMouseUpOrTouchEnd) {
				this._handleMouseUpOrTouchEnd = this._onMouseUpOrTouchEnd.bind(this);
			}
			if (this._app.mouse) {
				this._app.mouse[onOrOff]('mousemove', this._onMove, this);
				window[addOrRemoveEventListener]('mouseup', this._handleMouseUpOrTouchEnd, false);
			}
			if (platform.touch) {
				this._app.touch[onOrOff]('touchmove', this._onMove, this);
				window[addOrRemoveEventListener]('touchend', this._handleMouseUpOrTouchEnd, false);
				window[addOrRemoveEventListener]('touchcancel', this._handleMouseUpOrTouchEnd, false);
			}
			this._hasDragListeners = isOn;
		},
		_onMouseDownOrTouchStart: function (event) {
			if (this._element && !this._isDragging && this.enabled) {
				this._dragCamera = event.camera;
				this._calculateDragScale();
				var currentMousePosition = this._screenToLocal(event);
				if (currentMousePosition) {
					this._toggleDragListeners('on');
					this._isDragging = true;
					this._dragStartMousePosition.copy(currentMousePosition);
					this._dragStartHandlePosition.copy(this._element.entity.getLocalPosition());
					this.fire('drag:start');
				}
			}
		},
		_onMouseUpOrTouchEnd: function () {
			if (this._isDragging) {
				this._isDragging = false;
				this._toggleDragListeners('off');
				this.fire('drag:end');
			}
		},
		_screenToLocal: function (event) {
			this._determineInputPosition(event);
			this._chooseRayOriginAndDirection();
			_planeOrigin.copy(this._element.entity.getPosition());
			_planeNormal.copy(this._element.entity.forward).scale(-1);
			var denominator = _planeNormal.dot(_rayDirection);
			if (Math.abs(denominator) > 0) {
				var rayOriginToPlaneOrigin = _planeOrigin.sub(_rayOrigin);
				var collisionDistance = rayOriginToPlaneOrigin.dot(_planeNormal) / denominator;
				var position = _rayOrigin.add(_rayDirection.scale(collisionDistance));
				_entityRotation.copy(this._element.entity.getRotation()).invert().transformVector(position, position);
				position.mul(this._dragScale);
				return position;
			}
			return null;
		},
		_determineInputPosition: function (event) {
			var devicePixelRatio = this._app.graphicsDevice.maxPixelRatio;
			if (typeof event.x !== 'undefined' && typeof event.y !== 'undefined') {
				_inputScreenPosition.x = event.x * devicePixelRatio;
				_inputScreenPosition.y = event.y * devicePixelRatio;
			} else if (event.changedTouches) {
				_inputScreenPosition.x = event.changedTouches[0].x * devicePixelRatio;
				_inputScreenPosition.y = event.changedTouches[0].y * devicePixelRatio;
			} else {
				console.warn('Could not determine position from input event');
			}
		},
		_chooseRayOriginAndDirection: function () {
			if (this._element.screen && this._element.screen.screen.screenSpace) {
				_rayOrigin.set(_inputScreenPosition.x, -_inputScreenPosition.y, 0);
				_rayDirection.set(0, 0, -1);
			} else {
				_inputWorldPosition.copy(this._dragCamera.screenToWorld(_inputScreenPosition.x, _inputScreenPosition.y, 1));
				_rayOrigin.copy(this._dragCamera.entity.getPosition());
				_rayDirection.copy(_inputWorldPosition).sub(_rayOrigin).normalize();
			}
		},
		_calculateDragScale: function () {
			var current = this._element.entity.parent;
			var screen = this._element.screen && this._element.screen.screen;
			var isWithin2DScreen = screen && screen.screenSpace;
			var screenScale = isWithin2DScreen ? screen.scale : 1;
			var dragScale = this._dragScale;
			dragScale.set(screenScale, screenScale, screenScale);
			while (current) {
				dragScale.mul(current.getLocalScale());
				current = current.parent;
				if (isWithin2DScreen && current.screen) {
					break;
				}
			}
			dragScale.x = 1 / dragScale.x;
			dragScale.y = 1 / dragScale.y;
			dragScale.z = 1 / dragScale.z;
		},
		_onMove: function (event) {
			if (this._element && this._isDragging && this.enabled && this._element.enabled && this._element.entity.enabled) {
				var currentMousePosition = this._screenToLocal(event);
				if (this._dragStartMousePosition && currentMousePosition) {
					this._deltaMousePosition.copy(currentMousePosition).sub(this._dragStartMousePosition);
					this._deltaHandlePosition.copy(this._dragStartHandlePosition).add(this._deltaMousePosition);
					if (this._axis) {
						var currentPosition = this._element.entity.getLocalPosition();
						var constrainedAxis = OPPOSITE_AXIS[this._axis];
						this._deltaHandlePosition[constrainedAxis] = currentPosition[constrainedAxis];
					}
					this._element.entity.setLocalPosition(this._deltaHandlePosition);
					this.fire('drag:move', this._deltaHandlePosition);
				}
			}
		},
		destroy: function () {
			this._toggleLifecycleListeners('off');
			this._toggleDragListeners('off');
		}
	});
	Object.defineProperty(ElementDragHelper.prototype, 'enabled', {
		get: function () {
			return this._enabled;
		},
		set: function (value) {
			this._enabled = value;
		}
	});
	Object.defineProperty(ElementDragHelper.prototype, 'isDragging', {
		get: function () {
			return this._isDragging;
		}
	});

	var SCROLL_MODE_CLAMP = 0;
	var SCROLL_MODE_BOUNCE = 1;
	var SCROLL_MODE_INFINITE = 2;
	var SCROLLBAR_VISIBILITY_SHOW_ALWAYS = 0;
	var SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED = 1;

	var _tempScrollValue = new Vec2();
	function ScrollViewComponent(system, entity) {
		Component.call(this, system, entity);
		this._viewportReference = new EntityReference(this, 'viewportEntity', {
			'element#gain': this._onViewportElementGain,
			'element#resize': this._onSetContentOrViewportSize
		});
		this._contentReference = new EntityReference(this, 'contentEntity', {
			'element#gain': this._onContentElementGain,
			'element#lose': this._onContentElementLose,
			'element#resize': this._onSetContentOrViewportSize
		});
		this._scrollbarUpdateFlags = {};
		this._scrollbarReferences = {};
		this._scrollbarReferences[ORIENTATION_HORIZONTAL] = new EntityReference(this, 'horizontalScrollbarEntity', {
			'scrollbar#set:value': this._onSetHorizontalScrollbarValue,
			'scrollbar#gain': this._onHorizontalScrollbarGain
		});
		this._scrollbarReferences[ORIENTATION_VERTICAL] = new EntityReference(this, 'verticalScrollbarEntity', {
			'scrollbar#set:value': this._onSetVerticalScrollbarValue,
			'scrollbar#gain': this._onVerticalScrollbarGain
		});
		this._prevContentSizes = {};
		this._prevContentSizes[ORIENTATION_HORIZONTAL] = null;
		this._prevContentSizes[ORIENTATION_VERTICAL] = null;
		this._scroll = new Vec2();
		this._velocity = new Vec3();
		this._dragStartPosition = new Vec3();
		this._disabledContentInput = false;
		this._disabledContentInputEntities = [];
		this._toggleLifecycleListeners('on', system);
		this._toggleElementListeners('on');
	}
	ScrollViewComponent.prototype = Object.create(Component.prototype);
	ScrollViewComponent.prototype.constructor = ScrollViewComponent;
	Object.assign(ScrollViewComponent.prototype, {
		_toggleLifecycleListeners: function (onOrOff, system) {
			this[onOrOff]('set_horizontal', this._onSetHorizontalScrollingEnabled, this);
			this[onOrOff]('set_vertical', this._onSetVerticalScrollingEnabled, this);
			system.app.systems.element[onOrOff]('add', this._onElementComponentAdd, this);
			system.app.systems.element[onOrOff]('beforeremove', this._onElementComponentRemove, this);
		},
		_toggleElementListeners: function (onOrOff) {
			if (this.entity.element) {
				if (onOrOff === 'on' && this._hasElementListeners) {
					return;
				}
				this.entity.element[onOrOff]('resize', this._onSetContentOrViewportSize, this);
				this._hasElementListeners = (onOrOff === 'on');
			}
		},
		_onElementComponentAdd: function (entity) {
			if (this.entity === entity) {
				this._toggleElementListeners('on');
			}
		},
		_onElementComponentRemove: function (entity) {
			if (this.entity === entity) {
				this._toggleElementListeners('off');
			}
		},
		_onViewportElementGain: function () {
			this._syncAll();
		},
		_onContentElementGain: function () {
			this._destroyDragHelper();
			this._contentDragHelper = new ElementDragHelper(this._contentReference.entity.element);
			this._contentDragHelper.on('drag:start', this._onContentDragStart, this);
			this._contentDragHelper.on('drag:end', this._onContentDragEnd, this);
			this._contentDragHelper.on('drag:move', this._onContentDragMove, this);
			this._prevContentSizes[ORIENTATION_HORIZONTAL] = null;
			this._prevContentSizes[ORIENTATION_VERTICAL] = null;
			this._syncAll();
		},
		_onContentElementLose: function () {
			this._destroyDragHelper();
		},
		_onContentDragStart: function () {
			if (this._contentReference.entity && this.enabled && this.entity.enabled) {
				this._dragStartPosition.copy(this._contentReference.entity.getLocalPosition());
			}
		},
		_onContentDragEnd: function () {
			this._prevContentDragPosition = null;
			this._enableContentInput();
		},
		_onContentDragMove: function (position) {
			if (this._contentReference.entity && this.enabled && this.entity.enabled) {
				this._wasDragged = true;
				this._setScrollFromContentPosition(position);
				this._setVelocityFromContentPositionDelta(position);
				if (!this._disabledContentInput) {
					var dx = (position.x - this._dragStartPosition.x);
					var dy = (position.y - this._dragStartPosition.y);
					if (Math.abs(dx) > this.dragThreshold ||
						Math.abs(dy) > this.dragThreshold) {
						this._disableContentInput();
					}
				}
			}
		},
		_onSetContentOrViewportSize: function () {
			this._syncAll();
		},
		_onSetHorizontalScrollbarValue: function (scrollValueX) {
			if (!this._scrollbarUpdateFlags[ORIENTATION_HORIZONTAL] && this.enabled && this.entity.enabled) {
				this._onSetScroll(scrollValueX, null);
			}
		},
		_onSetVerticalScrollbarValue: function (scrollValueY) {
			if (!this._scrollbarUpdateFlags[ORIENTATION_VERTICAL] && this.enabled && this.entity.enabled) {
				this._onSetScroll(null, scrollValueY);
			}
		},
		_onSetHorizontalScrollingEnabled: function () {
			this._syncScrollbarEnabledState(ORIENTATION_HORIZONTAL);
		},
		_onSetVerticalScrollingEnabled: function () {
			this._syncScrollbarEnabledState(ORIENTATION_VERTICAL);
		},
		_onHorizontalScrollbarGain: function () {
			this._syncScrollbarEnabledState(ORIENTATION_HORIZONTAL);
			this._syncScrollbarPosition(ORIENTATION_HORIZONTAL);
		},
		_onVerticalScrollbarGain: function () {
			this._syncScrollbarEnabledState(ORIENTATION_VERTICAL);
			this._syncScrollbarPosition(ORIENTATION_VERTICAL);
		},
		_onSetScroll: function (x, y, resetVelocity) {
			if (resetVelocity !== false) {
				this._velocity.set(0, 0, 0);
			}
			var hasChanged = false;
			hasChanged |= this._updateAxis(x, 'x', ORIENTATION_HORIZONTAL);
			hasChanged |= this._updateAxis(y, 'y', ORIENTATION_VERTICAL);
			if (hasChanged) {
				this.fire('set:scroll', this._scroll);
			}
		},
		_updateAxis: function (scrollValue, axis, orientation) {
			var hasChanged = (scrollValue !== null && Math.abs(scrollValue - this._scroll[axis]) > 1e-5);
			if (hasChanged || this._isDragging() || scrollValue === 0) {
				this._scroll[axis] = this._determineNewScrollValue(scrollValue, axis, orientation);
				this._syncContentPosition(orientation);
				this._syncScrollbarPosition(orientation);
			}
			return hasChanged;
		},
		_determineNewScrollValue: function (scrollValue, axis, orientation) {
			if (!this._getScrollingEnabled(orientation)) {
				return this._scroll[axis];
			}
			switch (this.scrollMode) {
				case SCROLL_MODE_CLAMP:
					return math.clamp(scrollValue, 0, this._getMaxScrollValue(orientation));
				case SCROLL_MODE_BOUNCE:
					this._setVelocityFromOvershoot(scrollValue, axis, orientation);
					return scrollValue;
				case SCROLL_MODE_INFINITE:
					return scrollValue;
				default:
					console.warn('Unhandled scroll mode:' + this.scrollMode);
					return scrollValue;
			}
		},
		_syncAll: function () {
			this._syncContentPosition(ORIENTATION_HORIZONTAL);
			this._syncContentPosition(ORIENTATION_VERTICAL);
			this._syncScrollbarPosition(ORIENTATION_HORIZONTAL);
			this._syncScrollbarPosition(ORIENTATION_VERTICAL);
			this._syncScrollbarEnabledState(ORIENTATION_HORIZONTAL);
			this._syncScrollbarEnabledState(ORIENTATION_VERTICAL);
		},
		_syncContentPosition: function (orientation) {
			var axis = this._getAxis(orientation);
			var sign = this._getSign(orientation);
			var contentEntity = this._contentReference.entity;
			if (contentEntity) {
				var prevContentSize = this._prevContentSizes[orientation];
				var currContentSize = this._getContentSize(orientation);
				if (prevContentSize !== null && Math.abs(prevContentSize - currContentSize) > 1e-4) {
					var prevMaxOffset = this._getMaxOffset(orientation, prevContentSize);
					var currMaxOffset = this._getMaxOffset(orientation, currContentSize);
					if (currMaxOffset === 0) {
						this._scroll[axis] = 1;
					} else {
						this._scroll[axis] = math.clamp(this._scroll[axis] * prevMaxOffset / currMaxOffset, 0, 1);
					}
				}
				var offset = this._scroll[axis] * this._getMaxOffset(orientation);
				var contentPosition = contentEntity.getLocalPosition();
				contentPosition[axis] = offset * sign;
				contentEntity.setLocalPosition(contentPosition);
				this._prevContentSizes[orientation] = currContentSize;
			}
		},
		_syncScrollbarPosition: function (orientation) {
			var axis = this._getAxis(orientation);
			var scrollbarEntity = this._scrollbarReferences[orientation].entity;
			if (scrollbarEntity && scrollbarEntity.scrollbar) {
				this._scrollbarUpdateFlags[orientation] = true;
				scrollbarEntity.scrollbar.value = this._scroll[axis];
				scrollbarEntity.scrollbar.handleSize = this._getScrollbarHandleSize(axis, orientation);
				this._scrollbarUpdateFlags[orientation] = false;
			}
		},
		_syncScrollbarEnabledState: function (orientation) {
			var entity = this._scrollbarReferences[orientation].entity;
			if (entity) {
				var isScrollingEnabled = this._getScrollingEnabled(orientation);
				var requestedVisibility = this._getScrollbarVisibility(orientation);
				switch (requestedVisibility) {
					case SCROLLBAR_VISIBILITY_SHOW_ALWAYS:
						entity.enabled = isScrollingEnabled;
						return;
					case SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED:
						entity.enabled = isScrollingEnabled && this._contentIsLargerThanViewport(orientation);
						return;
					default:
						console.warn('Unhandled scrollbar visibility:' + requestedVisibility);
						entity.enabled = isScrollingEnabled;
				}
			}
		},
		_contentIsLargerThanViewport: function (orientation) {
			return this._getContentSize(orientation) > this._getViewportSize(orientation);
		},
		_contentPositionToScrollValue: function (contentPosition) {
			var maxOffsetH = this._getMaxOffset(ORIENTATION_HORIZONTAL);
			var maxOffsetV = this._getMaxOffset(ORIENTATION_VERTICAL);
			if (maxOffsetH === 0) {
				_tempScrollValue.x = 0;
			} else {
				_tempScrollValue.x = contentPosition.x / maxOffsetH;
			}
			if (maxOffsetV === 0) {
				_tempScrollValue.y = 0;
			} else {
				_tempScrollValue.y = contentPosition.y / -maxOffsetV;
			}
			return _tempScrollValue;
		},
		_getMaxOffset: function (orientation, contentSize) {
			contentSize = contentSize === undefined ? this._getContentSize(orientation) : contentSize;
			var viewportSize = this._getViewportSize(orientation);
			if (contentSize < viewportSize) {
				return -this._getViewportSize(orientation);
			}
			return viewportSize - contentSize;
		},
		_getMaxScrollValue: function (orientation) {
			return this._contentIsLargerThanViewport(orientation) ? 1 : 0;
		},
		_getScrollbarHandleSize: function (axis, orientation) {
			var viewportSize = this._getViewportSize(orientation);
			var contentSize = this._getContentSize(orientation);
			if (Math.abs(contentSize) < 0.001) {
				return 1;
			}
			var handleSize = Math.min(viewportSize / contentSize, 1);
			var overshoot = this._toOvershoot(this._scroll[axis], orientation);
			if (overshoot === 0) {
				return handleSize;
			}
			return handleSize / (1 + Math.abs(overshoot));
		},
		_getViewportSize: function (orientation) {
			return this._getSize(orientation, this._viewportReference);
		},
		_getContentSize: function (orientation) {
			return this._getSize(orientation, this._contentReference);
		},
		_getSize: function (orientation, entityReference) {
			if (entityReference.entity && entityReference.entity.element) {
				return entityReference.entity.element[this._getCalculatedDimension(orientation)];
			}
			return 0;
		},
		_getScrollingEnabled: function (orientation) {
			if (orientation === ORIENTATION_HORIZONTAL) {
				return this.horizontal;
			} else if (orientation === ORIENTATION_VERTICAL) {
				return this.vertical;
			}
			console.warn('Unrecognized orientation: ' + orientation);
		},
		_getScrollbarVisibility: function (orientation) {
			if (orientation === ORIENTATION_HORIZONTAL) {
				return this.horizontalScrollbarVisibility;
			} else if (orientation === ORIENTATION_VERTICAL) {
				return this.verticalScrollbarVisibility;
			}
			console.warn('Unrecognized orientation: ' + orientation);
		},
		_getSign: function (orientation) {
			return orientation === ORIENTATION_HORIZONTAL ? 1 : -1;
		},
		_getAxis: function (orientation) {
			return orientation === ORIENTATION_HORIZONTAL ? 'x' : 'y';
		},
		_getCalculatedDimension: function (orientation) {
			return orientation === ORIENTATION_HORIZONTAL ? 'calculatedWidth' : 'calculatedHeight';
		},
		_destroyDragHelper: function () {
			if (this._contentDragHelper) {
				this._contentDragHelper.destroy();
			}
		},
		onUpdate: function () {
			if (this._contentReference.entity) {
				this._updateVelocity();
				this._syncScrollbarEnabledState(ORIENTATION_HORIZONTAL);
				this._syncScrollbarEnabledState(ORIENTATION_VERTICAL);
			}
		},
		_updateVelocity: function () {
			if (!this._isDragging()) {
				if (this.scrollMode === SCROLL_MODE_BOUNCE) {
					if (this._hasOvershoot('x', ORIENTATION_HORIZONTAL)) {
						this._setVelocityFromOvershoot(this.scroll.x, 'x', ORIENTATION_HORIZONTAL);
					}
					if (this._hasOvershoot('y', ORIENTATION_VERTICAL)) {
						this._setVelocityFromOvershoot(this.scroll.y, 'y', ORIENTATION_VERTICAL);
					}
				}
				this._velocity.x *= (1 - this.friction);
				this._velocity.y *= (1 - this.friction);
				if (Math.abs(this._velocity.x) > 1e-4 || Math.abs(this._velocity.y) > 1e-4) {
					var position = this._contentReference.entity.getLocalPosition();
					position.x += this._velocity.x;
					position.y += this._velocity.y;
					this._contentReference.entity.setLocalPosition(position);
					this._setScrollFromContentPosition(position);
				}
			}
		},
		_hasOvershoot: function (axis, orientation) {
			return Math.abs(this._toOvershoot(this.scroll[axis], orientation)) > 0.001;
		},
		_toOvershoot: function (scrollValue, orientation) {
			var maxScrollValue = this._getMaxScrollValue(orientation);
			if (scrollValue < 0) {
				return scrollValue;
			} else if (scrollValue > maxScrollValue) {
				return scrollValue - maxScrollValue;
			}
			return 0;
		},
		_setVelocityFromOvershoot: function (scrollValue, axis, orientation) {
			var overshootValue = this._toOvershoot(scrollValue, orientation);
			var overshootPixels = overshootValue * this._getMaxOffset(orientation) * this._getSign(orientation);
			if (Math.abs(overshootPixels) > 0) {
				this._velocity[axis] = -overshootPixels / (this.bounceAmount * 50 + 1);
			}
		},
		_setVelocityFromContentPositionDelta: function (position) {
			if (this._prevContentDragPosition) {
				this._velocity.sub2(position, this._prevContentDragPosition);
				this._prevContentDragPosition.copy(position);
			} else {
				this._velocity.set(0, 0, 0);
				this._prevContentDragPosition = position.clone();
			}
		},
		_setScrollFromContentPosition: function (position) {
			var scrollValue = this._contentPositionToScrollValue(position);
			if (this._isDragging()) {
				scrollValue = this._applyScrollValueTension(scrollValue);
			}
			this._onSetScroll(scrollValue.x, scrollValue.y, false);
		},
		_applyScrollValueTension: function (scrollValue) {
			var max;
			var overshoot;
			var factor = 1;
			max = this._getMaxScrollValue(ORIENTATION_HORIZONTAL);
			overshoot = this._toOvershoot(scrollValue.x, ORIENTATION_HORIZONTAL);
			if (overshoot > 0) {
				scrollValue.x = max + factor * Math.log10(1 + overshoot);
			} else if (overshoot < 0) {
				scrollValue.x = -factor * Math.log10(1 - overshoot);
			}
			max = this._getMaxScrollValue(ORIENTATION_VERTICAL);
			overshoot = this._toOvershoot(scrollValue.y, ORIENTATION_VERTICAL);
			if (overshoot > 0) {
				scrollValue.y = max + factor * Math.log10(1 + overshoot);
			} else if (overshoot < 0) {
				scrollValue.y = -factor * Math.log10(1 - overshoot);
			}
			return scrollValue;
		},
		_isDragging: function () {
			return this._contentDragHelper && this._contentDragHelper.isDragging;
		},
		_setScrollbarComponentsEnabled: function (enabled) {
			if (this._scrollbarReferences[ORIENTATION_HORIZONTAL].hasComponent('scrollbar')) {
				this._scrollbarReferences[ORIENTATION_HORIZONTAL].entity.scrollbar.enabled = enabled;
			}
			if (this._scrollbarReferences[ORIENTATION_VERTICAL].hasComponent('scrollbar')) {
				this._scrollbarReferences[ORIENTATION_VERTICAL].entity.scrollbar.enabled = enabled;
			}
		},
		_setContentDraggingEnabled: function (enabled) {
			if (this._contentDragHelper) {
				this._contentDragHelper.enabled = enabled;
			}
		},
		_enableContentInput: function () {
			while (this._disabledContentInputEntities.length) {
				var e = this._disabledContentInputEntities.pop();
				if (e.element) {
					e.element.useInput = true;
				}
			}
			this._disabledContentInput = false;
		},
		_disableContentInput: function () {
			var self = this;
			var _disableInput = function (e) {
				if (e.element && e.element.useInput) {
					self._disabledContentInputEntities.push(e);
					e.element.useInput = false;
				}
				var children = e.children;
				var i, l;
				for (i = 0, l = children.length; i < l; i++) {
					_disableInput(children[i]);
				}
			};
			var contentEntity = this._contentReference.entity;
			if (contentEntity) {
				var children = contentEntity.children;
				var i, l = children.length;
				for (i = 0; i < l; i++) {
					_disableInput(children[i]);
				}
			}
			this._disabledContentInput = true;
		},
		onEnable: function () {
			this._viewportReference.onParentComponentEnable();
			this._contentReference.onParentComponentEnable();
			this._scrollbarReferences[ORIENTATION_HORIZONTAL].onParentComponentEnable();
			this._scrollbarReferences[ORIENTATION_VERTICAL].onParentComponentEnable();
			this._setScrollbarComponentsEnabled(true);
			this._setContentDraggingEnabled(true);
			this._syncAll();
		},
		onDisable: function () {
			this._setScrollbarComponentsEnabled(false);
			this._setContentDraggingEnabled(false);
		},
		onRemove: function () {
			this._toggleLifecycleListeners('off', this.system);
			this._toggleElementListeners('off');
			this._destroyDragHelper();
		}
	});
	Object.defineProperty(ScrollViewComponent.prototype, 'scroll', {
		get: function () {
			return this._scroll;
		},
		set: function (value) {
			this._onSetScroll(value.x, value.y);
		}
	});

	function ScrollViewComponentData() {
		this.enabled = true;
	}

	var _schema$f = [
		{ name: 'enabled', type: 'boolean' },
		{ name: 'horizontal', type: 'boolean' },
		{ name: 'vertical', type: 'boolean' },
		{ name: 'scrollMode', type: 'number' },
		{ name: 'bounceAmount', type: 'number' },
		{ name: 'friction', type: 'number' },
		{ name: 'dragThreshold', type: 'number' },
		{ name: 'horizontalScrollbarVisibility', type: 'number' },
		{ name: 'verticalScrollbarVisibility', type: 'number' },
		{ name: 'viewportEntity', type: 'entity' },
		{ name: 'contentEntity', type: 'entity' },
		{ name: 'horizontalScrollbarEntity', type: 'entity' },
		{ name: 'verticalScrollbarEntity', type: 'entity' }
	];
	var DEFAULT_DRAG_THRESHOLD = 10;
	var ScrollViewComponentSystem = function ScrollViewComponentSystem(app) {
		ComponentSystem.call(this, app);
		this.id = 'scrollview';
		this.ComponentType = ScrollViewComponent;
		this.DataType = ScrollViewComponentData;
		this.schema = _schema$f;
		this.on('beforeremove', this._onRemoveComponent, this);
		ComponentSystem.bind('update', this.onUpdate, this);
	};
	ScrollViewComponentSystem.prototype = Object.create(ComponentSystem.prototype);
	ScrollViewComponentSystem.prototype.constructor = ScrollViewComponentSystem;
	Component._buildAccessors(ScrollViewComponent.prototype, _schema$f);
	Object.assign(ScrollViewComponentSystem.prototype, {
		initializeComponentData: function (component, data, properties) {
			if (data.dragThreshold === undefined) {
				data.dragThreshold = DEFAULT_DRAG_THRESHOLD;
			}
			ComponentSystem.prototype.initializeComponentData.call(this, component, data, _schema$f);
		},
		onUpdate: function (dt) {
			var components = this.store;
			for (var id in components) {
				var entity = components[id].entity;
				var component = entity.scrollview;
				if (component.enabled && entity.enabled) {
					component.onUpdate();
				}
			}
		},
		_onRemoveComponent: function (entity, component) {
			component.onRemove();
		}
	});

	function ScrollbarComponent(system, entity) {
		Component.call(this, system, entity);
		this._app = system.app;
		this._handleReference = new EntityReference(this, 'handleEntity', {
			'element#gain': this._onHandleElementGain,
			'element#lose': this._onHandleElementLose,
			'element#set:anchor': this._onSetHandleAlignment,
			'element#set:margin': this._onSetHandleAlignment,
			'element#set:pivot': this._onSetHandleAlignment
		});
		this._toggleLifecycleListeners('on');
	}
	ScrollbarComponent.prototype = Object.create(Component.prototype);
	ScrollbarComponent.prototype.constructor = ScrollbarComponent;
	Object.assign(ScrollbarComponent.prototype, {
		_toggleLifecycleListeners: function (onOrOff) {
			this[onOrOff]('set_value', this._onSetValue, this);
			this[onOrOff]('set_handleSize', this._onSetHandleSize, this);
			this[onOrOff]('set_orientation', this._onSetOrientation, this);
		},
		_onHandleElementGain: function () {
			this._destroyDragHelper();
			this._handleDragHelper = new ElementDragHelper(this._handleReference.entity.element, this._getAxis());
			this._handleDragHelper.on('drag:move', this._onHandleDrag, this);
			this._updateHandlePositionAndSize();
		},
		_onHandleElementLose: function () {
			this._destroyDragHelper();
		},
		_onHandleDrag: function (position) {
			if (this._handleReference.entity && this.enabled && this.entity.enabled) {
				this.value = this._handlePositionToScrollValue(position[this._getAxis()]);
			}
		},
		_onSetValue: function (name, oldValue, newValue) {
			if (Math.abs(newValue - oldValue) > 1e-5) {
				this.data.value = math.clamp(newValue, 0, 1);
				this._updateHandlePositionAndSize();
				this.fire('set:value', this.data.value);
			}
		},
		_onSetHandleSize: function (name, oldValue, newValue) {
			if (Math.abs(newValue - oldValue) > 1e-5) {
				this.data.handleSize = math.clamp(newValue, 0, 1);
				this._updateHandlePositionAndSize();
			}
		},
		_onSetHandleAlignment: function () {
			this._updateHandlePositionAndSize();
		},
		_onSetOrientation: function (name, oldValue, newValue) {
			if (newValue !== oldValue && this._handleReference.hasComponent('element')) {
				this._handleReference.entity.element[this._getOppositeDimension()] = 0;
			}
		},
		_updateHandlePositionAndSize: function () {
			var handleEntity = this._handleReference.entity;
			var handleElement = handleEntity && handleEntity.element;
			if (handleEntity) {
				var position = handleEntity.getLocalPosition();
				position[this._getAxis()] = this._getHandlePosition();
				this._handleReference.entity.setLocalPosition(position);
			}
			if (handleElement) {
				handleElement[this._getDimension()] = this._getHandleLength();
			}
		},
		_handlePositionToScrollValue: function (handlePosition) {
			return handlePosition * this._getSign() / this._getUsableTrackLength();
		},
		_scrollValueToHandlePosition: function (value) {
			return value * this._getSign() * this._getUsableTrackLength();
		},
		_getUsableTrackLength: function () {
			return Math.max(this._getTrackLength() - this._getHandleLength(), 0.001);
		},
		_getTrackLength: function () {
			if (this.entity.element) {
				return this.orientation === ORIENTATION_HORIZONTAL ? this.entity.element.calculatedWidth : this.entity.element.calculatedHeight;
			}
			return 0;
		},
		_getHandleLength: function () {
			return this._getTrackLength() * this.handleSize;
		},
		_getHandlePosition: function () {
			return this._scrollValueToHandlePosition(this.value);
		},
		_getSign: function () {
			return this.orientation === ORIENTATION_HORIZONTAL ? 1 : -1;
		},
		_getAxis: function () {
			return this.orientation === ORIENTATION_HORIZONTAL ? 'x' : 'y';
		},
		_getDimension: function () {
			return this.orientation === ORIENTATION_HORIZONTAL ? 'width' : 'height';
		},
		_getOppositeDimension: function () {
			return this.orientation === ORIENTATION_HORIZONTAL ? 'height' : 'width';
		},
		_destroyDragHelper: function () {
			if (this._handleDragHelper) {
				this._handleDragHelper.destroy();
			}
		},
		_setHandleDraggingEnabled: function (enabled) {
			if (this._handleDragHelper) {
				this._handleDragHelper.enabled = enabled;
			}
		},
		onEnable: function () {
			this._handleReference.onParentComponentEnable();
			this._setHandleDraggingEnabled(true);
		},
		onDisable: function () {
			this._setHandleDraggingEnabled(false);
		},
		onRemove: function () {
			this._destroyDragHelper();
			this._toggleLifecycleListeners('off');
		}
	});

	function ScrollbarComponentData() {
		this.enabled = true;
	}

	var _schema$g = [
		{ name: 'enabled', type: 'boolean' },
		{ name: 'orientation', type: 'number' },
		{ name: 'value', type: 'number' },
		{ name: 'handleSize', type: 'number' },
		{ name: 'handleEntity', type: 'entity' }
	];
	function ScrollbarComponentSystem(app) {
		ComponentSystem.call(this, app);
		this.id = 'scrollbar';
		this.ComponentType = ScrollbarComponent;
		this.DataType = ScrollbarComponentData;
		this.schema = _schema$g;
		this.on('beforeremove', this._onRemoveComponent, this);
	}
	ScrollbarComponentSystem.prototype = Object.create(ComponentSystem.prototype);
	ScrollbarComponentSystem.prototype.constructor = ScrollbarComponentSystem;
	Component._buildAccessors(ScrollbarComponent.prototype, _schema$g);
	Object.assign(ScrollbarComponentSystem.prototype, {
		initializeComponentData: function (component, data, properties) {
			ComponentSystem.prototype.initializeComponentData.call(this, component, data, _schema$g);
		},
		_onRemoveComponent: function (entity, component) {
			component.onRemove();
		}
	});

	var STATE_PLAYING = 0;
	var STATE_PAUSED = 1;
	var STATE_STOPPED = 2;
	var capTime = function (time, duration) {
		return (time % duration) || 0;
	};
	if (hasAudioContext()) {
		exports.SoundInstance = function (manager, sound, options) {
			EventHandler.call(this);
			options = options || {};
			this._volume = options.volume !== undefined ? math.clamp(Number(options.volume) || 0, 0, 1) : 1;
			this._pitch = options.pitch !== undefined ? Math.max(0.01, Number(options.pitch) || 0) : 1;
			this._loop = !!(options.loop !== undefined ? options.loop : false);
			this._sound = sound;
			this._state = STATE_STOPPED;
			this._suspended = false;
			this._suspendEndEvent = false;
			this._suspendInstanceEvents = false;
			this._startTime = Math.max(0, Number(options.startTime) || 0);
			this._duration = Math.max(0, Number(options.duration) || 0);
			this._startedAt = 0;
			this._startOffset = null;
			this._currentTime = 0;
			this._currentOffset = 0;
			this._playWhenLoaded = true;
			this._manager = manager;
			this._inputNode = null;
			this._connectorNode = null;
			this._firstNode = null;
			this._lastNode = null;
			this._initializeNodes();
			this._onPlayCallback = options.onPlay;
			this._onPauseCallback = options.onPause;
			this._onResumeCallback = options.onResume;
			this._onStopCallback = options.onStop;
			this._onEndCallback = options.onEnd;
			this._endedHandler = this._onEnded.bind(this);
			this.source = null;
		};
		exports.SoundInstance.prototype = Object.create(EventHandler.prototype);
		exports.SoundInstance.prototype.constructor = exports.SoundInstance;
		Object.assign(exports.SoundInstance.prototype, {
			_initializeNodes: function () {
				this.gain = this._manager.context.createGain();
				this._inputNode = this.gain;
				this._connectorNode = this.gain;
				this._connectorNode.connect(this._manager.context.destination);
			},
			play: function () {
				if (this._state !== STATE_STOPPED) {
					this.stop();
				}
				if (!this.source) {
					this._createSource();
				}
				var offset = capTime(this._startOffset, this.duration);
				offset = capTime(this._startTime + offset, this._sound.duration);
				this._startOffset = null;
				if (this._duration) {
					this.source.start(0, offset, this._duration);
				} else {
					this.source.start(0, offset);
				}
				this._startedAt = this._manager.context.currentTime;
				this._currentTime = 0;
				this._currentOffset = offset;
				this._state = STATE_PLAYING;
				this._playWhenLoaded = false;
				this.volume = this._volume;
				this.loop = this._loop;
				this.pitch = this._pitch;
				this._manager.on('volumechange', this._onManagerVolumeChange, this);
				this._manager.on('suspend', this._onManagerSuspend, this);
				this._manager.on('resume', this._onManagerResume, this);
				this._manager.on('destroy', this._onManagerDestroy, this);
				if (this._manager.suspended) {
					this._onManagerSuspend();
				}
				if (!this._suspendInstanceEvents)
					this._onPlay();
				return true;
			},
			pause: function () {
				if (this._state !== STATE_PLAYING || !this.source)
					return false;
				this._updateCurrentTime();
				this._state = STATE_PAUSED;
				this._suspendEndEvent = true;
				this.source.stop(0);
				this.source = null;
				this._playWhenLoaded = false;
				this._startOffset = null;
				if (!this._suspendInstanceEvents)
					this._onPause();
				return true;
			},
			resume: function () {
				if (this._state !== STATE_PAUSED) {
					return false;
				}
				if (!this.source) {
					this._createSource();
				}
				var offset = this.currentTime;
				if (this._startOffset !== null) {
					offset = capTime(this._startOffset, this.duration);
					offset = capTime(this._startTime + offset, this._sound.duration);
					this._startOffset = null;
				}
				if (this._duration) {
					this.source.start(0, offset, this._duration);
				} else {
					this.source.start(0, offset);
				}
				this._state = STATE_PLAYING;
				this._startedAt = this._manager.context.currentTime;
				this._currentOffset = offset;
				this.volume = this._volume;
				this.loop = this._loop;
				this.pitch = this._pitch;
				this._playWhenLoaded = false;
				if (!this._suspendInstanceEvents)
					this._onResume();
				return true;
			},
			stop: function () {
				if (this._state === STATE_STOPPED || !this.source)
					return false;
				this._manager.off('volumechange', this._onManagerVolumeChange, this);
				this._manager.off('suspend', this._onManagerSuspend, this);
				this._manager.off('resume', this._onManagerResume, this);
				this._manager.off('destroy', this._onManagerDestroy, this);
				this._startedAt = 0;
				this._currentTime = 0;
				this._currentOffset = 0;
				this._startOffset = null;
				this._playWhenLoaded = false;
				this._suspendEndEvent = true;
				if (this._state === STATE_PLAYING) {
					this.source.stop(0);
				}
				this.source = null;
				this._state = STATE_STOPPED;
				if (!this._suspendInstanceEvents)
					this._onStop();
				return true;
			},
			setExternalNodes: function (firstNode, lastNode) {
				if (!firstNode) {
					console.error('The firstNode must be a valid Audio Node');
					return;
				}
				if (!lastNode) {
					lastNode = firstNode;
				}
				var speakers = this._manager.context.destination;
				if (this._firstNode !== firstNode) {
					if (this._firstNode) {
						this._connectorNode.disconnect(this._firstNode);
					} else {
						this._connectorNode.disconnect(speakers);
					}
					this._firstNode = firstNode;
					this._connectorNode.connect(firstNode);
				}
				if (this._lastNode !== lastNode) {
					if (this._lastNode) {
						this._lastNode.disconnect(speakers);
					}
					this._lastNode = lastNode;
					this._lastNode.connect(speakers);
				}
			},
			clearExternalNodes: function () {
				var speakers = this._manager.context.destination;
				if (this._firstNode) {
					this._connectorNode.disconnect(this._firstNode);
					this._firstNode = null;
				}
				if (this._lastNode) {
					this._lastNode.disconnect(speakers);
					this._lastNode = null;
				}
				this._connectorNode.connect(speakers);
			},
			getExternalNodes: function () {
				return [this._firstNode, this._lastNode];
			},
			_createSource: function () {
				if (!this._sound) {
					return null;
				}
				var context = this._manager.context;
				if (this._sound.buffer) {
					this.source = context.createBufferSource();
					this.source.buffer = this._sound.buffer;
					this.source.connect(this._inputNode);
					this.source.onended = this._endedHandler;
					this.source.loopStart = capTime(this._startTime, this.source.buffer.duration);
					if (this._duration) {
						this.source.loopEnd = Math.max(this.source.loopStart, capTime(this._startTime + this._duration, this.source.buffer.duration));
					}
				}
				return this.source;
			},
			_updateCurrentTime: function () {
				this._currentTime = capTime((this._manager.context.currentTime - this._startedAt) * this._pitch + this._currentOffset, this.duration);
			},
			_onManagerDestroy: function () {
				if (this.source && this._state === STATE_PLAYING) {
					this.source.stop(0);
					this.source = null;
				}
			}
		});
		Object.defineProperty(exports.SoundInstance.prototype, 'volume', {
			get: function () {
				return this._volume;
			},
			set: function (volume) {
				volume = math.clamp(volume, 0, 1);
				this._volume = volume;
				if (this.gain) {
					this.gain.gain.value = volume * this._manager.volume;
				}
			}
		});
		Object.defineProperty(exports.SoundInstance.prototype, 'pitch', {
			get: function () {
				return this._pitch;
			},
			set: function (pitch) {
				this._currentOffset = this.currentTime;
				this._startedAt = this._manager.context.currentTime;
				this._pitch = Math.max(Number(pitch) || 0, 0.01);
				if (this.source) {
					this.source.playbackRate.value = this._pitch;
				}
			}
		});
		Object.defineProperty(exports.SoundInstance.prototype, 'loop', {
			get: function () {
				return this._loop;
			},
			set: function (loop) {
				this._loop = !!loop;
				if (this.source) {
					this.source.loop = this._loop;
				}
			}
		});
		Object.defineProperty(exports.SoundInstance.prototype, 'sound', {
			get: function () {
				return this._sound;
			},
			set: function (value) {
				this._sound = value;
				if (this._state !== STATE_STOPPED) {
					this.stop();
				} else {
					this._createSource();
				}
			}
		});
		Object.defineProperty(exports.SoundInstance.prototype, 'currentTime', {
			get: function () {
				if (this._startOffset !== null) {
					return this._startOffset;
				}
				if (this._state === STATE_PAUSED) {
					return this._currentTime;
				}
				if (this._state === STATE_STOPPED || !this.source) {
					return 0;
				}
				this._updateCurrentTime();
				return this._currentTime;
			},
			set: function (value) {
				if (value < 0) return;
				if (this._state === STATE_PLAYING) {
					this.stop();
					var suspend = this._suspendInstanceEvents;
					this._suspendInstanceEvents = true;
					this._startOffset = value;
					this.play();
					this._suspendInstanceEvents = suspend;
				} else {
					this._startOffset = value;
					this._currentTime = value;
				}
			}
		});
	} else if (hasAudio()) {
		exports.SoundInstance = function (manager, resource, options) {
			EventHandler.call(this);
			options = options || {};
			this._volume = options.volume !== undefined ? math.clamp(Number(options.volume) || 0, 0, 1) : 1;
			this._pitch = options.pitch !== undefined ? Math.max(0.01, Number(options.pitch) || 0) : 1;
			this._loop = !!(options.loop !== undefined ? options.loop : false);
			this._sound = resource;
			this._state = STATE_STOPPED;
			this._suspended = false;
			this._suspendEndEvent = false;
			this._suspendInstanceEvents = false;
			this._playWhenLoaded = true;
			this._startTime = Math.max(0, Number(options.startTime) || 0);
			this._duration = Math.max(0, Number(options.duration) || 0);
			this._startOffset = null;
			this._isReady = false;
			this._manager = manager;
			this._loadedMetadataHandler = this._onLoadedMetadata.bind(this);
			this._timeUpdateHandler = this._onTimeUpdate.bind(this);
			this._endedHandler = this._onEnded.bind(this);
			this._onPlayCallback = options.onPlay;
			this._onPauseCallback = options.onPause;
			this._onResumeCallback = options.onResume;
			this._onStopCallback = options.onStop;
			this._onEndCallback = options.onEnd;
			this.source = null;
			this._createSource();
		};
		exports.SoundInstance.prototype = Object.create(EventHandler.prototype);
		exports.SoundInstance.prototype.constructor = exports.SoundInstance;
		Object.assign(exports.SoundInstance.prototype, {
			play: function () {
				if (this._state !== STATE_STOPPED) {
					this.stop();
				}
				if (!this.source) {
					if (!this._createSource()) {
						return false;
					}
				}
				this.volume = this._volume;
				this.pitch = this._pitch;
				this.loop = this._loop;
				this.source.play();
				this._state = STATE_PLAYING;
				this._playWhenLoaded = false;
				this._manager.on('volumechange', this._onManagerVolumeChange, this);
				this._manager.on('suspend', this._onManagerSuspend, this);
				this._manager.on('resume', this._onManagerResume, this);
				this._manager.on('destroy', this._onManagerDestroy, this);
				if (this._manager.suspended)
					this._onManagerSuspend();
				if (!this._suspendInstanceEvents)
					this._onPlay();
				return true;
			},
			pause: function () {
				if (!this.source || this._state !== STATE_PLAYING)
					return false;
				this._suspendEndEvent = true;
				this.source.pause();
				this._playWhenLoaded = false;
				this._state = STATE_PAUSED;
				this._startOffset = null;
				if (!this._suspendInstanceEvents)
					this._onPause();
				return true;
			},
			resume: function () {
				if (!this.source || this._state !== STATE_PAUSED)
					return false;
				this._state = STATE_PLAYING;
				this._playWhenLoaded = false;
				if (this.source.paused) {
					this.source.play();
					if (!this._suspendInstanceEvents)
						this._onResume();
				}
				return true;
			},
			stop: function () {
				if (!this.source || this._state === STATE_STOPPED)
					return false;
				this._manager.off('volumechange', this._onManagerVolumeChange, this);
				this._manager.off('suspend', this._onManagerSuspend, this);
				this._manager.off('resume', this._onManagerResume, this);
				this._manager.off('destroy', this._onManagerDestroy, this);
				this._suspendEndEvent = true;
				this.source.pause();
				this._playWhenLoaded = false;
				this._state = STATE_STOPPED;
				this._startOffset = null;
				if (!this._suspendInstanceEvents)
					this._onStop();
				return true;
			},
			setExternalNodes: function () {
			},
			clearExternalNodes: function () {
			},
			getExternalNodes: function () {
				return [null, null];
			},
			_onLoadedMetadata: function () {
				this.source.removeEventListener('loadedmetadata', this._loadedMetadataHandler);
				this._isReady = true;
				var offset = capTime(this._startOffset, this.duration);
				offset = capTime(this._startTime + offset, this._sound.duration);
				this._startOffset = null;
				this.source.currentTime = offset;
			},
			_createSource: function () {
				if (this._sound && this._sound.audio) {
					this._isReady = false;
					this.source = this._sound.audio.cloneNode(true);
					this.source.addEventListener('loadedmetadata', this._loadedMetadataHandler);
					this.source.addEventListener('timeupdate', this._timeUpdateHandler);
					this.source.onended = this._endedHandler;
				}
				return this.source;
			},
			_onTimeUpdate: function () {
				if (!this._duration)
					return;
				if (this.source.currentTime > capTime(this._startTime + this._duration, this.source.duration)) {
					if (this.loop) {
						this.source.currentTime = capTime(this._startTime, this.source.duration);
					} else {
						this.source.removeEventListener('timeupdate', this._timeUpdateHandler);
						this.source.pause();
						this._onEnded();
					}
				}
			},
			_onManagerDestroy: function () {
				if (this.source) {
					this.source.pause();
				}
			}
		});
		Object.defineProperty(exports.SoundInstance.prototype, 'volume', {
			get: function () {
				return this._volume;
			},
			set: function (volume) {
				volume = math.clamp(volume, 0, 1);
				this._volume = volume;
				if (this.source) {
					this.source.volume = volume * this._manager.volume;
				}
			}
		});
		Object.defineProperty(exports.SoundInstance.prototype, 'pitch', {
			get: function () {
				return this._pitch;
			},
			set: function (pitch) {
				this._pitch = Math.max(Number(pitch) || 0, 0.01);
				if (this.source) {
					this.source.playbackRate = this._pitch;
				}
			}
		});
		Object.defineProperty(exports.SoundInstance.prototype, 'loop', {
			get: function () {
				return this._loop;
			},
			set: function (loop) {
				this._loop = !!loop;
				if (this.source) {
					this.source.loop = this._loop;
				}
			}
		});
		Object.defineProperty(exports.SoundInstance.prototype, 'sound', {
			get: function () {
				return this._sound;
			},
			set: function (value) {
				this.stop();
				this._sound = value;
			}
		});
		Object.defineProperty(exports.SoundInstance.prototype, 'currentTime', {
			get: function () {
				if (this._startOffset !== null) {
					return this._startOffset;
				}
				if (this._state === STATE_STOPPED || !this.source) {
					return 0;
				}
				return this.source.currentTime - this._startTime;
			},
			set: function (value) {
				if (value < 0) return;
				this._startOffset = value;
				if (this.source && this._isReady) {
					this.source.currentTime = capTime(this._startTime + capTime(value, this.duration), this._sound.duration);
					this._startOffset = null;
				}
			}
		});
	} else {
		exports.SoundInstance = function () { };
	}
	Object.assign(exports.SoundInstance.prototype, {
		_onPlay: function () {
			this.fire('play');
			if (this._onPlayCallback)
				this._onPlayCallback(this);
		},
		_onPause: function () {
			this.fire('pause');
			if (this._onPauseCallback)
				this._onPauseCallback(this);
		},
		_onResume: function () {
			this.fire('resume');
			if (this._onResumeCallback)
				this._onResumeCallback(this);
		},
		_onStop: function () {
			this.fire('stop');
			if (this._onStopCallback)
				this._onStopCallback(this);
		},
		_onEnded: function () {
			if (this._suspendEndEvent) {
				this._suspendEndEvent = false;
				return;
			}
			this.fire('end');
			if (this._onEndCallback)
				this._onEndCallback(this);
			this.stop();
		},
		_onManagerVolumeChange: function () {
			this.volume = this._volume;
		},
		_onManagerSuspend: function () {
			if (this._state === STATE_PLAYING && !this._suspended) {
				this._suspended = true;
				this.pause();
			}
		},
		_onManagerResume: function () {
			if (this._suspended) {
				this._suspended = false;
				this.resume();
			}
		}
	});
	Object.defineProperty(exports.SoundInstance.prototype, 'startTime', {
		get: function () {
			return this._startTime;
		},
		set: function (value) {
			this._startTime = Math.max(0, Number(value) || 0);
			var isPlaying = this._state === STATE_PLAYING;
			this.stop();
			if (isPlaying) {
				this.play();
			}
		}
	});
	Object.defineProperty(exports.SoundInstance.prototype, 'duration', {
		get: function () {
			if (!this._sound) {
				return 0;
			}
			if (this._duration) {
				return capTime(this._duration, this._sound.duration);
			}
			return this._sound.duration;
		},
		set: function (value) {
			this._duration = Math.max(0, Number(value) || 0);
			var isPlaying = this._state === STATE_PLAYING;
			this.stop();
			if (isPlaying) {
				this.play();
			}
		}
	});
	Object.defineProperty(exports.SoundInstance.prototype, 'isPlaying', {
		get: function () {
			return this._state === STATE_PLAYING;
		}
	});
	Object.defineProperty(exports.SoundInstance.prototype, 'isPaused', {
		get: function () {
			return this._state === STATE_PAUSED;
		}
	});
	Object.defineProperty(exports.SoundInstance.prototype, 'isStopped', {
		get: function () {
			return this._state === STATE_STOPPED;
		}
	});
	Object.defineProperty(exports.SoundInstance.prototype, 'isSuspended', {
		get: function () {
			return this._suspended;
		}
	});

	var MAX_DISTANCE$1 = 10000;

	if (hasAudioContext()) {
		exports.SoundInstance3d = function (manager, sound, options) {
			exports.SoundInstance.call(this, manager, sound, options);
			options = options || {};
			this._position = new Vec3();
			if (options.position)
				this.position = options.position;
			this._velocity = new Vec3();
			if (options.velocity)
				this.velocity = options.velocity;
			this.maxDistance = options.maxDistance !== undefined ? Number(options.maxDistance) : MAX_DISTANCE$1;
			this.refDistance = options.refDistance !== undefined ? Number(options.refDistance) : 1;
			this.rollOffFactor = options.rollOffFactor !== undefined ? Number(options.rollOffFactor) : 1;
			this.distanceModel = options.distanceModel !== undefined ? options.distanceModel : DISTANCE_LINEAR;
		};
		exports.SoundInstance3d.prototype = Object.create(exports.SoundInstance.prototype);
		exports.SoundInstance3d.prototype.constructor = exports.SoundInstance3d;
		Object.assign(exports.SoundInstance3d.prototype, {
			_initializeNodes: function () {
				this.gain = this._manager.context.createGain();
				this.panner = this._manager.context.createPanner();
				this.panner.connect(this.gain);
				this._inputNode = this.panner;
				this._connectorNode = this.gain;
				this._connectorNode.connect(this._manager.context.destination);
			}
		});
		Object.defineProperty(exports.SoundInstance3d.prototype, 'position', {
			get: function () {
				return this._position;
			},
			set: function (position) {
				this._position.copy(position);
				this.panner.setPosition(position.x, position.y, position.z);
			}
		});
		Object.defineProperty(exports.SoundInstance3d.prototype, 'velocity', {
			get: function () {
				return this._velocity;
			},
			set: function (velocity) {
				this._velocity.copy(velocity);
				this.panner.setVelocity(velocity.x, velocity.y, velocity.z);
			}
		});
		Object.defineProperty(exports.SoundInstance3d.prototype, 'maxDistance', {
			get: function () {
				return this.panner.maxDistance;
			},
			set: function (value) {
				this.panner.maxDistance = value;
			}
		});
		Object.defineProperty(exports.SoundInstance3d.prototype, 'refDistance', {
			get: function () {
				return this.panner.refDistance;
			},
			set: function (value) {
				this.panner.refDistance = value;
			}
		});
		Object.defineProperty(exports.SoundInstance3d.prototype, 'rollOffFactor', {
			get: function () {
				return this.panner.rolloffFactor;
			},
			set: function (value) {
				this.panner.rolloffFactor = value;
			}
		});
		Object.defineProperty(exports.SoundInstance3d.prototype, 'distanceModel', {
			get: function () {
				return this.panner.distanceModel;
			},
			set: function (value) {
				this.panner.distanceModel = value;
			}
		});
	} else if (hasAudio()) {
		var offset$1 = new Vec3();
		var fallOff$1 = function (posOne, posTwo, refDistance, maxDistance, rollOffFactor, distanceModel) {
			offset$1 = offset$1.sub2(posOne, posTwo);
			var distance = offset$1.length();
			if (distance < refDistance) {
				return 1;
			} else if (distance > maxDistance) {
				return 0;
			}
			var result = 0;
			if (distanceModel === DISTANCE_LINEAR) {
				result = 1 - rollOffFactor * (distance - refDistance) / (maxDistance - refDistance);
			} else if (distanceModel === DISTANCE_INVERSE) {
				result = refDistance / (refDistance + rollOffFactor * (distance - refDistance));
			} else if (distanceModel === DISTANCE_EXPONENTIAL) {
				result = Math.pow(distance / refDistance, -rollOffFactor);
			}
			return math.clamp(result, 0, 1);
		};
		exports.SoundInstance3d = function (manager, sound, options) {
			exports.SoundInstance.call(this, manager, sound, options);
			options = options || {};
			this._position = new Vec3();
			if (options.position)
				this.position = options.position;
			this._velocity = new Vec3();
			if (options.velocity)
				this.velocity = options.velocity;
			this._maxDistance = options.maxDistance !== undefined ? Number(options.maxDistance) : MAX_DISTANCE$1;
			this._refDistance = options.refDistance !== undefined ? Number(options.refDistance) : 1;
			this._rollOffFactor = options.rollOffFactor !== undefined ? Number(options.rollOffFactor) : 1;
			this._distanceModel = options.distanceModel !== undefined ? options.distanceModel : DISTANCE_LINEAR;
		};
		exports.SoundInstance3d.prototype = Object.create(exports.SoundInstance.prototype);
		exports.SoundInstance3d.prototype.constructor = exports.SoundInstance3d;
		Object.defineProperty(exports.SoundInstance3d.prototype, 'position', {
			get: function () {
				return this._position;
			},
			set: function (position) {
				this._position.copy(position);
				if (this.source) {
					var listener = this._manager.listener;
					var lpos = listener.getPosition();
					var factor = fallOff$1(lpos, this._position, this.refDistance, this.maxDistance, this.rollOffFactor, this.distanceModel);
					var v = this.volume;
					this.source.volume = v * factor * this._manager.volume;
				}
			}
		});
		Object.defineProperty(exports.SoundInstance3d.prototype, 'velocity', {
			get: function () {
				return this._velocity;
			},
			set: function (velocity) {
				this._velocity.copy(velocity);
			}
		});
		Object.defineProperty(exports.SoundInstance3d.prototype, 'maxDistance', {
			get: function () {
				return this._maxDistance;
			},
			set: function (value) {
				this._maxDistance = value;
			}
		});
		Object.defineProperty(exports.SoundInstance3d.prototype, 'refDistance', {
			get: function () {
				return this._refDistance;
			},
			set: function (value) {
				this._refDistance = value;
			}
		});
		Object.defineProperty(exports.SoundInstance3d.prototype, 'rollOffFactor', {
			get: function () {
				return this._rollOffFactor;
			},
			set: function (value) {
				this._rollOffFactor = value;
			}
		});
		Object.defineProperty(exports.SoundInstance3d.prototype, 'distanceModel', {
			get: function () {
				return this._distanceModel;
			},
			set: function (value) {
				this._distanceModel = value;
			}
		});
	} else {
		exports.SoundInstance3d = function () { };
	}

	var instanceOptions = {
		volume: 0,
		pitch: 0,
		loop: false,
		startTime: 0,
		duration: 0,
		position: new Vec3(),
		maxDistance: 0,
		refDistance: 0,
		rollOffFactor: 0,
		distanceModel: 0,
		onPlay: null,
		onPause: null,
		onResume: null,
		onStop: null,
		onEnd: null
	};
	function SoundSlot(component, name, options) {
		EventHandler.call(this);
		this._component = component;
		this._assets = component.system.app.assets;
		this._manager = component.system.manager;
		this.name = name || 'Untitled';
		options = options || {};
		this._volume = options.volume !== undefined ? math.clamp(Number(options.volume) || 0, 0, 1) : 1;
		this._pitch = options.pitch !== undefined ? Math.max(0.01, Number(options.pitch) || 0) : 1;
		this._loop = !!(options.loop !== undefined ? options.loop : false);
		this._duration = options.duration > 0 ? options.duration : null;
		this._startTime = Math.max(0, Number(options.startTime) || 0);
		this._overlap = !!(options.overlap);
		this._autoPlay = !!(options.autoPlay);
		this._firstNode = null;
		this._lastNode = null;
		this._asset = options.asset;
		if (this._asset instanceof Asset) {
			this._asset = this._asset.id;
		}
		this._onInstancePlayHandler = this._onInstancePlay.bind(this);
		this._onInstancePauseHandler = this._onInstancePause.bind(this);
		this._onInstanceResumeHandler = this._onInstanceResume.bind(this);
		this._onInstanceStopHandler = this._onInstanceStop.bind(this);
		this._onInstanceEndHandler = this._onInstanceEnd.bind(this);
		this.instances = [];
	}
	SoundSlot.prototype = Object.create(EventHandler.prototype);
	SoundSlot.prototype.constructor = SoundSlot;
	Object.assign(SoundSlot.prototype, {
		play: function () {
			if (!this.overlap) {
				this.stop();
			}
			if (!this.isLoaded && !this._hasAsset()) {
				return;
			}
			var instance = this._createInstance();
			this.instances.push(instance);
			if (!this.isLoaded) {
				var onLoad = function (sound) {
					var playWhenLoaded = instance._playWhenLoaded;
					instance.sound = sound;
					if (playWhenLoaded) {
						instance.play();
					}
				};
				this.off('load', onLoad);
				this.once('load', onLoad);
				this.load();
			} else {
				instance.play();
			}
			return instance;
		},
		pause: function () {
			var paused = false;
			var instances = this.instances;
			for (var i = 0, len = instances.length; i < len; i++) {
				if (instances[i].pause()) {
					paused = true;
				}
			}
			return paused;
		},
		resume: function () {
			var resumed = false;
			var instances = this.instances;
			for (var i = 0, len = instances.length; i < len; i++) {
				if (instances[i].resume())
					resumed = true;
			}
			return resumed;
		},
		stop: function () {
			var stopped = false;
			var instances = this.instances;
			var i = instances.length;
			while (i--) {
				instances[i].stop();
				stopped = true;
			}
			instances.length = 0;
			return stopped;
		},
		load: function () {
			if (!this._hasAsset())
				return;
			var asset = this._assets.get(this._asset);
			if (!asset) {
				this._assets.off('add:' + this._asset, this._onAssetAdd, this);
				this._assets.once('add:' + this._asset, this._onAssetAdd, this);
				return;
			}
			asset.off('remove', this._onAssetRemoved, this);
			asset.on('remove', this._onAssetRemoved, this);
			if (!asset.resource) {
				asset.off('load', this._onAssetLoad, this);
				asset.once('load', this._onAssetLoad, this);
				this._assets.load(asset);
				return;
			}
			this.fire('load', asset.resource);
		},
		setExternalNodes: function (firstNode, lastNode) {
			if (!(firstNode)) {
				console.error('The firstNode must have a valid AudioNode');
				return;
			}
			if (!lastNode) {
				lastNode = firstNode;
			}
			this._firstNode = firstNode;
			this._lastNode = lastNode;
			if (!this._overlap) {
				var instances = this.instances;
				for (var i = 0, len = instances.length; i < len; i++) {
					instances[i].setExternalNodes(firstNode, lastNode);
				}
			}
		},
		clearExternalNodes: function () {
			this._firstNode = null;
			this._lastNode = null;
			if (!this._overlap) {
				var instances = this.instances;
				for (var i = 0, len = instances.length; i < len; i++) {
					instances[i].clearExternalNodes();
				}
			}
		},
		getExternalNodes: function () {
			return [this._firstNode, this._lastNode];
		},
		_hasAsset: function () {
			return this._asset != null;
		},
		_createInstance: function () {
			var instance = null;
			var component = this._component;
			var sound = null;
			if (this._hasAsset()) {
				var asset = this._assets.get(this._asset);
				if (asset) {
					sound = asset.resource;
				}
			}
			var data = instanceOptions;
			data.volume = this._volume * component.volume;
			data.pitch = this._pitch * component.pitch;
			data.loop = this._loop;
			data.startTime = this._startTime;
			data.duration = this._duration;
			data.onPlay = this._onInstancePlayHandler;
			data.onPause = this._onInstancePauseHandler;
			data.onResume = this._onInstanceResumeHandler;
			data.onStop = this._onInstanceStopHandler;
			data.onEnd = this._onInstanceEndHandler;
			if (component.positional) {
				data.position.copy(component.entity.getPosition());
				data.maxDistance = component.maxDistance;
				data.refDistance = component.refDistance;
				data.rollOffFactor = component.rollOffFactor;
				data.distanceModel = component.distanceModel;
				instance = new exports.SoundInstance3d(this._manager, sound, data);
			} else {
				instance = new exports.SoundInstance(this._manager, sound, data);
			}
			if (this._firstNode) {
				instance.setExternalNodes(this._firstNode, this._lastNode);
			}
			return instance;
		},
		_onInstancePlay: function (instance) {
			this.fire('play', instance);
			this._component.fire('play', this, instance);
		},
		_onInstancePause: function (instance) {
			this.fire('pause', instance);
			this._component.fire('pause', this, instance);
		},
		_onInstanceResume: function (instance) {
			this.fire('resume', instance);
			this._component.fire('resume', this, instance);
		},
		_onInstanceStop: function (instance) {
			var idx = this.instances.indexOf(instance);
			if (idx !== -1) {
				this.instances.splice(idx, 1);
			}
			this.fire('stop', instance);
			this._component.fire('stop', this, instance);
		},
		_onInstanceEnd: function (instance) {
			var idx = this.instances.indexOf(instance);
			if (idx !== -1) {
				this.instances.splice(idx, 1);
			}
			this.fire('end', instance);
			this._component.fire('end', this, instance);
		},
		_onAssetAdd: function (asset) {
			this.load();
		},
		_onAssetLoad: function (asset) {
			this.load();
		},
		_onAssetRemoved: function (asset) {
			asset.off('remove', this._onAssetRemoved, this);
			this._assets.off('add:' + asset.id, this._onAssetAdd, this);
			this.stop();
		},
		updatePosition: function (position) {
			var instances = this.instances;
			for (var i = 0, len = instances.length; i < len; i++) {
				instances[i].position = position;
			}
		}
	});
	Object.defineProperty(SoundSlot.prototype, 'volume', {
		get: function () {
			return this._volume;
		},
		set: function (value) {
			this._volume = math.clamp(Number(value) || 0, 0, 1);
			if (!this._overlap) {
				var instances = this.instances;
				for (var i = 0, len = instances.length; i < len; i++) {
					instances[i].volume = this._volume * this._component.volume;
				}
			}
		}
	});
	Object.defineProperty(SoundSlot.prototype, 'pitch', {
		get: function () {
			return this._pitch;
		},
		set: function (value) {
			this._pitch = Math.max(Number(value) || 0, 0.01);
			if (!this._overlap) {
				var instances = this.instances;
				for (var i = 0, len = instances.length; i < len; i++) {
					instances[i].pitch = this.pitch * this._component.pitch;
				}
			}
		}
	});
	Object.defineProperty(SoundSlot.prototype, 'loop', {
		get: function () {
			return this._loop;
		},
		set: function (value) {
			this._loop = !!value;
			var instances = this.instances;
			for (var i = 0, len = instances.length; i < len; i++) {
				instances[i].loop = this._loop;
			}
		}
	});
	Object.defineProperty(SoundSlot.prototype, 'autoPlay', {
		get: function () {
			return this._autoPlay;
		},
		set: function (value) {
			this._autoPlay = !!value;
		}
	});
	Object.defineProperty(SoundSlot.prototype, 'overlap', {
		get: function () {
			return this._overlap;
		},
		set: function (value) {
			this._overlap = !!value;
		}
	});
	Object.defineProperty(SoundSlot.prototype, 'startTime', {
		get: function () {
			return this._startTime;
		},
		set: function (value) {
			this._startTime = Math.max(0, Number(value) || 0);
			if (!this._overlap) {
				var instances = this.instances;
				for (var i = 0, len = instances.length; i < len; i++) {
					instances[i].startTime = this._startTime;
				}
			}
		}
	});
	Object.defineProperty(SoundSlot.prototype, 'duration', {
		get: function () {
			var assetDuration = 0;
			if (this._hasAsset()) {
				var asset = this._assets.get(this._asset);
				assetDuration = asset.resource ? asset.resource.duration : 0;
			}
			if (this._duration != null) {
				return this._duration % (assetDuration || 1);
			}
			return assetDuration;
		},
		set: function (value) {
			this._duration = Math.max(0, Number(value) || 0) || null;
			if (!this._overlap) {
				var instances = this.instances;
				for (var i = 0, len = instances.length; i < len; i++) {
					instances[i].duration = this._duration;
				}
			}
		}
	});
	Object.defineProperty(SoundSlot.prototype, 'asset', {
		get: function () {
			return this._asset;
		},
		set: function (value) {
			var old = this._asset;
			if (old) {
				this._assets.off('add:' + old, this._onAssetAdd, this);
				var oldAsset = this._assets.get(old);
				if (oldAsset) {
					oldAsset.off('remove', this._onAssetRemoved, this);
				}
			}
			this._asset = value;
			if (this._asset instanceof Asset) {
				this._asset = this._asset.id;
			}
			if (this._hasAsset() && this._component.enabled && this._component.entity.enabled) {
				this.load();
			}
		}
	});
	Object.defineProperty(SoundSlot.prototype, 'isLoaded', {
		get: function () {
			if (this._hasAsset()) {
				var asset = this._assets.get(this._asset);
				if (asset) {
					return !!asset.resource;
				}
			}
			return false;
		}
	});
	Object.defineProperty(SoundSlot.prototype, 'isPlaying', {
		get: function () {
			var instances = this.instances;
			for (var i = 0, len = instances.length; i < len; i++) {
				if (instances[i].isPlaying)
					return true;
			}
			return false;
		}
	});
	Object.defineProperty(SoundSlot.prototype, 'isPaused', {
		get: function () {
			var instances = this.instances;
			var len = instances.length;
			if (len === 0)
				return false;
			for (var i = 0; i < len; i++) {
				if (!instances[i].isPaused)
					return false;
			}
			return true;
		}
	});
	Object.defineProperty(SoundSlot.prototype, 'isStopped', {
		get: function () {
			var instances = this.instances;
			for (var i = 0, len = instances.length; i < len; i++) {
				if (!instances[i].isStopped)
					return false;
			}
			return true;
		}
	});

	function SoundComponent(system, entity) {
		Component.call(this, system, entity);
		this._volume = 1;
		this._pitch = 1;
		this._positional = true;
		this._refDistance = 1;
		this._maxDistance = 10000;
		this._rollOffFactor = 1;
		this._distanceModel = DISTANCE_LINEAR;
		this._slots = {};
		this._playingBeforeDisable = {};
	}
	SoundComponent.prototype = Object.create(Component.prototype);
	SoundComponent.prototype.constructor = SoundComponent;
	function defineSoundPropertyBasic(publicName, privateName) {
		Object.defineProperty(SoundComponent.prototype, publicName, {
			get: function () {
				return this[privateName];
			},
			set: function (newValue) {
				this[privateName] = newValue;
				var slots = this._slots;
				for (var key in slots) {
					var slot = slots[key];
					if (!slot.overlap) {
						var instances = slot.instances;
						for (var i = 0, len = instances.length; i < len; i++) {
							instances[i][publicName] = newValue;
						}
					}
				}
			}
		});
	}
	function defineSoundPropertyFactor(publicName, privateName) {
		Object.defineProperty(SoundComponent.prototype, publicName, {
			get: function () {
				return this[privateName];
			},
			set: function (newValue) {
				this[privateName] = newValue;
				var slots = this._slots;
				for (var key in slots) {
					var slot = slots[key];
					if (!slot.overlap) {
						var instances = slot.instances;
						for (var i = 0, len = instances.length; i < len; i++) {
							instances[i][publicName] = slot[publicName] * newValue;
						}
					}
				}
			}
		});
	}
	defineSoundPropertyFactor('pitch', '_pitch');
	defineSoundPropertyFactor('volume', '_volume');
	defineSoundPropertyBasic('refDistance', '_refDistance');
	defineSoundPropertyBasic('maxDistance', '_maxDistance');
	defineSoundPropertyBasic('rollOffFactor', '_rollOffFactor');
	defineSoundPropertyBasic('distanceModel', '_distanceModel');
	Object.defineProperty(SoundComponent.prototype, "positional", {
		get: function () {
			return this._positional;
		},
		set: function (newValue) {
			this._positional = newValue;
			var slots = this._slots;
			for (var key in slots) {
				var slot = slots[key];
				if (!slot.overlap) {
					var instances = slot.instances;
					for (var i = 0, len = instances.length; i < len; i++) {
						var isPlaying = instances[i].isPlaying || instances[i].isSuspended;
						var currentTime = instances[i].currentTime;
						if (isPlaying)
							instances[i].stop();
						instances[i] = slot._createInstance();
						if (isPlaying) {
							instances[i].play();
							instances[i].currentTime = currentTime;
						}
					}
				}
			}
		}
	});
	Object.defineProperty(SoundComponent.prototype, "slots", {
		get: function () {
			return this._slots;
		},
		set: function (newValue) {
			var key;
			var oldValue = this._slots;
			if (oldValue) {
				for (key in oldValue) {
					oldValue[key].stop();
				}
			}
			var slots = {};
			for (key in newValue) {
				if (!(newValue[key] instanceof SoundSlot)) {
					if (newValue[key].name) {
						slots[newValue[key].name] = new SoundSlot(this, newValue[key].name, newValue[key]);
					}
				} else {
					slots[newValue[key].name] = newValue[key];
				}
			}
			this._slots = slots;
			if (this.enabled && this.entity.enabled)
				this.onEnable();
		}
	});
	Object.assign(SoundComponent.prototype, {
		onEnable: function () {
			if (this.system._inTools) {
				return;
			}
			var slots = this._slots;
			var playingBeforeDisable = this._playingBeforeDisable;
			for (var key in slots) {
				var slot = slots[key];
				if (slot.autoPlay && slot.isStopped) {
					slot.play();
				} else if (playingBeforeDisable[key]) {
					slot.resume();
				} else if (!slot.isLoaded) {
					slot.load();
				}
			}
		},
		onDisable: function () {
			var slots = this._slots;
			var playingBeforeDisable = {};
			for (var key in slots) {
				if (!slots[key].overlap) {
					if (slots[key].isPlaying) {
						slots[key].pause();
						playingBeforeDisable[key] = true;
					}
				}
			}
			this._playingBeforeDisable = playingBeforeDisable;
		},
		onRemove: function () {
			this.off();
		},
		addSlot: function (name, options) {
			var slots = this._slots;
			if (slots[name]) {
				return null;
			}
			var slot = new SoundSlot(this, name, options);
			slots[name] = slot;
			if (slot.autoPlay && this.enabled && this.entity.enabled) {
				slot.play();
			}
			return slot;
		},
		removeSlot: function (name) {
			var slots = this._slots;
			if (slots[name]) {
				slots[name].stop();
				delete slots[name];
			}
		},
		slot: function (name) {
			return this._slots[name];
		},
		play: function (name) {
			if (!this.enabled || !this.entity.enabled) {
				return null;
			}
			var slot = this._slots[name];
			if (!slot) {
				return null;
			}
			return slot.play();
		},
		pause: function (name) {
			var slot;
			var slots = this._slots;
			if (name) {
				slot = slots[name];
				if (!slot) {
					return;
				}
				slot.pause();
			} else {
				for (var key in slots) {
					slots[key].pause();
				}
			}
		},
		resume: function (name) {
			var slots = this._slots;
			if (name) {
				var slot = slots[name];
				if (!slot) {
					return;
				}
				if (slot.isPaused) {
					slot.resume();
				}
			} else {
				for (var key in slots) {
					slots[key].resume();
				}
			}
		},
		stop: function (name) {
			var slots = this._slots;
			if (name) {
				var slot = slots[name];
				if (!slot) {
					return;
				}
				slot.stop();
			} else {
				for (var key in slots) {
					slots[key].stop();
				}
			}
		}
	});

	function SoundComponentData() {
		this.enabled = true;
	}

	var _schema$h = ['enabled'];
	var SoundComponentSystem = function (app, manager) {
		ComponentSystem.call(this, app);
		this.id = "sound";
		this.ComponentType = SoundComponent;
		this.DataType = SoundComponentData;
		this.schema = _schema$h;
		this.manager = manager;
		ComponentSystem.bind('update', this.onUpdate, this);
		this.on('beforeremove', this.onBeforeRemove, this);
	};
	SoundComponentSystem.prototype = Object.create(ComponentSystem.prototype);
	SoundComponentSystem.prototype.constructor = SoundComponentSystem;
	Component._buildAccessors(SoundComponent.prototype, _schema$h);
	Object.assign(SoundComponentSystem.prototype, {
		initializeComponentData: function (component, data, properties) {
			properties = [
				'volume',
				'pitch',
				'positional',
				'refDistance',
				'maxDistance',
				'rollOffFactor',
				'distanceModel',
				'slots'
			];
			for (var i = 0; i < properties.length; i++) {
				if (data.hasOwnProperty(properties[i])) {
					component[properties[i]] = data[properties[i]];
				}
			}
			ComponentSystem.prototype.initializeComponentData.call(this, component, data, ['enabled']);
		},
		cloneComponent: function (entity, clone) {
			var srcComponent = entity.sound;
			var srcSlots = srcComponent.slots;
			var slots = {};
			for (var key in srcSlots) {
				var srcSlot = srcSlots[key];
				slots[key] = {
					name: srcSlot.name,
					volume: srcSlot.volume,
					pitch: srcSlot.pitch,
					loop: srcSlot.loop,
					duration: srcSlot.duration,
					startTime: srcSlot.startTime,
					overlap: srcSlot.overlap,
					autoPlay: srcSlot.autoPlay,
					asset: srcSlot.asset
				};
			}
			var cloneData = {
				distanceModel: srcComponent.distanceModel,
				enabled: srcComponent.enabled,
				maxDistance: srcComponent.maxDistance,
				pitch: srcComponent.pitch,
				positional: srcComponent.positional,
				refDistance: srcComponent.refDistance,
				rollOffFactor: srcComponent.rollOffFactor,
				slots: slots,
				volume: srcComponent.volume
			};
			return this.addComponent(clone, cloneData);
		},
		onUpdate: function (dt) {
			var store = this.store;
			for (var id in store) {
				if (store.hasOwnProperty(id)) {
					var item = store[id];
					var entity = item.entity;
					if (entity.enabled) {
						var component = entity.sound;
						if (component.enabled && component.positional) {
							var position = entity.getPosition();
							var slots = component.slots;
							for (var key in slots) {
								slots[key].updatePosition(position);
							}
						}
					}
				}
			}
		},
		onBeforeRemove: function (entity, component) {
			var slots = component.slots;
			for (var key in slots) {
				if (!slots[key].overlap) {
					slots[key].stop();
				}
			}
			component.onRemove();
		}
	});
	Object.defineProperty(SoundComponentSystem.prototype, 'volume', {
		get: function () {
			return this.manager.volume;
		},
		set: function (volume) {
			this.manager.volume = volume;
		}
	});
	Object.defineProperty(SoundComponentSystem.prototype, 'context', {
		get: function () {
			if (!hasAudioContext()) {
				return null;
			}
			return this.manager.context;
		}
	});

	var SPRITETYPE_SIMPLE = 'simple';
	var SPRITETYPE_ANIMATED = 'animated';

	function SpriteAnimationClip(component, data) {
		EventHandler.call(this);
		this._component = component;
		this._frame = 0;
		this._sprite = null;
		this._spriteAsset = null;
		this.spriteAsset = data.spriteAsset;
		this.name = data.name;
		this.fps = data.fps || 0;
		this.loop = data.loop || false;
		this._playing = false;
		this._paused = false;
		this._time = 0;
	}
	SpriteAnimationClip.prototype = Object.create(EventHandler.prototype);
	SpriteAnimationClip.prototype.constructor = SpriteAnimationClip;
	Object.assign(SpriteAnimationClip.prototype, {
		_onSpriteAssetAdded: function (asset) {
			this._component.system.app.assets.off('add:' + asset.id, this._onSpriteAssetAdded, this);
			if (this._spriteAsset === asset.id) {
				this._bindSpriteAsset(asset);
			}
		},
		_bindSpriteAsset: function (asset) {
			asset.on("load", this._onSpriteAssetLoad, this);
			asset.on("remove", this._onSpriteAssetRemove, this);
			if (asset.resource) {
				this._onSpriteAssetLoad(asset);
			} else {
				this._component.system.app.assets.load(asset);
			}
		},
		_unbindSpriteAsset: function (asset) {
			asset.off("load", this._onSpriteAssetLoad, this);
			asset.off("remove", this._onSpriteAssetRemove, this);
			if (asset.resource && asset.resource.atlas) {
				this._component.system.app.assets.off('load:' + asset.data.textureAtlasAsset, this._onTextureAtlasLoad, this);
			}
		},
		_onSpriteAssetLoad: function (asset) {
			if (!asset.resource) {
				this.sprite = null;
			} else {
				if (!asset.resource.atlas) {
					var atlasAssetId = asset.data.textureAtlasAsset;
					var assets = this._component.system.app.assets;
					assets.off('load:' + atlasAssetId, this._onTextureAtlasLoad, this);
					assets.once('load:' + atlasAssetId, this._onTextureAtlasLoad, this);
				} else {
					this.sprite = asset.resource;
				}
			}
		},
		_onTextureAtlasLoad: function (atlasAsset) {
			var spriteAsset = this._spriteAsset;
			if (spriteAsset instanceof Asset) {
				this._onSpriteAssetLoad(spriteAsset);
			} else {
				this._onSpriteAssetLoad(this._component.system.app.assets.get(spriteAsset));
			}
		},
		_onSpriteAssetRemove: function (asset) {
			this.sprite = null;
		},
		_onSpriteMeshesChange: function () {
			if (this._component.currentClip === this) {
				this._component._showFrame(this.frame);
			}
		},
		_onSpritePpuChanged: function () {
			if (this._component.currentClip === this) {
				if (this.sprite.renderMode !== SPRITE_RENDERMODE_SIMPLE) {
					this._component._showFrame(this.frame);
				}
			}
		},
		_update: function (dt) {
			if (this.fps === 0) return;
			if (!this._playing || this._paused || !this._sprite) return;
			var dir = this.fps < 0 ? -1 : 1;
			var time = this._time + dt * this._component.speed * dir;
			var duration = this.duration;
			var end = (time > duration || time < 0);
			this._setTime(time);
			var frame = this.frame;
			if (this._sprite) {
				frame = Math.floor(this._sprite.frameKeys.length * this._time / duration);
			} else {
				frame = 0;
			}
			if (frame !== this._frame) {
				this._setFrame(frame);
			}
			if (end) {
				if (this.loop) {
					this.fire('loop');
					this._component.fire('loop', this);
				} else {
					this._playing = false;
					this._paused = false;
					this.fire('end');
					this._component.fire('end', this);
				}
			}
		},
		_setTime: function (value) {
			this._time = value;
			var duration = this.duration;
			if (this._time < 0) {
				if (this.loop) {
					this._time = this._time % duration + duration;
				} else {
					this._time = 0;
				}
			} else if (this._time > duration) {
				if (this.loop) {
					this._time %= duration;
				} else {
					this._time = duration;
				}
			}
		},
		_setFrame: function (value) {
			if (this._sprite) {
				this._frame = math.clamp(value, 0, this._sprite.frameKeys.length - 1);
			} else {
				this._frame = value;
			}
			if (this._component.currentClip === this) {
				this._component._showFrame(this._frame);
			}
		},
		_destroy: function () {
			if (this._sprite) {
				this.sprite = null;
			}
			if (this._spriteAsset) {
				this.spriteAsset = null;
			}
		},
		play: function () {
			if (this._playing)
				return;
			this._playing = true;
			this._paused = false;
			this.frame = 0;
			this.fire('play');
			this._component.fire('play', this);
		},
		pause: function () {
			if (!this._playing || this._paused)
				return;
			this._paused = true;
			this.fire('pause');
			this._component.fire('pause', this);
		},
		resume: function () {
			if (!this._paused) return;
			this._paused = false;
			this.fire('resume');
			this._component.fire('resume', this);
		},
		stop: function () {
			if (!this._playing) return;
			this._playing = false;
			this._paused = false;
			this._time = 0;
			this.frame = 0;
			this.fire('stop');
			this._component.fire('stop', this);
		}
	});
	Object.defineProperty(SpriteAnimationClip.prototype, "spriteAsset", {
		get: function () {
			return this._spriteAsset;
		},
		set: function (value) {
			var assets = this._component.system.app.assets;
			var id = value;
			if (value instanceof Asset) {
				id = value.id;
			}
			if (this._spriteAsset !== id) {
				if (this._spriteAsset) {
					var prev = assets.get(this._spriteAsset);
					if (prev) {
						this._unbindSpriteAsset(prev);
					}
				}
				this._spriteAsset = id;
				if (this._spriteAsset) {
					var asset = assets.get(this._spriteAsset);
					if (!asset) {
						this.sprite = null;
						assets.on('add:' + this._spriteAsset, this._onSpriteAssetAdded, this);
					} else {
						this._bindSpriteAsset(asset);
					}
				} else {
					this.sprite = null;
				}
			}
		}
	});
	Object.defineProperty(SpriteAnimationClip.prototype, "sprite", {
		get: function () {
			return this._sprite;
		},
		set: function (value) {
			if (this._sprite) {
				this._sprite.off('set:meshes', this._onSpriteMeshesChange, this);
				this._sprite.off('set:pixelsPerUnit', this._onSpritePpuChanged, this);
				this._sprite.off('set:atlas', this._onSpriteMeshesChange, this);
				if (this._sprite.atlas) {
					this._sprite.atlas.off('set:texture', this._onSpriteMeshesChange, this);
				}
			}
			this._sprite = value;
			if (this._sprite) {
				this._sprite.on('set:meshes', this._onSpriteMeshesChange, this);
				this._sprite.on('set:pixelsPerUnit', this._onSpritePpuChanged, this);
				this._sprite.on('set:atlas', this._onSpriteMeshesChange, this);
				if (this._sprite.atlas) {
					this._sprite.atlas.on('set:texture', this._onSpriteMeshesChange, this);
				}
			}
			if (this._component.currentClip === this) {
				var mi;
				if (!value || !value.atlas) {
					mi = this._component._meshInstance;
					if (mi) {
						mi.deleteParameter('texture_emissiveMap');
						mi.deleteParameter('texture_opacityMap');
					}
					this._component._hideModel();
				} else {
					if (value.atlas.texture) {
						mi = this._component._meshInstance;
						if (mi) {
							mi.setParameter('texture_emissiveMap', value.atlas.texture);
							mi.setParameter('texture_opacityMap', value.atlas.texture);
						}
						if (this._component.enabled && this._component.entity.enabled) {
							this._component._showModel();
						}
					}
					if (this.time && this.fps) {
						this.time = this.time;
					} else {
						this.frame = this.frame;
					}
				}
			}
		}
	});
	Object.defineProperty(SpriteAnimationClip.prototype, "frame", {
		get: function () {
			return this._frame;
		},
		set: function (value) {
			this._setFrame(value);
			var fps = this.fps || Number.MIN_VALUE;
			this._setTime(this._frame / fps);
		}
	});
	Object.defineProperty(SpriteAnimationClip.prototype, "isPlaying", {
		get: function () {
			return this._playing;
		}
	});
	Object.defineProperty(SpriteAnimationClip.prototype, "isPaused", {
		get: function () {
			return this._paused;
		}
	});
	Object.defineProperty(SpriteAnimationClip.prototype, "duration", {
		get: function () {
			if (this._sprite) {
				var fps = this.fps || Number.MIN_VALUE;
				return this._sprite.frameKeys.length / Math.abs(fps);
			}
			return 0;
		}
	});
	Object.defineProperty(SpriteAnimationClip.prototype, "time", {
		get: function () {
			return this._time;
		},
		set: function (value) {
			this._setTime(value);
			if (this._sprite) {
				this.frame = Math.min(this._sprite.frameKeys.length - 1, Math.floor(this._time * Math.abs(this.fps)));
			} else {
				this.frame = 0;
			}
		}
	});

	var PARAM_EMISSIVE_MAP = 'texture_emissiveMap';
	var PARAM_OPACITY_MAP = 'texture_opacityMap';
	var PARAM_EMISSIVE = 'material_emissive';
	var PARAM_OPACITY = 'material_opacity';
	var PARAM_INNER_OFFSET = 'innerOffset';
	var PARAM_OUTER_SCALE = 'outerScale';
	var PARAM_ATLAS_RECT = 'atlasRect';
	var SpriteComponent = function SpriteComponent(system, entity) {
		Component.call(this, system, entity);
		this._type = SPRITETYPE_SIMPLE;
		this._material = system.defaultMaterial;
		this._color = new Color(1, 1, 1, 1);
		this._colorUniform = new Float32Array(3);
		this._speed = 1;
		this._flipX = false;
		this._flipY = false;
		this._width = 1;
		this._height = 1;
		this._drawOrder = 0;
		this._layers = [LAYERID_WORLD];
		this._outerScale = new Vec2(1, 1);
		this._outerScaleUniform = new Float32Array(2);
		this._innerOffset = new Vec4();
		this._innerOffsetUniform = new Float32Array(4);
		this._atlasRect = new Vec4();
		this._atlasRectUniform = new Float32Array(4);
		this._batchGroupId = -1;
		this._batchGroup = null;
		this._node = new GraphNode();
		this._model = new Model();
		this._model.graph = this._node;
		this._meshInstance = null;
		entity.addChild(this._model.graph);
		this._model._entity = entity;
		this._updateAabbFunc = this._updateAabb.bind(this);
		this._addedModel = false;
		this._autoPlayClip = null;
		this._clips = {};
		this._defaultClip = new SpriteAnimationClip(this, {
			name: this.entity.name,
			fps: 0,
			loop: false,
			spriteAsset: null
		});
		this._currentClip = this._defaultClip;
	};
	SpriteComponent.prototype = Object.create(Component.prototype);
	SpriteComponent.prototype.constructor = SpriteComponent;
	Object.assign(SpriteComponent.prototype, {
		onEnable: function () {
			var app = this.system.app;
			var scene = app.scene;
			scene.on("set:layers", this._onLayersChanged, this);
			if (scene.layers) {
				scene.layers.on("add", this._onLayerAdded, this);
				scene.layers.on("remove", this._onLayerRemoved, this);
			}
			this._showModel();
			if (this._autoPlayClip)
				this._tryAutoPlay();
			if (this._batchGroupId >= 0) {
				app.batcher.insert(BatchGroup.SPRITE, this._batchGroupId, this.entity);
			}
		},
		onDisable: function () {
			var app = this.system.app;
			var scene = app.scene;
			scene.off("set:layers", this._onLayersChanged, this);
			if (scene.layers) {
				scene.layers.off("add", this._onLayerAdded, this);
				scene.layers.off("remove", this._onLayerRemoved, this);
			}
			this.stop();
			this._hideModel();
			if (this._batchGroupId >= 0) {
				app.batcher.remove(BatchGroup.SPRITE, this._batchGroupId, this.entity);
			}
		},
		onDestroy: function () {
			this._currentClip = null;
			if (this._defaultClip) {
				this._defaultClip._destroy();
				this._defaultClip = null;
			}
			for (var key in this._clips) {
				this._clips[key]._destroy();
			}
			this._clips = null;
			this._hideModel();
			this._model = null;
			if (this._node) {
				if (this._node.parent)
					this._node.parent.removeChild(this._node);
				this._node = null;
			}
			if (this._meshInstance) {
				this._meshInstance.material = null;
				this._meshInstance.mesh = null;
				this._meshInstance = null;
			}
		},
		_showModel: function () {
			if (this._addedModel) return;
			if (!this._meshInstance) return;
			var i;
			var len;
			var meshInstances = [this._meshInstance];
			for (i = 0, len = this._layers.length; i < len; i++) {
				var layer = this.system.app.scene.layers.getLayerById(this._layers[i]);
				if (layer) {
					layer.addMeshInstances(meshInstances);
				}
			}
			this._addedModel = true;
		},
		_hideModel: function () {
			if (!this._addedModel || !this._meshInstance) return;
			var i;
			var len;
			var meshInstances = [this._meshInstance];
			for (i = 0, len = this._layers.length; i < len; i++) {
				var layer = this.system.app.scene.layers.getLayerById(this._layers[i]);
				if (layer) {
					layer.removeMeshInstances(meshInstances);
				}
			}
			this._addedModel = false;
		},
		_showFrame: function (frame) {
			if (!this.sprite) return;
			var mesh = this.sprite.meshes[frame];
			if (!mesh) {
				if (this._meshInstance) {
					this._meshInstance.mesh = null;
					this._meshInstance.visible = false;
				}
				return;
			}
			var material;
			if (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED) {
				material = this.system.default9SlicedMaterialSlicedMode;
			} else if (this.sprite.renderMode === SPRITE_RENDERMODE_TILED) {
				material = this.system.default9SlicedMaterialTiledMode;
			} else {
				material = this.system.defaultMaterial;
			}
			if (!this._meshInstance) {
				this._meshInstance = new MeshInstance(this._node, mesh, this._material);
				this._meshInstance.castShadow = false;
				this._meshInstance.receiveShadow = false;
				this._meshInstance.drawOrder = this._drawOrder;
				this._model.meshInstances.push(this._meshInstance);
				this._colorUniform[0] = this._color.r;
				this._colorUniform[1] = this._color.g;
				this._colorUniform[2] = this._color.b;
				this._meshInstance.setParameter(PARAM_EMISSIVE, this._colorUniform);
				this._meshInstance.setParameter(PARAM_OPACITY, this._color.a);
				if (this.enabled && this.entity.enabled) {
					this._showModel();
				}
			}
			if (this._meshInstance.material !== material) {
				this._meshInstance.material = material;
			}
			if (this._meshInstance.mesh !== mesh) {
				this._meshInstance.mesh = mesh;
				this._meshInstance.visible = true;
				this._meshInstance._aabbVer = -1;
			}
			if (this.sprite.atlas && this.sprite.atlas.texture) {
				this._meshInstance.setParameter(PARAM_EMISSIVE_MAP, this.sprite.atlas.texture);
				this._meshInstance.setParameter(PARAM_OPACITY_MAP, this.sprite.atlas.texture);
			} else {
				this._meshInstance.deleteParameter(PARAM_EMISSIVE_MAP);
				this._meshInstance.deleteParameter(PARAM_OPACITY_MAP);
			}
			if (this.sprite.atlas && (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === SPRITE_RENDERMODE_TILED)) {
				this._meshInstance._updateAabbFunc = this._updateAabbFunc;
				var frameData = this.sprite.atlas.frames[this.sprite.frameKeys[frame]];
				if (frameData) {
					var borderWidthScale = 2 / frameData.rect.z;
					var borderHeightScale = 2 / frameData.rect.w;
					this._innerOffset.set(
						frameData.border.x * borderWidthScale,
						frameData.border.y * borderHeightScale,
						frameData.border.z * borderWidthScale,
						frameData.border.w * borderHeightScale
					);
					var tex = this.sprite.atlas.texture;
					this._atlasRect.set(frameData.rect.x / tex.width,
										frameData.rect.y / tex.height,
										frameData.rect.z / tex.width,
										frameData.rect.w / tex.height
					);
				} else {
					this._innerOffset.set(0, 0, 0, 0);
				}
				this._innerOffsetUniform[0] = this._innerOffset.x;
				this._innerOffsetUniform[1] = this._innerOffset.y;
				this._innerOffsetUniform[2] = this._innerOffset.z;
				this._innerOffsetUniform[3] = this._innerOffset.w;
				this._meshInstance.setParameter(PARAM_INNER_OFFSET, this._innerOffsetUniform);
				this._atlasRectUniform[0] = this._atlasRect.x;
				this._atlasRectUniform[1] = this._atlasRect.y;
				this._atlasRectUniform[2] = this._atlasRect.z;
				this._atlasRectUniform[3] = this._atlasRect.w;
				this._meshInstance.setParameter(PARAM_ATLAS_RECT, this._atlasRectUniform);
			} else {
				this._meshInstance._updateAabbFunc = null;
			}
			this._updateTransform();
		},
		_updateTransform: function () {
			var scaleX = this.flipX ? -1 : 1;
			var scaleY = this.flipY ? -1 : 1;
			var posX = 0;
			var posY = 0;
			if (this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === SPRITE_RENDERMODE_TILED)) {
				var w = 1;
				var h = 1;
				if (this.sprite.atlas) {
					var frameData = this.sprite.atlas.frames[this.sprite.frameKeys[this.frame]];
					if (frameData) {
						w = frameData.rect.z;
						h = frameData.rect.w;
						posX = (0.5 - frameData.pivot.x) * this._width;
						posY = (0.5 - frameData.pivot.y) * this._height;
					}
				}
				var scaleMulX = w / this.sprite.pixelsPerUnit;
				var scaleMulY = h / this.sprite.pixelsPerUnit;
				this._outerScale.set(Math.max(this._width, this._innerOffset.x * scaleMulX), Math.max(this._height, this._innerOffset.y * scaleMulY));
				scaleX *= scaleMulX;
				scaleY *= scaleMulY;
				this._outerScale.x /= scaleMulX;
				this._outerScale.y /= scaleMulY;
				scaleX *= math.clamp(this._width / (this._innerOffset.x * scaleMulX), 0.0001, 1);
				scaleY *= math.clamp(this._height / (this._innerOffset.y * scaleMulY), 0.0001, 1);
				if (this._meshInstance) {
					this._outerScaleUniform[0] = this._outerScale.x;
					this._outerScaleUniform[1] = this._outerScale.y;
					this._meshInstance.setParameter(PARAM_OUTER_SCALE, this._outerScaleUniform, 0xFFFFFFFF);
				}
			}
			this._node.setLocalScale(scaleX, scaleY, 1);
			this._node.setLocalPosition(posX, posY, 0);
		},
		_updateAabb: function (aabb) {
			aabb.center.set(0, 0, 0);
			aabb.halfExtents.set(this._outerScale.x * 0.5, this._outerScale.y * 0.5, 0.001);
			aabb.setFromTransformedAabb(aabb, this._node.getWorldTransform());
			return aabb;
		},
		_tryAutoPlay: function () {
			if (!this._autoPlayClip) return;
			if (this.type !== SPRITETYPE_ANIMATED) return;
			var clip = this._clips[this._autoPlayClip];
			if (clip && !clip.isPlaying && (!this._currentClip || !this._currentClip.isPlaying)) {
				if (this.enabled && this.entity.enabled) {
					this.play(clip.name);
				}
			}
		},
		_onLayersChanged: function (oldComp, newComp) {
			oldComp.off("add", this.onLayerAdded, this);
			oldComp.off("remove", this.onLayerRemoved, this);
			newComp.on("add", this.onLayerAdded, this);
			newComp.on("remove", this.onLayerRemoved, this);
			if (this.enabled && this.entity.enabled) {
				this._showModel();
			}
		},
		_onLayerAdded: function (layer) {
			var index = this.layers.indexOf(layer.id);
			if (index < 0) return;
			if (this._addedModel && this.enabled && this.entity.enabled && this._meshInstance) {
				layer.addMeshInstances([this._meshInstance]);
			}
		},
		_onLayerRemoved: function (layer) {
			if (!this._meshInstance) return;
			var index = this.layers.indexOf(layer.id);
			if (index < 0) return;
			layer.removeMeshInstances([this._meshInstance]);
		},
		removeModelFromLayers: function () {
			var layer;
			for (var i = 0; i < this.layers.length; i++) {
				layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
				if (!layer) continue;
				layer.removeMeshInstances([this._meshInstance]);
			}
		},
		addClip: function (data) {
			var clip = new SpriteAnimationClip(this, {
				name: data.name,
				fps: data.fps,
				loop: data.loop,
				spriteAsset: data.spriteAsset
			});
			this._clips[data.name] = clip;
			if (clip.name && clip.name === this._autoPlayClip)
				this._tryAutoPlay();
			return clip;
		},
		removeClip: function (name) {
			delete this._clips[name];
		},
		clip: function (name) {
			return this._clips[name];
		},
		play: function (name) {
			var clip = this._clips[name];
			var current = this._currentClip;
			if (current && current !== clip) {
				current._playing = false;
			}
			this._currentClip = clip;
			if (this._currentClip) {
				this._currentClip = clip;
				this._currentClip.play();
			}
			return clip;
		},
		pause: function () {
			if (this._currentClip === this._defaultClip) return;
			if (this._currentClip.isPlaying) {
				this._currentClip.pause();
			}
		},
		resume: function () {
			if (this._currentClip === this._defaultClip) return;
			if (this._currentClip.isPaused) {
				this._currentClip.resume();
			}
		},
		stop: function () {
			if (this._currentClip === this._defaultClip) return;
			this._currentClip.stop();
		}
	});
	Object.defineProperty(SpriteComponent.prototype, "type", {
		get: function () {
			return this._type;
		},
		set: function (value) {
			if (this._type === value)
				return;
			this._type = value;
			if (this._type === SPRITETYPE_SIMPLE) {
				this.stop();
				this._currentClip = this._defaultClip;
				if (this.enabled && this.entity.enabled) {
					this._currentClip.frame = this.frame;
					if (this._currentClip.sprite) {
						this._showModel();
					} else {
						this._hideModel();
					}
				}
			} else if (this._type === SPRITETYPE_ANIMATED) {
				this.stop();
				if (this._autoPlayClip) {
					this._tryAutoPlay();
				}
				if (this._currentClip && this._currentClip.isPlaying && this.enabled && this.entity.enabled) {
					this._showModel();
				} else {
					this._hideModel();
				}
			}
		}
	});
	Object.defineProperty(SpriteComponent.prototype, "frame", {
		get: function () {
			return this._currentClip.frame;
		},
		set: function (value) {
			this._currentClip.frame = value;
		}
	});
	Object.defineProperty(SpriteComponent.prototype, "spriteAsset", {
		get: function () {
			return this._defaultClip._spriteAsset;
		},
		set: function (value) {
			this._defaultClip.spriteAsset = value;
		}
	});
	Object.defineProperty(SpriteComponent.prototype, "sprite", {
		get: function () {
			return this._currentClip.sprite;
		},
		set: function (value) {
			this._currentClip.sprite = value;
		}
	});
	Object.defineProperty(SpriteComponent.prototype, "material", {
		get: function () {
			return this._material;
		},
		set: function (value) {
			this._material = value;
			if (this._meshInstance) {
				this._meshInstance.material = value;
			}
		}
	});
	Object.defineProperty(SpriteComponent.prototype, "color", {
		get: function () {
			return this._color;
		},
		set: function (value) {
			this._color.r = value.r;
			this._color.g = value.g;
			this._color.b = value.b;
			if (this._meshInstance) {
				this._colorUniform[0] = this._color.r;
				this._colorUniform[1] = this._color.g;
				this._colorUniform[2] = this._color.b;
				this._meshInstance.setParameter(PARAM_EMISSIVE, this._colorUniform);
			}
		}
	});
	Object.defineProperty(SpriteComponent.prototype, "opacity", {
		get: function () {
			return this._color.a;
		},
		set: function (value) {
			this._color.a = value;
			if (this._meshInstance) {
				this._meshInstance.setParameter(PARAM_OPACITY, value);
			}
		}
	});
	Object.defineProperty(SpriteComponent.prototype, "clips", {
		get: function () {
			return this._clips;
		},
		set: function (value) {
			var name, key;
			if (!value) {
				for (name in this._clips) {
					this.removeClip(name);
				}
				return;
			}
			for (name in this._clips) {
				var found = false;
				for (key in value) {
					if (value[key].name === name) {
						found = true;
						this._clips[name].fps = value[key].fps;
						this._clips[name].loop = value[key].loop;
						if (value[key].hasOwnProperty('sprite')) {
							this._clips[name].sprite = value[key].sprite;
						} else if (value[key].hasOwnProperty('spriteAsset')) {
							this._clips[name].spriteAsset = value[key].spriteAsset;
						}
						break;
					}
				}
				if (!found) {
					this.removeClip(name);
				}
			}
			for (key in value) {
				if (this._clips[value[key].name]) continue;
				this.addClip(value[key]);
			}
			if (this._autoPlayClip) {
				this._tryAutoPlay();
			}
			if (!this._currentClip || !this._currentClip.sprite) {
				this._hideModel();
			}
		}
	});
	Object.defineProperty(SpriteComponent.prototype, "currentClip", {
		get: function () {
			return this._currentClip;
		}
	});
	Object.defineProperty(SpriteComponent.prototype, "speed", {
		get: function () {
			return this._speed;
		},
		set: function (value) {
			this._speed = value;
		}
	});
	Object.defineProperty(SpriteComponent.prototype, "flipX", {
		get: function () {
			return this._flipX;
		},
		set: function (value) {
			if (this._flipX === value) return;
			this._flipX = value;
			this._updateTransform();
		}
	});
	Object.defineProperty(SpriteComponent.prototype, "flipY", {
		get: function () {
			return this._flipY;
		},
		set: function (value) {
			if (this._flipY === value) return;
			this._flipY = value;
			this._updateTransform();
		}
	});
	Object.defineProperty(SpriteComponent.prototype, "width", {
		get: function () {
			return this._width;
		},
		set: function (value) {
			if (value === this._width) return;
			this._width = value;
			this._outerScale.x = this._width;
			if (this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_TILED || this.sprite.renderMode === SPRITE_RENDERMODE_SLICED)) {
				this._updateTransform();
			}
		}
	});
	Object.defineProperty(SpriteComponent.prototype, "height", {
		get: function () {
			return this._height;
		},
		set: function (value) {
			if (value === this._height) return;
			this._height = value;
			this._outerScale.y = this.height;
			if (this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_TILED || this.sprite.renderMode === SPRITE_RENDERMODE_SLICED)) {
				this._updateTransform();
			}
		}
	});
	Object.defineProperty(SpriteComponent.prototype, "batchGroupId", {
		get: function () {
			return this._batchGroupId;
		},
		set: function (value) {
			if (this._batchGroupId === value)
				return;
			var prev = this._batchGroupId;
			this._batchGroupId = value;
			if (this.entity.enabled && prev >= 0) {
				this.system.app.batcher.remove(BatchGroup.SPRITE, prev, this.entity);
			}
			if (this.entity.enabled && value >= 0) {
				this.system.app.batcher.insert(BatchGroup.SPRITE, value, this.entity);
			} else {
				if (prev >= 0) {
					if (this._currentClip && this._currentClip.sprite && this.enabled && this.entity.enabled) {
						this._showModel();
					}
				}
			}
		}
	});
	Object.defineProperty(SpriteComponent.prototype, "autoPlayClip", {
		get: function () {
			return this._autoPlayClip;
		},
		set: function (value) {
			this._autoPlayClip = value instanceof SpriteAnimationClip ? value.name : value;
			this._tryAutoPlay();
		}
	});
	Object.defineProperty(SpriteComponent.prototype, "drawOrder", {
		get: function () {
			return this._drawOrder;
		},
		set: function (value) {
			this._drawOrder = value;
			if (this._meshInstance) {
				this._meshInstance.drawOrder = value;
			}
		}
	});
	Object.defineProperty(SpriteComponent.prototype, "layers", {
		get: function () {
			return this._layers;
		},
		set: function (value) {
			if (this._addedModel) {
				this._hideModel();
			}
			this._layers = value;
			if (!this._meshInstance) {
				return;
			}
			if (this.enabled && this.entity.enabled) {
				this._showModel();
			}
		}
	});
	Object.defineProperty(SpriteComponent.prototype, "aabb", {
		get: function () {
			if (this._meshInstance) {
				return this._meshInstance.aabb;
			}
			return null;
		}
	});

	function SpriteComponentData() {
		this.enabled = true;
	}

	var _schema$i = ['enabled'];
	function SpriteComponentSystem(app) {
		ComponentSystem.call(this, app);
		this.id = 'sprite';
		this.ComponentType = SpriteComponent;
		this.DataType = SpriteComponentData;
		this.schema = _schema$i;
		this._defaultTexture = null;
		this._defaultMaterial = null;
		this._default9SlicedMaterialSlicedMode = null;
		this._default9SlicedMaterialTiledMode = null;
		ComponentSystem.bind('update', this.onUpdate, this);
		this.on('beforeremove', this.onBeforeRemove, this);
	}
	SpriteComponentSystem.prototype = Object.create(ComponentSystem.prototype);
	SpriteComponentSystem.prototype.constructor = SpriteComponentSystem;
	Component._buildAccessors(SpriteComponent.prototype, _schema$i);
	Object.defineProperties(SpriteComponentSystem.prototype, {
		defaultMaterial: {
			get: function () {
				if (!this._defaultMaterial) {
					var texture = new Texture(this.app.graphicsDevice, {
						width: 1,
						height: 1,
						format: PIXELFORMAT_R8_G8_B8_A8
					});
					var pixels = new Uint8Array(texture.lock());
					pixels[0] = pixels[1] = pixels[2] = pixels[3] = 255;
					texture.name = 'sprite';
					texture.unlock();
					var material = new StandardMaterial();
					material.diffuse.set(0, 0, 0);
					material.emissive.set(0.5, 0.5, 0.5);
					material.emissiveMap = texture;
					material.emissiveMapTint = true;
					material.opacityMap = texture;
					material.opacityMapChannel = "a";
					material.opacityTint = true;
					material.opacity = 0;
					material.useLighting = false;
					material.useGammaTonemap = false;
					material.useFog = false;
					material.useSkybox = false;
					material.blendType = BLEND_PREMULTIPLIED;
					material.depthWrite = false;
					material.pixelSnap = false;
					material.cull = CULLFACE_NONE;
					material.update();
					this._defaultTexture = texture;
					this._defaultMaterial = material;
				}
				return this._defaultMaterial;
			},
			set: function (material) {
				this._defaultMaterial = material;
			}
		},
		default9SlicedMaterialSlicedMode: {
			get: function () {
				if (!this._default9SlicedMaterialSlicedMode) {
					var material = this.defaultMaterial.clone();
					material.nineSlicedMode = SPRITE_RENDERMODE_SLICED;
					material.update();
					this._default9SlicedMaterialSlicedMode = material;
				}
				return this._default9SlicedMaterialSlicedMode;
			},
			set: function (material) {
				this._default9SlicedMaterialSlicedMode = material;
			}
		},
		default9SlicedMaterialTiledMode: {
			get: function () {
				if (!this._default9SlicedMaterialTiledMode) {
					var material = this.defaultMaterial.clone();
					material.nineSlicedMode = SPRITE_RENDERMODE_TILED;
					material.update();
					this._default9SlicedMaterialTiledMode = material;
				}
				return this._default9SlicedMaterialTiledMode;
			},
			set: function (material) {
				this._default9SlicedMaterialTiledMode = material;
			}
		}
	});
	Object.assign(SpriteComponentSystem.prototype, {
		destroy: function () {
			if (this._defaultTexture) {
				this._defaultTexture.destroy();
				this._defaultTexture = null;
			}
		},
		initializeComponentData: function (component, data, properties) {
			if (data.enabled !== undefined) {
				component.enabled = data.enabled;
			}
			component.type = data.type;
			if (data.layers && Array.isArray(data.layers)) {
				component.layers = data.layers.slice(0);
			}
			if (data.drawOrder !== undefined) {
				component.drawOrder = data.drawOrder;
			}
			if (data.color !== undefined) {
				if (data.color instanceof Color) {
					component.color.set(data.color.r, data.color.g, data.color.b, data.opacity !== undefined ? data.opacity : 1);
				} else {
					component.color.set(data.color[0], data.color[1], data.color[2], data.opacity !== undefined ? data.opacity : 1);
				}
				component.color = component.color;
			}
			if (data.opacity !== undefined) {
				component.opacity = data.opacity;
			}
			if (data.flipX !== undefined) {
				component.flipX = data.flipX;
			}
			if (data.flipY !== undefined) {
				component.flipY = data.flipY;
			}
			if (data.width !== undefined) {
				component.width = data.width;
			}
			if (data.height !== undefined) {
				component.height = data.height;
			}
			if (data.spriteAsset !== undefined) {
				component.spriteAsset = data.spriteAsset;
			}
			if (data.sprite) {
				component.sprite = data.sprite;
			}
			if (data.frame !== undefined) {
				component.frame = data.frame;
			}
			if (data.clips) {
				for (var name in data.clips) {
					component.addClip(data.clips[name]);
				}
			}
			if (data.speed !== undefined)  {
				component.speed = data.speed;
			}
			if (data.autoPlayClip) {
				component.autoPlayClip = data.autoPlayClip;
			}
			component.batchGroupId = data.batchGroupId === undefined || data.batchGroupId === null ? -1 : data.batchGroupId;
			ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
		},
		cloneComponent: function (entity, clone) {
			var source = entity.sprite;
			return this.addComponent(clone, {
				enabled: source.enabled,
				type: source.type,
				spriteAsset: source.spriteAsset,
				sprite: source.sprite,
				frame: source.frame,
				color: source.color.clone(),
				opacity: source.opacity,
				flipX: source.flipX,
				flipY: source.flipY,
				speed: source.speed,
				clips: source.clips,
				autoPlayClip: source.autoPlayClip,
				batchGroupId: source.batchGroupId,
				drawOrder: source.drawOrder,
				layers: source.layers.slice(0)
			});
		},
		onUpdate: function (dt) {
			var components = this.store;
			for (var id in components) {
				if (components.hasOwnProperty(id)) {
					var component = components[id];
					if (component.data.enabled && component.entity.enabled) {
						var sprite = component.entity.sprite;
						if (sprite._currentClip) {
							sprite._currentClip._update(dt);
						}
					}
				}
			}
		},
		onBeforeRemove: function (entity, component) {
			component.onDestroy();
		}
	});

	function ZoneComponent(system, entity) {
		Component.call(this, system, entity);
		this._oldState = true;
		this._size = new Vec3();
		this.on('set_enabled', this._onSetEnabled, this);
	}
	ZoneComponent.prototype = Object.create(Component.prototype);
	ZoneComponent.prototype.constructor = ZoneComponent;
	Object.assign(ZoneComponent.prototype, {
		onEnable: function () {
			this._checkState();
		},
		onDisable: function () {
			this._checkState();
		},
		_onSetEnabled: function (prop, old, value) {
			this._checkState();
		},
		_checkState: function () {
			var state = this.enabled && this.entity.enabled;
			if (state === this._oldState)
				return;
			this._oldState = state;
			this.fire('enable');
			this.fire('state', this.enabled);
		},
		_onBeforeRemove: function () {
			this.fire('remove');
		}
	});
	Object.defineProperty(ZoneComponent.prototype, 'size', {
		set: function (data) {
			if (data instanceof Vec3) {
				this._size.copy(data);
			} else if (data instanceof Array && data.length >= 3) {
				this.size.set(data[0], data[1], data[2]);
			}
		},
		get: function () {
			return this._size;
		}
	});

	function ZoneComponentData() {
		this.enabled = true;
	}

	var _schema$j = ['enabled'];
	var ZoneComponentSystem = function ZoneComponentSystem(app) {
		ComponentSystem.call(this, app);
		this.id = 'zone';
		this.ComponentType = ZoneComponent;
		this.DataType = ZoneComponentData;
		this.schema = _schema$j;
		this.on('beforeremove', this._onBeforeRemove, this);
	};
	ZoneComponentSystem.prototype = Object.create(ComponentSystem.prototype);
	ZoneComponentSystem.prototype.constructor = ZoneComponentSystem;
	Component._buildAccessors(ZoneComponent.prototype, _schema$j);
	Object.assign(ZoneComponentSystem.prototype, {
		initializeComponentData: function (component, data, properties) {
			component.enabled = data.hasOwnProperty('enabled') ? !!data.enabled : true;
			if (data.size) {
				if (data.size instanceof Vec3) {
					component.size.copy(data.size);
				} else if (data.size instanceof Array && data.size.length >= 3) {
					component.size.set(data.size[0], data.size[1], data.size[2]);
				}
			}
		},
		cloneComponent: function (entity, clone) {
			var data = {
				size: entity.zone.size
			};
			return this.addComponent(clone, data);
		},
		_onBeforeRemove: function (entity, component) {
			component._onBeforeRemove();
		}
	});

	function ApplicationStats(device) {
		this.frame = {
			fps: 0,
			ms: 0,
			dt: 0,
			updateStart: 0,
			updateTime: 0,
			renderStart: 0,
			renderTime: 0,
			physicsStart: 0,
			physicsTime: 0,
			cullTime: 0,
			sortTime: 0,
			skinTime: 0,
			morphTime: 0,
			instancingTime: 0,
			triangles: 0,
			otherPrimitives: 0,
			shaders: 0,
			materials: 0,
			cameras: 0,
			shadowMapUpdates: 0,
			shadowMapTime: 0,
			depthMapTime: 0,
			forwardTime: 0,
			_timeToCountFrames: 0,
			_fpsAccum: 0
		};
		this.drawCalls = {
			forward: 0,
			depth: 0,
			shadow: 0,
			immediate: 0,
			misc: 0,
			total: 0,
			skinned: 0,
			instanced: 0,
			removedByInstancing: 0
		};
		this.misc = {
			renderTargetCreationTime: 0
		};
		this.particles = {
			updatesPerFrame: 0, _updatesPerFrame: 0,
			frameTime: 0, _frameTime: 0
		};
		this.vram = device._vram;
		this.shaders = device._shaderStats;
		Object.defineProperty(this.vram, 'totalUsed', {
			get: function () {
				return this.tex + this.vb + this.ib;
			}
		});
		Object.defineProperty(this, 'scene', {
			get: function () {
				return Application._currentApplication.scene._stats;
			}
		});
		Object.defineProperty(this, 'lightmapper', {
			get: function () {
				return Application._currentApplication.lightmapper._stats;
			}
		});
		Object.defineProperty(this, 'batcher', {
			get: function () {
				return Application._currentApplication.batcher._stats;
			}
		});
	}

	function SceneRegistryItem(name, url) {
		this.name = name;
		this.url = url;
	}
	function SceneRegistry(app) {
		this._app = app;
		this._list = [];
		this._index = {};
		this._urlIndex = {};
	}
	SceneRegistry.prototype.destroy = function () {
		this._app = null;
	};
	SceneRegistry.prototype.list = function () {
		return this._list;
	};
	SceneRegistry.prototype.add = function (name, url) {
		if (this._index.hasOwnProperty(name)) {
			return false;
		}
		var item = new SceneRegistryItem(name, url);
		var i = this._list.push(item);
		this._index[item.name] = i - 1;
		this._urlIndex[item.url] = i - 1;
		return true;
	};
	SceneRegistry.prototype.find = function (name) {
		if (this._index.hasOwnProperty(name)) {
			return this._list[this._index[name]];
		}
		return null;
	};
	SceneRegistry.prototype.findByUrl = function (url) {
		if (this._urlIndex.hasOwnProperty(url)) {
			return this._list[this._urlIndex[url]];
		}
		return null;
	};
	SceneRegistry.prototype.remove = function (name) {
		if (this._index.hasOwnProperty(name)) {
			var i = this._index[name];
			var item = this._list[i];
			delete this._urlIndex[item.url];
			delete this._index[name];
			this._list.splice(i, 1);
			for (i = 0; i < this._list.length; i++) {
				item = this._list[i];
				this._index[item.name] = i;
				this._urlIndex[item.url] = i;
			}
		}
	};
	SceneRegistry.prototype.loadSceneHierarchy = function (url, callback) {
		var self = this;
		var handler = this._app.loader.getHandler("hierarchy");
		if (this._app.assets && this._app.assets.prefix && !ABSOLUTE_URL.test(url)) {
			url = path.join(this._app.assets.prefix, url);
		}
		handler.load(url, function (err, data) {
			if (err) {
				if (callback) callback(err);
				return;
			}
			var _loaded = function () {
				self._app.systems.script.preloading = true;
				var entity = handler.open(url, data);
				self._app.systems.script.preloading = false;
				self._app.loader.clearCache(url, "hierarchy");
				self._app.root.addChild(entity);
				ComponentSystem.initialize(entity);
				ComponentSystem.postInitialize(entity);
				if (callback) callback(err, entity);
			};
			self._app._preloadScripts(data, _loaded);
		});
	};
	SceneRegistry.prototype.loadSceneSettings = function (url, callback) {
		var self = this;
		if (this._app.assets && this._app.assets.prefix && !ABSOLUTE_URL.test(url)) {
			url = path.join(this._app.assets.prefix, url);
		}
		this._app.loader.load(url, "scenesettings", function (err, settings) {
			if (!err) {
				self._app.applySceneSettings(settings);
				if (callback) {
					callback(null);
				}
			} else {
				if (callback) {
					callback(err);
				}
			}
		});
	};
	SceneRegistry.prototype.loadScene =  function (url, callback) {
		var self = this;
		var handler = this._app.loader.getHandler("scene");
		if (this._app.assets && this._app.assets.prefix && !ABSOLUTE_URL.test(url)) {
			url = path.join(this._app.assets.prefix, url);
		}
		handler.load(url, function (err, data) {
			if (!err) {
				var _loaded = function () {
					self._app.systems.script.preloading = true;
					var scene = handler.open(url, data);
					self._app.systems.script.preloading = false;
					self._app.loader.clearCache(url, "scene");
					self._app.loader.patch({
						resource: scene,
						type: "scene"
					}, self._app.assets);
					self._app.root.addChild(scene.root);
					if (self._app.systems.rigidbody && typeof Ammo !== 'undefined') {
						self._app.systems.rigidbody.gravity.set(scene._gravity.x, scene._gravity.y, scene._gravity.z);
					}
					if (callback) {
						callback(null, scene);
					}
				};
				self._app._preloadScripts(data, _loaded);
			} else {
				if (callback) {
					callback(err);
				}
			}
		});
	};

	var _deprecationWarning = false;
	var tempGraphNode = new GraphNode();
	exports.app = null;
	function Application(canvas, options) {
		EventHandler.call(this);
		options = options || {};
		console.log("Powered by PlayCanvas " + version + " " + revision);
		Application._applications[canvas.id] = this;
		Application._currentApplication = this;
		exports.app = this;
		this._time = 0;
		this.timeScale = 1;
		this.maxDeltaTime = 0.1;
		this.frame = 0;
		this.autoRender = true;
		this.renderNextFrame = false;
		this.useLegacyScriptAttributeCloning = script.legacy;
		this._librariesLoaded = false;
		this._fillMode = FILLMODE_KEEP_ASPECT;
		this._resolutionMode = RESOLUTION_FIXED;
		this._allowResize = true;
		this.context = this;
		if (! options.graphicsDeviceOptions)
			options.graphicsDeviceOptions = { };
		options.graphicsDeviceOptions.xrCompatible = true;
		this.graphicsDevice = new GraphicsDevice(canvas, options.graphicsDeviceOptions);
		this.stats = new ApplicationStats(this.graphicsDevice);
		this._soundManager = new SoundManager(options);
		this.loader = new ResourceLoader(this);
		this._entityIndex = {};
		this.scene = new Scene();
		this.root = new Entity(this);
		this.root._enabledInHierarchy = true;
		this._enableList = [];
		this._enableList.size = 0;
		this.assets = new AssetRegistry(this.loader);
		if (options.assetPrefix) this.assets.prefix = options.assetPrefix;
		this.bundles = new BundleRegistry(this.assets);
		this.enableBundles = (typeof TextDecoder !== 'undefined');
		this.scriptsOrder = options.scriptsOrder || [];
		this.scripts = new ScriptRegistry(this);
		this.i18n = new I18n(this);
		this.scenes = new SceneRegistry(this);
		var self = this;
		this.defaultLayerWorld = new Layer({
			name: "World",
			id: LAYERID_WORLD
		});
		if (this.graphicsDevice.webgl2) {
			this.defaultLayerDepth = new Layer({
				enabled: false,
				name: "Depth",
				id: LAYERID_DEPTH,
				onEnable: function () {
					if (this.renderTarget) return;
					var depthBuffer = new Texture(self.graphicsDevice, {
						format: PIXELFORMAT_DEPTHSTENCIL,
						width: self.graphicsDevice.width,
						height: self.graphicsDevice.height
					});
					depthBuffer.name = 'rt-depth2';
					depthBuffer.minFilter = FILTER_NEAREST;
					depthBuffer.magFilter = FILTER_NEAREST;
					depthBuffer.addressU = ADDRESS_CLAMP_TO_EDGE;
					depthBuffer.addressV = ADDRESS_CLAMP_TO_EDGE;
					this.renderTarget = new RenderTarget({
						colorBuffer: null,
						depthBuffer: depthBuffer,
						autoResolve: false
					});
					self.graphicsDevice.scope.resolve("uDepthMap").setValue(depthBuffer);
				},
				onDisable: function () {
					if (!this.renderTarget) return;
					this.renderTarget._depthBuffer.destroy();
					this.renderTarget.destroy();
					this.renderTarget = null;
				},
				onPreRenderOpaque: function (cameraPass) {
					var gl = self.graphicsDevice.gl;
					this.srcFbo = gl.getParameter(gl.FRAMEBUFFER_BINDING);
					if (!this.renderTarget || (this.renderTarget.width !== self.graphicsDevice.width || this.renderTarget.height !== self.graphicsDevice.height)) {
						this.onDisable();
						this.onEnable();
					}
					this.oldClear = this.cameras[cameraPass].camera._clearOptions;
					this.cameras[cameraPass].camera._clearOptions = this.depthClearOptions;
				},
				onPostRenderOpaque: function (cameraPass) {
					if (!this.renderTarget) return;
					this.cameras[cameraPass].camera._clearOptions = this.oldClear;
					var gl = self.graphicsDevice.gl;
					self.graphicsDevice.setRenderTarget(this.renderTarget);
					self.graphicsDevice.updateBegin();
					gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this.srcFbo);
					gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.renderTarget._glFrameBuffer);
					gl.blitFramebuffer( 0, 0, this.renderTarget.width, this.renderTarget.height,
										0, 0, this.renderTarget.width, this.renderTarget.height,
										gl.DEPTH_BUFFER_BIT,
										gl.NEAREST);
				}
			});
			this.defaultLayerDepth.depthClearOptions = {
				flags: 0
			};
		} else {
			this.defaultLayerDepth = new Layer({
				enabled: false,
				name: "Depth",
				id: LAYERID_DEPTH,
				shaderPass: SHADER_DEPTH,
				onEnable: function () {
					if (this.renderTarget) return;
					var colorBuffer = new Texture(self.graphicsDevice, {
						format: PIXELFORMAT_R8_G8_B8_A8,
						width: self.graphicsDevice.width,
						height: self.graphicsDevice.height
					});
					colorBuffer.name = 'rt-depth1';
					colorBuffer.minFilter = FILTER_NEAREST;
					colorBuffer.magFilter = FILTER_NEAREST;
					colorBuffer.addressU = ADDRESS_CLAMP_TO_EDGE;
					colorBuffer.addressV = ADDRESS_CLAMP_TO_EDGE;
					this.renderTarget = new RenderTarget(self.graphicsDevice, colorBuffer, {
						depth: true,
						stencil: self.graphicsDevice.supportsStencil
					});
					self.graphicsDevice.scope.resolve("uDepthMap").setValue(colorBuffer);
				},
				onDisable: function () {
					if (!this.renderTarget) return;
					this.renderTarget._colorBuffer.destroy();
					this.renderTarget.destroy();
					this.renderTarget = null;
				},
				onPostCull: function (cameraPass) {
					var visibleObjects = this.instances.visibleOpaque[cameraPass];
					var visibleList = visibleObjects.list;
					var visibleLength = 0;
					var layers = self.scene.layers.layerList;
					var subLayerEnabled = self.scene.layers.subLayerEnabled;
					var isTransparent = self.scene.layers.subLayerList;
					var rt = self.defaultLayerWorld.renderTarget;
					var cam = this.cameras[cameraPass];
					var layer;
					var j;
					var layerVisibleList, layerCamId, layerVisibleListLength, drawCall, transparent;
					for (var i = 0; i < layers.length; i++) {
						layer = layers[i];
						if (layer === this) break;
						if (layer.renderTarget !== rt || !layer.enabled || !subLayerEnabled[i]) continue;
						layerCamId = layer.cameras.indexOf(cam);
						if (layerCamId < 0) continue;
						transparent = isTransparent[i];
						layerVisibleList = transparent ? layer.instances.visibleTransparent[layerCamId] : layer.instances.visibleOpaque[layerCamId];
						layerVisibleListLength = layerVisibleList.length;
						layerVisibleList = layerVisibleList.list;
						for (j = 0; j < layerVisibleListLength; j++) {
							drawCall = layerVisibleList[j];
							if (drawCall.material && drawCall.material.depthWrite && !drawCall._noDepthDrawGl1) {
								visibleList[visibleLength] = drawCall;
								visibleLength++;
							}
						}
					}
					visibleObjects.length = visibleLength;
				},
				onPreRenderOpaque: function (cameraPass) {
					if (!this.renderTarget || (this.renderTarget.width !== self.graphicsDevice.width || this.renderTarget.height !== self.graphicsDevice.height)) {
						this.onDisable();
						this.onEnable();
					}
					this.oldClear = this.cameras[cameraPass].camera._clearOptions;
					this.cameras[cameraPass].camera._clearOptions = this.rgbaDepthClearOptions;
				},
				onDrawCall: function () {
					self.graphicsDevice.setColorWrite(true, true, true, true);
				},
				onPostRenderOpaque: function (cameraPass) {
					if (!this.renderTarget) return;
					this.cameras[cameraPass].camera._clearOptions = this.oldClear;
				}
			});
			this.defaultLayerDepth.rgbaDepthClearOptions = {
				color: [254.0 / 255, 254.0 / 255, 254.0 / 255, 254.0 / 255],
				depth: 1.0,
				flags: CLEARFLAG_COLOR | CLEARFLAG_DEPTH
			};
		}
		this.defaultLayerSkybox = new Layer({
			enabled: false,
			name: "Skybox",
			id: LAYERID_SKYBOX,
			opaqueSortMode: SORTMODE_NONE
		});
		this.defaultLayerUi = new Layer({
			enabled: true,
			name: "UI",
			id: LAYERID_UI,
			transparentSortMode: SORTMODE_MANUAL,
			passThrough: false
		});
		this.defaultLayerImmediate = new Layer({
			enabled: true,
			name: "Immediate",
			id: LAYERID_IMMEDIATE,
			opaqueSortMode: SORTMODE_NONE,
			passThrough: true
		});
		this.defaultLayerComposition = new LayerComposition();
		this.defaultLayerComposition.pushOpaque(this.defaultLayerWorld);
		this.defaultLayerComposition.pushOpaque(this.defaultLayerDepth);
		this.defaultLayerComposition.pushOpaque(this.defaultLayerSkybox);
		this.defaultLayerComposition.pushTransparent(this.defaultLayerWorld);
		this.defaultLayerComposition.pushOpaque(this.defaultLayerImmediate);
		this.defaultLayerComposition.pushTransparent(this.defaultLayerImmediate);
		this.defaultLayerComposition.pushTransparent(this.defaultLayerUi);
		this.scene.layers = this.defaultLayerComposition;
		this._immediateLayer = this.defaultLayerImmediate;
		this.scene.on('set:layers', function (oldComp, newComp) {
			var list = newComp.layerList;
			var layer;
			for (var i = 0; i < list.length; i++) {
				layer = list[i];
				switch (layer.id) {
					case LAYERID_DEPTH:
						layer.onEnable = self.defaultLayerDepth.onEnable;
						layer.onDisable = self.defaultLayerDepth.onDisable;
						layer.onPreRenderOpaque = self.defaultLayerDepth.onPreRenderOpaque;
						layer.onPostRenderOpaque = self.defaultLayerDepth.onPostRenderOpaque;
						layer.depthClearOptions = self.defaultLayerDepth.depthClearOptions;
						layer.rgbaDepthClearOptions = self.defaultLayerDepth.rgbaDepthClearOptions;
						layer.shaderPass = self.defaultLayerDepth.shaderPass;
						layer.onPostCull = self.defaultLayerDepth.onPostCull;
						layer.onDrawCall = self.defaultLayerDepth.onDrawCall;
						break;
					case LAYERID_UI:
						layer.passThrough = self.defaultLayerUi.passThrough;
						break;
					case LAYERID_IMMEDIATE:
						layer.passThrough = self.defaultLayerImmediate.passThrough;
						break;
				}
			}
		});
		this.renderer = new ForwardRenderer(this.graphicsDevice);
		this.renderer.scene = this.scene;
		this.lightmapper = new Lightmapper(this.graphicsDevice, this.root, this.scene, this.renderer, this.assets);
		this.once('prerender', this._firstBake, this);
		this.batcher = new BatchManager(this.graphicsDevice, this.root, this.scene);
		this.once('prerender', this._firstBatch, this);
		this.keyboard = options.keyboard || null;
		this.mouse = options.mouse || null;
		this.touch = options.touch || null;
		this.gamepads = options.gamepads || null;
		this.elementInput = options.elementInput || null;
		if (this.elementInput)
			this.elementInput.app = this;
		this.vr = null;
		this.xr = new XrManager(this);
		if (this.elementInput)
			this.elementInput.attachSelectEvents();
		this._inTools = false;
		this._skyboxLast = 0;
		this._scriptPrefix = options.scriptPrefix || '';
		if (this.enableBundles) {
			this.loader.addHandler("bundle", new BundleHandler(this.assets));
		}
		this.loader.addHandler("animation", new AnimationHandler());
		this.loader.addHandler("animclip", new AnimClipHandler());
		this.loader.addHandler("animstategraph", new AnimStateGraphHandler());
		this.loader.addHandler("model", new ModelHandler(this.graphicsDevice, this.scene.defaultMaterial));
		this.loader.addHandler("material", new MaterialHandler(this));
		this.loader.addHandler("texture", new TextureHandler(this.graphicsDevice, this.assets, this.loader));
		this.loader.addHandler("text", new TextHandler());
		this.loader.addHandler("json", new JsonHandler());
		this.loader.addHandler("audio", new AudioHandler(this._soundManager));
		this.loader.addHandler("script", new ScriptHandler(this));
		this.loader.addHandler("scene", new SceneHandler(this));
		this.loader.addHandler("cubemap", new CubemapHandler(this.graphicsDevice, this.assets, this.loader));
		this.loader.addHandler("html", new HtmlHandler());
		this.loader.addHandler("css", new CssHandler());
		this.loader.addHandler("shader", new ShaderHandler());
		this.loader.addHandler("hierarchy", new HierarchyHandler(this));
		this.loader.addHandler("scenesettings", new SceneSettingsHandler(this));
		this.loader.addHandler("folder", new FolderHandler());
		this.loader.addHandler("font", new FontHandler(this.loader));
		this.loader.addHandler("binary", new BinaryHandler());
		this.loader.addHandler("textureatlas", new TextureAtlasHandler(this.loader));
		this.loader.addHandler("sprite", new SpriteHandler(this.assets, this.graphicsDevice));
		this.loader.addHandler("template", new TemplateHandler(this));
		this.loader.addHandler("container", new ContainerHandler(this.graphicsDevice, this.scene.defaultMaterial));
		this.systems = new ComponentSystemRegistry();
		this.systems.add(new RigidBodyComponentSystem(this));
		this.systems.add(new CollisionComponentSystem(this));
		this.systems.add(new AnimationComponentSystem(this));
		this.systems.add(new AnimComponentSystem(this));
		this.systems.add(new ModelComponentSystem(this));
		this.systems.add(new CameraComponentSystem(this));
		this.systems.add(new LightComponentSystem(this));
		if (script.legacy) {
			this.systems.add(new ScriptLegacyComponentSystem(this));
		} else {
			this.systems.add(new ScriptComponentSystem(this));
		}
		this.systems.add(new AudioSourceComponentSystem(this, this._soundManager));
		this.systems.add(new SoundComponentSystem(this, this._soundManager));
		this.systems.add(new AudioListenerComponentSystem(this, this._soundManager));
		this.systems.add(new ParticleSystemComponentSystem(this));
		this.systems.add(new ScreenComponentSystem(this));
		this.systems.add(new ElementComponentSystem(this));
		this.systems.add(new ButtonComponentSystem(this));
		this.systems.add(new ScrollViewComponentSystem(this));
		this.systems.add(new ScrollbarComponentSystem(this));
		this.systems.add(new SpriteComponentSystem(this));
		this.systems.add(new LayoutGroupComponentSystem(this));
		this.systems.add(new LayoutChildComponentSystem(this));
		this.systems.add(new ZoneComponentSystem(this));
		this._visibilityChangeHandler = this.onVisibilityChange.bind(this);
		if (typeof document !== 'undefined') {
			if (document.hidden !== undefined) {
				this._hiddenAttr = 'hidden';
				document.addEventListener('visibilitychange', this._visibilityChangeHandler, false);
			} else if (document.mozHidden !== undefined) {
				this._hiddenAttr = 'mozHidden';
				document.addEventListener('mozvisibilitychange', this._visibilityChangeHandler, false);
			} else if (document.msHidden !== undefined) {
				this._hiddenAttr = 'msHidden';
				document.addEventListener('msvisibilitychange', this._visibilityChangeHandler, false);
			} else if (document.webkitHidden !== undefined) {
				this._hiddenAttr = 'webkitHidden';
				document.addEventListener('webkitvisibilitychange', this._visibilityChangeHandler, false);
			}
		}
		this.meshInstanceArray = [];
		this.tick = makeTick(this);
	}
	Application.prototype = Object.create(EventHandler.prototype);
	Application.prototype.constructor = Application;
	Application._currentApplication = null;
	Application._applications = {};
	Application.getApplication = function (id) {
		return id ? Application._applications[id] : Application._currentApplication;
	};
	var Progress = function (length) {
		this.length = length;
		this.count = 0;
		this.inc = function () {
			this.count++;
		};
		this.done = function () {
			return (this.count === this.length);
		};
	};
	Object.defineProperty(Application.prototype, 'fillMode', {
		get: function () {
			return this._fillMode;
		}
	});
	Object.defineProperty(Application.prototype, 'resolutionMode', {
		get: function () {
			return this._resolutionMode;
		}
	});
	Object.assign(Application.prototype, {
		configure: function (url, callback) {
			var self = this;
			http.get(url, function (err, response) {
				if (err) {
					callback(err);
					return;
				}
				var props = response.application_properties;
				var scenes = response.scenes;
				var assets = response.assets;
				self._parseApplicationProperties(props, function (err) {
					self._parseScenes(scenes);
					self._parseAssets(assets);
					if (!err) {
						callback(null);
					} else {
						callback(err);
					}
				});
			});
		},
		preload: function (callback) {
			var self = this;
			var i, total;
			self.fire("preload:start");
			var assets = this.assets.list({
				preload: true
			});
			var _assets = new Progress(assets.length);
			var _done = false;
			var done = function () {
				if (!self.graphicsDevice) {
					return;
				}
				if (!_done && _assets.done()) {
					_done = true;
					self.fire("preload:end");
					callback();
				}
			};
			total = assets.length;
			var count = function () {
				return _assets.count;
			};
			if (_assets.length) {
				var onAssetLoad = function (asset) {
					_assets.inc();
					self.fire('preload:progress', count() / total);
					if (_assets.done())
						done();
				};
				var onAssetError = function (err, asset) {
					_assets.inc();
					self.fire('preload:progress', count() / total);
					if (_assets.done())
						done();
				};
				for (i = 0; i < assets.length; i++) {
					if (!assets[i].loaded) {
						assets[i].once('load', onAssetLoad);
						assets[i].once('error', onAssetError);
						this.assets.load(assets[i]);
					} else {
						_assets.inc();
						self.fire("preload:progress", count() / total);
						if (_assets.done())
							done();
					}
				}
			} else {
				done();
			}
		},
		getSceneUrl: function (name) {
			var entry = this.scenes.find(name);
			if (entry) {
				return entry.url;
			}
			return null;
		},
		loadSceneHierarchy: function (url, callback) {
			this.scenes.loadSceneHierarchy(url, callback);
		},
		loadSceneSettings: function (url, callback) {
			this.scenes.loadSceneSettings(url, callback);
		},
		loadScene: function (url, callback) {
			this.scenes.loadScene(url, callback);
		},
		_preloadScripts: function (sceneData, callback) {
			if (!script.legacy) {
				callback();
				return;
			}
			var self = this;
			self.systems.script.preloading = true;
			var scripts = this._getScriptReferences(sceneData);
			var i = 0, l = scripts.length;
			var progress = new Progress(l);
			var scriptUrl;
			var regex = /^http(s)?:\/\//;
			if (l) {
				var onLoad = function (err, ScriptType) {
					if (err)
						console.error(err);
					progress.inc();
					if (progress.done()) {
						self.systems.script.preloading = false;
						callback();
					}
				};
				for (i = 0; i < l; i++) {
					scriptUrl = scripts[i];
					if (!regex.test(scriptUrl.toLowerCase()) && self._scriptPrefix)
						scriptUrl = path.join(self._scriptPrefix, scripts[i]);
					this.loader.load(scriptUrl, 'script', onLoad);
				}
			} else {
				self.systems.script.preloading = false;
				callback();
			}
		},
		_parseApplicationProperties: function (props, callback) {
			var i;
			var len;
			if (!props.useDevicePixelRatio)
				props.useDevicePixelRatio = props.use_device_pixel_ratio;
			if (!props.resolutionMode)
				props.resolutionMode = props.resolution_mode;
			if (!props.fillMode)
				props.fillMode = props.fill_mode;
			this._width = props.width;
			this._height = props.height;
			if (props.useDevicePixelRatio) {
				this.graphicsDevice.maxPixelRatio = window.devicePixelRatio;
			}
			this.setCanvasResolution(props.resolutionMode, this._width, this._height);
			this.setCanvasFillMode(props.fillMode, this._width, this._height);
			if (props.layers && props.layerOrder) {
				var composition = new LayerComposition();
				var layers = {};
				for (var key in props.layers) {
					var data = props.layers[key];
					data.id = parseInt(key, 10);
					data.enabled = data.id !== LAYERID_DEPTH;
					layers[key] = new Layer(data);
				}
				for (i = 0, len = props.layerOrder.length; i < len; i++) {
					var sublayer = props.layerOrder[i];
					var layer = layers[sublayer.layer];
					if (!layer) continue;
					if (sublayer.transparent) {
						composition.pushTransparent(layer);
					} else {
						composition.pushOpaque(layer);
					}
					composition.subLayerEnabled[i] = sublayer.enabled;
				}
				this.scene.layers = composition;
			}
			if (props.batchGroups) {
				for (i = 0, len = props.batchGroups.length; i < len; i++) {
					var grp = props.batchGroups[i];
					this.batcher.addGroup(grp.name, grp.dynamic, grp.maxAabbSize, grp.id, grp.layers);
				}
			}
			if (props.i18nAssets) {
				this.i18n.assets = props.i18nAssets;
			}
			this._loadLibraries(props.libraries, callback);
		},
		_loadLibraries: function (urls, callback) {
			var len = urls.length;
			var count = len;
			var self = this;
			var regex = /^http(s)?:\/\//;
			if (len) {
				var onLoad = function (err, script) {
					count--;
					if (err) {
						callback(err);
					} else if (count === 0) {
						self.onLibrariesLoaded();
						callback(null);
					}
				};
				for (var i = 0; i < len; ++i) {
					var url = urls[i];
					if (!regex.test(url.toLowerCase()) && self._scriptPrefix)
						url = path.join(self._scriptPrefix, url);
					this.loader.load(url, 'script', onLoad);
				}
			} else {
				self.onLibrariesLoaded();
				callback(null);
			}
		},
		_parseScenes: function (scenes) {
			if (!scenes) return;
			for (var i = 0; i < scenes.length; i++) {
				this.scenes.add(scenes[i].name, scenes[i].url);
			}
		},
		_parseAssets: function (assets) {
			var i, id;
			var list = [];
			var scriptsIndex = {};
			var bundlesIndex = {};
			if (!script.legacy) {
				for (i = 0; i < this.scriptsOrder.length; i++) {
					id = this.scriptsOrder[i];
					if (!assets[id])
						continue;
					scriptsIndex[id] = true;
					list.push(assets[id]);
				}
				if (this.enableBundles) {
					for (id in assets) {
						if (assets[id].type === 'bundle') {
							bundlesIndex[id] = true;
							list.push(assets[id]);
						}
					}
				}
				for (id in assets) {
					if (scriptsIndex[id] || bundlesIndex[id])
						continue;
					list.push(assets[id]);
				}
			} else {
				if (this.enableBundles) {
					for (id in assets) {
						if (assets[id].type === 'bundle') {
							bundlesIndex[id] = true;
							list.push(assets[id]);
						}
					}
				}
				for (id in assets) {
					if (bundlesIndex[id])
						continue;
					list.push(assets[id]);
				}
			}
			for (i = 0; i < list.length; i++) {
				var data = list[i];
				var asset = new Asset(data.name, data.type, data.file, data.data);
				asset.id = parseInt(data.id, 10);
				asset.preload = data.preload ? data.preload : false;
				asset.loaded = data.type === 'script' && data.data && data.data.loadingType > 0;
				asset.tags.add(data.tags);
				if (data.i18n) {
					for (var locale in data.i18n) {
						asset.addLocalizedAssetId(locale, data.i18n[locale]);
					}
				}
				this.assets.add(asset);
			}
		},
		_getScriptReferences: function (scene) {
			var i, key;
			var priorityScripts = [];
			if (scene.settings.priority_scripts) {
				priorityScripts = scene.settings.priority_scripts;
			}
			var _scripts = [];
			var _index = {};
			for (i = 0; i < priorityScripts.length; i++) {
				_scripts.push(priorityScripts[i]);
				_index[priorityScripts[i]] = true;
			}
			var entities = scene.entities;
			for (key in entities) {
				if (!entities[key].components.script) {
					continue;
				}
				var scripts = entities[key].components.script.scripts;
				for (i = 0; i < scripts.length; i++) {
					if (_index[scripts[i].url])
						continue;
					_scripts.push(scripts[i].url);
					_index[scripts[i].url] = true;
				}
			}
			return _scripts;
		},
		start: function () {
			this.frame = 0;
			this.fire("start", {
				timestamp: now(),
				target: this
			});
			if (!this._librariesLoaded) {
				this.onLibrariesLoaded();
			}
			ComponentSystem.initialize(this.root);
			this.fire("initialize");
			ComponentSystem.postInitialize(this.root);
			this.fire("postinitialize");
			this.tick();
		},
		update: function (dt) {
			this.frame++;
			this.graphicsDevice.updateClientRect();
			if (this.vr) this.vr.poll();
			if (script.legacy)
				ComponentSystem.fixedUpdate(1.0 / 60.0, this._inTools);
			ComponentSystem.update(dt, this._inTools);
			ComponentSystem.animationUpdate(dt, this._inTools);
			ComponentSystem.postUpdate(dt, this._inTools);
			this.fire("update", dt);
			if (this.controller) {
				this.controller.update(dt);
			}
			if (this.mouse) {
				this.mouse.update(dt);
			}
			if (this.keyboard) {
				this.keyboard.update(dt);
			}
			if (this.gamepads) {
				this.gamepads.update(dt);
			}
		},
		render: function () {
			this.fire("prerender");
			this.root.syncHierarchy();
			this.batcher.updateAll();
			this.renderer.renderComposition(this.scene.layers);
			this.fire("postrender");
		},
		_fillFrameStats: function (now, dt, ms) {
			var stats = this.stats.frame;
			stats.dt = dt;
			stats.ms = ms;
			if (now > stats._timeToCountFrames) {
				stats.fps = stats._fpsAccum;
				stats._fpsAccum = 0;
				stats._timeToCountFrames = now + 1000;
			} else {
				stats._fpsAccum++;
			}
			stats.cameras = this.renderer._camerasRendered;
			stats.materials = this.renderer._materialSwitches;
			stats.shaders = this.graphicsDevice._shaderSwitchesPerFrame;
			stats.shadowMapUpdates = this.renderer._shadowMapUpdates;
			stats.shadowMapTime = this.renderer._shadowMapTime;
			stats.depthMapTime = this.renderer._depthMapTime;
			stats.forwardTime = this.renderer._forwardTime;
			var prims = this.graphicsDevice._primsPerFrame;
			stats.triangles = prims[PRIMITIVE_TRIANGLES] / 3 +
				Math.max(prims[PRIMITIVE_TRISTRIP] - 2, 0) +
				Math.max(prims[PRIMITIVE_TRIFAN] - 2, 0);
			stats.cullTime = this.renderer._cullTime;
			stats.sortTime = this.renderer._sortTime;
			stats.skinTime = this.renderer._skinTime;
			stats.morphTime = this.renderer._morphTime;
			stats.instancingTime = this.renderer._instancingTime;
			stats.otherPrimitives = 0;
			for (var i = 0; i < prims.length; i++) {
				if (i < PRIMITIVE_TRIANGLES) {
					stats.otherPrimitives += prims[i];
				}
				prims[i] = 0;
			}
			this.renderer._camerasRendered = 0;
			this.renderer._materialSwitches = 0;
			this.renderer._shadowMapUpdates = 0;
			this.graphicsDevice._shaderSwitchesPerFrame = 0;
			this.renderer._cullTime = 0;
			this.renderer._sortTime = 0;
			this.renderer._skinTime = 0;
			this.renderer._morphTime = 0;
			this.renderer._instancingTime = 0;
			this.renderer._shadowMapTime = 0;
			this.renderer._depthMapTime = 0;
			this.renderer._forwardTime = 0;
			stats = this.stats.drawCalls;
			stats.forward = this.renderer._forwardDrawCalls;
			stats.culled = this.renderer._numDrawCallsCulled;
			stats.depth = 0;
			stats.shadow = this.renderer._shadowDrawCalls;
			stats.skinned = this.renderer._skinDrawCalls;
			stats.immediate = 0;
			stats.instanced = 0;
			stats.removedByInstancing = 0;
			stats.total = this.graphicsDevice._drawCallsPerFrame;
			stats.misc = stats.total - (stats.forward + stats.shadow);
			this.renderer._depthDrawCalls = 0;
			this.renderer._shadowDrawCalls = 0;
			this.renderer._forwardDrawCalls = 0;
			this.renderer._numDrawCallsCulled = 0;
			this.renderer._skinDrawCalls = 0;
			this.renderer._immediateRendered = 0;
			this.renderer._instancedDrawCalls = 0;
			this.renderer._removedByInstancing = 0;
			this.graphicsDevice._drawCallsPerFrame = 0;
			this.stats.misc.renderTargetCreationTime = this.graphicsDevice.renderTargetCreationTime;
			stats = this.stats.particles;
			stats.updatesPerFrame = stats._updatesPerFrame;
			stats.frameTime = stats._frameTime;
			stats._updatesPerFrame = 0;
			stats._frameTime = 0;
		},
		setCanvasFillMode: function (mode, width, height) {
			this._fillMode = mode;
			this.resizeCanvas(width, height);
		},
		setCanvasResolution: function (mode, width, height) {
			this._resolutionMode = mode;
			if (mode === RESOLUTION_AUTO && (width === undefined)) {
				width = this.graphicsDevice.canvas.clientWidth;
				height = this.graphicsDevice.canvas.clientHeight;
			}
			this.graphicsDevice.resizeCanvas(width, height);
		},
		isHidden: function () {
			return document[this._hiddenAttr];
		},
		onVisibilityChange: function () {
			if (this.isHidden()) {
				this._soundManager.suspend();
			} else {
				this._soundManager.resume();
			}
		},
		resizeCanvas: function (width, height) {
			if (!this._allowResize) return;
			if (this.xr && this.xr.session)
				return;
			var windowWidth = window.innerWidth;
			var windowHeight = window.innerHeight;
			if (this._fillMode === FILLMODE_KEEP_ASPECT) {
				var r = this.graphicsDevice.canvas.width / this.graphicsDevice.canvas.height;
				var winR = windowWidth / windowHeight;
				if (r > winR) {
					width = windowWidth;
					height = width / r;
				} else {
					height = windowHeight;
					width = height * r;
				}
			} else if (this._fillMode === FILLMODE_FILL_WINDOW) {
				width = windowWidth;
				height = windowHeight;
			}
			this.graphicsDevice.canvas.style.width = width + 'px';
			this.graphicsDevice.canvas.style.height = height + 'px';
			if (this._resolutionMode === RESOLUTION_AUTO) {
				this.setCanvasResolution(RESOLUTION_AUTO);
			}
			return {
				width: width,
				height: height
			};
		},
		onLibrariesLoaded: function () {
			this._librariesLoaded = true;
			this.systems.rigidbody.onLibraryLoaded();
		},
		applySceneSettings: function (settings) {
			var asset;
			if (this.systems.rigidbody && typeof Ammo !== 'undefined') {
				var gravity = settings.physics.gravity;
				this.systems.rigidbody.gravity.set(gravity[0], gravity[1], gravity[2]);
			}
			this.scene.applySettings(settings);
			if (settings.render.hasOwnProperty('skybox')) {
				if (settings.render.skybox) {
					asset = this.assets.get(settings.render.skybox);
					if (asset) {
						this.setSkybox(asset);
					} else {
						this.assets.once('add:' + settings.render.skybox, this.setSkybox, this);
					}
				} else {
					this.setSkybox(null);
				}
			}
		},
		setSkybox: function (asset) {
			if (asset) {
				if (this._skyboxLast === asset.id) {
					if (this.scene.skyboxMip === 0 && !asset.loadFaces) {
						this._skyboxLoad(asset);
					} else {
						this._onSkyboxChange(asset);
					}
					return;
				}
				if (this._skyboxLast) {
					this.assets.off('add:' + this._skyboxLast, this.setSkybox, this);
					this.assets.off('load:' + this._skyboxLast, this._onSkyboxChange, this);
					this.assets.off('remove:' + this._skyboxLast, this._skyboxRemove, this);
				}
				this._skyboxLast = asset.id;
				this.assets.on('load:' + asset.id, this._onSkyboxChange, this);
				this.assets.once('remove:' + asset.id, this._skyboxRemove, this);
				if (asset.resource)
					this.scene.setSkybox(asset.resources);
				this._skyboxLoad(asset);
			} else {
				if (!this._skyboxLast)
					return;
				this._skyboxRemove({
					id: this._skyboxLast
				});
			}
		},
		enableVr: function () {
			if (!this.vr) {
				this.vr = new VrManager(this);
			}
		},
		disableVr: function () {
			if (this.vr) {
				this.vr.destroy();
				this.vr = null;
			}
		},
		_onSkyboxChange: function (asset) {
			this.scene.setSkybox(asset.resources);
		},
		_skyboxLoad: function (asset) {
			if (this.scene.skyboxMip === 0)
				asset.loadFaces = true;
			this.assets.load(asset);
			this._onSkyboxChange(asset);
		},
		_skyboxRemove: function (asset) {
			if (!this._skyboxLast)
				return;
			this.assets.off('add:' + asset.id, this.setSkybox, this);
			this.assets.off('load:' + asset.id, this._onSkyboxChange, this);
			this.assets.off('remove:' + asset.id, this._skyboxRemove, this);
			this.scene.setSkybox(null);
			this._skyboxLast = null;
		},
		_firstBake: function () {
			this.lightmapper.bake(null, this.scene.lightmapMode);
		},
		_firstBatch: function () {
			if (this.scene._needsStaticPrepare) {
				this.renderer.prepareStaticMeshes(this.graphicsDevice, this.scene);
				this.scene._needsStaticPrepare = false;
			}
			this.batcher.generate();
		},
		_processTimestamp: function (timestamp) {
			return timestamp;
		},
		_preRenderImmediate: function () {
			for (var i = 0; i < this._immediateData.lineBatches.length; i++) {
				if (this._immediateData.lineBatches[i]) {
					this._immediateData.lineBatches[i].finalize(this.meshInstanceArray);
				}
			}
		},
		_postRenderImmediate: function () {
			for (var i = 0; i < this._immediateData.layers.length; i++) {
				this._immediateData.layers[i].clearMeshInstances(true);
			}
			this._immediateData.layers.length = 0;
		},
		_initImmediate: function () {
			if (!this._immediateData) {
				this._immediateData = new ImmediateData(this.graphicsDevice);
				this.on('prerender', this._preRenderImmediate, this);
				this.on('postrender', this._postRenderImmediate, this);
			}
		},
		_addLines: function (position, color, options) {
			var layer = (options && options.layer) ? options.layer : this.scene.layers.getLayerById(LAYERID_IMMEDIATE);
			var depthTest = (options && options.depthTest !== undefined) ? options.depthTest : true;
			var mask = (options && options.mask) ? options.mask : undefined;
			this._initImmediate();
			this._immediateData.addLayer(layer);
			var idx = this._immediateData.getLayerIdx(layer);
			if (idx === undefined) {
				var batch = new LineBatch();
				batch.init(this.graphicsDevice, this._immediateData.lineVertexFormat, layer, position.length / 2);
				batch.material.depthTest = depthTest;
				if (mask) batch.meshInstance.mask = mask;
				idx = this._immediateData.lineBatches.push(batch) - 1;
				this._immediateData.addLayerIdx(idx, layer);
			} else {
				this._immediateData.lineBatches[idx].init(this.graphicsDevice, this._immediateData.lineVertexFormat, layer, position.length / 2);
				this._immediateData.lineBatches[idx].material.depthTest = depthTest;
				if (mask) this._immediateData.lineBatches[idx].meshInstance.mask = mask;
			}
			this._immediateData.lineBatches[idx].addLines(position, color);
		},
		renderLine: function (start, end, color) {
			var endColor = color;
			var options;
			var arg3 = arguments[3];
			var arg4 = arguments[4];
			if (arg3 instanceof Color) {
				endColor = arg3;
				if (typeof arg4 === 'number') {
					if (!_deprecationWarning) {
						console.warn("lineBatch argument is deprecated for renderLine. Use options.layer instead");
						_deprecationWarning = true;
					}
					if (arg4 === LINEBATCH_OVERLAY) {
						options = {
							layer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE),
							depthTest: false
						};
					} else {
						options = {
							layer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE),
							depthTest: true
						};
					}
				} else {
					options = arg4;
				}
			} else if (typeof arg3 === 'number') {
				if (!_deprecationWarning) {
					console.warn("lineBatch argument is deprecated for renderLine. Use options.layer instead");
					_deprecationWarning = true;
				}
				endColor = color;
				if (arg3 === LINEBATCH_OVERLAY) {
					options = {
						layer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE),
						depthTest: false
					};
				} else {
					options = {
						layer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE),
						depthTest: true
					};
				}
			} else if (arg3) {
				options = arg3;
			}
			this._addLines([start, end], [color, endColor], options);
		},
		renderLines: function (position, color, options) {
			if (!options) {
				options = {
					layer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE),
					depthTest: true
				};
			} else if (typeof options === 'number') {
				if (!_deprecationWarning) {
					console.warn("lineBatch argument is deprecated for renderLine. Use options.layer instead");
					_deprecationWarning = true;
				}
				if (options === LINEBATCH_OVERLAY) {
					options = {
						layer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE),
						depthTest: false
					};
				} else {
					options = {
						layer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE),
						depthTest: true
					};
				}
			}
			var multiColor = !!color.length;
			if (multiColor) {
				if (position.length !== color.length) {
					console.error("renderLines: position/color arrays have different lengths");
					return;
				}
			}
			if (position.length % 2 !== 0) {
				console.error("renderLines: array length is not divisible by 2");
				return;
			}
			this._addLines(position, color, options);
		},
		renderWireCube: function (matrix, color, options) {
			var i;
			this._initImmediate();
			if (!this._immediateData.cubeLocalPos) {
				var x = 0.5;
				this._immediateData.cubeLocalPos = [new Vec3(-x, -x, -x), new Vec3(-x, x, -x), new Vec3(x, x, -x), new Vec3(x, -x, -x),
					new Vec3(-x, -x, x), new Vec3(-x, x, x), new Vec3(x, x, x), new Vec3(x, -x, x)];
				this._immediateData.cubeWorldPos = [new Vec3(), new Vec3(), new Vec3(), new Vec3(),
					new Vec3(), new Vec3(), new Vec3(), new Vec3()];
			}
			var cubeLocalPos = this._immediateData.cubeLocalPos;
			var cubeWorldPos = this._immediateData.cubeWorldPos;
			for (i = 0; i < 8; i++) {
				matrix.transformPoint(cubeLocalPos[i], cubeWorldPos[i]);
			}
			this.renderLines([
				cubeWorldPos[0], cubeWorldPos[1],
				cubeWorldPos[1], cubeWorldPos[2],
				cubeWorldPos[2], cubeWorldPos[3],
				cubeWorldPos[3], cubeWorldPos[0],
				cubeWorldPos[4], cubeWorldPos[5],
				cubeWorldPos[5], cubeWorldPos[6],
				cubeWorldPos[6], cubeWorldPos[7],
				cubeWorldPos[7], cubeWorldPos[4],
				cubeWorldPos[0], cubeWorldPos[4],
				cubeWorldPos[1], cubeWorldPos[5],
				cubeWorldPos[2], cubeWorldPos[6],
				cubeWorldPos[3], cubeWorldPos[7]
			], color, options);
		},
		renderMeshInstance: function (meshInstance, options) {
			if (!options) {
				options = {
					layer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE)
				};
			}
			this._initImmediate();
			this._immediateData.addLayer(options.layer);
			this.meshInstanceArray[0] = meshInstance;
			options.layer.addMeshInstances(this.meshInstanceArray, true);
		},
		renderMesh: function (mesh, material, matrix, options) {
			if (!options) {
				options = {
					layer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE)
				};
			}
			this._initImmediate();
			tempGraphNode.worldTransform = matrix;
			tempGraphNode._dirtyWorld = tempGraphNode._dirtyNormal = false;
			var instance = new MeshInstance(tempGraphNode, mesh, material);
			instance.cull = false;
			if (options.mask) instance.mask = options.mask;
			this._immediateData.addLayer(options.layer);
			this.meshInstanceArray[0] = instance;
			options.layer.addMeshInstances(this.meshInstanceArray, true);
		},
		renderQuad: function (matrix, material, options) {
			if (!options) {
				options = {
					layer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE)
				};
			}
			this._initImmediate();
			if (!this._immediateData.quadMesh) {
				var format = new VertexFormat(this.graphicsDevice, [
					{ semantic: SEMANTIC_POSITION, components: 3, type: TYPE_FLOAT32 }
				]);
				var quadVb = new VertexBuffer(this.graphicsDevice, format, 4);
				var iterator = new VertexIterator(quadVb);
				iterator.element[SEMANTIC_POSITION].set(-0.5, -0.5, 0);
				iterator.next();
				iterator.element[SEMANTIC_POSITION].set(0.5, -0.5, 0);
				iterator.next();
				iterator.element[SEMANTIC_POSITION].set(-0.5, 0.5, 0);
				iterator.next();
				iterator.element[SEMANTIC_POSITION].set(0.5, 0.5, 0);
				iterator.end();
				this._immediateData.quadMesh = new Mesh(this.graphicsDevice);
				this._immediateData.quadMesh.vertexBuffer = quadVb;
				this._immediateData.quadMesh.primitive[0].type = PRIMITIVE_TRISTRIP;
				this._immediateData.quadMesh.primitive[0].base = 0;
				this._immediateData.quadMesh.primitive[0].count = 4;
				this._immediateData.quadMesh.primitive[0].indexed = false;
			}
			tempGraphNode.worldTransform = matrix;
			tempGraphNode._dirtyWorld = tempGraphNode._dirtyNormal = false;
			var quad = new MeshInstance(tempGraphNode, this._immediateData.quadMesh, material);
			quad.cull = false;
			this.meshInstanceArray[0] = quad;
			this._immediateData.addLayer(options.layer);
			options.layer.addMeshInstances(this.meshInstanceArray, true);
		},
		destroy: function () {
			var i, l;
			var canvasId = this.graphicsDevice.canvas.id;
			this.off('librariesloaded');
			document.removeEventListener('visibilitychange', this._visibilityChangeHandler, false);
			document.removeEventListener('mozvisibilitychange', this._visibilityChangeHandler, false);
			document.removeEventListener('msvisibilitychange', this._visibilityChangeHandler, false);
			document.removeEventListener('webkitvisibilitychange', this._visibilityChangeHandler, false);
			this._visibilityChangeHandler = null;
			this.onVisibilityChange = null;
			this.root.destroy();
			this.root = null;
			if (this.mouse) {
				this.mouse.off();
				this.mouse.detach();
				this.mouse = null;
			}
			if (this.keyboard) {
				this.keyboard.off();
				this.keyboard.detach();
				this.keyboard = null;
			}
			if (this.touch) {
				this.touch.off();
				this.touch.detach();
				this.touch = null;
			}
			if (this.elementInput) {
				this.elementInput.detach();
				this.elementInput = null;
			}
			if (this.controller) {
				this.controller = null;
			}
			var systems = this.systems.list;
			for (i = 0, l = systems.length; i < l; i++) {
				systems[i].destroy();
			}
			ComponentSystem.destroy();
			var assets = this.assets.list();
			for (i = 0; i < assets.length; i++) {
				assets[i].unload();
				assets[i].off();
			}
			this.assets.off();
			this.bundles.destroy();
			this.bundles = null;
			this.i18n.destroy();
			this.i18n = null;
			for (var key in this.loader.getHandler('script')._cache) {
				var element = this.loader.getHandler('script')._cache[key];
				var parent = element.parentNode;
				if (parent) parent.removeChild(element);
			}
			this.loader.getHandler('script')._cache = {};
			this.loader.destroy();
			this.loader = null;
			this.scene.destroy();
			this.scene = null;
			this.systems = [];
			this.context = null;
			this.scripts.destroy();
			this.scripts = null;
			this.scenes.destroy();
			this.scenes = null;
			this.lightmapper.destroy();
			this.lightmapper = null;
			this.batcher.destroyManager();
			this.batcher = null;
			this._entityIndex = {};
			this.defaultLayerDepth.onPreRenderOpaque = null;
			this.defaultLayerDepth.onPostRenderOpaque = null;
			this.defaultLayerDepth.onDisable = null;
			this.defaultLayerDepth.onEnable = null;
			this.defaultLayerDepth = null;
			this.defaultLayerWorld = null;
			destroyPostEffectQuad();
			if (this.vr) {
				this.vr.destroy();
				this.vr = null;
			}
			this.xr.end();
			this.graphicsDevice.destroy();
			this.graphicsDevice = null;
			this.renderer = null;
			this.tick = null;
			this.off();
			if (this._soundManager) {
				this._soundManager.destroy();
				this._soundManager = null;
			}
			script.app = null;
			ParticleEmitter.DEFAULT_PARAM_TEXTURE = null;
			Application._applications[canvasId] = null;
			if (Application._currentApplication === this) {
				Application._currentApplication = null;
			}
		},
		getEntityFromIndex: function (guid) {
			return this._entityIndex[guid];
		}
	});
	var _frameEndData = {};
	var makeTick = function (_app) {
		var application = _app;
		var frameRequest;
		return function (timestamp, frame) {
			if (!application.graphicsDevice)
				return;
			Application._currentApplication = application;
			if (frameRequest) {
				window.cancelAnimationFrame(frameRequest);
				frameRequest = null;
			}
			exports.app = application;
			var currentTime = application._processTimestamp(timestamp) || now();
			var ms = currentTime - (application._time || currentTime);
			var dt = ms / 1000.0;
			dt = math.clamp(dt, 0, application.maxDeltaTime);
			dt *= application.timeScale;
			application._time = currentTime;
			if (application.vr && application.vr.display) {
				frameRequest = application.vr.display.requestAnimationFrame(application.tick);
			} else if (application.xr.session) {
				frameRequest = application.xr.session.requestAnimationFrame(application.tick);
			} else {
				frameRequest = window.requestAnimationFrame(application.tick);
			}
			if (application.graphicsDevice.contextLost)
				return;
			application.fire("frameupdate", ms);
			if (frame) {
				application.xr.update(frame);
				application.graphicsDevice.defaultFramebuffer = frame.session.renderState.baseLayer.framebuffer;
			} else {
				application.graphicsDevice.defaultFramebuffer = null;
			}
			application.update(dt);
			application.fire("framerender");
			if (application.autoRender || application.renderNextFrame) {
				application.render();
				application.renderNextFrame = false;
			}
			_frameEndData.timestamp = now();
			_frameEndData.target = application;
			application.fire("frameend", _frameEndData);
			application.fire("frameEnd", _frameEndData);
			if (application.vr && application.vr.display && application.vr.display.presenting) {
				application.vr.display.submitFrame();
			}
		};
	};

	function getDefaultMaterial() {
		return Application.getApplication().scene.defaultMaterial;
	}

	var id$2 = 0;
	function Material() {
		this.name = "Untitled";
		this.id = id$2++;
		this._shader = null;
		this.variants = {};
		this.parameters = {};
		this.alphaTest = 0;
		this.alphaToCoverage = false;
		this.blend = false;
		this.blendSrc = BLENDMODE_ONE;
		this.blendDst = BLENDMODE_ZERO;
		this.blendEquation = BLENDEQUATION_ADD;
		this.separateAlphaBlend = false;
		this.blendSrcAlpha = BLENDMODE_ONE;
		this.blendDstAlpha = BLENDMODE_ZERO;
		this.blendAlphaEquation = BLENDEQUATION_ADD;
		this.cull = CULLFACE_BACK;
		this.depthTest = true;
		this.depthWrite = true;
		this.stencilFront = null;
		this.stencilBack = null;
		this.depthBias = 0;
		this.slopeDepthBias = 0;
		this.redWrite = true;
		this.greenWrite = true;
		this.blueWrite = true;
		this.alphaWrite = true;
		this.meshInstances = [];
		this._shaderVersion = 0;
		this._scene = null;
		this._dirtyBlend = false;
		this.dirty = true;
	}
	Object.defineProperty(Material.prototype, 'shader', {
		get: function () {
			return this._shader;
		},
		set: function (shader) {
			this._shader = shader;
		}
	});
	Object.defineProperty(Material.prototype, 'blendType', {
		get: function () {
			if ((!this.blend) &&
				(this.blendSrc === BLENDMODE_ONE) &&
				(this.blendDst === BLENDMODE_ZERO) &&
				(this.blendEquation === BLENDEQUATION_ADD)) {
				return BLEND_NONE;
			} else if ((this.blend) &&
					   (this.blendSrc === BLENDMODE_SRC_ALPHA) &&
					   (this.blendDst === BLENDMODE_ONE_MINUS_SRC_ALPHA) &&
					   (this.blendEquation === BLENDEQUATION_ADD)) {
				return BLEND_NORMAL;
			} else if ((this.blend) &&
					   (this.blendSrc === BLENDMODE_ONE) &&
					   (this.blendDst === BLENDMODE_ONE) &&
					   (this.blendEquation === BLENDEQUATION_ADD)) {
				return BLEND_ADDITIVE;
			} else if ((this.blend) &&
					   (this.blendSrc === BLENDMODE_SRC_ALPHA) &&
					   (this.blendDst === BLENDMODE_ONE) &&
					   (this.blendEquation === BLENDEQUATION_ADD)) {
				return BLEND_ADDITIVEALPHA;
			} else if ((this.blend) &&
					   (this.blendSrc === BLENDMODE_DST_COLOR) &&
					   (this.blendDst === BLENDMODE_SRC_COLOR) &&
					   (this.blendEquation === BLENDEQUATION_ADD)) {
				return BLEND_MULTIPLICATIVE2X;
			} else if ((this.blend) &&
					   (this.blendSrc === BLENDMODE_ONE_MINUS_DST_COLOR) &&
					   (this.blendDst === BLENDMODE_ONE) &&
					   (this.blendEquation === BLENDEQUATION_ADD)) {
				return BLEND_SCREEN;
			} else if ((this.blend) &&
					   (this.blendSrc === BLENDMODE_ONE) &&
					   (this.blendDst === BLENDMODE_ONE) &&
					   (this.blendEquation === BLENDEQUATION_MIN)) {
				return BLEND_MIN;
			} else if ((this.blend) &&
					   (this.blendSrc === BLENDMODE_ONE) &&
					   (this.blendDst === BLENDMODE_ONE) &&
					   (this.blendEquation === BLENDEQUATION_MAX)) {
				return BLEND_MAX;
			} else if ((this.blend) &&
					   (this.blendSrc === BLENDMODE_DST_COLOR) &&
					   (this.blendDst === BLENDMODE_ZERO) &&
					   (this.blendEquation === BLENDEQUATION_ADD)) {
				return BLEND_MULTIPLICATIVE;
			} else if ((this.blend) &&
					   (this.blendSrc === BLENDMODE_ONE) &&
					   (this.blendDst === BLENDMODE_ONE_MINUS_SRC_ALPHA) &&
					   (this.blendEquation === BLENDEQUATION_ADD)) {
				return BLEND_PREMULTIPLIED;
			}
			return BLEND_NORMAL;
		},
		set: function (type) {
			var prevBlend = this.blend;
			switch (type) {
				case BLEND_NONE:
					this.blend = false;
					this.blendSrc = BLENDMODE_ONE;
					this.blendDst = BLENDMODE_ZERO;
					this.blendEquation = BLENDEQUATION_ADD;
					break;
				case BLEND_NORMAL:
					this.blend = true;
					this.blendSrc = BLENDMODE_SRC_ALPHA;
					this.blendDst = BLENDMODE_ONE_MINUS_SRC_ALPHA;
					this.blendEquation = BLENDEQUATION_ADD;
					break;
				case BLEND_PREMULTIPLIED:
					this.blend = true;
					this.blendSrc = BLENDMODE_ONE;
					this.blendDst = BLENDMODE_ONE_MINUS_SRC_ALPHA;
					this.blendEquation = BLENDEQUATION_ADD;
					break;
				case BLEND_ADDITIVE:
					this.blend = true;
					this.blendSrc = BLENDMODE_ONE;
					this.blendDst = BLENDMODE_ONE;
					this.blendEquation = BLENDEQUATION_ADD;
					break;
				case BLEND_ADDITIVEALPHA:
					this.blend = true;
					this.blendSrc = BLENDMODE_SRC_ALPHA;
					this.blendDst = BLENDMODE_ONE;
					this.blendEquation = BLENDEQUATION_ADD;
					break;
				case BLEND_MULTIPLICATIVE2X:
					this.blend = true;
					this.blendSrc = BLENDMODE_DST_COLOR;
					this.blendDst = BLENDMODE_SRC_COLOR;
					this.blendEquation = BLENDEQUATION_ADD;
					break;
				case BLEND_SCREEN:
					this.blend = true;
					this.blendSrc = BLENDMODE_ONE_MINUS_DST_COLOR;
					this.blendDst = BLENDMODE_ONE;
					this.blendEquation = BLENDEQUATION_ADD;
					break;
				case BLEND_MULTIPLICATIVE:
					this.blend = true;
					this.blendSrc = BLENDMODE_DST_COLOR;
					this.blendDst = BLENDMODE_ZERO;
					this.blendEquation = BLENDEQUATION_ADD;
					break;
				case BLEND_MIN:
					this.blend = true;
					this.blendSrc = BLENDMODE_ONE;
					this.blendDst = BLENDMODE_ONE;
					this.blendEquation = BLENDEQUATION_MIN;
					break;
				case BLEND_MAX:
					this.blend = true;
					this.blendSrc = BLENDMODE_ONE;
					this.blendDst = BLENDMODE_ONE;
					this.blendEquation = BLENDEQUATION_MAX;
					break;
			}
			if (prevBlend !== this.blend) {
				if (this._scene) {
					this._scene.layers._dirtyBlend = true;
				} else {
					this._dirtyBlend = true;
				}
			}
			this._updateMeshInstanceKeys();
		}
	});
	Material.prototype._cloneInternal = function (clone) {
		clone.name = this.name;
		clone.shader = this.shader;
		clone.alphaTest = this.alphaTest;
		clone.alphaToCoverage = this.alphaToCoverage;
		clone.blend = this.blend;
		clone.blendSrc = this.blendSrc;
		clone.blendDst = this.blendDst;
		clone.blendEquation = this.blendEquation;
		clone.separateAlphaBlend = this.separateAlphaBlend;
		clone.blendSrcAlpha = this.blendSrcAlpha;
		clone.blendDstAlpha = this.blendDstAlpha;
		clone.blendAlphaEquation = this.blendAlphaEquation;
		clone.cull = this.cull;
		clone.depthTest = this.depthTest;
		clone.depthWrite = this.depthWrite;
		clone.depthBias = this.depthBias;
		clone.slopeDepthBias = this.slopeDepthBias;
		if (this.stencilFront) clone.stencilFront = this.stencilFront.clone();
		if (this.stencilBack) {
			if (this.stencilFront === this.stencilBack) {
				clone.stencilBack = clone.stencilFront;
			} else {
				clone.stencilBack = this.stencilBack.clone();
			}
		}
		clone.redWrite = this.redWrite;
		clone.greenWrite = this.greenWrite;
		clone.blueWrite = this.blueWrite;
		clone.alphaWrite = this.alphaWrite;
	};
	Material.prototype.clone = function () {
		var clone = new Material();
		this._cloneInternal(clone);
		return clone;
	};
	Material.prototype._updateMeshInstanceKeys = function () {
		var i, meshInstances = this.meshInstances;
		for (i = 0; i < meshInstances.length; i++) {
			meshInstances[i].updateKey();
		}
	};
	Material.prototype.updateUniforms = function () {
	};
	Material.prototype.updateShader = function (device, scene, objDefs) {
	};
	Material.prototype.update = function () {
		this.dirty = true;
		if (this._shader) this._shader.failed = false;
	};
	Material.prototype.clearParameters = function () {
		this.parameters = {};
	};
	Material.prototype.getParameters = function () {
		return this.parameters;
	};
	Material.prototype.clearVariants = function () {
		var meshInstance;
		this.variants = {};
		var j;
		for (var i = 0; i < this.meshInstances.length; i++) {
			meshInstance = this.meshInstances[i];
			for (j = 0; j < meshInstance._shader.length; j++) {
				meshInstance._shader[j] = null;
			}
		}
	};
	Material.prototype.getParameter = function (name) {
		return this.parameters[name];
	};
	Material.prototype.setParameter = function (name, data, passFlags) {
		if (passFlags === undefined) passFlags = -524285;
		if (data === undefined && typeof name === 'object') {
			var uniformObject = name;
			if (uniformObject.length) {
				for (var i = 0; i < uniformObject.length; i++) {
					this.setParameter(uniformObject[i]);
				}
				return;
			}
			name = uniformObject.name;
			data = uniformObject.value;
		}
		var param = this.parameters[name];
		if (param) {
			param.data = data;
			param.passFlags = passFlags;
		} else {
			this.parameters[name] = {
				scopeId: null,
				data: data,
				passFlags: passFlags
			};
		}
	};
	Material.prototype.deleteParameter = function (name) {
		if (this.parameters[name]) {
			delete this.parameters[name];
		}
	};
	Material.prototype.setParameters = function () {
		for (var paramName in this.parameters) {
			var parameter = this.parameters[paramName];
			parameter.scopeId.setValue(parameter.data);
		}
	};
	Material.prototype.destroy = function () {
		this.variants = {};
		this.shader = null;
		var meshInstance, j;
		for (var i = 0; i < this.meshInstances.length; i++) {
			meshInstance = this.meshInstances[i];
			for (j = 0; j < meshInstance._shader.length; j++) {
				meshInstance._shader[j] = null;
			}
			meshInstance._material = null;
			var defaultMaterial = getDefaultMaterial();
			if (this !== defaultMaterial) {
				meshInstance.material = defaultMaterial;
			}
		}
	};

	function StandardMaterialOptionsBuilder() {
		this._mapXForms = null;
	}
	StandardMaterialOptionsBuilder.prototype.updateMinRef = function (options, device, scene, stdMat, objDefs, staticLightList, pass, sortedLights, prefilteredCubeMap128) {
		this._updateSharedOptions(options, stdMat, objDefs, pass);
		this._updateMinOptions(options, stdMat);
		this._updateUVOptions(options, stdMat, objDefs, true);
	};
	StandardMaterialOptionsBuilder.prototype.updateRef = function (options, device, scene, stdMat, objDefs, staticLightList, pass, sortedLights, prefilteredCubeMap128) {
		this._updateSharedOptions(options, stdMat, objDefs, pass);
		options.useTexCubeLod = device.useTexCubeLod;
		this._updateEnvOptions(options, stdMat, scene, prefilteredCubeMap128);
		this._updateMaterialOptions(options, stdMat);
		if (pass === SHADER_FORWARDHDR) {
			if (options.gamma) options.gamma = GAMMA_SRGBHDR;
			options.toneMap = TONEMAP_LINEAR;
		}
		options.hasTangents = objDefs && stdMat.normalMap && ((objDefs & SHADERDEF_TANGENTS) !== 0);
		this._updateLightOptions(options, stdMat, objDefs, sortedLights, staticLightList);
		this._updateUVOptions(options, stdMat, objDefs, false);
		options.clearCoat = stdMat.clearCoat;
		options.clearCoatGlossiness = stdMat.clearCoatGlossiness;
	};
	StandardMaterialOptionsBuilder.prototype._updateSharedOptions = function (options, stdMat, objDefs, pass) {
		options.pass = pass;
		options.alphaTest = stdMat.alphaTest > 0;
		options.forceFragmentPrecision = stdMat.forceFragmentPrecision || "";
		options.chunks = stdMat.chunks || "";
		options.blendType = stdMat.blendType;
		options.forceUv1 = stdMat.forceUv1;
		options.screenSpace = objDefs && (objDefs & SHADERDEF_SCREENSPACE) !== 0;
		options.skin = objDefs && (objDefs & SHADERDEF_SKIN) !== 0;
		options.useInstancing = objDefs && (objDefs & SHADERDEF_INSTANCING) !== 0;
		options.useMorphPosition = objDefs && (objDefs & SHADERDEF_MORPH_POSITION) !== 0;
		options.useMorphNormal = objDefs && (objDefs & SHADERDEF_MORPH_NORMAL) !== 0;
		options.useMorphTextureBased = objDefs && (objDefs & SHADERDEF_MORPH_TEXTURE_BASED) !== 0;
		options.nineSlicedMode = stdMat.nineSlicedMode || 0;
	};
	StandardMaterialOptionsBuilder.prototype._updateUVOptions = function (options, stdMat, objDefs, minimalOptions) {
		var hasUv0 = false;
		var hasUv1 = false;
		var hasVcolor = false;
		if (objDefs) {
			hasUv0 = (objDefs & SHADERDEF_UV0) !== 0;
			hasUv1 = (objDefs & SHADERDEF_UV1) !== 0;
			hasVcolor = (objDefs & SHADERDEF_VCOLOR) !== 0;
		}
		options.vertexColors = false;
		this._mapXForms = [];
		for (var p in _matTex2D) {
			this._updateTexOptions(options, stdMat, p, hasUv0, hasUv1, hasVcolor, minimalOptions);
		}
		this._mapXForms = null;
	};
	StandardMaterialOptionsBuilder.prototype._updateMinOptions = function (options, stdMat) {
		options.opacityTint = stdMat.opacity !== 1 && stdMat.blendType !== BLEND_NONE;
		options.lights = [];
	};
	StandardMaterialOptionsBuilder.prototype._updateMaterialOptions = function (options, stdMat) {
		var diffuseTint = ((stdMat.diffuse.r !== 1 || stdMat.diffuse.g !== 1 || stdMat.diffuse.b !== 1) &&
			(stdMat.diffuseTint || (!stdMat.diffuseMap && !stdMat.diffuseVertexColor))) ? 3 : 0;
		var specularTint = false;
		var useSpecular = (stdMat.useMetalness ? true : !!stdMat.specularMap) || (!!stdMat.sphereMap) || (!!stdMat.cubeMap) || (!!stdMat.dpAtlas);
		useSpecular = useSpecular || (stdMat.useMetalness ? true : !(stdMat.specular.r === 0 && stdMat.specular.g === 0 && stdMat.specular.b === 0));
		useSpecular = useSpecular || stdMat.enableGGXSpecular;
		useSpecular = useSpecular || (stdMat.clearCoat > 0);
		if (useSpecular) {
			if ((stdMat.specularTint || (!stdMat.specularMap && !stdMat.specularVertexColor)) && !stdMat.useMetalness) {
				specularTint = stdMat.specular.r !== 1 || stdMat.specular.g !== 1 || stdMat.specular.b !== 1;
			}
		}
		var emissiveTint = stdMat.emissiveMap ? 0 : 3;
		if (!emissiveTint) {
			emissiveTint = (stdMat.emissive.r !== 1 || stdMat.emissive.g !== 1 || stdMat.emissive.b !== 1 || stdMat.emissiveIntensity !== 1) && stdMat.emissiveTint;
			emissiveTint = emissiveTint ? 3 : (stdMat.emissiveIntensity !== 1 ? 1 : 0);
		}
		var isPackedNormalMap = stdMat.normalMap ? (stdMat.normalMap.format === PIXELFORMAT_DXT5 || stdMat.normalMap.type === TEXTURETYPE_SWIZZLEGGGR) : false;
		options.opacityTint = (stdMat.opacity !== 1 && stdMat.blendType !== BLEND_NONE) ? 1 : 0;
		options.blendMapsWithColors = true;
		options.ambientTint = stdMat.ambientTint;
		options.diffuseTint = diffuseTint;
		options.specularTint = specularTint ? 3 : 0;
		options.metalnessTint = (stdMat.useMetalness && stdMat.metalness < 1) ? 1 : 0;
		options.glossTint = 1;
		options.emissiveTint = emissiveTint;
		options.alphaToCoverage = stdMat.alphaToCoverage;
		options.normalizeNormalMap = stdMat.normalizeNormalMap;
		options.sphereMap = !!stdMat.sphereMap;
		options.cubeMap = !!stdMat.cubeMap;
		options.dpAtlas = !!stdMat.dpAtlas;
		options.ambientSH = !!stdMat.ambientSH;
		options.useSpecular = useSpecular;
		options.emissiveFormat = stdMat.emissiveMap ? (stdMat.emissiveMap.type === TEXTURETYPE_RGBM ? 1 : (stdMat.emissiveMap.format === PIXELFORMAT_RGBA32F ? 2 : 0)) : null;
		options.lightMapFormat = stdMat.lightMap ? (stdMat.lightMap.type === TEXTURETYPE_RGBM ? 1 : (stdMat.lightMap.format === PIXELFORMAT_RGBA32F ? 2 : 0)) : null;
		options.specularAntialias = stdMat.specularAntialias && (!!stdMat.normalMap) && (!!stdMat.normalMap.mipmaps) && !isPackedNormalMap;
		options.conserveEnergy = stdMat.conserveEnergy;
		options.occludeSpecular = stdMat.occludeSpecular;
		options.occludeSpecularFloat = (stdMat.occludeSpecularIntensity !== 1.0);
		options.occludeDirect = stdMat.occludeDirect;
		options.shadingModel = stdMat.shadingModel;
		options.fresnelModel = stdMat.fresnelModel;
		options.packedNormal = isPackedNormalMap;
		options.fastTbn = stdMat.fastTbn;
		options.cubeMapProjection = stdMat.cubeMapProjection;
		options.customFragmentShader = stdMat.customFragmentShader;
		options.refraction = !!stdMat.refraction;
		options.useMetalness = stdMat.useMetalness;
		options.enableGGXSpecular = stdMat.enableGGXSpecular;
		options.msdf = !!stdMat.msdfMap;
		options.twoSidedLighting = stdMat.twoSidedLighting;
		options.pixelSnap = stdMat.pixelSnap;
		options.aoMapUv = stdMat.aoUvSet;
		options.diffuseDetail = !!stdMat.diffuseMap;
		options.normalDetail = !!stdMat.normalMap;
		options.diffuseDetailMode = stdMat.diffuseDetailMode;
		options.detailModes = !!options.diffuseDetail;
	};
	StandardMaterialOptionsBuilder.prototype._updateEnvOptions = function (options, stdMat, scene, prefilteredCubeMap128) {
		var rgbmAmbient = (prefilteredCubeMap128 && prefilteredCubeMap128.type === TEXTURETYPE_RGBM) ||
			(stdMat.cubeMap && stdMat.cubeMap.type === TEXTURETYPE_RGBM) ||
			(stdMat.dpAtlas && stdMat.dpAtlas.type === TEXTURETYPE_RGBM);
		var hdrAmbient = (prefilteredCubeMap128 && (prefilteredCubeMap128.type === TEXTURETYPE_RGBM || prefilteredCubeMap128.format === PIXELFORMAT_RGBA32F)) ||
			(stdMat.cubeMap && (stdMat.cubeMap.type === TEXTURETYPE_RGBM || stdMat.cubeMap.format === PIXELFORMAT_RGBA32F)) ||
			(stdMat.dpAtlas && (stdMat.dpAtlas.type === TEXTURETYPE_RGBM || stdMat.dpAtlas.format === PIXELFORMAT_RGBA32F));
		var rgbmReflection = (prefilteredCubeMap128 && !stdMat.cubeMap && !stdMat.sphereMap && !stdMat.dpAtlas && prefilteredCubeMap128.type === TEXTURETYPE_RGBM) ||
			(stdMat.cubeMap && stdMat.cubeMap.type === TEXTURETYPE_RGBM) ||
			(stdMat.sphereMap && stdMat.sphereMap.type === TEXTURETYPE_RGBM) ||
			(stdMat.dpAtlas && stdMat.dpAtlas.type === TEXTURETYPE_RGBM);
		var hdrReflection = ((prefilteredCubeMap128 && !stdMat.cubeMap && !stdMat.sphereMap && !stdMat.dpAtlas) ? prefilteredCubeMap128.type === TEXTURETYPE_RGBM || prefilteredCubeMap128.format === PIXELFORMAT_RGBA32F : false) ||
			(stdMat.cubeMap && (stdMat.cubeMap.type === TEXTURETYPE_RGBM || stdMat.cubeMap.format === PIXELFORMAT_RGBA32F)) ||
			(stdMat.sphereMap && (stdMat.sphereMap.type === TEXTURETYPE_RGBM || stdMat.sphereMap.format === PIXELFORMAT_RGBA32F)) ||
			(stdMat.dpAtlas && (stdMat.dpAtlas.type === TEXTURETYPE_RGBM || stdMat.dpAtlas.format === PIXELFORMAT_RGBA32F));
		var globalSky128;
		if (stdMat.useSkybox && scene._skyboxPrefiltered)
			globalSky128 = scene._skyboxPrefiltered[0];
		options.fog = stdMat.useFog ? scene.fog : "none";
		options.gamma = stdMat.useGammaTonemap ? scene.gammaCorrection : GAMMA_NONE;
		options.toneMap = stdMat.useGammaTonemap ? scene.toneMapping : -1;
		options.rgbmAmbient = rgbmAmbient;
		options.hdrAmbient = hdrAmbient;
		options.rgbmReflection = rgbmReflection;
		options.hdrReflection = hdrReflection;
		options.useRgbm = rgbmReflection || rgbmAmbient || (stdMat.emissiveMap && stdMat.emissiveMap.type === TEXTURETYPE_RGBM) || (stdMat.lightMap && stdMat.lightMap.type === TEXTURETYPE_RGBM);
		options.fixSeams = prefilteredCubeMap128 ? prefilteredCubeMap128.fixCubemapSeams : (stdMat.cubeMap ? stdMat.cubeMap.fixCubemapSeams : false);
		options.prefilteredCubemap = !!prefilteredCubeMap128;
		options.skyboxIntensity = (prefilteredCubeMap128 && globalSky128 && prefilteredCubeMap128 === globalSky128) && (scene.skyboxIntensity !== 1);
	};
	StandardMaterialOptionsBuilder.prototype._updateLightOptions = function (options, stdMat, objDefs, sortedLights, staticLightList) {
		options.lightMap = false;
		options.lightMapChannel = "";
		options.lightMapUv = 0;
		options.lightMapTransform = 0;
		options.lightMapWithoutAmbient = false;
		options.dirLightMap = false;
		if (objDefs) {
			options.noShadow = (objDefs & SHADERDEF_NOSHADOW) !== 0;
			if ((objDefs & SHADERDEF_LM) !== 0) {
				options.lightMapFormat = 1;
				options.lightMap = true;
				options.lightMapChannel = "rgb";
				options.lightMapUv = 1;
				options.lightMapTransform = 0;
				options.lightMapWithoutAmbient = !stdMat.lightMap;
				options.useRgbm = true;
				if ((objDefs & SHADERDEF_DIRLM) !== 0) {
					options.dirLightMap = true;
				}
			}
		}
		if (stdMat.useLighting) {
			var lightsFiltered = [];
			var mask = objDefs ? (objDefs >> 16) : 1;
			if (sortedLights) {
				this._collectLights(LIGHTTYPE_DIRECTIONAL, sortedLights[LIGHTTYPE_DIRECTIONAL], lightsFiltered, mask);
				this._collectLights(LIGHTTYPE_POINT, sortedLights[LIGHTTYPE_POINT], lightsFiltered, mask, staticLightList);
				this._collectLights(LIGHTTYPE_SPOT, sortedLights[LIGHTTYPE_SPOT], lightsFiltered, mask, staticLightList);
			}
			options.lights = lightsFiltered;
		} else {
			options.lights = [];
		}
		if (options.lights.length === 0) {
			options.noShadow = true;
		}
	};
	StandardMaterialOptionsBuilder.prototype._updateTexOptions = function (options, stdMat, p, hasUv0, hasUv1, hasVcolor, minimalOptions) {
		var mname = p + "Map";
		var vname = p + "VertexColor";
		var vcname = p + "VertexColorChannel";
		var cname = mname + "Channel";
		var tname = mname + "Transform";
		var uname = mname + "Uv";
		if (p !== "light") {
			options[mname] = false;
			options[cname] = "";
			options[tname] = 0;
			options[uname] = 0;
		}
		options[vname] = false;
		options[vcname] = "";
		var isOpacity = p === "opacity";
		if (isOpacity && stdMat.blendType === BLEND_NONE && stdMat.alphaTest === 0.0 && !stdMat.alphaToCoverage)
			return options;
		if (!minimalOptions || isOpacity) {
			if (p !== "height" && stdMat[vname]) {
				if (hasVcolor) {
					options[vname] = stdMat[vname];
					options[vcname] = stdMat[vcname];
					options.vertexColors = true;
				}
			}
			if (stdMat[mname]) {
				var allow = true;
				if (stdMat[uname] === 0 && !hasUv0) allow = false;
				if (stdMat[uname] === 1 && !hasUv1) allow = false;
				if (allow) {
					options[mname] = !!stdMat[mname];
					options[tname] = this._getMapTransformID(stdMat[tname], stdMat[uname]);
					options[cname] = stdMat[cname];
					options[uname] = stdMat[uname];
				}
			}
		}
	};
	StandardMaterialOptionsBuilder.prototype._collectLights = function (lType, lights, lightsFiltered, mask, staticLightList) {
		var light;
		var i;
		for (i = 0; i < lights.length; i++) {
			light = lights[i];
			if (light.enabled) {
				if (light.mask & mask) {
					if (lType !== LIGHTTYPE_DIRECTIONAL) {
						if (light.isStatic) {
							continue;
						}
					}
					lightsFiltered.push(light);
				}
			}
		}
		if (staticLightList) {
			for (i = 0; i < staticLightList.length; i++) {
				light = staticLightList[i];
				if (light._type === lType) {
					lightsFiltered.push(light);
				}
			}
		}
	};
	StandardMaterialOptionsBuilder.prototype._getMapTransformID = function (xform, uv) {
		if (!xform) return 0;
		if (!this._mapXForms[uv]) this._mapXForms[uv] = [];
		var i, same;
		for (i = 0; i < this._mapXForms[uv].length; i++) {
			same = true;
			if (this._mapXForms[uv][i][0] != xform.x) {
				same = false;
				break;
			}
			if (this._mapXForms[uv][i][1] != xform.y) {
				same = false;
				break;
			}
			if (this._mapXForms[uv][i][2] != xform.z) {
				same = false;
				break;
			}
			if (this._mapXForms[uv][i][3] != xform.w) {
				same = false;
				break;
			}
			if (same) {
				return i + 1;
			}
		}
		var newID = this._mapXForms[uv].length;
		this._mapXForms[uv][newID] = [];
		this._mapXForms[uv][newID][0] = xform.x;
		this._mapXForms[uv][newID][1] = xform.y;
		this._mapXForms[uv][newID][2] = xform.z;
		this._mapXForms[uv][newID][3] = xform.w;
		return newID + 1;
	};

	function StandardMaterial() {
		Material.call(this);
		this._assetReferences = {};
		this._validator = null;
		this.shaderOptBuilder = new StandardMaterialOptionsBuilder();
		this.reset();
	}
	StandardMaterial.prototype = Object.create(Material.prototype);
	StandardMaterial.prototype.constructor = StandardMaterial;
	StandardMaterial.TEXTURE_PARAMETERS = standardMaterialTextureParameters;
	StandardMaterial.CUBEMAP_PARAMETERS = standardMaterialCubemapParameters;
	var _propsSerial = [];
	var _propsSerialDefaultVal = [];
	var _propsInternalNull = [];
	var _propsInternalVec3 = [];
	var _prop2Uniform = {};
	var _defineTex2D = function (obj, name, uv, channels, defChannel, vertexColor, detailMode) {
		var privMap = "_" + name + "Map";
		var privMapTiling = privMap + "Tiling";
		var privMapOffset = privMap + "Offset";
		var mapTransform = privMap.substring(1) + "Transform";
		var mapTransformUniform = mapTransform + "Uniform";
		var privMapUv = privMap + "Uv";
		var privMapChannel = privMap + "Channel";
		var privMapVertexColor = "_" + name + "VertexColor";
		var privMapVertexColorChannel = "_" + name + "VertexColorChannel";
		var privMapDetailMode = "_" + name + "Mode";
		obj[privMap] = null;
		obj[privMapTiling] = new Vec2(1, 1);
		obj[privMapOffset] = new Vec2(0, 0);
		obj[mapTransform] = null;
		obj[mapTransformUniform] = null;
		obj[privMapUv] = uv;
		if (channels > 0) {
			var channel = defChannel ? defChannel : (channels > 1 ? "rgb" : "g");
			obj[privMapChannel] = channel;
			if (vertexColor) obj[privMapVertexColorChannel] = channel;
		}
		if (vertexColor) obj[privMapVertexColor] = false;
		if (detailMode) obj[privMapDetailMode] = DETAILMODE_MUL;
		_matTex2D[name] = channels;
		Object.defineProperty(StandardMaterial.prototype, privMap.substring(1), {
			get: function () {
				return this[privMap];
			},
			set: function (value) {
				var oldVal = this[privMap];
				if (!!oldVal ^ !!value) this.dirtyShader = true;
				if (oldVal && value) {
					if (oldVal.type !== value.type || oldVal.fixCubemapSeams !== value.fixCubemapSeams || oldVal.format !== value.format) {
						this.dirtyShader = true;
					}
				}
				this[privMap] = value;
			}
		});
		var mapTiling = privMapTiling.substring(1);
		var mapOffset = privMapOffset.substring(1);
		Object.defineProperty(StandardMaterial.prototype, mapTiling, {
			get: function () {
				return this[privMapTiling];
			},
			set: function (value) {
				this.dirtyShader = true;
				this[privMapTiling] = value;
			}
		});
		_prop2Uniform[mapTiling] = function (mat, val, changeMat) {
			var tform = mat._updateMapTransform(
				changeMat ? mat[mapTransform] : null,
				val,
				mat[privMapOffset]
			);
			return { name: ("texture_" + mapTransform), value: tform.data };
		};
		Object.defineProperty(StandardMaterial.prototype, mapOffset, {
			get: function () {
				return this[privMapOffset];
			},
			set: function (value) {
				this.dirtyShader = true;
				this[privMapOffset] = value;
			}
		});
		_prop2Uniform[mapOffset] = function (mat, val, changeMat) {
			var tform = mat._updateMapTransform(
				changeMat ? mat[mapTransform] : null,
				mat[privMapTiling],
				val
			);
			return { name: ("texture_" + mapTransform), value: tform.data };
		};
		Object.defineProperty(StandardMaterial.prototype, privMapUv.substring(1), {
			get: function () {
				return this[privMapUv];
			},
			set: function (value) {
				if (this[privMapUv] !== value) this.dirtyShader = true;
				this[privMapUv] = value;
			}
		});
		Object.defineProperty(StandardMaterial.prototype, privMapChannel.substring(1), {
			get: function () {
				return this[privMapChannel];
			},
			set: function (value) {
				if (this[privMapChannel] !== value) this.dirtyShader = true;
				this[privMapChannel] = value;
			}
		});
		if (vertexColor) {
			Object.defineProperty(StandardMaterial.prototype, privMapVertexColor.substring(1), {
				get: function () {
					return this[privMapVertexColor];
				},
				set: function (value) {
					this.dirtyShader = true;
					this[privMapVertexColor] = value;
				}
			});
			Object.defineProperty(StandardMaterial.prototype, privMapVertexColorChannel.substring(1), {
				get: function () {
					return this[privMapVertexColorChannel];
				},
				set: function (value) {
					if (this[privMapVertexColorChannel] !== value) this.dirtyShader = true;
					this[privMapVertexColorChannel] = value;
				}
			});
		}
		if (detailMode) {
			Object.defineProperty(StandardMaterial.prototype, privMapDetailMode.substring(1), {
				get: function () {
					return this[privMapDetailMode];
				},
				set: function (value) {
					this.dirtyShader = true;
					this[privMapDetailMode] = value;
				}
			});
		}
		_propsSerial.push(privMap.substring(1));
		_propsSerial.push(privMapTiling.substring(1));
		_propsSerial.push(privMapOffset.substring(1));
		_propsSerial.push(privMapUv.substring(1));
		_propsSerial.push(privMapChannel.substring(1));
		if (vertexColor) {
			_propsSerial.push(privMapVertexColor.substring(1));
			_propsSerial.push(privMapVertexColorChannel.substring(1));
		}
		if (detailMode) {
			_propsSerial.push(privMapDetailMode.substring(1));
		}
		_propsInternalNull.push(mapTransform);
	};
	var _propsColor = [];
	var _defineColor = function (obj, name, defaultValue, hasMultiplier) {
		var priv = "_" + name;
		var uform = name + "Uniform";
		var mult = name + "Intensity";
		var pmult = "_" + mult;
		obj[priv] = defaultValue;
		obj[uform] = new Float32Array(3);
		Object.defineProperty(StandardMaterial.prototype, name, {
			get: function () {
				this.dirtyColor = true;
				this.dirtyShader = true;
				return this[priv];
			},
			set: function (newValue) {
				var oldValue = this[priv];
				var wasRound = (oldValue.r === 0 && oldValue.g === 0 && oldValue.b === 0) || (oldValue.r === 1 && oldValue.g === 1 && oldValue.b === 1);
				var isRound = (newValue.r === 0 && newValue.g === 0 && newValue.b === 0) || (newValue.r === 1 && newValue.g === 1 && newValue.b === 1);
				if (wasRound ^ isRound) this.dirtyShader = true;
				this.dirtyColor = true;
				this[priv] = newValue;
			}
		});
		_propsSerial.push(name);
		_propsInternalVec3.push(uform);
		_propsColor.push(name);
		_prop2Uniform[name] = function (mat, val, changeMat) {
			var arr = changeMat ? mat[uform] : new Float32Array(3);
			var gammaCorrection = false;
			if (mat.useGammaTonemap) {
				var scene = mat._scene || Application.getApplication().scene;
				gammaCorrection = scene.gammaCorrection;
			}
			for (var c = 0; c < 3; c++) {
				if (gammaCorrection) {
					arr[c] = Math.pow(val.data[c], 2.2);
				} else {
					arr[c] = val.data[c];
				}
				if (hasMultiplier) arr[c] *= mat[pmult];
			}
			return { name: ("material_" + name), value: arr };
		};
		if (hasMultiplier) {
			obj[pmult] = 1;
			Object.defineProperty(StandardMaterial.prototype, mult, {
				get: function () {
					return this[pmult];
				},
				set: function (newValue) {
					var oldValue = this[pmult];
					var wasRound = oldValue === 0 || oldValue === 1;
					var isRound = newValue === 0 || newValue === 1;
					if (wasRound ^ isRound) this.dirtyShader = true;
					this.dirtyColor = true;
					this[pmult] = newValue;
				}
			});
			_propsSerial.push(mult);
			_prop2Uniform[mult] = function (mat, val, changeMat) {
				var arr = changeMat ? mat[uform] : new Float32Array(3);
				var gammaCorrection = false;
				if (mat.useGammaTonemap) {
					var scene = mat._scene || Application.getApplication().scene;
					gammaCorrection = scene.gammaCorrection;
				}
				for (var c = 0; c < 3; c++) {
					if (gammaCorrection) {
						arr[c] = Math.pow(mat[priv].data[c], 2.2);
					} else {
						arr[c] = mat[priv].data[c];
					}
					arr[c] *= mat[pmult];
				}
				return { name: ("material_" + name), value: arr };
			};
		}
	};
	var _defineFloat = function (obj, name, defaultValue, func) {
		var priv = "_" + name;
		obj[priv] = defaultValue;
		Object.defineProperty(StandardMaterial.prototype, name, {
			get: function () {
				return this[priv];
			},
			set: function (newValue) {
				var oldValue = this[priv];
				if (oldValue === newValue) return;
				this[priv] = newValue;
				var wasRound = oldValue === 0 || oldValue === 1;
				var isRound = newValue === 0 || newValue === 1;
				if (wasRound || isRound) this.dirtyShader = true;
			}
		});
		_propsSerial.push(name);
		_prop2Uniform[name] = func !== undefined ? func : function (mat, val, changeMat) {
			return {
				name: "material_" + name,
				value: val
			};
		};
	};
	var _defineObject = function (obj, name, func) {
		var priv = "_" + name;
		obj[priv] = null;
		Object.defineProperty(StandardMaterial.prototype, name, {
			get: function () {
				return this[priv];
			},
			set: function (value) {
				var oldVal = this[priv];
				if (!!oldVal ^ !!value) this.dirtyShader = true;
				this[priv] = value;
			}
		});
		_propsSerial.push(name);
		_prop2Uniform[name] = func;
	};
	var _defineAlias = function (obj, newName, oldName) {
		Object.defineProperty(StandardMaterial.prototype, oldName, {
			get: function () {
				return this[newName];
			},
			set: function (value) {
				this[newName] = value;
			}
		});
	};
	var _defineChunks = function (obj) {
		Object.defineProperty(StandardMaterial.prototype, "chunks", {
			get: function () {
				this.dirtyShader = true;
				return this._chunks;
			},
			set: function (value) {
				this.dirtyShader = true;
				this._chunks = value;
			}
		});
		_propsSerial.push("chunks");
	};
	var _defineFlag = function (obj, name, defaultValue) {
		var priv = "_" + name;
		obj[priv] = defaultValue;
		Object.defineProperty(StandardMaterial.prototype, name, {
			get: function () {
				return this[priv];
			},
			set: function (value) {
				if (this[priv] !== value) this.dirtyShader = true;
				this[priv] = value;
			}
		});
		_propsSerial.push(name);
	};
	var Chunks = function () { };
	Chunks.prototype.copy = function (from) {
		for (var p in from) {
			if (from.hasOwnProperty(p) && p !== 'copy')
				this[p] = from[p];
		}
	};
	Object.assign(StandardMaterial.prototype, {
		reset: function () {
			var i;
			for (i = 0; i < _propsSerial.length; i++) {
				var defVal = _propsSerialDefaultVal[i];
				this[_propsSerial[i]] = defVal ? (defVal.clone ? defVal.clone() : defVal) : defVal;
			}
			for (i = 0; i < _propsInternalNull.length; i++) {
				this[_propsInternalNull[i]] = null;
			}
			for (i = 0; i < _propsInternalVec3.length; i++) {
				this[_propsInternalVec3[i]] = new Float32Array(3);
			}
			this._chunks = new Chunks();
			this.cubeMapMinUniform = new Float32Array(3);
			this.cubeMapMaxUniform = new Float32Array(3);
		},
		_cloneInternal: function (clone) {
			Material.prototype._cloneInternal.call(this, clone);
			var pname;
			for (var i = 0; i < _propsSerial.length; i++) {
				pname = _propsSerial[i];
				if (this[pname] !== undefined) {
					if (this[pname] && this[pname].copy) {
						if (clone[pname]) {
							clone[pname].copy(this[pname]);
						} else {
							clone[pname] = this[pname].clone();
						}
					} else {
						clone[pname] = this[pname];
					}
				}
			}
		},
		clone: function () {
			var clone = new StandardMaterial();
			this._cloneInternal(clone);
			return clone;
		},
		_updateMapTransform: function (transform, tiling, offset) {
			if (tiling.x === 1 && tiling.y === 1 && offset.x === 0 && offset.y === 0) {
				return null;
			}
			transform = transform || new Vec4();
			transform.set(tiling.x, tiling.y, offset.x, offset.y);
			return transform;
		},
		_setParameter: function (name, value) {
			if (!this.parameters[name])
				this._propsSet.push(name);
			this.setParameter(name, value);
		},
		_clearParameters: function () {
			var props = this._propsSet;
			for (var i = 0; i < props.length; i++) {
				delete this.parameters[props[i]];
			}
			this._propsSet = [];
		},
		_updateMap: function (p) {
			var mname = p + "Map";
			var map = this[mname];
			if (map) {
				this._setParameter("texture_" + mname, map);
				var tname = mname + "Transform";
				this[tname] = this._updateMapTransform(
					this[tname],
					this[mname + "Tiling"],
					this[mname + "Offset"]
				);
				var transform = this[tname];
				if (transform) {
					var uname = mname + "TransformUniform";
					var uniform = this[uname];
					if (!uniform) {
						uniform = new Float32Array(4);
						this[uname] = uniform;
					}
					uniform[0] = transform.x;
					uniform[1] = transform.y;
					uniform[2] = transform.z;
					uniform[3] = transform.w;
					this._setParameter('texture_' + tname, uniform);
				}
			}
		},
		getUniform: function (varName, value, changeMat) {
			var func = _prop2Uniform[varName];
			if (func) {
				return func(this, value, changeMat);
			}
			return null;
		},
		updateUniforms: function () {
			var uniform;
			this._clearParameters();
			this._setParameter('material_ambient', this.ambientUniform);
			if (!this.diffuseMap || this.diffuseTint) {
				this._setParameter('material_diffuse', this.diffuseUniform);
			}
			if (!this.useMetalness) {
				if (!this.specularMap || this.specularTint) {
					this._setParameter('material_specular', this.specularUniform);
				}
			} else {
				if (!this.metalnessMap || this.metalness < 1) {
					this._setParameter('material_metalness', this.metalness);
				}
				if (this.enableGGXSpecular){
					this._setParameter('material_anisotropy', this.anisotropy);
				}
			}
			if (this.clearCoat > 0) {
				this._setParameter('material_clearCoatSpecularity', this.clearCoat);
				this._setParameter('material_clearCoatGlossiness', this.clearCoatGlossiness);
				this._setParameter('material_clearCoatReflectivity', this.clearCoat);
			}
			uniform = this.getUniform("shininess", this.shininess, true);
			this._setParameter(uniform.name, uniform.value);
			if (!this.emissiveMap || this.emissiveTint) {
				this._setParameter('material_emissive', this.emissiveUniform);
			}
			if (this.emissiveMap) {
				this._setParameter('material_emissiveIntensity', this.emissiveIntensity);
			}
			if (this.refraction > 0) {
				this._setParameter('material_refraction', this.refraction);
				this._setParameter('material_refractionIndex', this.refractionIndex);
			}
			this._setParameter('material_opacity', this.opacity);
			if (this.occludeSpecular) {
				this._setParameter('material_occludeSpecularIntensity', this.occludeSpecularIntensity);
			}
			if (this.cubeMapProjection === CUBEPROJ_BOX) {
				this._setParameter(this.getUniform("cubeMapProjectionBox", this.cubeMapProjectionBox, true));
			}
			for (var p in _matTex2D) {
				this._updateMap(p);
			}
			if (this.ambientSH) {
				this._setParameter('ambientSH[0]', this.ambientSH);
			}
			if (this.normalMap) {
				this._setParameter('material_bumpiness', this.bumpiness);
			}
			if (this.normalMap && this.normalDetailMap) {
				this._setParameter('material_normalDetailMapBumpiness', this.normalDetailMapBumpiness);
			}
			if (this.heightMap) {
				uniform = this.getUniform('heightMapFactor', this.heightMapFactor, true);
				this._setParameter(uniform.name, uniform.value);
			}
			if (this.cubeMap) {
				this._setParameter('texture_cubeMap', this.cubeMap);
			}
			if (this.prefilteredCubeMap128) {
				this._setParameter('texture_prefilteredCubeMap128', this.prefilteredCubeMap128);
			} else if (this._scene && this._scene._skyboxPrefiltered[0]) {
				this._setParameter('texture_prefilteredCubeMap128', this._scene._skyboxPrefiltered[0]);
			}
			if (this.prefilteredCubeMap64) {
				this._setParameter('texture_prefilteredCubeMap64', this.prefilteredCubeMap64);
			} else if (this._scene && this._scene._skyboxPrefiltered[1]) {
				this._setParameter('texture_prefilteredCubeMap64', this._scene._skyboxPrefiltered[1]);
			}
			if (this.prefilteredCubeMap32) {
				this._setParameter('texture_prefilteredCubeMap32', this.prefilteredCubeMap32);
			} else if (this._scene && this._scene._skyboxPrefiltered[2]) {
				this._setParameter('texture_prefilteredCubeMap32', this._scene._skyboxPrefiltered[2]);
			}
			if (this.prefilteredCubeMap16) {
				this._setParameter('texture_prefilteredCubeMap16', this.prefilteredCubeMap16);
			} else if (this._scene && this._scene._skyboxPrefiltered[3]) {
				this._setParameter('texture_prefilteredCubeMap16', this._scene._skyboxPrefiltered[3]);
			}
			if (this.prefilteredCubeMap8) {
				this._setParameter('texture_prefilteredCubeMap8', this.prefilteredCubeMap8);
			} else if (this._scene && this._scene._skyboxPrefiltered[4]) {
				this._setParameter('texture_prefilteredCubeMap8', this._scene._skyboxPrefiltered[4]);
			}
			if (this.prefilteredCubeMap4) {
				this._setParameter('texture_prefilteredCubeMap4', this.prefilteredCubeMap4);
			} else if (this._scene && this._scene._skyboxPrefiltered[5]) {
				this._setParameter('texture_prefilteredCubeMap4', this._scene._skyboxPrefiltered[5]);
			}
			if (this.sphereMap) {
				this._setParameter('texture_sphereMap', this.sphereMap);
			}
			if (this.dpAtlas) {
				this._setParameter('texture_sphereMap', this.dpAtlas);
			}
			this._setParameter('material_reflectivity', this.reflectivity);
			if (this.dirtyShader || !this._scene) {
				this.shader = null;
				this.clearVariants();
			}
			this._processColor();
		},
		_processColor: function () {
			var c, i;
			if (!this.dirtyColor) return;
			if (!this._scene && this.useGammaTonemap) return;
			var gammaCorrection = false;
			if (this.useGammaTonemap) gammaCorrection = this._scene.gammaCorrection;
			for (i = 0; i < _propsColor.length; i++) {
				var clr = this["_" + _propsColor[i]];
				var arr = this[_propsColor[i] + "Uniform"];
				if (gammaCorrection) {
					arr[0] = Math.pow(clr.r, 2.2);
					arr[1] = Math.pow(clr.g, 2.2);
					arr[2] = Math.pow(clr.b, 2.2);
				} else {
					arr[0] = clr.r;
					arr[1] = clr.g;
					arr[2] = clr.b;
				}
			}
			for (c = 0; c < 3; c++) {
				this.emissiveUniform[c] *= this.emissiveIntensity;
			}
			this.dirtyColor = false;
		},
		_updateShaderGlobals: function (device, scene) {
			if (!this._colorProcessed && this._scene) {
				this._colorProcessed = true;
				this._processColor();
			}
			var useTexCubeLod = device.useTexCubeLod;
			var useDp = !device.extTextureLod;
			var globalSky128, globalSky64, globalSky32, globalSky16, globalSky8, globalSky4;
			if (this.useSkybox) {
				globalSky128 = scene._skyboxPrefiltered[0];
				globalSky64 = scene._skyboxPrefiltered[1];
				globalSky32 = scene._skyboxPrefiltered[2];
				globalSky16 = scene._skyboxPrefiltered[3];
				globalSky8 = scene._skyboxPrefiltered[4];
				globalSky4 = scene._skyboxPrefiltered[5];
			}
			var prefilteredCubeMap128 = this.prefilteredCubeMap128 || globalSky128;
			var prefilteredCubeMap64 = this.prefilteredCubeMap64 || globalSky64;
			var prefilteredCubeMap32 = this.prefilteredCubeMap32 || globalSky32;
			var prefilteredCubeMap16 = this.prefilteredCubeMap16 || globalSky16;
			var prefilteredCubeMap8 = this.prefilteredCubeMap8 || globalSky8;
			var prefilteredCubeMap4 = this.prefilteredCubeMap4 || globalSky4;
			if (prefilteredCubeMap128) {
				var allMips = prefilteredCubeMap128 &&
							 prefilteredCubeMap64 &&
							 prefilteredCubeMap32 &&
							 prefilteredCubeMap16 &&
							 prefilteredCubeMap8 &&
							 prefilteredCubeMap4;
				if (useDp && allMips) {
					if (!prefilteredCubeMap128.dpAtlas) {
						var atlas = [prefilteredCubeMap128, prefilteredCubeMap64, prefilteredCubeMap32,
							prefilteredCubeMap16, prefilteredCubeMap8, prefilteredCubeMap4];
						prefilteredCubeMap128.dpAtlas = generateDpAtlas(device, atlas);
						prefilteredCubeMap128.sh = shFromCubemap(prefilteredCubeMap16);
					}
					this.dpAtlas = prefilteredCubeMap128.dpAtlas;
					this.ambientSH = prefilteredCubeMap128.sh;
					this._setParameter('ambientSH[0]', this.ambientSH);
					this._setParameter('texture_sphereMap', this.dpAtlas);
				} else if (useTexCubeLod) {
					if (prefilteredCubeMap128._levels.length < 6) {
						if (allMips) {
							this._setParameter('texture_prefilteredCubeMap128', prefilteredCubeMap128);
						} else {
							console.log("Can't use prefiltered cubemap: " + allMips + ", " + useTexCubeLod + ", " + prefilteredCubeMap128._levels);
						}
					} else {
						this._setParameter('texture_prefilteredCubeMap128', prefilteredCubeMap128);
					}
				} else if (allMips) {
					this._setParameter('texture_prefilteredCubeMap128', prefilteredCubeMap128);
					this._setParameter('texture_prefilteredCubeMap64', prefilteredCubeMap64);
					this._setParameter('texture_prefilteredCubeMap32', prefilteredCubeMap32);
					this._setParameter('texture_prefilteredCubeMap16', prefilteredCubeMap16);
					this._setParameter('texture_prefilteredCubeMap8', prefilteredCubeMap8);
					this._setParameter('texture_prefilteredCubeMap4', prefilteredCubeMap4);
				} else {
					console.log("Can't use prefiltered cubemap: " + allMips + ", " + useTexCubeLod + ", " + prefilteredCubeMap128._levels);
				}
			}
			return prefilteredCubeMap128;
		},
		updateShader: function (device, scene, objDefs, staticLightList, pass, sortedLights) {
			var prefilteredCubeMap128 = this._updateShaderGlobals(device, scene);
			var minimalOptions = pass > SHADER_FORWARDHDR && pass <= SHADER_PICK;
			var options = minimalOptions ? standard.optionsContextMin : standard.optionsContext;
			if (minimalOptions)
				this.shaderOptBuilder.updateMinRef(options, device, scene, this, objDefs, staticLightList, pass, sortedLights, prefilteredCubeMap128);
			else
				this.shaderOptBuilder.updateRef(options, device, scene, this, objDefs, staticLightList, pass, sortedLights, prefilteredCubeMap128);
			if (this.onUpdateShader) {
				options = this.onUpdateShader(options);
			}
			var library = device.getProgramLibrary();
			this.shader = library.getProgram('standard', options);
			if (!objDefs) {
				this.clearVariants();
				this.variants[0] = this.shader;
			}
			this.dirtyShader = false;
		}
	});
	var _defineMaterialProps = function (obj) {
		obj.dirtyShader = true;
		obj.dirtyColor = true;
		obj._scene = null;
		obj._colorProcessed = false;
		_defineColor(obj, "ambient", new Color(0.7, 0.7, 0.7));
		_defineColor(obj, "diffuse", new Color(1, 1, 1));
		_defineColor(obj, "specular", new Color(0, 0, 0));
		_defineColor(obj, "emissive", new Color(0, 0, 0), true);
		_defineFloat(obj, "shininess", 25, function (mat, shininess) {
			var value;
			if (mat.shadingModel === SPECULAR_PHONG) {
				value = Math.pow(2, shininess * 0.01 * 11);
			} else {
				value = shininess * 0.01;
			}
			return { name: "material_shininess", value: value };
		});
		_defineFloat(obj, "heightMapFactor", 1, function (mat, height) {
			return { name: 'material_heightMapFactor', value: height * 0.025 };
		});
		_defineFloat(obj, "opacity", 1);
		_defineFloat(obj, "alphaTest", 0);
		_defineFloat(obj, "bumpiness", 1);
		_defineFloat(obj, "normalDetailMapBumpiness", 1);
		_defineFloat(obj, "reflectivity", 1);
		_defineFloat(obj, "occludeSpecularIntensity", 1);
		_defineFloat(obj, "refraction", 0);
		_defineFloat(obj, "refractionIndex", 1.0 / 1.5);
		_defineFloat(obj, "metalness", 1);
		_defineFloat(obj, "anisotropy", 0);
		_defineFloat(obj, "clearCoat", 0);
		_defineFloat(obj, "clearCoatGlossiness", 1);
		_defineFloat(obj, "aoUvSet", 0, null);
		_defineObject(obj, "ambientSH", function (mat, val, changeMat) {
			return { name: "ambientSH[0]", value: val };
		});
		_defineObject(obj, "cubeMapProjectionBox", function (mat, val, changeMat) {
			var bmin = changeMat ? mat.cubeMapMinUniform : new Float32Array(3);
			var bmax = changeMat ? mat.cubeMapMaxUniform : new Float32Array(3);
			bmin[0] = val.center.x - val.halfExtents.x;
			bmin[1] = val.center.y - val.halfExtents.y;
			bmin[2] = val.center.z - val.halfExtents.z;
			bmax[0] = val.center.x + val.halfExtents.x;
			bmax[1] = val.center.y + val.halfExtents.y;
			bmax[2] = val.center.z + val.halfExtents.z;
			return [{ name: "envBoxMin", value: bmin }, { name: "envBoxMax", value: bmax }];
		});
		_defineChunks();
		_defineFlag(obj, "ambientTint", false);
		_defineFlag(obj, "diffuseTint", false);
		_defineFlag(obj, "specularTint", false);
		_defineFlag(obj, "emissiveTint", false);
		_defineFlag(obj, "fastTbn", false);
		_defineFlag(obj, "specularAntialias", false);
		_defineFlag(obj, "useMetalness", false);
		_defineFlag(obj, "enableGGXSpecular", false);
		_defineFlag(obj, "occludeDirect", false);
		_defineFlag(obj, "normalizeNormalMap", true);
		_defineFlag(obj, "conserveEnergy", true);
		_defineFlag(obj, "occludeSpecular", SPECOCC_AO);
		_defineFlag(obj, "shadingModel", SPECULAR_BLINN);
		_defineFlag(obj, "fresnelModel", FRESNEL_NONE);
		_defineFlag(obj, "cubeMapProjection", CUBEPROJ_NONE);
		_defineFlag(obj, "customFragmentShader", null);
		_defineFlag(obj, "forceFragmentPrecision", null);
		_defineFlag(obj, "useFog", true);
		_defineFlag(obj, "useLighting", true);
		_defineFlag(obj, "useGammaTonemap", true);
		_defineFlag(obj, "useSkybox", true);
		_defineFlag(obj, "forceUv1", false);
		_defineFlag(obj, "pixelSnap", false);
		_defineFlag(obj, "twoSidedLighting", false);
		_defineFlag(obj, "nineSlicedMode", undefined);
		_defineTex2D(obj, "diffuse", 0, 3, "", true);
		_defineTex2D(obj, "specular", 0, 3, "", true);
		_defineTex2D(obj, "emissive", 0, 3, "", true);
		_defineTex2D(obj, "normal", 0, -1, "", false);
		_defineTex2D(obj, "metalness", 0, 1, "", true);
		_defineTex2D(obj, "gloss", 0, 1, "", true);
		_defineTex2D(obj, "opacity", 0, 1, "a", true);
		_defineTex2D(obj, "height", 0, 1, "", false);
		_defineTex2D(obj, "ao", 0, 1, "", true);
		_defineTex2D(obj, "light", 1, 3, "", true);
		_defineTex2D(obj, "msdf", 0, 3, "", false);
		_defineTex2D(obj, "diffuseDetail", 0, 3, "", false, true);
		_defineTex2D(obj, "normalDetail", 0, -1, "", false);
		_defineObject(obj, "cubeMap");
		_defineObject(obj, "sphereMap");
		_defineObject(obj, "dpAtlas");
		_defineObject(obj, "prefilteredCubeMap128");
		_defineObject(obj, "prefilteredCubeMap64");
		_defineObject(obj, "prefilteredCubeMap32");
		_defineObject(obj, "prefilteredCubeMap16");
		_defineObject(obj, "prefilteredCubeMap8");
		_defineObject(obj, "prefilteredCubeMap4");
		_defineAlias(obj, "diffuseTint", "diffuseMapTint");
		_defineAlias(obj, "specularTint", "specularMapTint");
		_defineAlias(obj, "emissiveTint", "emissiveMapTint");
		_defineAlias(obj, "aoVertexColor", "aoMapVertexColor");
		_defineAlias(obj, "diffuseVertexColor", "diffuseMapVertexColor");
		_defineAlias(obj, "specularVertexColor", "specularMapVertexColor");
		_defineAlias(obj, "emissiveVertexColor", "emissiveMapVertexColor");
		_defineAlias(obj, "metalnessVertexColor", "metalnessMapVertexColor");
		_defineAlias(obj, "glossVertexColor", "glossMapVertexColor");
		_defineAlias(obj, "opacityVertexColor", "opacityMapVertexColor");
		_defineAlias(obj, "lightVertexColor", "lightMapVertexColor");
		for (var i = 0; i < _propsSerial.length; i++) {
			_propsSerialDefaultVal[i] = obj[_propsSerial[i]];
		}
		obj._propsSet = [];
	};
	_defineMaterialProps(StandardMaterial.prototype);

	function ProgramLibrary(device) {
		this._device = device;
		this._cache = {};
		this._generators = {};
		this._isClearingCache = false;
		this._precached = false;
		this._programsCollection = [];
		this._defaultStdMatOption = {};
		this._defaultStdMatOptionMin = {};
		var m = new StandardMaterial();
		m.shaderOptBuilder.updateRef(
			this._defaultStdMatOption, device, {}, m, null, [], SHADER_FORWARD, null, null);
		m.shaderOptBuilder.updateMinRef(
			this._defaultStdMatOptionMin, device, {}, m, null, [], SHADER_SHADOW, null, null);
	}
	ProgramLibrary.prototype.register = function (name, generator) {
		if (!this.isRegistered(name)) {
			this._generators[name] = generator;
		}
	};
	ProgramLibrary.prototype.unregister = function (name) {
		if (this.isRegistered(name)) {
			delete this._generators[name];
		}
	};
	ProgramLibrary.prototype.isRegistered = function (name) {
		var generator = this._generators[name];
		return (generator !== undefined);
	};
	ProgramLibrary.prototype.getProgram = function (name, options) {
		var generator = this._generators[name];
		if (generator === undefined) {
			return null;
		}
		var gd = this._device;
		var key = generator.generateKey(options);
		var shader = this._cache[key];
		if (!shader) {
			var lights;
			if (options.lights) {
				lights = options.lights;
				options.lights = lights.map(function (l) {
					var lcopy = l.clone ? l.clone() : l;
					lcopy.key = l.key;
					return lcopy;
				});
			}
			this.storeNewProgram(name, options);
			if (options.lights)
				options.lights = lights;
			if (this._precached)
				console.warn("ProgramLibrary#getProgram: Cache miss for shader", name, "key", key, "after shaders precaching");
			var shaderDefinition = generator.createShaderDefinition(gd, options);
			shader = this._cache[key] = new Shader(gd, shaderDefinition);
		}
		return shader;
	};
	ProgramLibrary.prototype.storeNewProgram = function (name, options) {
		var opt = {};
		if (name === "standard") {
			var defaultMat = this._getDefaultStdMatOptions(options.pass);
			for (var p in options) {
				if ((options.hasOwnProperty(p) && defaultMat[p] !== options[p]) || p === "pass")
					opt[p] = options[p];
			}
		} else {
			opt = options;
		}
		this._programsCollection.push(JSON.stringify({ name: name, options: opt }));
	};
	ProgramLibrary.prototype.dumpPrograms = function () {
		var text = 'var device = pc.app ? pc.app.graphicsDevice : pc.Application.getApplication().graphicsDevice;\n';
		text += 'var shaders = [';
		if (this._programsCollection[0])
			text += '\n\t' + this._programsCollection[0];
		for (var i = 1; i < this._programsCollection.length; ++i) {
			text += ',\n\t' + this._programsCollection[i];
		}
		text += '\n];\n';
		text += 'device.programLib.precompile(shaders);\n';
		text += 'if (pc.version != \"' + version + '\" || pc.revision != \"' + revision + '\")\n';
		text += '\tconsole.warn(\"precompile-shaders.js: engine version mismatch, rebuild shaders lib with current engine\");';
		var element = document.createElement('a');
		element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
		element.setAttribute('download', 'precompile-shaders.js');
		element.style.display = 'none';
		document.body.appendChild(element);
		element.click();
		document.body.removeChild(element);
	};
	ProgramLibrary.prototype.clearCache = function () {
		var cache = this._cache;
		this._isClearingCache = true;
		for (var key in cache) {
			if (cache.hasOwnProperty(key)) {
				cache[key].destroy();
			}
		}
		this._cache = {};
		this._isClearingCache = false;
	};
	ProgramLibrary.prototype.removeFromCache = function (shader) {
		if (this._isClearingCache) return;
		var cache = this._cache;
		for (var key in cache) {
			if (cache.hasOwnProperty(key)) {
				if (cache[key] === shader) {
					delete cache[key];
					break;
				}
			}
		}
	};
	ProgramLibrary.prototype._getDefaultStdMatOptions = function (pass) {
		return (pass > SHADER_FORWARDHDR && pass <= SHADER_PICK) ?
			this._defaultStdMatOptionMin : this._defaultStdMatOption;
	};
	ProgramLibrary.prototype.precompile = function (cache) {
		if (cache) {
			var shaders = new Array(cache.length);
			for (var i = 0; i < cache.length; i++) {
				if (cache[i].name === "standard") {
					var opt = cache[i].options;
					var defaultMat = this._getDefaultStdMatOptions(opt.pass);
					for (var p in defaultMat) {
						if (defaultMat.hasOwnProperty(p) && opt[p] === undefined)
							opt[p] = defaultMat[p];
					}
					opt.useTexCubeLod = this._device.useTexCubeLod;
				}
				shaders[i] = this.getProgram(cache[i].name, cache[i].options);
			}
		}
		this._precached = true;
	};

	function Version() {
		this.globalId = 0;
		this.revision = 0;
	}
	Object.assign(Version.prototype, {
		equals: function (other) {
			return this.globalId === other.globalId &&
				   this.revision === other.revision;
		},
		notequals: function (other) {
			return this.globalId !== other.globalId ||
				   this.revision !== other.revision;
		},
		copy: function (other) {
			this.globalId = other.globalId;
			this.revision = other.revision;
		},
		reset: function () {
			this.globalId = 0;
			this.revision = 0;
		}
	});

	var idCounter = 0;
	function VersionedObject() {
		idCounter++;
		this.version = new Version();
		this.version.globalId = idCounter;
	}
	Object.assign(VersionedObject.prototype, {
		increment: function () {
			this.version.revision++;
		}
	});

	function ScopeId(name) {
		this.name = name;
		this.value = null;
		this.versionObject = new VersionedObject();
	}
	Object.assign(ScopeId.prototype, {
		setValue: function (value) {
			this.value = value;
			this.versionObject.increment();
		},
		getValue: function () {
			return this.value;
		}
	});

	function ScopeSpace(name) {
		this.name = name;
		this.variables = {};
		this.namespaces = {};
	}
	Object.assign(ScopeSpace.prototype, {
		resolve: function (name) {
			if (!this.variables.hasOwnProperty(name)) {
				this.variables[name] = new ScopeId(name);
			}
			return this.variables[name];
		},
		getSubSpace: function (name) {
			if (!this.namespaces.hasOwnProperty(name)) {
				this.namespaces[name] = new ScopeSpace(name);
			}
			return this.namespaces[name];
		}
	});

	function ShaderInput(graphicsDevice, name, type, locationId) {
		this.locationId = locationId;
		this.scopeId = graphicsDevice.scope.resolve(name);
		this.version = new Version();
		if (name.substr(name.length - 3) === "[0]") {
			switch (type) {
				case UNIFORMTYPE_FLOAT: type = UNIFORMTYPE_FLOATARRAY; break;
				case UNIFORMTYPE_VEC2: type = UNIFORMTYPE_VEC2ARRAY; break;
				case UNIFORMTYPE_VEC3: type = UNIFORMTYPE_VEC3ARRAY; break;
				case UNIFORMTYPE_VEC4: type = UNIFORMTYPE_VEC4ARRAY; break;
			}
		}
		this.dataType = type;
		this.value = [null, null, null, null];
		this.array = [];
	}

	var EVENT_RESIZE = 'resizecanvas';
	var _downsampleImage = function (image, size) {
		var srcW = image.width;
		var srcH = image.height;
		if ((srcW > size) || (srcH > size)) {
			var scale = size / Math.max(srcW, srcH);
			var dstW = Math.floor(srcW * scale);
			var dstH = Math.floor(srcH * scale);
			console.warn('Image dimensions larger than max supported texture size of ' + size + '. ' +
						 'Resizing from ' + srcW + ', ' + srcH + ' to ' + dstW + ', ' + dstH + '.');
			var canvas = document.createElement('canvas');
			canvas.width = dstW;
			canvas.height = dstH;
			var context = canvas.getContext('2d');
			context.drawImage(image, 0, 0, srcW, srcH, 0, 0, dstW, dstH);
			return canvas;
		}
		return image;
	};
	function testRenderable(gl, pixelFormat) {
		var result = true;
		var texture = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, texture);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 2, 2, 0, gl.RGBA, pixelFormat, null);
		var framebuffer = gl.createFramebuffer();
		gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
		gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
		if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE) {
			result = false;
		}
		gl.bindTexture(gl.TEXTURE_2D, null);
		gl.deleteTexture(texture);
		gl.bindFramebuffer(gl.FRAMEBUFFER, null);
		gl.deleteFramebuffer(framebuffer);
		return result;
	}
	function testTextureHalfFloatUpdatable(gl, pixelFormat) {
		var result = true;
		var texture = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, texture);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		var data = new Uint16Array(4 * 2 * 2);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 2, 2, 0, gl.RGBA, pixelFormat, data);
		if (gl.getError() !== gl.NO_ERROR) {
			result = false;
			console.log("Above error related to HALF_FLOAT_OES can be ignored, it was triggered by testing half float texture support");
		}
		gl.bindTexture(gl.TEXTURE_2D, null);
		gl.deleteTexture(texture);
		return result;
	}
	function testTextureFloatHighPrecision(device) {
		if (!device.textureFloatRenderable)
			return false;
		var test1 = createShaderFromCode(device, shaderChunks.fullscreenQuadVS, shaderChunks.precisionTestPS, "ptest1");
		var test2 = createShaderFromCode(device, shaderChunks.fullscreenQuadVS, shaderChunks.precisionTest2PS, "ptest2");
		var textureOptions = {
			format: PIXELFORMAT_RGBA32F,
			width: 1,
			height: 1,
			mipmaps: false,
			minFilter: FILTER_NEAREST,
			magFilter: FILTER_NEAREST
		};
		var tex1 = new Texture(device, textureOptions);
		tex1.name = 'testFHP';
		var targ1 = new RenderTarget(device, tex1, {
			depth: false
		});
		drawQuadWithShader(device, targ1, test1);
		textureOptions.format = PIXELFORMAT_R8_G8_B8_A8;
		var tex2 = new Texture(device, textureOptions);
		tex2.name = 'testFHP';
		var targ2 = new RenderTarget(device, tex2, {
			depth: false
		});
		device.constantTexSource.setValue(tex1);
		drawQuadWithShader(device, targ2, test2);
		var prevFramebuffer = device.activeFramebuffer;
		device.setFramebuffer(targ2._glFrameBuffer);
		var pixels = new Uint8Array(4);
		device.readPixels(0, 0, 1, 1, pixels);
		device.setFramebuffer(prevFramebuffer);
		var x = pixels[0] / 255;
		var y = pixels[1] / 255;
		var z = pixels[2] / 255;
		var w = pixels[3] / 255;
		var f = x / (256 * 256 * 256) + y / (256 * 256) + z / 256 + w;
		tex1.destroy();
		targ1.destroy();
		tex2.destroy();
		targ2.destroy();
		return f === 0;
	}
	var GraphicsDevice = function (canvas, options) {
		EventHandler.call(this);
		var i;
		this.canvas = canvas;
		this.shader = null;
		this.indexBuffer = null;
		this.vertexBuffers = [];
		this._enableAutoInstancing = false;
		this.autoInstancingMaxObjects = 16384;
		this.defaultFramebuffer = null;
		this.boundVao = null;
		this.transformFeedbackBuffer = null;
		this.activeFramebuffer = null;
		this.textureUnit = 0;
		this.textureUnits = [];
		this._maxPixelRatio = 1;
		this.renderTarget = null;
		this.feedback = null;
		this._tempEnableSafariTextureUnitWorkaround = !!window.safari;
		this._width = 0;
		this._height = 0;
		this.updateClientRect();
		this.vertexShaderCache = {};
		this.fragmentShaderCache = {};
		this.shaders = [];
		this.buffers = [];
		this.textures = [];
		this.targets = [];
		this._vaoMap = new Map();
		this.contextLost = false;
		this._contextLostHandler = function (event) {
			event.preventDefault();
			this.contextLost = true;
			this.fire('devicelost');
		}.bind(this);
		this._contextRestoredHandler = function () {
			this.initializeContext();
			this.contextLost = false;
			this.fire('devicerestored');
		}.bind(this);
		var preferWebGl2 = (options && options.preferWebGl2 !== undefined) ? options.preferWebGl2 : true;
		var names = preferWebGl2 ? ["webgl2", "experimental-webgl2", "webgl", "experimental-webgl"] :
			["webgl", "experimental-webgl"];
		var gl = null;
		options = options || {};
		options.stencil = true;
		for (i = 0; i < names.length; i++) {
			try {
				gl = canvas.getContext(names[i], options);
			} catch (e) { }
			if (gl) {
				this.webgl2 = preferWebGl2 && i < 2;
				break;
			}
		}
		if (!gl) {
			throw new Error("WebGL not supported");
		}
		this.gl = gl;
		window.setupVertexArrayObject(gl);
		canvas.addEventListener("webglcontextlost", this._contextLostHandler, false);
		canvas.addEventListener("webglcontextrestored", this._contextRestoredHandler, false);
		this.initializeExtensions();
		this.initializeCapabilities();
		this.initializeRenderState();
		for (i = 0; i < this.maxCombinedTextures; i++) {
			this.textureUnits.push([null, null, null]);
		}
		this.defaultClearOptions = {
			color: [0, 0, 0, 1],
			depth: 1,
			stencil: 0,
			flags: CLEARFLAG_COLOR | CLEARFLAG_DEPTH
		};
		this.glAddress = [
			gl.REPEAT,
			gl.CLAMP_TO_EDGE,
			gl.MIRRORED_REPEAT
		];
		this.glBlendEquation = [
			gl.FUNC_ADD,
			gl.FUNC_SUBTRACT,
			gl.FUNC_REVERSE_SUBTRACT,
			this.webgl2 ? gl.MIN : this.extBlendMinmax ? this.extBlendMinmax.MIN_EXT : gl.FUNC_ADD,
			this.webgl2 ? gl.MAX : this.extBlendMinmax ? this.extBlendMinmax.MAX_EXT : gl.FUNC_ADD
		];
		this.glBlendFunction = [
			gl.ZERO,
			gl.ONE,
			gl.SRC_COLOR,
			gl.ONE_MINUS_SRC_COLOR,
			gl.DST_COLOR,
			gl.ONE_MINUS_DST_COLOR,
			gl.SRC_ALPHA,
			gl.SRC_ALPHA_SATURATE,
			gl.ONE_MINUS_SRC_ALPHA,
			gl.DST_ALPHA,
			gl.ONE_MINUS_DST_ALPHA
		];
		this.glComparison = [
			gl.NEVER,
			gl.LESS,
			gl.EQUAL,
			gl.LEQUAL,
			gl.GREATER,
			gl.NOTEQUAL,
			gl.GEQUAL,
			gl.ALWAYS
		];
		this.glStencilOp = [
			gl.KEEP,
			gl.ZERO,
			gl.REPLACE,
			gl.INCR,
			gl.INCR_WRAP,
			gl.DECR,
			gl.DECR_WRAP,
			gl.INVERT
		];
		this.glClearFlag = [
			0,
			gl.COLOR_BUFFER_BIT,
			gl.DEPTH_BUFFER_BIT,
			gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT,
			gl.STENCIL_BUFFER_BIT,
			gl.STENCIL_BUFFER_BIT | gl.COLOR_BUFFER_BIT,
			gl.STENCIL_BUFFER_BIT | gl.DEPTH_BUFFER_BIT,
			gl.STENCIL_BUFFER_BIT | gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT
		];
		this.glCull = [
			0,
			gl.BACK,
			gl.FRONT,
			gl.FRONT_AND_BACK
		];
		this.glFilter = [
			gl.NEAREST,
			gl.LINEAR,
			gl.NEAREST_MIPMAP_NEAREST,
			gl.NEAREST_MIPMAP_LINEAR,
			gl.LINEAR_MIPMAP_NEAREST,
			gl.LINEAR_MIPMAP_LINEAR
		];
		this.glPrimitive = [
			gl.POINTS,
			gl.LINES,
			gl.LINE_LOOP,
			gl.LINE_STRIP,
			gl.TRIANGLES,
			gl.TRIANGLE_STRIP,
			gl.TRIANGLE_FAN
		];
		this.glType = [
			gl.BYTE,
			gl.UNSIGNED_BYTE,
			gl.SHORT,
			gl.UNSIGNED_SHORT,
			gl.INT,
			gl.UNSIGNED_INT,
			gl.FLOAT
		];
		this.pcUniformType = {};
		this.pcUniformType[gl.BOOL]		 = UNIFORMTYPE_BOOL;
		this.pcUniformType[gl.INT]		  = UNIFORMTYPE_INT;
		this.pcUniformType[gl.FLOAT]		= UNIFORMTYPE_FLOAT;
		this.pcUniformType[gl.FLOAT_VEC2]   = UNIFORMTYPE_VEC2;
		this.pcUniformType[gl.FLOAT_VEC3]   = UNIFORMTYPE_VEC3;
		this.pcUniformType[gl.FLOAT_VEC4]   = UNIFORMTYPE_VEC4;
		this.pcUniformType[gl.INT_VEC2]	 = UNIFORMTYPE_IVEC2;
		this.pcUniformType[gl.INT_VEC3]	 = UNIFORMTYPE_IVEC3;
		this.pcUniformType[gl.INT_VEC4]	 = UNIFORMTYPE_IVEC4;
		this.pcUniformType[gl.BOOL_VEC2]	= UNIFORMTYPE_BVEC2;
		this.pcUniformType[gl.BOOL_VEC3]	= UNIFORMTYPE_BVEC3;
		this.pcUniformType[gl.BOOL_VEC4]	= UNIFORMTYPE_BVEC4;
		this.pcUniformType[gl.FLOAT_MAT2]   = UNIFORMTYPE_MAT2;
		this.pcUniformType[gl.FLOAT_MAT3]   = UNIFORMTYPE_MAT3;
		this.pcUniformType[gl.FLOAT_MAT4]   = UNIFORMTYPE_MAT4;
		this.pcUniformType[gl.SAMPLER_2D]   = UNIFORMTYPE_TEXTURE2D;
		this.pcUniformType[gl.SAMPLER_CUBE] = UNIFORMTYPE_TEXTURECUBE;
		if (this.webgl2) {
			this.pcUniformType[gl.SAMPLER_2D_SHADOW]   = UNIFORMTYPE_TEXTURE2D_SHADOW;
			this.pcUniformType[gl.SAMPLER_CUBE_SHADOW] = UNIFORMTYPE_TEXTURECUBE_SHADOW;
			this.pcUniformType[gl.SAMPLER_3D]		  = UNIFORMTYPE_TEXTURE3D;
		}
		this.targetToSlot = {};
		this.targetToSlot[gl.TEXTURE_2D] = 0;
		this.targetToSlot[gl.TEXTURE_CUBE_MAP] = 1;
		this.targetToSlot[gl.TEXTURE_3D] = 2;
		var scopeX, scopeY, scopeZ, scopeW;
		var uniformValue;
		this.commitFunction = [];
		this.commitFunction[UNIFORMTYPE_BOOL] = function (uniform, value) {
			if (uniform.value !== value) {
				gl.uniform1i(uniform.locationId, value);
				uniform.value = value;
			}
		};
		this.commitFunction[UNIFORMTYPE_INT] = this.commitFunction[UNIFORMTYPE_BOOL];
		this.commitFunction[UNIFORMTYPE_FLOAT] = function (uniform, value) {
			if (uniform.value !== value) {
				gl.uniform1f(uniform.locationId, value);
				uniform.value = value;
			}
		};
		this.commitFunction[UNIFORMTYPE_VEC2]  = function (uniform, value) {
			uniformValue = uniform.value;
			scopeX = value[0];
			scopeY = value[1];
			if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY) {
				gl.uniform2fv(uniform.locationId, value);
				uniformValue[0] = scopeX;
				uniformValue[1] = scopeY;
			}
		};
		this.commitFunction[UNIFORMTYPE_VEC3]  = function (uniform, value) {
			uniformValue = uniform.value;
			scopeX = value[0];
			scopeY = value[1];
			scopeZ = value[2];
			if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ) {
				gl.uniform3fv(uniform.locationId, value);
				uniformValue[0] = scopeX;
				uniformValue[1] = scopeY;
				uniformValue[2] = scopeZ;
			}
		};
		this.commitFunction[UNIFORMTYPE_VEC4]  = function (uniform, value) {
			uniformValue = uniform.value;
			scopeX = value[0];
			scopeY = value[1];
			scopeZ = value[2];
			scopeW = value[3];
			if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ || uniformValue[3] !== scopeW) {
				gl.uniform4fv(uniform.locationId, value);
				uniformValue[0] = scopeX;
				uniformValue[1] = scopeY;
				uniformValue[2] = scopeZ;
				uniformValue[3] = scopeW;
			}
		};
		this.commitFunction[UNIFORMTYPE_IVEC2] = function (uniform, value) {
			uniformValue = uniform.value;
			scopeX = value[0];
			scopeY = value[1];
			if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY) {
				gl.uniform2iv(uniform.locationId, value);
				uniformValue[0] = scopeX;
				uniformValue[1] = scopeY;
			}
		};
		this.commitFunction[UNIFORMTYPE_BVEC2] = this.commitFunction[UNIFORMTYPE_IVEC2];
		this.commitFunction[UNIFORMTYPE_IVEC3] = function (uniform, value) {
			uniformValue = uniform.value;
			scopeX = value[0];
			scopeY = value[1];
			scopeZ = value[2];
			if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ) {
				gl.uniform3iv(uniform.locationId, value);
				uniformValue[0] = scopeX;
				uniformValue[1] = scopeY;
				uniformValue[2] = scopeZ;
			}
		};
		this.commitFunction[UNIFORMTYPE_BVEC3] = this.commitFunction[UNIFORMTYPE_IVEC3];
		this.commitFunction[UNIFORMTYPE_IVEC4] = function (uniform, value) {
			uniformValue = uniform.value;
			scopeX = value[0];
			scopeY = value[1];
			scopeZ = value[2];
			scopeW = value[3];
			if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ || uniformValue[3] !== scopeW) {
				gl.uniform4iv(uniform.locationId, value);
				uniformValue[0] = scopeX;
				uniformValue[1] = scopeY;
				uniformValue[2] = scopeZ;
				uniformValue[3] = scopeW;
			}
		};
		this.commitFunction[UNIFORMTYPE_BVEC4] = this.commitFunction[UNIFORMTYPE_IVEC4];
		this.commitFunction[UNIFORMTYPE_MAT2]  = function (uniform, value) {
			gl.uniformMatrix2fv(uniform.locationId, false, value);
		};
		this.commitFunction[UNIFORMTYPE_MAT3]  = function (uniform, value) {
			gl.uniformMatrix3fv(uniform.locationId, false, value);
		};
		this.commitFunction[UNIFORMTYPE_MAT4]  = function (uniform, value) {
			gl.uniformMatrix4fv(uniform.locationId, false, value);
		};
		this.commitFunction[UNIFORMTYPE_FLOATARRAY] = function (uniform, value) {
			gl.uniform1fv(uniform.locationId, value);
		};
		this.commitFunction[UNIFORMTYPE_VEC2ARRAY]  = function (uniform, value) {
			gl.uniform2fv(uniform.locationId, value);
		};
		this.commitFunction[UNIFORMTYPE_VEC3ARRAY]  = function (uniform, value) {
			gl.uniform3fv(uniform.locationId, value);
		};
		this.commitFunction[UNIFORMTYPE_VEC4ARRAY]  = function (uniform, value) {
			gl.uniform4fv(uniform.locationId, value);
		};
		this.scope = new ScopeSpace("Device");
		this.programLib = new ProgramLibrary(this);
		for (var generator in programlib)
			this.programLib.register(generator, programlib[generator]);
		this.supportsBoneTextures = this.extTextureFloat && this.maxVertexTextures > 0;
		this.useTexCubeLod = this.extTextureLod && this.maxTextures < 16;
		var numUniforms = this.vertexUniformsCount;
		numUniforms -= 4 * 4;
		numUniforms -= 8;
		numUniforms -= 1;
		numUniforms -= 4 * 4;
		this.boneLimit = Math.floor(numUniforms / 3);
		this.boneLimit = Math.min(this.boneLimit, 128);
		if (this.unmaskedRenderer === 'Mali-450 MP') {
			this.boneLimit = 34;
		}
		this._drawCallsPerFrame = 0;
		this._shaderSwitchesPerFrame = 0;
		this._primsPerFrame = [];
		for (i = PRIMITIVE_POINTS; i <= PRIMITIVE_TRIFAN; i++) {
			this._primsPerFrame[i] = 0;
		}
		this._renderTargetCreationTime = 0;
		this._vram = {
			tex: 0,
			vb: 0,
			ib: 0
		};
		this._shaderStats = {
			vsCompiled: 0,
			fsCompiled: 0,
			linked: 0,
			materialShaders: 0,
			compileTime: 0
		};
		this.constantTexSource = this.scope.resolve("source");
		if (this.extTextureFloat) {
			if (this.webgl2) {
				this.textureFloatRenderable = !!this.extColorBufferFloat;
			} else {
				this.textureFloatRenderable = testRenderable(gl, gl.FLOAT);
			}
		} else {
			this.textureFloatRenderable = false;
		}
		if (this.extTextureHalfFloat) {
			if (this.webgl2) {
				this.textureHalfFloatRenderable = !!this.extColorBufferFloat;
			} else {
				this.textureHalfFloatRenderable = testRenderable(gl, this.extTextureHalfFloat.HALF_FLOAT_OES);
			}
		} else {
			this.textureHalfFloatRenderable = false;
		}
		this.supportsMorphTargetTexturesCore = (this.maxPrecision === "highp" && this.maxVertexTextures >= 2);
		this._textureFloatHighPrecision = undefined;
		this._textureHalfFloatUpdatable = undefined;
		this.createGrabPass(options.alpha);
		VertexFormat.init(this);
	};
	GraphicsDevice.prototype = Object.create(EventHandler.prototype);
	GraphicsDevice.prototype.constructor = GraphicsDevice;
	Object.assign(GraphicsDevice.prototype, {
		getPrecision: function () {
			var gl = this.gl;
			var precision = "highp";
			if (gl.getShaderPrecisionFormat) {
				var vertexShaderPrecisionHighpFloat = gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT);
				var vertexShaderPrecisionMediumpFloat = gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT);
				var fragmentShaderPrecisionHighpFloat = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
				var fragmentShaderPrecisionMediumpFloat = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT );
				var highpAvailable = vertexShaderPrecisionHighpFloat.precision > 0 && fragmentShaderPrecisionHighpFloat.precision > 0;
				var mediumpAvailable = vertexShaderPrecisionMediumpFloat.precision > 0 && fragmentShaderPrecisionMediumpFloat.precision > 0;
				if (!highpAvailable) {
					if (mediumpAvailable) {
						precision = "mediump";
					} else {
						precision = "lowp";
					}
				}
			}
			return precision;
		},
		initializeExtensions: function () {
			var gl = this.gl;
			var ext;
			var supportedExtensions = gl.getSupportedExtensions();
			var getExtension = function () {
				for (var i = 0; i < arguments.length; i++) {
					if (supportedExtensions.indexOf(arguments[i]) !== -1) {
						return gl.getExtension(arguments[i]);
					}
				}
				return null;
			};
			if (this.webgl2) {
				this.extBlendMinmax = true;
				this.extDrawBuffers = true;
				this.extInstancing = true;
				this.extStandardDerivatives = true;
				this.extTextureFloat = true;
				this.extTextureHalfFloat = true;
				this.extTextureHalfFloatLinear = true;
				this.extTextureLod = true;
				this.extUintElement = true;
				this.extVertexArrayObject = true;
				this.extColorBufferFloat = getExtension('EXT_color_buffer_float');
				this.extDisjointTimerQuery = getExtension('EXT_disjoint_timer_query_webgl2', 'EXT_disjoint_timer_query');
			} else {
				this.extBlendMinmax = getExtension("EXT_blend_minmax");
				this.extDrawBuffers = getExtension('EXT_draw_buffers');
				this.extInstancing = getExtension("ANGLE_instanced_arrays");
				if (this.extInstancing) {
					ext = this.extInstancing;
					gl.drawArraysInstanced = ext.drawArraysInstancedANGLE.bind(ext);
					gl.drawElementsInstanced = ext.drawElementsInstancedANGLE.bind(ext);
					gl.vertexAttribDivisor = ext.vertexAttribDivisorANGLE.bind(ext);
				}
				this.extStandardDerivatives = getExtension("OES_standard_derivatives");
				this.extTextureFloat = getExtension("OES_texture_float");
				this.extTextureHalfFloat = getExtension("OES_texture_half_float");
				this.extTextureHalfFloatLinear = getExtension("OES_texture_half_float_linear");
				this.extTextureLod = getExtension('EXT_shader_texture_lod');
				this.extUintElement = getExtension("OES_element_index_uint");
				this.extVertexArrayObject = getExtension("OES_vertex_array_object");
				if (this.extVertexArrayObject) {
					ext = this.extVertexArrayObject;
					gl.createVertexArray = ext.createVertexArrayOES.bind(ext);
					gl.deleteVertexArray = ext.deleteVertexArrayOES.bind(ext);
					gl.isVertexArray = ext.isVertexArrayOES.bind(ext);
					gl.bindVertexArray = ext.bindVertexArrayOES.bind(ext);
				}
				this.extColorBufferFloat = null;
				this.extDisjointTimerQuery = null;
			}
			this.extDebugRendererInfo = getExtension('WEBGL_debug_renderer_info');
			this.extTextureFloatLinear = getExtension("OES_texture_float_linear");
			this.extFloatBlend = getExtension("EXT_float_blend");
			this.extTextureFilterAnisotropic = getExtension('EXT_texture_filter_anisotropic', 'WEBKIT_EXT_texture_filter_anisotropic');
			this.extCompressedTextureETC1 = getExtension('WEBGL_compressed_texture_etc1');
			this.extCompressedTextureETC = getExtension('WEBGL_compressed_texture_etc');
			this.extCompressedTexturePVRTC = getExtension('WEBGL_compressed_texture_pvrtc', 'WEBKIT_WEBGL_compressed_texture_pvrtc');
			this.extCompressedTextureS3TC = getExtension('WEBGL_compressed_texture_s3tc', 'WEBKIT_WEBGL_compressed_texture_s3tc');
			this.extCompressedTextureATC = getExtension('WEBGL_compressed_texture_atc');
			this.extCompressedTextureASTC = getExtension('WEBGL_compressed_texture_astc');
			this.extParallelShaderCompile = getExtension('KHR_parallel_shader_compile');
			this.supportsInstancing = !!this.extInstancing;
		},
		initializeCapabilities: function () {
			var gl = this.gl;
			var ext;
			this.maxPrecision = this.precision = this.getPrecision();
			var contextAttribs = gl.getContextAttributes();
			this.supportsMsaa = contextAttribs.antialias;
			this.supportsStencil = contextAttribs.stencil;
			this.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
			this.maxCubeMapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
			this.maxRenderBufferSize = gl.getParameter(gl.MAX_RENDERBUFFER_SIZE);
			this.maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
			this.maxCombinedTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
			this.maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
			this.vertexUniformsCount = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
			this.fragmentUniformsCount = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
			if (this.webgl2) {
				this.maxDrawBuffers = gl.getParameter(gl.MAX_DRAW_BUFFERS);
				this.maxColorAttachments = gl.getParameter(gl.MAX_COLOR_ATTACHMENTS);
				this.maxVolumeSize = gl.getParameter(gl.MAX_3D_TEXTURE_SIZE);
			} else {
				ext = this.extDrawBuffers;
				this.maxDrawBuffers = ext ? gl.getParameter(ext.MAX_DRAW_BUFFERS_EXT) : 1;
				this.maxColorAttachments = ext ? gl.getParameter(ext.MAX_COLOR_ATTACHMENTS_EXT) : 1;
				this.maxVolumeSize = 1;
			}
			ext = this.extDebugRendererInfo;
			this.unmaskedRenderer = ext ? gl.getParameter(ext.UNMASKED_RENDERER_WEBGL) : '';
			this.unmaskedVendor = ext ? gl.getParameter(ext.UNMASKED_VENDOR_WEBGL) : '';
			ext = this.extTextureFilterAnisotropic;
			this.maxAnisotropy = ext ? gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1;
			this.samples = gl.getParameter(gl.SAMPLES);
		},
		initializeRenderState: function () {
			var gl = this.gl;
			this.blending = false;
			gl.disable(gl.BLEND);
			this.blendSrc = BLENDMODE_ONE;
			this.blendDst = BLENDMODE_ZERO;
			this.blendSrcAlpha = BLENDMODE_ONE;
			this.blendDstAlpha = BLENDMODE_ZERO;
			this.separateAlphaBlend = false;
			this.blendEquation = BLENDEQUATION_ADD;
			this.blendAlphaEquation = BLENDEQUATION_ADD;
			this.separateAlphaEquation = false;
			gl.blendFunc(gl.ONE, gl.ZERO);
			gl.blendEquation(gl.FUNC_ADD);
			this.writeRed = true;
			this.writeGreen = true;
			this.writeBlue = true;
			this.writeAlpha = true;
			gl.colorMask(true, true, true, true);
			this.cullMode = CULLFACE_BACK;
			gl.enable(gl.CULL_FACE);
			gl.cullFace(gl.BACK);
			this.depthTest = true;
			gl.enable(gl.DEPTH_TEST);
			this.depthFunc = FUNC_LESSEQUAL;
			gl.depthFunc(gl.LEQUAL);
			this.depthWrite = true;
			gl.depthMask(true);
			this.stencil = false;
			gl.disable(gl.STENCIL_TEST);
			this.stencilFuncFront = this.stencilFuncBack = FUNC_ALWAYS;
			this.stencilRefFront = this.stencilRefBack = 0;
			this.stencilMaskFront = this.stencilMaskBack = 0xFF;
			gl.stencilFunc(gl.ALWAYS, 0, 0xFF);
			this.stencilFailFront = this.stencilFailBack = STENCILOP_KEEP;
			this.stencilZfailFront = this.stencilZfailBack = STENCILOP_KEEP;
			this.stencilZpassFront = this.stencilZpassBack = STENCILOP_KEEP;
			this.stencilWriteMaskFront = 0xFF;
			this.stencilWriteMaskBack = 0xFF;
			gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
			gl.stencilMask(0xFF);
			this.alphaToCoverage = false;
			this.raster = true;
			if (this.webgl2) {
				gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
				gl.disable(gl.RASTERIZER_DISCARD);
			}
			this.depthBiasEnabled = false;
			gl.disable(gl.POLYGON_OFFSET_FILL);
			this.clearDepth = 1;
			gl.clearDepth(1);
			this.clearRed = 0;
			this.clearBlue = 0;
			this.clearGreen = 0;
			this.clearAlpha = 0;
			gl.clearColor(0, 0, 0, 0);
			this.clearStencil = 0;
			gl.clearStencil(0);
			this.vx = this.vy = this.vw = this.vh = 0;
			this.sx = this.sy = this.sw = this.sh = 0;
			if (this.webgl2) {
				gl.hint(gl.FRAGMENT_SHADER_DERIVATIVE_HINT, gl.NICEST);
			} else {
				if (this.extStandardDerivatives) {
					gl.hint(this.extStandardDerivatives.FRAGMENT_SHADER_DERIVATIVE_HINT_OES, gl.NICEST);
				}
			}
			gl.enable(gl.SCISSOR_TEST);
			gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
			this.unpackFlipY = false;
			gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
			this.unpackPremultiplyAlpha = false;
			gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
		},
		initializeContext: function () {
			this.initializeExtensions();
			this.initializeCapabilities();
			this.initializeRenderState();
			var i, len;
			for (i = 0, len = this.shaders.length; i < len; i++) {
				this.compileAndLinkShader(this.shaders[i]);
			}
			this.shader = null;
			for (i = 0, len = this.buffers.length; i < len; i++) {
				this.buffers[i].bufferId = undefined;
				this.buffers[i].unlock();
			}
			this.boundVao = null;
			this.indexBuffer = null;
			this.vertexBuffers = [];
			for (i = 0, len = this.textures.length; i < len; i++) {
				var texture = this.textures[i];
				this.destroyTexture(texture);
				texture.dirtyAll();
			}
			this.textureUnit = 0;
			this.textureUnits.length = 0;
			for (i = 0; i < this.maxCombinedTextures; i++) {
				this.textureUnits.push([null, null, null]);
			}
			for (i = 0, len = this.targets.length; i < len; i++) {
				this.targets[i]._glFrameBuffer = undefined;
				this.targets[i]._glDepthBuffer = undefined;
				this.targets[i]._glResolveFrameBuffer = undefined;
				this.targets[i]._glMsaaColorBuffer = undefined;
				this.targets[i]._glMsaaDepthBuffer = undefined;
			}
			this.renderTarget = null;
			this.activeFramebuffer = null;
			this.feedback = null;
			this.transformFeedbackBuffer = null;
		},
		createGrabPass: function (alpha) {
			if (this.grabPassTexture) return;
			var format = alpha ? PIXELFORMAT_R8_G8_B8_A8 : PIXELFORMAT_R8_G8_B8;
			var grabPassTexture = new Texture(this, {
				format: format,
				minFilter: FILTER_LINEAR,
				magFilter: FILTER_LINEAR,
				addressU: ADDRESS_CLAMP_TO_EDGE,
				addressV: ADDRESS_CLAMP_TO_EDGE,
				mipmaps: false
			});
			grabPassTexture.name = 'texture_grabPass';
			var grabPassTextureId = this.scope.resolve(grabPassTexture.name);
			grabPassTextureId.setValue(grabPassTexture);
			var grabPassRenderTarget = new RenderTarget({
				colorBuffer: grabPassTexture,
				depth: false
			});
			this.grabPassRenderTarget = grabPassRenderTarget;
			this.grabPassTextureId = grabPassTextureId;
			this.grabPassTexture = grabPassTexture;
		},
		updateGrabPass: function () {
			var gl = this.gl;
			var renderTarget = this.renderTarget;
			var resolveRenderTarget = renderTarget && renderTarget._glResolveFrameBuffer;
			var grabPassTexture = this.grabPassTexture;
			var width = this.width;
			var height = this.height;
			if (this.webgl2 && width === grabPassTexture._width && height === grabPassTexture._height) {
				if (resolveRenderTarget) renderTarget.resolve(true);
				var currentFrameBuffer = renderTarget ? renderTarget._glFrameBuffer : null;
				var resolvedFrameBuffer = renderTarget ? renderTarget._glResolveFrameBuffer || renderTarget._glFrameBuffer : null;
				this.initRenderTarget(this.grabPassRenderTarget);
				var grabPassFrameBuffer = this.grabPassRenderTarget._glFrameBuffer;
				gl.bindFramebuffer(gl.READ_FRAMEBUFFER, resolvedFrameBuffer);
				gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, grabPassFrameBuffer);
				gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, gl.COLOR_BUFFER_BIT, gl.NEAREST);
				gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, currentFrameBuffer);
			} else {
				if (resolveRenderTarget) {
					renderTarget.resolve(true);
					gl.bindFramebuffer(gl.FRAMEBUFFER, renderTarget._glResolveFrameBuffer);
				}
				var format = grabPassTexture._glFormat;
				gl.copyTexImage2D(gl.TEXTURE_2D, 0, format, 0, 0, width, height, 0);
				grabPassTexture._width = width;
				grabPassTexture._height = height;
				if (resolveRenderTarget) {
					gl.bindFramebuffer(gl.FRAMEBUFFER, renderTarget._glFrameBuffer);
				}
			}
		},
		destroyGrabPass: function () {
			this.grabPassRenderTarget.destroy();
			this.grabPassRenderTarget = null;
			this.grabPassTextureId = null;
			this.grabPassTexture.destroy();
			this.grabPassTexture = null;
		},
		updateClientRect: function () {
			this.clientRect = this.canvas.getBoundingClientRect();
		},
		setViewport: function (x, y, w, h) {
			if ((this.vx !== x) || (this.vy !== y) || (this.vw !== w) || (this.vh !== h)) {
				this.gl.viewport(x, y, w, h);
				this.vx = x;
				this.vy = y;
				this.vw = w;
				this.vh = h;
			}
		},
		setScissor: function (x, y, w, h) {
			if ((this.sx !== x) || (this.sy !== y) || (this.sw !== w) || (this.sh !== h)) {
				this.gl.scissor(x, y, w, h);
				this.sx = x;
				this.sy = y;
				this.sw = w;
				this.sh = h;
			}
		},
		getProgramLibrary: function () {
			return this.programLib;
		},
		setProgramLibrary: function (programLib) {
			this.programLib = programLib;
		},
		setFramebuffer: function (fb) {
			if (this.activeFramebuffer !== fb) {
				this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, fb);
				this.activeFramebuffer = fb;
			}
		},
		_checkFbo: function () {
			var gl = this.gl;
			var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
			switch (status) {
				case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
					console.error("ERROR: FRAMEBUFFER_INCOMPLETE_ATTACHMENT");
					break;
				case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
					console.error("ERROR: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");
					break;
				case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
					console.error("ERROR: FRAMEBUFFER_INCOMPLETE_DIMENSIONS");
					break;
				case gl.FRAMEBUFFER_UNSUPPORTED:
					console.error("ERROR: FRAMEBUFFER_UNSUPPORTED");
					break;
				case gl.FRAMEBUFFER_COMPLETE:
					break;
			}
		},
		copyRenderTarget: function (source, dest, color, depth) {
			var gl = this.gl;
			if (!this.webgl2 && depth) {
				return false;
			}
			if (color) {
				if (!dest) {
					if (!source._colorBuffer) {
						return false;
					}
				} else {
					if (!source._colorBuffer || !dest._colorBuffer) {
						return false;
					}
					if (source._colorBuffer._format !== dest._colorBuffer._format) {
						return false;
					}
				}
			}
			if (depth) {
				if (!source._depthBuffer || !dest._depthBuffer) {
					return false;
				}
				if (source._depthBuffer._format !== dest._depthBuffer._format) {
					return false;
				}
			}
			if (this.webgl2 && dest) {
				var prevRt = this.renderTarget;
				this.renderTarget = dest;
				this.updateBegin();
				gl.bindFramebuffer(gl.READ_FRAMEBUFFER, source ? source._glFrameBuffer : null);
				gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, dest._glFrameBuffer);
				var w = source ? source.width : dest.width;
				var h = source ? source.height : dest.height;
				gl.blitFramebuffer( 0, 0, w, h,
									0, 0, w, h,
									(color ? gl.COLOR_BUFFER_BIT : 0) | (depth ? gl.DEPTH_BUFFER_BIT : 0),
									gl.NEAREST);
				this.renderTarget = prevRt;
				gl.bindFramebuffer(gl.FRAMEBUFFER, prevRt ? prevRt._glFrameBuffer : null);
			} else {
				var shader = this.getCopyShader();
				this.constantTexSource.setValue(source._colorBuffer);
				drawQuadWithShader(this, dest, shader);
			}
			return true;
		},
		initRenderTarget: function (target) {
			if (target._glFrameBuffer) return;
			target._device = this;
			var gl = this.gl;
			target._glFrameBuffer = gl.createFramebuffer();
			this.setFramebuffer(target._glFrameBuffer);
			var colorBuffer = target._colorBuffer;
			if (colorBuffer) {
				if (!colorBuffer._glTexture) {
					colorBuffer._width = Math.min(colorBuffer.width, this.maxRenderBufferSize);
					colorBuffer._height = Math.min(colorBuffer.height, this.maxRenderBufferSize);
					this.setTexture(colorBuffer, 0);
				}
				gl.framebufferTexture2D(
					gl.FRAMEBUFFER,
					gl.COLOR_ATTACHMENT0,
					colorBuffer._cubemap ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + target._face : gl.TEXTURE_2D,
					colorBuffer._glTexture,
					0
				);
			}
			var depthBuffer = target._depthBuffer;
			if (depthBuffer && this.webgl2) {
				if (!depthBuffer._glTexture) {
					depthBuffer._width = Math.min(depthBuffer.width, this.maxRenderBufferSize);
					depthBuffer._height = Math.min(depthBuffer.height, this.maxRenderBufferSize);
					this.setTexture(depthBuffer, 0);
				}
				if (target._stencil) {
					gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT,
											depthBuffer._cubemap ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + target._face : gl.TEXTURE_2D,
											target._depthBuffer._glTexture, 0);
				} else {
					gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT,
											depthBuffer._cubemap ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + target._face : gl.TEXTURE_2D,
											target._depthBuffer._glTexture, 0);
				}
			} else if (target._depth) {
				var willRenderMsaa = target._samples > 1 && this.webgl2;
				if (!willRenderMsaa) {
					if (!target._glDepthBuffer) {
						target._glDepthBuffer = gl.createRenderbuffer();
					}
					gl.bindRenderbuffer(gl.RENDERBUFFER, target._glDepthBuffer);
					if (target._stencil) {
						gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, target.width, target.height);
						gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, target._glDepthBuffer);
					} else {
						gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, target.width, target.height);
						gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, target._glDepthBuffer);
					}
					gl.bindRenderbuffer(gl.RENDERBUFFER, null);
				}
			}
			if (this.webgl2 && target._samples > 1) {
				target._glResolveFrameBuffer = target._glFrameBuffer;
				target._glFrameBuffer = gl.createFramebuffer();
				this.setFramebuffer(target._glFrameBuffer);
				if (colorBuffer) {
					if (!target._glMsaaColorBuffer) {
						target._glMsaaColorBuffer = gl.createRenderbuffer();
					}
					gl.bindRenderbuffer(gl.RENDERBUFFER, target._glMsaaColorBuffer);
					gl.renderbufferStorageMultisample(gl.RENDERBUFFER, target._samples, colorBuffer._glInternalFormat, target.width, target.height);
					gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, target._glMsaaColorBuffer);
				}
				if (target._depth) {
					if (!target._glMsaaDepthBuffer) {
						target._glMsaaDepthBuffer = gl.createRenderbuffer();
					}
					gl.bindRenderbuffer(gl.RENDERBUFFER, target._glMsaaDepthBuffer);
					if (target._stencil) {
						gl.renderbufferStorageMultisample(gl.RENDERBUFFER, target._samples, gl.DEPTH24_STENCIL8, target.width, target.height);
						gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, target._glMsaaDepthBuffer);
					} else {
						gl.renderbufferStorageMultisample(gl.RENDERBUFFER, target._samples, gl.DEPTH_COMPONENT32F, target.width, target.height);
						gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, target._glMsaaDepthBuffer);
					}
				}
			}
			this.targets.push(target);
		},
		getCopyShader: function () {
			if (!this._copyShader) {
				this._copyShader = createShaderFromCode(this,
														shaderChunks.fullscreenQuadVS,
														shaderChunks.outputTex2DPS,
														"outputTex2D");
			}
			return this._copyShader;
		},
		updateBegin: function () {
			this.boundVao = null;
			if (this._tempEnableSafariTextureUnitWorkaround) {
				for (var unit = 0; unit < this.textureUnits.length; ++unit) {
					for (var slot = 0; slot < 3; ++slot) {
						this.textureUnits[unit][slot] = null;
					}
				}
			}
			var target = this.renderTarget;
			if (target) {
				if (!target._glFrameBuffer) {
					this.initRenderTarget(target);
				} else {
					this.setFramebuffer(target._glFrameBuffer);
				}
			} else {
				this.setFramebuffer(this.defaultFramebuffer);
			}
		},
		updateEnd: function () {
			var gl = this.gl;
			this.boundVao = null;
			this.gl.bindVertexArray(null);
			var target = this.renderTarget;
			if (target) {
				var colorBuffer = target._colorBuffer;
				if (colorBuffer && colorBuffer._glTexture && colorBuffer.mipmaps && colorBuffer.pot) {
					this.activeTexture(this.maxCombinedTextures - 1);
					this.bindTexture(colorBuffer);
					gl.generateMipmap(colorBuffer._glTarget);
				}
				if (this.webgl2 && target._samples > 1 && target.autoResolve) {
					target.resolve();
				}
			}
		},
		initializeTexture: function (texture) {
			var gl = this.gl;
			var ext;
			texture._glTexture = gl.createTexture();
			texture._glTarget = texture._cubemap ? gl.TEXTURE_CUBE_MAP :
				(texture._volume ? gl.TEXTURE_3D : gl.TEXTURE_2D);
			switch (texture._format) {
				case PIXELFORMAT_A8:
					texture._glFormat = gl.ALPHA;
					texture._glInternalFormat = gl.ALPHA;
					texture._glPixelType = gl.UNSIGNED_BYTE;
					break;
				case PIXELFORMAT_L8:
					texture._glFormat = gl.LUMINANCE;
					texture._glInternalFormat = gl.LUMINANCE;
					texture._glPixelType = gl.UNSIGNED_BYTE;
					break;
				case PIXELFORMAT_L8_A8:
					texture._glFormat = gl.LUMINANCE_ALPHA;
					texture._glInternalFormat = gl.LUMINANCE_ALPHA;
					texture._glPixelType = gl.UNSIGNED_BYTE;
					break;
				case PIXELFORMAT_R5_G6_B5:
					texture._glFormat = gl.RGB;
					texture._glInternalFormat = gl.RGB;
					texture._glPixelType = gl.UNSIGNED_SHORT_5_6_5;
					break;
				case PIXELFORMAT_R5_G5_B5_A1:
					texture._glFormat = gl.RGBA;
					texture._glInternalFormat = gl.RGBA;
					texture._glPixelType = gl.UNSIGNED_SHORT_5_5_5_1;
					break;
				case PIXELFORMAT_R4_G4_B4_A4:
					texture._glFormat = gl.RGBA;
					texture._glInternalFormat = gl.RGBA;
					texture._glPixelType = gl.UNSIGNED_SHORT_4_4_4_4;
					break;
				case PIXELFORMAT_R8_G8_B8:
					texture._glFormat = gl.RGB;
					texture._glInternalFormat = this.webgl2 ? gl.RGB8 : gl.RGB;
					texture._glPixelType = gl.UNSIGNED_BYTE;
					break;
				case PIXELFORMAT_R8_G8_B8_A8:
					texture._glFormat = gl.RGBA;
					texture._glInternalFormat = this.webgl2 ? gl.RGBA8 : gl.RGBA;
					texture._glPixelType = gl.UNSIGNED_BYTE;
					break;
				case PIXELFORMAT_DXT1:
					ext = this.extCompressedTextureS3TC;
					texture._glFormat = gl.RGB;
					texture._glInternalFormat = ext.COMPRESSED_RGB_S3TC_DXT1_EXT;
					break;
				case PIXELFORMAT_DXT3:
					ext = this.extCompressedTextureS3TC;
					texture._glFormat = gl.RGBA;
					texture._glInternalFormat = ext.COMPRESSED_RGBA_S3TC_DXT3_EXT;
					break;
				case PIXELFORMAT_DXT5:
					ext = this.extCompressedTextureS3TC;
					texture._glFormat = gl.RGBA;
					texture._glInternalFormat = ext.COMPRESSED_RGBA_S3TC_DXT5_EXT;
					break;
				case PIXELFORMAT_ETC1:
					ext = this.extCompressedTextureETC1;
					texture._glFormat = gl.RGB;
					texture._glInternalFormat = ext.COMPRESSED_RGB_ETC1_WEBGL;
					break;
				case PIXELFORMAT_PVRTC_2BPP_RGB_1:
					ext = this.extCompressedTexturePVRTC;
					texture._glFormat = gl.RGB;
					texture._glInternalFormat = ext.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
					break;
				case PIXELFORMAT_PVRTC_2BPP_RGBA_1:
					ext = this.extCompressedTexturePVRTC;
					texture._glFormat = gl.RGBA;
					texture._glInternalFormat = ext.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
					break;
				case PIXELFORMAT_PVRTC_4BPP_RGB_1:
					ext = this.extCompressedTexturePVRTC;
					texture._glFormat = gl.RGB;
					texture._glInternalFormat = ext.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
					break;
				case PIXELFORMAT_PVRTC_4BPP_RGBA_1:
					ext = this.extCompressedTexturePVRTC;
					texture._glFormat = gl.RGBA;
					texture._glInternalFormat = ext.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
					break;
				case PIXELFORMAT_ETC2_RGB:
					ext = this.extCompressedTextureETC;
					texture._glFormat = gl.RGB;
					texture._glInternalFormat = ext.COMPRESSED_RGB8_ETC2;
					break;
				case PIXELFORMAT_ETC2_RGBA:
					ext = this.extCompressedTextureETC;
					texture._glFormat = gl.RGBA;
					texture._glInternalFormat = ext.COMPRESSED_RGBA8_ETC2_EAC;
					break;
				case PIXELFORMAT_ASTC_4x4:
					ext = this.extCompressedTextureASTC;
					texture._glFormat = gl.RGBA;
					texture._glInternalFormat = ext.COMPRESSED_RGBA_ASTC_4x4_KHR;
					break;
				case PIXELFORMAT_ATC_RGB:
					ext = this.extCompressedTextureATC;
					texture._glFormat = gl.RGB;
					texture._glInternalFormat = ext.COMPRESSED_RGB_ATC_WEBGL;
					break;
				case PIXELFORMAT_ATC_RGBA:
					ext = this.extCompressedTextureATC;
					texture._glFormat = gl.RGBA;
					texture._glInternalFormat = ext.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL;
					break;
				case PIXELFORMAT_RGB16F:
					ext = this.extTextureHalfFloat;
					texture._glFormat = gl.RGB;
					if (this.webgl2) {
						texture._glInternalFormat = gl.RGB16F;
						texture._glPixelType = gl.HALF_FLOAT;
					} else {
						texture._glInternalFormat = gl.RGB;
						texture._glPixelType = ext.HALF_FLOAT_OES;
					}
					break;
				case PIXELFORMAT_RGBA16F:
					ext = this.extTextureHalfFloat;
					texture._glFormat = gl.RGBA;
					if (this.webgl2) {
						texture._glInternalFormat = gl.RGBA16F;
						texture._glPixelType = gl.HALF_FLOAT;
					} else {
						texture._glInternalFormat = gl.RGBA;
						texture._glPixelType = ext.HALF_FLOAT_OES;
					}
					break;
				case PIXELFORMAT_RGB32F:
					texture._glFormat = gl.RGB;
					if (this.webgl2) {
						texture._glInternalFormat = gl.RGB32F;
					} else {
						texture._glInternalFormat = gl.RGB;
					}
					texture._glPixelType = gl.FLOAT;
					break;
				case PIXELFORMAT_RGBA32F:
					texture._glFormat = gl.RGBA;
					if (this.webgl2) {
						texture._glInternalFormat = gl.RGBA32F;
					} else {
						texture._glInternalFormat = gl.RGBA;
					}
					texture._glPixelType = gl.FLOAT;
					break;
				case PIXELFORMAT_R32F:
					texture._glFormat = gl.RED;
					texture._glInternalFormat = gl.R32F;
					texture._glPixelType = gl.FLOAT;
					break;
				case PIXELFORMAT_DEPTH:
					if (this.webgl2) {
						texture._glFormat = gl.DEPTH_COMPONENT;
						texture._glInternalFormat = gl.DEPTH_COMPONENT32F;
						texture._glPixelType = gl.FLOAT;
					} else {
						texture._glFormat = gl.DEPTH_COMPONENT;
						texture._glInternalFormat = gl.DEPTH_COMPONENT;
						texture._glPixelType = gl.UNSIGNED_SHORT;
					}
					break;
				case PIXELFORMAT_DEPTHSTENCIL:
					texture._glFormat = gl.DEPTH_STENCIL;
					texture._glInternalFormat = gl.DEPTH24_STENCIL8;
					texture._glPixelType = gl.UNSIGNED_INT_24_8;
					break;
				case PIXELFORMAT_111110F:
					texture._glFormat = gl.RGB;
					texture._glInternalFormat = gl.R11F_G11F_B10F;
					texture._glPixelType = gl.FLOAT;
					break;
				case PIXELFORMAT_SRGB:
					texture._glFormat = gl.RGB;
					texture._glInternalFormat = gl.SRGB8;
					texture._glPixelType = gl.UNSIGNED_BYTE;
					break;
				case PIXELFORMAT_SRGBA:
					texture._glFormat = gl.RGBA;
					texture._glInternalFormat = gl.SRGB8_ALPHA8;
					texture._glPixelType = gl.UNSIGNED_BYTE;
					break;
			}
			this.textures.push(texture);
		},
		destroyTexture: function (texture) {
			if (texture._glTexture) {
				var idx = this.textures.indexOf(texture);
				if (idx !== -1) {
					this.textures.splice(idx, 1);
				}
				for (var uniformName in this.scope.variables) {
					var uniform = this.scope.variables[uniformName];
					if (uniform.value === texture) {
						uniform.value = null;
					}
				}
				for (var i = 0; i < this.textureUnits.length; i++) {
					var textureUnit = this.textureUnits[i];
					for (var j = 0; j < textureUnit.length; j++) {
						if (textureUnit[j] === texture._glTexture) {
							textureUnit[j] = null;
						}
					}
				}
				var gl = this.gl;
				gl.deleteTexture(texture._glTexture);
				delete texture._glTexture;
				delete texture._glTarget;
				delete texture._glFormat;
				delete texture._glInternalFormat;
				delete texture._glPixelType;
				this._vram.tex -= texture._gpuSize;
			}
		},
		setUnpackFlipY: function (flipY) {
			if (this.unpackFlipY !== flipY) {
				this.unpackFlipY = flipY;
				var gl = this.gl;
				gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
			}
		},
		setUnpackPremultiplyAlpha: function (premultiplyAlpha) {
			if (this.unpackPremultiplyAlpha !== premultiplyAlpha) {
				this.unpackPremultiplyAlpha = premultiplyAlpha;
				var gl = this.gl;
				gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultiplyAlpha);
			}
		},
		_isBrowserInterface: function (texture) {
			return (typeof HTMLCanvasElement !== 'undefined' && texture instanceof HTMLCanvasElement) ||
				   (typeof HTMLImageElement !== 'undefined' && texture instanceof HTMLImageElement) ||
				   (typeof HTMLVideoElement !== 'undefined' && texture instanceof HTMLVideoElement) ||
				   (typeof ImageBitmap !== 'undefined' && texture instanceof ImageBitmap);
		},
		uploadTexture: function (texture) {
			var gl = this.gl;
			if (!texture._needsUpload && ((texture._needsMipmapsUpload && texture._mipmapsUploaded) || !texture.pot))
				return;
			var mipLevel = 0;
			var mipObject;
			var resMult;
			var requiredMipLevels = Math.log2(Math.max(texture._width, texture._height)) + 1;
			while (texture._levels[mipLevel] || mipLevel === 0) {
				if (!texture._needsUpload && mipLevel === 0) {
					mipLevel++;
					continue;
				} else if (mipLevel && (!texture._needsMipmapsUpload || !texture._mipmaps)) {
					break;
				}
				mipObject = texture._levels[mipLevel];
				if (mipLevel == 1 && !texture._compressed && texture._levels.length < requiredMipLevels) {
					gl.generateMipmap(texture._glTarget);
					texture._mipmapsUploaded = true;
				}
				if (texture._cubemap) {
					var face;
					if (this._isBrowserInterface(mipObject[0])) {
						for (face = 0; face < 6; face++) {
							if (!texture._levelsUpdated[0][face])
								continue;
							var src = mipObject[face];
							if (src instanceof HTMLImageElement) {
								if (src.width > this.maxCubeMapSize || src.height > this.maxCubeMapSize) {
									src = _downsampleImage(src, this.maxCubeMapSize);
									if (mipLevel === 0) {
										texture._width = src.width;
										texture._height = src.height;
									}
								}
							}
							this.setUnpackFlipY(false);
							this.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);
							gl.texImage2D(
								gl.TEXTURE_CUBE_MAP_POSITIVE_X + face,
								mipLevel,
								texture._glInternalFormat,
								texture._glFormat,
								texture._glPixelType,
								src
							);
						}
					} else {
						resMult = 1 / Math.pow(2, mipLevel);
						for (face = 0; face < 6; face++) {
							if (!texture._levelsUpdated[0][face])
								continue;
							var texData = mipObject[face];
							if (texture._compressed) {
								gl.compressedTexImage2D(
									gl.TEXTURE_CUBE_MAP_POSITIVE_X + face,
									mipLevel,
									texture._glInternalFormat,
									Math.max(texture._width * resMult, 1),
									Math.max(texture._height * resMult, 1),
									0,
									texData
								);
							} else {
								this.setUnpackFlipY(false);
								this.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);
								gl.texImage2D(
									gl.TEXTURE_CUBE_MAP_POSITIVE_X + face,
									mipLevel,
									texture._glInternalFormat,
									Math.max(texture._width * resMult, 1),
									Math.max(texture._height * resMult, 1),
									0,
									texture._glFormat,
									texture._glPixelType,
									texData
								);
							}
						}
					}
				} else if (texture._volume) {
					resMult = 1 / Math.pow(2, mipLevel);
					if (texture._compressed) {
						gl.compressedTexImage3D(gl.TEXTURE_3D,
												mipLevel,
												texture._glInternalFormat,
												Math.max(texture._width * resMult, 1),
												Math.max(texture._height * resMult, 1),
												Math.max(texture._depth * resMult, 1),
												0,
												mipObject);
					} else {
						this.setUnpackFlipY(false);
						this.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);
						gl.texImage3D(gl.TEXTURE_3D,
									  mipLevel,
									  texture._glInternalFormat,
									  Math.max(texture._width * resMult, 1),
									  Math.max(texture._height * resMult, 1),
									  Math.max(texture._depth * resMult, 1),
									  0,
									  texture._glFormat,
									  texture._glPixelType,
									  mipObject);
					}
				} else {
					if (this._isBrowserInterface(mipObject)) {
						if (mipObject instanceof HTMLImageElement) {
							if (mipObject.width > this.maxTextureSize || mipObject.height > this.maxTextureSize) {
								mipObject = _downsampleImage(mipObject, this.maxTextureSize);
								if (mipLevel === 0) {
									texture._width = mipObject.width;
									texture._height = mipObject.height;
								}
							}
						}
						this.setUnpackFlipY(texture._flipY);
						this.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);
						gl.texImage2D(
							gl.TEXTURE_2D,
							mipLevel,
							texture._glInternalFormat,
							texture._glFormat,
							texture._glPixelType,
							mipObject
						);
					} else {
						resMult = 1 / Math.pow(2, mipLevel);
						if (texture._compressed) {
							gl.compressedTexImage2D(
								gl.TEXTURE_2D,
								mipLevel,
								texture._glInternalFormat,
								Math.max(texture._width * resMult, 1),
								Math.max(texture._height * resMult, 1),
								0,
								mipObject
							);
						} else {
							this.setUnpackFlipY(false);
							this.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);
							gl.texImage2D(
								gl.TEXTURE_2D,
								mipLevel,
								texture._glInternalFormat,
								Math.max(texture._width * resMult, 1),
								Math.max(texture._height * resMult, 1),
								0,
								texture._glFormat,
								texture._glPixelType,
								mipObject
							);
						}
					}
					if (mipLevel === 0) {
						texture._mipmapsUploaded = false;
					} else {
						texture._mipmapsUploaded = true;
					}
				}
				mipLevel++;
			}
			if (texture._needsUpload) {
				if (texture._cubemap) {
					for (var i = 0; i < 6; i++)
						texture._levelsUpdated[0][i] = false;
				} else {
					texture._levelsUpdated[0] = false;
				}
			}
			if (!texture._compressed && texture._mipmaps && texture._needsMipmapsUpload && texture.pot && texture._levels.length === 1) {
				gl.generateMipmap(texture._glTarget);
				texture._mipmapsUploaded = true;
			}
			if (texture._gpuSize) {
				this._vram.tex -= texture._gpuSize;
			}
			texture._gpuSize = texture.gpuSize;
			this._vram.tex += texture._gpuSize;
		},
		activeTexture: function (textureUnit) {
			if (this.textureUnit !== textureUnit) {
				this.gl.activeTexture(this.gl.TEXTURE0 + textureUnit);
				this.textureUnit = textureUnit;
			}
		},
		bindTexture: function (texture) {
			var textureTarget = texture._glTarget;
			var textureObject = texture._glTexture;
			var textureUnit = this.textureUnit;
			var slot = this.targetToSlot[textureTarget];
			if (this.textureUnits[textureUnit][slot] !== textureObject) {
				this.gl.bindTexture(textureTarget, textureObject);
				this.textureUnits[textureUnit][slot] = textureObject;
			}
		},
		bindTextureOnUnit: function (texture, textureUnit) {
			var textureTarget = texture._glTarget;
			var textureObject = texture._glTexture;
			var slot = this.targetToSlot[textureTarget];
			if (this.textureUnits[textureUnit][slot] !== textureObject) {
				this.activeTexture(textureUnit);
				this.gl.bindTexture(textureTarget, textureObject);
				this.textureUnits[textureUnit][slot] = textureObject;
			}
		},
		setTextureParameters: function (texture) {
			var gl = this.gl;
			var flags = texture._parameterFlags;
			var target = texture._glTarget;
			if (flags & 1) {
				var filter = texture._minFilter;
				if (!texture.pot || !texture._mipmaps || (texture._compressed && texture._levels.length === 1)) {
					if (filter === FILTER_NEAREST_MIPMAP_NEAREST || filter === FILTER_NEAREST_MIPMAP_LINEAR) {
						filter = FILTER_NEAREST;
					} else if (filter === FILTER_LINEAR_MIPMAP_NEAREST || filter === FILTER_LINEAR_MIPMAP_LINEAR) {
						filter = FILTER_LINEAR;
					}
				}
				gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, this.glFilter[filter]);
			}
			if (flags & 2) {
				gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, this.glFilter[texture._magFilter]);
			}
			if (flags & 4) {
				if (this.webgl2) {
					gl.texParameteri(target, gl.TEXTURE_WRAP_S, this.glAddress[texture._addressU]);
				} else {
					gl.texParameteri(target, gl.TEXTURE_WRAP_S, this.glAddress[texture.pot ? texture._addressU : ADDRESS_CLAMP_TO_EDGE]);
				}
			}
			if (flags & 8) {
				if (this.webgl2) {
					gl.texParameteri(target, gl.TEXTURE_WRAP_T, this.glAddress[texture._addressV]);
				} else {
					gl.texParameteri(target, gl.TEXTURE_WRAP_T, this.glAddress[texture.pot ? texture._addressV : ADDRESS_CLAMP_TO_EDGE]);
				}
			}
			if (flags & 16) {
				if (this.webgl2) {
					gl.texParameteri(target, gl.TEXTURE_WRAP_R, this.glAddress[texture._addressW]);
				}
			}
			if (flags & 32) {
				if (this.webgl2) {
					gl.texParameteri(target, gl.TEXTURE_COMPARE_MODE, texture._compareOnRead ? gl.COMPARE_REF_TO_TEXTURE : gl.NONE);
				}
			}
			if (flags & 64) {
				if (this.webgl2) {
					gl.texParameteri(target, gl.TEXTURE_COMPARE_FUNC, this.glComparison[texture._compareFunc]);
				}
			}
			if (flags & 128) {
				var ext = this.extTextureFilterAnisotropic;
				if (ext) {
					gl.texParameterf(target, ext.TEXTURE_MAX_ANISOTROPY_EXT, Math.max(1, Math.min(Math.round(texture._anisotropy), this.maxAnisotropy)));
				}
			}
		},
		setTexture: function (texture, textureUnit) {
			if (!texture._glTexture)
				this.initializeTexture(texture);
			if (texture._parameterFlags > 0 || texture._needsUpload || texture._needsMipmapsUpload || texture === this.grabPassTexture) {
				this.activeTexture(textureUnit);
				this.bindTexture(texture);
				if (texture._parameterFlags) {
					this.setTextureParameters(texture);
					texture._parameterFlags = 0;
				}
				if (texture === this.grabPassTexture) {
					this.updateGrabPass();
				} else if (texture._needsUpload || texture._needsMipmapsUpload) {
					this.uploadTexture(texture);
					texture._needsUpload = false;
					texture._needsMipmapsUpload = false;
				}
			} else {
				this.bindTextureOnUnit(texture, textureUnit);
			}
		},
		createVertexArray: function (vertexBuffers) {
			var i, vertexBuffer, key;
			var vao;
			var useCache = vertexBuffers.length > 1;
			if (useCache) {
				key = "";
				for (i = 0; i < vertexBuffers.length; i++) {
					vertexBuffer = vertexBuffers[i];
					key += vertexBuffer.id + vertexBuffer.format.renderingingHash;
				}
				vao = this._vaoMap.get(key);
			}
			if (!vao) {
				var gl = this.gl;
				vao = gl.createVertexArray();
				gl.bindVertexArray(vao);
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
				var e, elements;
				for (i = 0; i < vertexBuffers.length; i++) {
					vertexBuffer = vertexBuffers[i];
					gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer.bufferId);
					elements = vertexBuffer.format.elements;
					for (var j = 0; j < elements.length; j++) {
						e = elements[j];
						var loc = semanticToLocation[e.name];
						gl.vertexAttribPointer(loc, e.numComponents, this.glType[e.dataType], e.normalize, e.stride, e.offset);
						gl.enableVertexAttribArray(loc);
						if (vertexBuffer.instancing) {
							gl.vertexAttribDivisor(loc, 1);
						}
					}
				}
				gl.bindVertexArray(null);
				gl.bindBuffer(gl.ARRAY_BUFFER, null);
				if (useCache) {
					this._vaoMap.set(key, vao);
				}
			}
			return vao;
		},
		setBuffers: function () {
			var gl = this.gl;
			var vertexBuffer, vao;
			if (this.vertexBuffers.length === 1) {
				vertexBuffer = this.vertexBuffers[0];
				if (!vertexBuffer._vao) {
					vertexBuffer._vao = this.createVertexArray(this.vertexBuffers);
				}
				vao = vertexBuffer._vao;
			} else {
				vao = this.createVertexArray(this.vertexBuffers);
			}
			if (this.boundVao !== vao) {
				this.boundVao = vao;
				gl.bindVertexArray(vao);
			}
			this.vertexBuffers.length = 0;
			var bufferId = this.indexBuffer ? this.indexBuffer.bufferId : null;
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bufferId);
		},
		draw: function (primitive, numInstances, keepBuffers) {
			var gl = this.gl;
			var i, j, len;
			var sampler, samplerValue, texture, numTextures;
			var uniform, scopeId, uniformVersion, programVersion;
			var shader = this.shader;
			var samplers = shader.samplers;
			var uniforms = shader.uniforms;
			if (!keepBuffers) {
				this.setBuffers();
			}
			var textureUnit = 0;
			for (i = 0, len = samplers.length; i < len; i++) {
				sampler = samplers[i];
				samplerValue = sampler.scopeId.value;
				if (!samplerValue) {
					continue;
				}
				if (samplerValue instanceof Texture) {
					texture = samplerValue;
					this.setTexture(texture, textureUnit);
					if (sampler.slot !== textureUnit) {
						gl.uniform1i(sampler.locationId, textureUnit);
						sampler.slot = textureUnit;
					}
					textureUnit++;
				} else {
					sampler.array.length = 0;
					numTextures = samplerValue.length;
					for (j = 0; j < numTextures; j++) {
						texture = samplerValue[j];
						this.setTexture(texture, textureUnit);
						sampler.array[j] = textureUnit;
						textureUnit++;
					}
					gl.uniform1iv(sampler.locationId, sampler.array);
				}
			}
			for (i = 0, len = uniforms.length; i < len; i++) {
				uniform = uniforms[i];
				scopeId = uniform.scopeId;
				uniformVersion = uniform.version;
				programVersion = scopeId.versionObject.version;
				if (uniformVersion.globalId !== programVersion.globalId || uniformVersion.revision !== programVersion.revision) {
					uniformVersion.globalId = programVersion.globalId;
					uniformVersion.revision = programVersion.revision;
					if (scopeId.value !== null) {
						this.commitFunction[uniform.dataType](uniform, scopeId.value);
					}
				}
			}
			if (this.webgl2 && this.transformFeedbackBuffer) {
				gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, this.transformFeedbackBuffer.bufferId);
				gl.beginTransformFeedback(gl.POINTS);
			}
			var mode = this.glPrimitive[primitive.type];
			var count = primitive.count;
			if (primitive.indexed) {
				var indexBuffer = this.indexBuffer;
				var format = indexBuffer.glFormat;
				var offset = primitive.base * indexBuffer.bytesPerIndex;
				if (numInstances > 0) {
					gl.drawElementsInstanced(mode, count, format, offset, numInstances);
				} else {
					gl.drawElements(mode, count, format, offset);
				}
			} else {
				var first = primitive.base;
				if (numInstances > 0) {
					gl.drawArraysInstanced(mode, first, count, numInstances);
				} else {
					gl.drawArrays(mode, first, count);
				}
			}
			if (this.webgl2 && this.transformFeedbackBuffer) {
				gl.endTransformFeedback();
				gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, null);
			}
		},
		clear: function (options) {
			var defaultOptions = this.defaultClearOptions;
			options = options || defaultOptions;
			var flags = (options.flags == undefined) ? defaultOptions.flags : options.flags;
			if (flags !== 0) {
				var gl = this.gl;
				if (flags & CLEARFLAG_COLOR) {
					var color = (options.color == undefined) ? defaultOptions.color : options.color;
					this.setClearColor(color[0], color[1], color[2], color[3]);
				}
				if (flags & CLEARFLAG_DEPTH) {
					var depth = (options.depth == undefined) ? defaultOptions.depth : options.depth;
					this.setClearDepth(depth);
					if (!this.depthWrite) {
						gl.depthMask(true);
					}
				}
				if (flags & CLEARFLAG_STENCIL) {
					var stencil = (options.stencil == undefined) ? defaultOptions.stencil : options.stencil;
					this.setClearStencil(stencil);
				}
				gl.clear(this.glClearFlag[flags]);
				if (flags & CLEARFLAG_DEPTH) {
					if (!this.depthWrite) {
						gl.depthMask(false);
					}
				}
			}
		},
		readPixels: function (x, y, w, h, pixels) {
			var gl = this.gl;
			gl.readPixels(x, y, w, h, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
		},
		setClearDepth: function (depth) {
			if (depth !== this.clearDepth) {
				this.gl.clearDepth(depth);
				this.clearDepth = depth;
			}
		},
		setClearColor: function (r, g, b, a) {
			if ((r !== this.clearRed) || (g !== this.clearGreen) || (b !== this.clearBlue) || (a !== this.clearAlpha)) {
				this.gl.clearColor(r, g, b, a);
				this.clearRed = r;
				this.clearGreen = g;
				this.clearBlue = b;
				this.clearAlpha = a;
			}
		},
		setClearStencil: function (value) {
			if (value !== this.clearStencil) {
				this.gl.clearStencil(value);
				this.clearStencil = value;
			}
		},
		setRenderTarget: function (renderTarget) {
			this.renderTarget = renderTarget;
		},
		getRenderTarget: function () {
			return this.renderTarget;
		},
		getDepthTest: function () {
			return this.depthTest;
		},
		setDepthTest: function (depthTest) {
			if (this.depthTest !== depthTest) {
				var gl = this.gl;
				if (depthTest) {
					gl.enable(gl.DEPTH_TEST);
				} else {
					gl.disable(gl.DEPTH_TEST);
				}
				this.depthTest = depthTest;
			}
		},
		setDepthFunc: function (func) {
			if (this.depthFunc === func) return;
			this.gl.depthFunc(this.glComparison[func]);
			this.depthFunc = func;
		},
		getDepthWrite: function () {
			return this.depthWrite;
		},
		setDepthWrite: function (writeDepth) {
			if (this.depthWrite !== writeDepth) {
				this.gl.depthMask(writeDepth);
				this.depthWrite = writeDepth;
			}
		},
		setColorWrite: function (writeRed, writeGreen, writeBlue, writeAlpha) {
			if ((this.writeRed !== writeRed) ||
				(this.writeGreen !== writeGreen) ||
				(this.writeBlue !== writeBlue) ||
				(this.writeAlpha !== writeAlpha)) {
				this.gl.colorMask(writeRed, writeGreen, writeBlue, writeAlpha);
				this.writeRed = writeRed;
				this.writeGreen = writeGreen;
				this.writeBlue = writeBlue;
				this.writeAlpha = writeAlpha;
			}
		},
		setAlphaToCoverage: function (state) {
			if (!this.webgl2) return;
			if (this.alphaToCoverage === state) return;
			this.alphaToCoverage = state;
			if (state) {
				this.gl.enable(this.gl.SAMPLE_ALPHA_TO_COVERAGE);
			} else {
				this.gl.disable(this.gl.SAMPLE_ALPHA_TO_COVERAGE);
			}
		},
		setTransformFeedbackBuffer: function (tf) {
			if (this.transformFeedbackBuffer === tf)
				return;
			this.transformFeedbackBuffer = tf;
			if (this.webgl2) {
				var gl = this.gl;
				if (tf) {
					if (!this.feedback) {
						this.feedback = gl.createTransformFeedback();
					}
					gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, this.feedback);
				} else {
					gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);
				}
			}
		},
		setRaster: function (on) {
			if (this.raster === on) return;
			this.raster = on;
			if (this.webgl2) {
				if (on) {
					this.gl.disable(this.gl.RASTERIZER_DISCARD);
				} else {
					this.gl.enable(this.gl.RASTERIZER_DISCARD);
				}
			}
		},
		setDepthBias: function (on) {
			if (this.depthBiasEnabled === on) return;
			this.depthBiasEnabled = on;
			if (on) {
				this.gl.enable(this.gl.POLYGON_OFFSET_FILL);
			} else {
				this.gl.disable(this.gl.POLYGON_OFFSET_FILL);
			}
		},
		setDepthBiasValues: function (constBias, slopeBias) {
			this.gl.polygonOffset(slopeBias, constBias);
		},
		getBlending: function () {
			return this.blending;
		},
		setBlending: function (blending) {
			if (this.blending !== blending) {
				var gl = this.gl;
				if (blending) {
					gl.enable(gl.BLEND);
				} else {
					gl.disable(gl.BLEND);
				}
				this.blending = blending;
			}
		},
		setStencilTest: function (enable) {
			if (this.stencil !== enable) {
				var gl = this.gl;
				if (enable) {
					gl.enable(gl.STENCIL_TEST);
				} else {
					gl.disable(gl.STENCIL_TEST);
				}
				this.stencil = enable;
			}
		},
		setStencilFunc: function (func, ref, mask) {
			if (this.stencilFuncFront !== func || this.stencilRefFront !== ref || this.stencilMaskFront !== mask ||
				this.stencilFuncBack !== func || this.stencilRefBack !== ref || this.stencilMaskBack !== mask) {
				var gl = this.gl;
				gl.stencilFunc(this.glComparison[func], ref, mask);
				this.stencilFuncFront = this.stencilFuncBack = func;
				this.stencilRefFront = this.stencilRefBack = ref;
				this.stencilMaskFront = this.stencilMaskBack = mask;
			}
		},
		setStencilFuncFront: function (func, ref, mask) {
			if (this.stencilFuncFront !== func || this.stencilRefFront !== ref || this.stencilMaskFront !== mask) {
				var gl = this.gl;
				gl.stencilFuncSeparate(gl.FRONT, this.glComparison[func], ref, mask);
				this.stencilFuncFront = func;
				this.stencilRefFront = ref;
				this.stencilMaskFront = mask;
			}
		},
		setStencilFuncBack: function (func, ref, mask) {
			if (this.stencilFuncBack !== func || this.stencilRefBack !== ref || this.stencilMaskBack !== mask) {
				var gl = this.gl;
				gl.stencilFuncSeparate(gl.BACK, this.glComparison[func], ref, mask);
				this.stencilFuncBack = func;
				this.stencilRefBack = ref;
				this.stencilMaskBack = mask;
			}
		},
		setStencilOperation: function (fail, zfail, zpass, writeMask) {
			if (this.stencilFailFront !== fail || this.stencilZfailFront !== zfail || this.stencilZpassFront !== zpass ||
				this.stencilFailBack !== fail || this.stencilZfailBack !== zfail || this.stencilZpassBack !== zpass) {
				this.gl.stencilOp(this.glStencilOp[fail], this.glStencilOp[zfail], this.glStencilOp[zpass]);
				this.stencilFailFront = this.stencilFailBack = fail;
				this.stencilZfailFront = this.stencilZfailBack = zfail;
				this.stencilZpassFront = this.stencilZpassBack = zpass;
			}
			if (this.stencilWriteMaskFront !== writeMask || this.stencilWriteMaskBack !== writeMask) {
				this.gl.stencilMask(writeMask);
				this.stencilWriteMaskFront = writeMask;
				this.stencilWriteMaskBack = writeMask;
			}
		},
		setStencilOperationFront: function (fail, zfail, zpass, writeMask) {
			if (this.stencilFailFront !== fail || this.stencilZfailFront !== zfail || this.stencilZpassFront !== zpass) {
				this.gl.stencilOpSeparate(this.gl.FRONT, this.glStencilOp[fail], this.glStencilOp[zfail], this.glStencilOp[zpass]);
				this.stencilFailFront = fail;
				this.stencilZfailFront = zfail;
				this.stencilZpassFront = zpass;
			}
			if (this.stencilWriteMaskFront !== writeMask) {
				this.gl.stencilMaskSeparate(this.gl.FRONT, writeMask);
				this.stencilWriteMaskFront = writeMask;
			}
		},
		setStencilOperationBack: function (fail, zfail, zpass, writeMask) {
			if (this.stencilFailBack !== fail || this.stencilZfailBack !== zfail || this.stencilZpassBack !== zpass) {
				this.gl.stencilOpSeparate(this.gl.BACK, this.glStencilOp[fail], this.glStencilOp[zfail], this.glStencilOp[zpass]);
				this.stencilFailBack = fail;
				this.stencilZfailBack = zfail;
				this.stencilZpassBack = zpass;
			}
			if (this.stencilWriteMaskBack !== writeMask) {
				this.gl.stencilMaskSeparate(this.gl.BACK, writeMask);
				this.stencilWriteMaskBack = writeMask;
			}
		},
		setBlendFunction: function (blendSrc, blendDst) {
			if (this.blendSrc !== blendSrc || this.blendDst !== blendDst || this.separateAlphaBlend) {
				this.gl.blendFunc(this.glBlendFunction[blendSrc], this.glBlendFunction[blendDst]);
				this.blendSrc = blendSrc;
				this.blendDst = blendDst;
				this.separateAlphaBlend = false;
			}
		},
		setBlendFunctionSeparate: function (blendSrc, blendDst, blendSrcAlpha, blendDstAlpha) {
			if (this.blendSrc !== blendSrc || this.blendDst !== blendDst || this.blendSrcAlpha !== blendSrcAlpha || this.blendDstAlpha !== blendDstAlpha || !this.separateAlphaBlend) {
				this.gl.blendFuncSeparate(this.glBlendFunction[blendSrc], this.glBlendFunction[blendDst],
										  this.glBlendFunction[blendSrcAlpha], this.glBlendFunction[blendDstAlpha]);
				this.blendSrc = blendSrc;
				this.blendDst = blendDst;
				this.blendSrcAlpha = blendSrcAlpha;
				this.blendDstAlpha = blendDstAlpha;
				this.separateAlphaBlend = true;
			}
		},
		setBlendEquation: function (blendEquation) {
			if (this.blendEquation !== blendEquation || this.separateAlphaEquation) {
				this.gl.blendEquation(this.glBlendEquation[blendEquation]);
				this.blendEquation = blendEquation;
				this.separateAlphaEquation = false;
			}
		},
		setBlendEquationSeparate: function (blendEquation, blendAlphaEquation) {
			if (this.blendEquation !== blendEquation || this.blendAlphaEquation !== blendAlphaEquation || !this.separateAlphaEquation) {
				this.gl.blendEquationSeparate(this.glBlendEquation[blendEquation], this.glBlendEquation[blendAlphaEquation]);
				this.blendEquation = blendEquation;
				this.blendAlphaEquation = blendAlphaEquation;
				this.separateAlphaEquation = true;
			}
		},
		setCullMode: function (cullMode) {
			if (this.cullMode !== cullMode) {
				if (cullMode === CULLFACE_NONE) {
					this.gl.disable(this.gl.CULL_FACE);
				} else {
					if (this.cullMode === CULLFACE_NONE) {
						this.gl.enable(this.gl.CULL_FACE);
					}
					var mode = this.glCull[cullMode];
					if (this.cullFace !== mode) {
						this.gl.cullFace(mode);
						this.cullFace = mode;
					}
				}
				this.cullMode = cullMode;
			}
		},
		getCullMode: function () {
			return this.cullMode;
		},
		setIndexBuffer: function (indexBuffer) {
			this.indexBuffer = indexBuffer;
		},
		setVertexBuffer: function (vertexBuffer) {
			if (vertexBuffer) {
				this.vertexBuffers.push(vertexBuffer);
			}
		},
		compileShaderSource: function (src, isVertexShader) {
			var gl = this.gl;
			var glShader = isVertexShader ? this.vertexShaderCache[src] : this.fragmentShaderCache[src];
			if (!glShader) {
				glShader = gl.createShader(isVertexShader ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER);
				gl.shaderSource(glShader, src);
				gl.compileShader(glShader);
				if (isVertexShader) {
					this.vertexShaderCache[src] = glShader;
				} else {
					this.fragmentShaderCache[src] = glShader;
				}
			}
			return glShader;
		},
		compileAndLinkShader: function (shader) {
			var gl = this.gl;
			var definition = shader.definition;
			var attr, attrs = definition.attributes;
			var glVertexShader = this.compileShaderSource(definition.vshader, true);
			var glFragmentShader = this.compileShaderSource(definition.fshader, false);
			var glProgram = gl.createProgram();
			gl.attachShader(glProgram, glVertexShader);
			gl.attachShader(glProgram, glFragmentShader);
			if (this.webgl2 && definition.useTransformFeedback) {
				var outNames = [];
				for (attr in attrs) {
					if (attrs.hasOwnProperty(attr)) {
						outNames.push("out_" + attr);
					}
				}
				gl.transformFeedbackVaryings(glProgram, outNames, gl.INTERLEAVED_ATTRIBS);
			}
			var locations = {};
			for (attr in attrs) {
				if (attrs.hasOwnProperty(attr)) {
					var semantic = attrs[attr];
					var loc = semanticToLocation[semantic];
					if (locations.hasOwnProperty(loc)) ;
					locations[loc] = attr;
					gl.bindAttribLocation(glProgram, loc, attr);
				}
			}
			gl.linkProgram(glProgram);
			shader._glVertexShader = glVertexShader;
			shader._glFragmentShader = glFragmentShader;
			shader._glProgram = glProgram;
		},
		createShader: function (shader) {
			this.compileAndLinkShader(shader);
			this.shaders.push(shader);
		},
		destroyShader: function (shader) {
			var idx = this.shaders.indexOf(shader);
			if (idx !== -1) {
				this.shaders.splice(idx, 1);
			}
			if (shader._glProgram) {
				this.gl.deleteProgram(shader._glProgram);
				shader._glProgram = null;
				this.removeShaderFromCache(shader);
			}
		},
		_addLineNumbers: function (src) {
			var lines = src.split("\n");
			for (var i = 0, len = lines.length; i < len; i++) {
				lines[i] = (i + 1) + ":\t" + lines[i];
			}
			return lines.join( "\n" );
		},
		postLink: function (shader) {
			var gl = this.gl;
			var glVertexShader = shader._glVertexShader;
			var glFragmentShader = shader._glFragmentShader;
			var glProgram = shader._glProgram;
			var definition = shader.definition;
			if (!gl.getShaderParameter(glVertexShader, gl.COMPILE_STATUS)) {
				console.error("Failed to compile vertex shader:\n\n" + this._addLineNumbers(definition.vshader) + "\n\n" + gl.getShaderInfoLog(glVertexShader));
				return false;
			}
			if (!gl.getShaderParameter(glFragmentShader, gl.COMPILE_STATUS)) {
				console.error("Failed to compile fragment shader:\n\n" + this._addLineNumbers(definition.fshader) + "\n\n" + gl.getShaderInfoLog(glFragmentShader));
				return false;
			}
			if (!gl.getProgramParameter(glProgram, gl.LINK_STATUS)) {
				console.error("Failed to link shader program. Error: " + gl.getProgramInfoLog(glProgram));
				return false;
			}
			var i, info, location, shaderInput;
			i = 0;
			var numAttributes = gl.getProgramParameter(glProgram, gl.ACTIVE_ATTRIBUTES);
			while (i < numAttributes) {
				info = gl.getActiveAttrib(glProgram, i++);
				location = gl.getAttribLocation(glProgram, info.name);
				if (definition.attributes[info.name] === undefined) {
					console.error('Vertex shader attribute "' + info.name + '" is not mapped to a semantic in shader definition.');
				}
				shaderInput = new ShaderInput(this, definition.attributes[info.name], this.pcUniformType[info.type], location);
				shader.attributes.push(shaderInput);
			}
			i = 0;
			var numUniforms = gl.getProgramParameter(glProgram, gl.ACTIVE_UNIFORMS);
			while (i < numUniforms) {
				info = gl.getActiveUniform(glProgram, i++);
				location = gl.getUniformLocation(glProgram, info.name);
				shaderInput = new ShaderInput(this, info.name, this.pcUniformType[info.type], location);
				if (info.type === gl.SAMPLER_2D || info.type === gl.SAMPLER_CUBE ||
					(this.webgl2 && (info.type === gl.SAMPLER_2D_SHADOW || info.type === gl.SAMPLER_CUBE_SHADOW || info.type === gl.SAMPLER_3D))
				) {
					shader.samplers.push(shaderInput);
				} else {
					shader.uniforms.push(shaderInput);
				}
			}
			shader.ready = true;
			return true;
		},
		setShader: function (shader) {
			if (shader !== this.shader) {
				if (!shader.ready) {
					if (!this.postLink(shader)) {
						return false;
					}
				}
				this.shader = shader;
				this.gl.useProgram(shader._glProgram);
				this.attributesInvalidated = true;
			}
			return true;
		},
		getHdrFormat: function () {
			if (this.textureHalfFloatRenderable) {
				return PIXELFORMAT_RGB16F;
			} else if (this.textureFloatRenderable) {
				return PIXELFORMAT_RGB32F;
			}
			return PIXELFORMAT_R8_G8_B8_A8;
		},
		getBoneLimit: function () {
			return this.boneLimit;
		},
		setBoneLimit: function (maxBones) {
			this.boneLimit = maxBones;
		},
		resizeCanvas: function (width, height) {
			this._width = width;
			this._height = height;
			var ratio = Math.min(this._maxPixelRatio, window.devicePixelRatio);
			width *= ratio;
			height *= ratio;
			if (this.canvas.width === width && this.canvas.height === height)
				return;
			this.canvas.width = width;
			this.canvas.height = height;
			this.fire(EVENT_RESIZE, width, height);
		},
		setResolution: function (width, height) {
			this._width = width;
			this._height = height;
			this.canvas.width = width;
			this.canvas.height = height;
			this.fire(EVENT_RESIZE, width, height);
		},
		clearShaderCache: function () {
			var gl = this.gl;
			var shaderSrc;
			for (shaderSrc in this.fragmentShaderCache) {
				gl.deleteShader(this.fragmentShaderCache[shaderSrc]);
				delete this.fragmentShaderCache[shaderSrc];
			}
			for (shaderSrc in this.vertexShaderCache) {
				gl.deleteShader(this.vertexShaderCache[shaderSrc]);
				delete this.vertexShaderCache[shaderSrc];
			}
			this.programLib.clearCache();
		},
		clearVertexArrayObjectCache: function () {
			var gl = this.gl;
			this._vaoMap.forEach(function (item, key, mapObj) {
				gl.deleteVertexArray(item);
			});
			this._vaoMap.clear();
		},
		removeShaderFromCache: function (shader) {
			this.programLib.removeFromCache(shader);
		},
		destroy: function () {
			var gl = this.gl;
			this.destroyGrabPass();
			if (this.webgl2 && this.feedback) {
				gl.deleteTransformFeedback(this.feedback);
			}
			this.clearShaderCache();
			this.clearVertexArrayObjectCache();
			this.canvas.removeEventListener('webglcontextlost', this._contextLostHandler, false);
			this.canvas.removeEventListener('webglcontextrestored', this._contextRestoredHandler, false);
			this._contextLostHandler = null;
			this._contextRestoredHandler = null;
			this.canvas = null;
			this.gl = null;
		}
	});
	Object.defineProperty(GraphicsDevice.prototype, 'width', {
		get: function () {
			return this.gl.drawingBufferWidth || this.canvas.width;
		}
	});
	Object.defineProperty(GraphicsDevice.prototype, 'height', {
		get: function () {
			return this.gl.drawingBufferHeight || this.canvas.height;
		}
	});
	Object.defineProperty(GraphicsDevice.prototype, 'fullscreen', {
		get: function () {
			return !!document.fullscreenElement;
		},
		set: function (fullscreen) {
			if (fullscreen) {
				var canvas = this.gl.canvas;
				canvas.requestFullscreen();
			} else {
				document.exitFullscreen();
			}
		}
	});
	Object.defineProperty(GraphicsDevice.prototype, 'enableAutoInstancing', {
		get: function () {
			return this._enableAutoInstancing;
		},
		set: function (value) {
			this._enableAutoInstancing = value && this.extInstancing;
		}
	});
	Object.defineProperty(GraphicsDevice.prototype, 'maxPixelRatio', {
		get: function () {
			return this._maxPixelRatio;
		},
		set: function (ratio) {
			this._maxPixelRatio = ratio;
			this.resizeCanvas(this._width, this._height);
		}
	});
	Object.defineProperty(GraphicsDevice.prototype, 'textureFloatHighPrecision', {
		get: function () {
			if (this._textureFloatHighPrecision === undefined) {
				this._textureFloatHighPrecision = testTextureFloatHighPrecision(this);
			}
			return this._textureFloatHighPrecision;
		}
	});
	Object.defineProperties(GraphicsDevice.prototype, {
		textureHalfFloatUpdatable: {
			get: function () {
				if (this._textureHalfFloatUpdatable === undefined) {
					if (this.webgl2) {
						this._textureHalfFloatUpdatable = true;
					} else {
						this._textureHalfFloatUpdatable = testTextureHalfFloatUpdatable(this.gl, this.extTextureHalfFloat.HALF_FLOAT_OES);
					}
				}
				return this._textureHalfFloatUpdatable;
			}
		}
	});

	var defaultOptions = {
		depth: true,
		face: 0
	};
	var RenderTarget = function (options) {
		var _arg2 = arguments[1];
		var _arg3 = arguments[2];
		if (options instanceof GraphicsDevice) {
			this._colorBuffer = _arg2;
			options = _arg3;
		} else {
			this._colorBuffer = options.colorBuffer;
		}
		this._glFrameBuffer = null;
		this._glDepthBuffer = null;
		options = (options !== undefined) ? options : defaultOptions;
		this._depthBuffer = options.depthBuffer;
		this._face = (options.face !== undefined) ? options.face : 0;
		if (this._depthBuffer) {
			var format = this._depthBuffer._format;
			if (format === PIXELFORMAT_DEPTH) {
				this._depth = true;
				this._stencil = false;
			} else if (format === PIXELFORMAT_DEPTHSTENCIL) {
				this._depth = true;
				this._stencil = true;
			} else {
				this._depth = false;
				this._stencil = false;
			}
		} else {
			this._depth = (options.depth !== undefined) ? options.depth : true;
			this._stencil = (options.stencil !== undefined) ? options.stencil : false;
		}
		this._samples = (options.samples !== undefined) ? options.samples : 1;
		this.autoResolve = (options.autoResolve !== undefined) ? options.autoResolve : true;
		this._glResolveFrameBuffer = null;
		this._glMsaaColorBuffer = null;
		this._glMsaaDepthBuffer = null;
	};
	Object.assign(RenderTarget.prototype, {
		destroy: function () {
			if (!this._device) return;
			var device = this._device;
			var idx = device.targets.indexOf(this);
			if (idx !== -1) {
				device.targets.splice(idx, 1);
			}
			var gl = device.gl;
			if (this._glFrameBuffer) {
				gl.deleteFramebuffer(this._glFrameBuffer);
				this._glFrameBuffer = null;
			}
			if (this._glDepthBuffer) {
				gl.deleteRenderbuffer(this._glDepthBuffer);
				this._glDepthBuffer = null;
			}
			if (this._glResolveFrameBuffer) {
				gl.deleteFramebuffer(this._glResolveFrameBuffer);
				this._glResolveFrameBuffer = null;
			}
			if (this._glMsaaColorBuffer) {
				gl.deleteRenderbuffer(this._glMsaaColorBuffer);
				this._glMsaaColorBuffer = null;
			}
			if (this._glMsaaDepthBuffer) {
				gl.deleteRenderbuffer(this._glMsaaDepthBuffer);
				this._glMsaaDepthBuffer = null;
			}
		},
		resolve: function (color, depth) {
			if (!this._device) return;
			if (!this._device.webgl2) return;
			var gl = this._device.gl;
			if (color === undefined) color = true;
			if (depth === undefined && this._depthBuffer) depth = true;
			gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this._glFrameBuffer);
			gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this._glResolveFrameBuffer);
			gl.blitFramebuffer( 0, 0, this.width, this.height,
								0, 0, this.width, this.height,
								(color ? gl.COLOR_BUFFER_BIT : 0) | (depth ? gl.DEPTH_BUFFER_BIT : 0),
								gl.NEAREST);
			gl.bindFramebuffer(gl.FRAMEBUFFER, this._glFrameBuffer);
		},
		copy: function (source, color, depth) {
			if (!this._device) {
				if (source._device) {
					this._device = source._device;
				} else {
					return false;
				}
			}
			return this._device.copyRenderTarget(source, this, color, depth);
		}
	});
	Object.defineProperty(RenderTarget.prototype, 'colorBuffer', {
		get: function () {
			return this._colorBuffer;
		}
	});
	Object.defineProperty(RenderTarget.prototype, 'depthBuffer', {
		get: function () {
			return this._depthBuffer;
		}
	});
	Object.defineProperty(RenderTarget.prototype, 'face', {
		get: function () {
			return this._face;
		}
	});
	Object.defineProperty(RenderTarget.prototype, 'width', {
		get: function () {
			return this._colorBuffer ? this._colorBuffer.width : this._depthBuffer.width;
		}
	});
	Object.defineProperty(RenderTarget.prototype, 'height', {
		get: function () {
			return this._colorBuffer ? this._colorBuffer.height : this._depthBuffer.height;
		}
	});

	function syncToCpu(device, targ, face) {
		var tex = targ._colorBuffer;
		if (tex.format != PIXELFORMAT_R8_G8_B8_A8) return;
		var pixels = new Uint8Array(tex.width * tex.height * 4);
		var gl = device.gl;
		device.setFramebuffer(targ._glFrameBuffer);
		gl.readPixels(0, 0, tex.width, tex.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
		if (!tex._levels) tex._levels = [];
		if (!tex._levels[0]) tex._levels[0] = [];
		tex._levels[0][face] = pixels;
	}
	function prefilterCubemap(options) {
		var device = options.device;
		var sourceCubemap = options.sourceCubemap;
		var method = options.method;
		var samples = options.samples;
		var cpuSync = options.cpuSync;
		if (cpuSync && !sourceCubemap._levels[0]) {
			console.error("ERROR: prefilter: cubemap must have _levels");
			return;
		}
		var sourceType = sourceCubemap.type;
		var rgbmSource = sourceType === TEXTURETYPE_RGBM;
		var shader = createShaderFromCode(device,
										  shaderChunks.fullscreenQuadVS,
										  shaderChunks.rgbmPS + shaderChunks.prefilterCubemapPS
											  .replace(/\$METHOD/g, method === 0 ? "cos" : "phong")
											  .replace(/\$NUMSAMPLES/g, samples)
											  .replace(/\$textureCube/g, rgbmSource ? "textureCubeRGBM" : "textureCube"),
										  "prefilter" + method + "" + samples + "" + rgbmSource);
		var shader2 = createShaderFromCode(device,
										   shaderChunks.fullscreenQuadVS,
										   shaderChunks.outputCubemapPS,
										   "outputCubemap");
		var constantTexSource = device.scope.resolve("source");
		var constantParams = device.scope.resolve("params");
		var params = new Vec4();
		var size = sourceCubemap.width;
		var format = sourceCubemap.format;
		var cmapsList = [[], options.filteredFixed, options.filteredRgbm, options.filteredFixedRgbm];
		var gloss = method === 0 ? [0.9, 0.85, 0.7, 0.4, 0.25, 0.15, 0.1] : [512, 128, 32, 8, 2, 1, 1];
		var mipSize = [64, 32, 16, 8, 4, 2, 1];
		var numMips = 7;
		var targ;
		var i, face, pass;
		var rgbFormat = format === PIXELFORMAT_R8_G8_B8;
		var isImg = false;
		var nextCubemap, cubemap;
		if (cpuSync) {
			isImg = sourceCubemap._levels[0][0] instanceof HTMLImageElement;
		}
		if ((rgbFormat || isImg) && cpuSync) {
			format = PIXELFORMAT_R8_G8_B8_A8;
			nextCubemap = new Texture(device, {
				cubemap: true,
				type: sourceType,
				format: format,
				width: size,
				height: size,
				mipmaps: false
			});
			nextCubemap.name = 'prefiltered-cube';
			for (face = 0; face < 6; face++) {
				targ = new RenderTarget(device, nextCubemap, {
					face: face,
					depth: false
				});
				params.x = face;
				params.y = 0;
				constantTexSource.setValue(sourceCubemap);
				constantParams.setValue(params.data);
				drawQuadWithShader(device, targ, shader2);
				syncToCpu(device, targ, face);
			}
			sourceCubemap = nextCubemap;
		}
		if (size > 128) {
			var log128 = Math.round(Math.log2(128));
			var logSize = Math.round(Math.log2(size));
			var steps = logSize - log128;
			for (i = 0; i < steps; i++) {
				size = sourceCubemap.width * 0.5;
				var sampleGloss = method === 0 ? 1 : Math.pow(2, Math.round(Math.log2(gloss[0]) + (steps - i) * 2));
				nextCubemap = new Texture(device, {
					cubemap: true,
					type: sourceType,
					format: format,
					width: size,
					height: size,
					mipmaps: false
				});
				nextCubemap.name = 'prefiltered-cube';
				for (face = 0; face < 6; face++) {
					targ = new RenderTarget(device, nextCubemap, {
						face: face,
						depth: false
					});
					params.x = face;
					params.y = sampleGloss;
					params.z = size;
					params.w = rgbmSource ? 3 : 0;
					constantTexSource.setValue(sourceCubemap);
					constantParams.setValue(params.data);
					drawQuadWithShader(device, targ, shader2);
					if (i === steps - 1 && cpuSync) {
						syncToCpu(device, targ, face);
					}
				}
				sourceCubemap = nextCubemap;
			}
		}
		options.sourceCubemap = sourceCubemap;
		var sourceCubemapRgbm = null;
		if (!rgbmSource && options.filteredFixedRgbm) {
			nextCubemap = new Texture(device, {
				cubemap: true,
				type: TEXTURETYPE_RGBM,
				format: PIXELFORMAT_R8_G8_B8_A8,
				width: size,
				height: size,
				mipmaps: false
			});
			nextCubemap.name = 'prefiltered-cube';
			for (face = 0; face < 6; face++) {
				targ = new RenderTarget(device, nextCubemap, {
					face: face,
					depth: false
				});
				params.x = face;
				params.w = 2;
				constantTexSource.setValue(sourceCubemap);
				constantParams.setValue(params.data);
				drawQuadWithShader(device, targ, shader2);
				syncToCpu(device, targ, face);
			}
			sourceCubemapRgbm = nextCubemap;
		}
		var unblurredGloss = method === 0 ? 1 : 2048;
		var startPass = method === 0 ? 0 : -1;
		cmapsList[startPass] = [];
		for (i = 0; i < numMips; i++) {
			for (pass = startPass; pass < cmapsList.length; pass++) {
				if (cmapsList[pass] != null) {
					cmapsList[pass][i] = new Texture(device, {
						cubemap: true,
						type: pass < 2 ? sourceType : TEXTURETYPE_RGBM,
						format: pass < 2 ? format : PIXELFORMAT_R8_G8_B8_A8,
						fixCubemapSeams: pass === 1 || pass === 3,
						width: mipSize[i],
						height: mipSize[i],
						mipmaps: false
					});
					cmapsList[pass][i].name = 'prefiltered-cube';
				}
			}
		}
		for (pass = startPass; pass < cmapsList.length; pass++) {
			if (cmapsList[pass] != null) {
				if (pass > 1 && rgbmSource) {
					cmapsList[pass] = cmapsList[pass - 2];
					continue;
				}
				for (i = 0; i < numMips; i++) {
					for (face = 0; face < 6; face++) {
						targ = new RenderTarget(device, cmapsList[pass][i], {
							face: face,
							depth: false
						});
						params.x = face;
						params.y = pass < 0 ? unblurredGloss : gloss[i];
						params.z = mipSize[i];
						params.w = rgbmSource ? 3 : pass;
						constantTexSource.setValue(i === 0 ? sourceCubemap :
							method === 0 ? cmapsList[0][i - 1] : cmapsList[-1][i - 1]);
						constantParams.setValue(params.data);
						drawQuadWithShader(device, targ, shader);
						if (cpuSync) syncToCpu(device, targ, face);
					}
				}
			}
		}
		options.filtered = cmapsList[0];
		var mips;
		if (cpuSync && options.singleFilteredFixed) {
			mips = [sourceCubemap].concat(options.filteredFixed);
			cubemap = new Texture(device, {
				cubemap: true,
				type: sourceType,
				fixCubemapSeams: true,
				format: format,
				width: 128,
				height: 128,
				addressU: ADDRESS_CLAMP_TO_EDGE,
				addressV: ADDRESS_CLAMP_TO_EDGE
			});
			cubemap.name = 'prefiltered-cube';
			for (i = 0; i < mips.length; i++)
				cubemap._levels[i] = mips[i]._levels[0];
			cubemap.upload();
			cubemap._prefilteredMips = true;
			options.singleFilteredFixed = cubemap;
		}
		if (cpuSync && options.singleFilteredFixedRgbm && options.filteredFixedRgbm) {
			mips = [sourceCubemapRgbm].concat(options.filteredFixedRgbm);
			cubemap = new Texture(device, {
				cubemap: true,
				type: TEXTURETYPE_RGBM,
				fixCubemapSeams: true,
				format: PIXELFORMAT_R8_G8_B8_A8,
				width: 128,
				height: 128,
				addressU: ADDRESS_CLAMP_TO_EDGE,
				addressV: ADDRESS_CLAMP_TO_EDGE
			});
			cubemap.name = 'prefiltered-cube';
			for (i = 0; i < mips.length; i++) {
				cubemap._levels[i] = mips[i]._levels[0];
			}
			cubemap.upload();
			cubemap._prefilteredMips = true;
			options.singleFilteredFixedRgbm = cubemap;
		}
	}
	function areaElement(x, y) {
		return Math.atan2(x * y, Math.sqrt(x * x + y * y + 1));
	}
	function texelCoordSolidAngle(u, v, size) {
		var _u = (2.0 * (u + 0.5) / size ) - 1.0;
		var _v = (2.0 * (v + 0.5) / size ) - 1.0;
		_u *= 1.0 - 1.0 / size;
		_v *= 1.0 - 1.0 / size;
		var invResolution = 1.0 / size;
		var x0 = _u - invResolution;
		var y0 = _v - invResolution;
		var x1 = _u + invResolution;
		var y1 = _v + invResolution;
		var solidAngle = areaElement(x0, y0) - areaElement(x0, y1) - areaElement(x1, y0) + areaElement(x1, y1);
		if ((u === 0 && v === 0) || (u === size - 1 && v === 0) || (u === 0 && v === size - 1) || (u === size - 1 && v === size - 1)) {
			solidAngle /= 3;
		} else if (u === 0 || v === 0 || u === size - 1 || v === size - 1) {
			solidAngle *= 0.5;
		}
		return solidAngle;
	}
	function shFromCubemap(source, dontFlipX) {
		var face;
		var cubeSize = source.width;
		var x, y;
		if (source.format != PIXELFORMAT_R8_G8_B8_A8) {
			console.error("ERROR: SH: cubemap must be RGBA8");
			return;
		}
		if (!source._levels[0]) {
			console.error("ERROR: SH: cubemap must be synced to CPU");
			return;
		}
		if (!source._levels[0][0].length) {
			if (source._levels[0][0] instanceof HTMLImageElement) {
				var device = Application.getApplication().graphicsDevice;
				var gl = device.gl;
				var shader = createShaderFromCode(device,
												  shaderChunks.fullscreenQuadVS,
												  shaderChunks.fullscreenQuadPS,
												  "fsQuadSimple");
				var constantTexSource = device.scope.resolve("source");
				for (face = 0; face < 6; face++) {
					var img = source._levels[0][face];
					var tex = new Texture(device, {
						cubemap: false,
						type: TEXTURETYPE_DEFAULT,
						format: source.format,
						width: cubeSize,
						height: cubeSize,
						mipmaps: false
					});
					tex.name = 'prefiltered-cube';
					tex._levels[0] = img;
					tex.upload();
					var tex2 = new Texture(device, {
						cubemap: false,
						type: TEXTURETYPE_DEFAULT,
						format: source.format,
						width: cubeSize,
						height: cubeSize,
						mipmaps: false
					});
					tex2.name = 'prefiltered-cube';
					var targ = new RenderTarget(device, tex2, {
						depth: false
					});
					constantTexSource.setValue(tex);
					drawQuadWithShader(device, targ, shader);
					var pixels = new Uint8Array(cubeSize * cubeSize * 4);
					gl.bindFramebuffer(gl.FRAMEBUFFER, targ._glFrameBuffer);
					gl.readPixels(0, 0, tex.width, tex.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
					source._levels[0][face] = pixels;
				}
			} else {
				console.error("ERROR: SH: cubemap must be composed of arrays or images");
				return;
			}
		}
		var dirs = [];
		for (y = 0; y < cubeSize; y++) {
			for (x = 0; x < cubeSize; x++) {
				var u = (x / (cubeSize - 1)) * 2 - 1;
				var v = (y / (cubeSize - 1)) * 2 - 1;
				dirs[y * cubeSize + x] = new Vec3(u, v, 1.0).normalize();
			}
		}
		var sh = new Float32Array(9 * 3);
		var coef1 = 0;
		var coef2 = 1 * 3;
		var coef3 = 2 * 3;
		var coef4 = 3 * 3;
		var coef5 = 4 * 3;
		var coef6 = 5 * 3;
		var coef7 = 6 * 3;
		var coef8 = 7 * 3;
		var coef9 = 8 * 3;
		var nx = 0;
		var px = 1;
		var ny = 2;
		var py = 3;
		var nz = 4;
		var pz = 5;
		var addr, c, a, value, weight, dir, dx, dy, dz;
		var weight1, weight2, weight3, weight4, weight5;
		var accum = 0;
		for (face = 0; face < 6; face++) {
			for (y = 0; y < cubeSize; y++) {
				for (x = 0; x < cubeSize; x++) {
					addr = y * cubeSize + x;
					weight = texelCoordSolidAngle(x, y, cubeSize);
					weight1 = weight * 4 / 17;
					weight2 = weight * 8 / 17;
					weight3 = weight * 15 / 17;
					weight4 = weight * 5 / 68;
					weight5 = weight * 15 / 68;
					dir = dirs[addr];
					if (face == nx) {
						dx = dir.z;
						dy = -dir.y;
						dz = -dir.x;
					} else if (face == px) {
						dx = -dir.z;
						dy = -dir.y;
						dz = dir.x;
					} else if (face == ny) {
						dx = dir.x;
						dy = dir.z;
						dz = dir.y;
					} else if (face == py) {
						dx = dir.x;
						dy = -dir.z;
						dz = -dir.y;
					} else if (face == nz) {
						dx = dir.x;
						dy = -dir.y;
						dz = dir.z;
					} else if (face == pz) {
						dx = -dir.x;
						dy = -dir.y;
						dz = -dir.z;
					}
					if (!dontFlipX) dx = -dx;
					a = source._levels[0][face][addr * 4 + 3] / 255.0;
					for (c = 0; c < 3; c++) {
						value =  source._levels[0][face][addr * 4 + c] / 255.0;
						if (source.type === TEXTURETYPE_RGBM) {
							value *= a * 8.0;
							value *= value;
						} else {
							value = Math.pow(value, 2.2);
						}
						sh[coef1 + c] += value * weight1;
						sh[coef2 + c] += value * weight2 * dx;
						sh[coef3 + c] += value * weight2 * dy;
						sh[coef4 + c] += value * weight2 * dz;
						sh[coef5 + c] += value * weight3 * dx * dz;
						sh[coef6 + c] += value * weight3 * dz * dy;
						sh[coef7 + c] += value * weight3 * dy * dx;
						sh[coef8 + c] += value * weight4 * (3.0 * dz * dz - 1.0);
						sh[coef9 + c] += value * weight5 * (dx * dx - dy * dy);
						accum += weight;
					}
				}
			}
		}
		for (c = 0; c < sh.length; c++) {
			sh[c] *= 4 * Math.PI / accum;
		}
		return sh;
	}

	var getCoding = function (texture) {
		switch (texture.type) {
			case TEXTURETYPE_RGBM:
				return "RGBM";
			case TEXTURETYPE_RGBE:
				return "RGBE";
			default:
				switch (texture.format) {
					case PIXELFORMAT_RGB16F:
					case PIXELFORMAT_RGB32F:
					case PIXELFORMAT_RGBA16F:
					case PIXELFORMAT_RGBA32F:
						return "Linear";
					default:
						return "Gamma";
				}
		}
	};
	var reprojectTexture = function (device, source, target, specularPower) {
		var decodeFunc = "decode" + getCoding(source);
		var encodeFunc = "encode" + getCoding(target);
		var sourceFunc = source.cubemap ? "sampleCubemap" : "sampleEquirect";
		var targetFunc = target.cubemap ? "getDirectionCubemap" : "getDirectionEquirect";
		var shader = createShaderFromCode(
			device,
			shaderChunks.fullscreenQuadVS,
			"#define DECODE_FUNC " + decodeFunc + "\n" +
			"#define ENCODE_FUNC " + encodeFunc + "\n" +
			"#define SOURCE_FUNC " + sourceFunc + "\n" +
			"#define TARGET_FUNC " + targetFunc + "\n" +
			"#define NUM_SAMPLES 1024\n\n" +
			shaderChunks.reprojectPS,
			"reproject" + decodeFunc + encodeFunc + sourceFunc + targetFunc,
			null,
			device.webgl2 ? "" : "#extension GL_OES_standard_derivatives: enable\n"
		);
		var constantSource = device.scope.resolve(source.cubemap ? "sourceCube" : "sourceTex");
		constantSource.setValue(source);
		var constantParams = device.scope.resolve("params");
		var params = new Vec4();
		params.y = (specularPower !== undefined) ? specularPower : 1;
		params.z = (specularPower !== undefined) ? 1 : 0;
		for (var face = 0; face < (target.cubemap ? 6 : 1); face++) {
			var targ = new RenderTarget(device, target, {
				face: face,
				depth: false
			});
			params.x = face;
			constantParams.setValue(params.data);
			drawQuadWithShader(device, targ, shader);
		}
	};

	var primitive = {
		type: PRIMITIVE_TRISTRIP,
		base: 0,
		count: 4,
		indexed: false
	};
	function PostEffect(graphicsDevice) {
		this.device = graphicsDevice;
		this.shader = null;
		this.depthMap = null;
		this.vertexBuffer = createFullscreenQuad(graphicsDevice);
		this.needsDepthBuffer = false;
	}
	Object.assign(PostEffect.prototype, {
		render: function (inputTarget, outputTarget, rect) {
		}
	});
	function createFullscreenQuad(device) {
		var vertexFormat = new VertexFormat(device, [
			{ semantic: SEMANTIC_POSITION, components: 2, type: TYPE_FLOAT32 }
		]);
		var vertexBuffer = new VertexBuffer(device, vertexFormat, 4);
		var iterator = new VertexIterator(vertexBuffer);
		iterator.element[SEMANTIC_POSITION].set(-1.0, -1.0);
		iterator.next();
		iterator.element[SEMANTIC_POSITION].set(1.0, -1.0);
		iterator.next();
		iterator.element[SEMANTIC_POSITION].set(-1.0, 1.0);
		iterator.next();
		iterator.element[SEMANTIC_POSITION].set(1.0, 1.0);
		iterator.end();
		return vertexBuffer;
	}
	function drawFullscreenQuad(device, target, vertexBuffer, shader, rect) {
		var oldRt = device.getRenderTarget();
		device.setRenderTarget(target);
		device.updateBegin();
		var w = (target !== null) ? target.width : device.width;
		var h = (target !== null) ? target.height : device.height;
		var x = 0;
		var y = 0;
		if (rect) {
			x = rect.x * w;
			y = rect.y * h;
			w *= rect.z;
			h *= rect.w;
		}
		var oldVx = device.vx;
		var oldVy = device.vy;
		var oldVw = device.vw;
		var oldVh = device.vh;
		device.setViewport(x, y, w, h);
		var oldSx = device.sx;
		var oldSy = device.sy;
		var oldSw = device.sw;
		var oldSh = device.sh;
		device.setScissor(x, y, w, h);
		var oldBlending = device.getBlending();
		var oldDepthTest = device.getDepthTest();
		var oldDepthWrite = device.getDepthWrite();
		var oldCullMode = device.getCullMode();
		var oldWR = device.writeRed;
		var oldWG = device.writeGreen;
		var oldWB = device.writeBlue;
		var oldWA = device.writeAlpha;
		device.setBlending(false);
		device.setDepthTest(false);
		device.setDepthWrite(false);
		device.setCullMode(CULLFACE_NONE);
		device.setColorWrite(true, true, true, true);
		device.setVertexBuffer(vertexBuffer, 0);
		device.setShader(shader);
		device.draw(primitive);
		device.setBlending(oldBlending);
		device.setDepthTest(oldDepthTest);
		device.setDepthWrite(oldDepthWrite);
		device.setCullMode(oldCullMode);
		device.setColorWrite(oldWR, oldWG, oldWB, oldWA);
		device.updateEnd();
		device.setRenderTarget(oldRt);
		device.updateBegin();
		device.setViewport(oldVx, oldVy, oldVw, oldVh);
		device.setScissor(oldSx, oldSy, oldSw, oldSh);
	}

	function TransformFeedback(inputBuffer, usage) {
		usage = usage || BUFFER_GPUDYNAMIC;
		this.device = inputBuffer.device;
		var gl = this.device.gl;
		this._inputBuffer = inputBuffer;
		if (usage === BUFFER_GPUDYNAMIC && inputBuffer.usage !== usage) {
			gl.bindBuffer(gl.ARRAY_BUFFER, inputBuffer.bufferId);
			gl.bufferData(gl.ARRAY_BUFFER, inputBuffer.storage, gl.DYNAMIC_COPY);
		}
		this._outputBuffer = new VertexBuffer(inputBuffer.device, inputBuffer.format, inputBuffer.numVertices, usage, inputBuffer.storage);
	}
	TransformFeedback.createShader = function (graphicsDevice, vsCode, name) {
		return createShaderFromCode(graphicsDevice, vsCode, null, name, true);
	};
	Object.assign(TransformFeedback.prototype, {
		destroy: function () {
			this._outputBuffer.destroy();
		},
		process: function (shader, swap) {
			if (swap === undefined) swap = true;
			var device = this.device;
			device.setRenderTarget(null);
			device.updateBegin();
			device.setVertexBuffer(this._inputBuffer, 0);
			device.setRaster(false);
			device.setTransformFeedbackBuffer(this._outputBuffer);
			device.setShader(shader);
			device.draw({
				type: PRIMITIVE_POINTS,
				base: 0,
				count: this._inputBuffer.numVertices,
				indexed: false
			});
			device.setTransformFeedbackBuffer(null);
			device.setRaster(true);
			device.updateEnd();
			if (swap) {
				var tmp = this._inputBuffer.bufferId;
				this._inputBuffer.bufferId = this._outputBuffer.bufferId;
				this._outputBuffer.bufferId = tmp;
				tmp = this._inputBuffer._vao;
				this._inputBuffer._vao = this._outputBuffer._vao;
				this._outputBuffer._vao = tmp;
			}
		}
	});
	Object.defineProperty(TransformFeedback.prototype, 'inputBuffer', {
		get: function () {
			return this._inputBuffer;
		}
	});
	Object.defineProperty(TransformFeedback.prototype, 'outputBuffer', {
		get: function () {
			return this._outputBuffer;
		}
	});

	function DepthMaterial() {
		Material.call(this);
	}
	DepthMaterial.prototype = Object.create(Material.prototype);
	DepthMaterial.prototype.constructor = DepthMaterial;
	Object.assign(DepthMaterial.prototype, {
		clone: function () {
			var clone = new DepthMaterial();
			Material.prototype._cloneInternal.call(this, clone);
			return clone;
		},
		updateShader: function (device) {
			var options = {
				skin: !!this.meshInstances[0].skinInstance
			};
			var library = device.getProgramLibrary();
			this.shader = library.getProgram('depth', options);
		}
	});

	function Picker(app, width, height) {
		if (app instanceof GraphicsDevice) {
			app = Application.getApplication();
		}
		this.app = app;
		this.device = app.graphicsDevice;
		var device = this.device;
		this.library = device.getProgramLibrary();
		this.pickColor = new Float32Array(4);
		this.pickColor[3] = 1;
		this.scene = null;
		this.drawCalls = [];
		this.layer = null;
		this.layerComp = null;
		this.clearOptions = {
			color: [1, 1, 1, 1],
			depth: 1,
			flags: CLEARFLAG_COLOR | CLEARFLAG_DEPTH
		};
		var self = this;
		this._clearDepthOptions = {
			depth: 1.0,
			flags: CLEARFLAG_DEPTH
		};
		this.clearDepthCommand = new Command(0, 0, function (){
			device.clear(self._clearDepthOptions);
		});
		this.resize(width, height);
		this._ignoreOpacityFor = null;
	}
	Picker.prototype.getSelection = function (x, y, width, height) {
		var device = this.device;
		if (typeof x === 'object') {
			var rect = x;
			x = rect.x;
			y = rect.y;
			width = rect.width;
			height = rect.height;
		} else {
			y = this.layer.renderTarget.height - (y + (height || 1));
		}
		width = width || 1;
		height = height || 1;
		var prevRenderTarget = device.renderTarget;
		device.setRenderTarget(this.layer.renderTarget);
		device.updateBegin();
		var pixels = new Uint8Array(4 * width * height);
		device.readPixels(x, y, width, height, pixels);
		device.updateEnd();
		device.setRenderTarget(prevRenderTarget);
		var selection = [];
		var drawCalls = this.layer.instances.visibleOpaque[0].list;
		var r, g, b, index;
		for (var i = 0; i < width * height; i++) {
			r = pixels[4 * i + 0];
			g = pixels[4 * i + 1];
			b = pixels[4 * i + 2];
			index = r << 16 | g << 8 | b;
			if (index !== 0xffffff) {
				var selectedMeshInstance = drawCalls[index];
				if (selection.indexOf(selectedMeshInstance) === -1) {
					selection.push(selectedMeshInstance);
				}
			}
		}
		return selection;
	};
	Picker.prototype.prepare = function (camera, scene, arg) {
		var device = this.device;
		var i, j;
		var self = this;
		if (camera instanceof Camera) {
			camera = camera.node.camera;
		}
		this.scene = scene;
		var sourceLayer = null;
		var sourceRt = null;
		if (arg instanceof Layer) {
			sourceLayer = arg;
		} else {
			sourceRt = arg;
		}
		if (!this.layer) {
			var pickColorId = device.scope.resolve('uColor');
			this.layer = new Layer({
				name: "Picker",
				shaderPass: SHADER_PICK,
				opaqueSortMode: SORTMODE_NONE,
				onEnable: function () {
					if (this.renderTarget) return;
					var colorBuffer = new Texture(device, {
						format: PIXELFORMAT_R8_G8_B8_A8,
						width: self.width,
						height: self.height
					});
					colorBuffer.name = 'pick';
					colorBuffer.minFilter = FILTER_NEAREST;
					colorBuffer.magFilter = FILTER_NEAREST;
					colorBuffer.addressU = ADDRESS_CLAMP_TO_EDGE;
					colorBuffer.addressV = ADDRESS_CLAMP_TO_EDGE;
					this.renderTarget = new RenderTarget(device, colorBuffer, {
						depth: true
					});
				},
				onDisable: function () {
					if (!this.renderTarget) return;
					this.renderTarget._colorBuffer.destroy();
					this.renderTarget.destroy();
					this.renderTarget = null;
				},
				onDrawCall: function (meshInstance, index) {
					self.pickColor[0] = ((index >> 16) & 0xff) / 255;
					self.pickColor[1] = ((index >> 8) & 0xff) / 255;
					self.pickColor[2] = (index & 0xff) / 255;
					pickColorId.setValue(self.pickColor);
					device.setBlending(false);
				}
			});
			this.layerComp = new LayerComposition();
			this.layerComp.pushOpaque(this.layer);
			this.meshInstances = this.layer.opaqueMeshInstances;
			this._instancesVersion = -1;
		}
		var instanceList, instanceListLength, drawCall;
		if (!sourceLayer) {
			this.layer.clearMeshInstances();
			var layers = scene.layers.layerList;
			var subLayerEnabled = scene.layers.subLayerEnabled;
			var isTransparent = scene.layers.subLayerList;
			var layer;
			var layerCamId, transparent;
			for (i = 0; i < layers.length; i++) {
				if (layers[i].overrideClear && layers[i]._clearDepthBuffer) layers[i]._pickerCleared = false;
			}
			for (i = 0; i < layers.length; i++) {
				layer = layers[i];
				if (layer.renderTarget !== sourceRt || !layer.enabled || !subLayerEnabled[i]) continue;
				layerCamId = layer.cameras.indexOf(camera);
				if (layerCamId < 0) continue;
				if (layer.overrideClear && layer._clearDepthBuffer && !layer._pickerCleared) {
					this.meshInstances.push(this.clearDepthCommand);
					layer._pickerCleared = true;
				}
				transparent = isTransparent[i];
				instanceList = transparent ? layer.instances.transparentMeshInstances : layer.instances.opaqueMeshInstances;
				instanceListLength = instanceList.length;
				for (j = 0; j < instanceListLength; j++) {
					drawCall = instanceList[j];
					if (drawCall.pick) {
						this.meshInstances.push(drawCall);
					}
				}
			}
		} else {
			if (this._instancesVersion !== sourceLayer._version) {
				this.layer.clearMeshInstances();
				instanceList = sourceLayer.instances.opaqueMeshInstances;
				instanceListLength = instanceList.length;
				for (j = 0; j < instanceListLength; j++) {
					drawCall = instanceList[j];
					if (drawCall.pick) {
						this.meshInstances.push(drawCall);
					}
				}
				instanceList = sourceLayer.instances.transparentMeshInstances;
				instanceListLength = instanceList.length;
				for (j = 0; j < instanceListLength; j++) {
					drawCall = instanceList[j];
					if (drawCall.pick) {
						this.meshInstances.push(drawCall);
					}
				}
				this._instancesVersion = sourceLayer._version;
			}
		}
		if (this.layer.cameras[0] !== camera) {
			this.layer.clearCameras();
			this.layer.addCamera(camera);
		}
		this.onLayerPreRender(this.layer, sourceLayer, sourceRt);
		this.app.renderer.renderComposition(this.layerComp);
		this.onLayerPostRender(this.layer);
	};
	Picker.prototype.onLayerPreRender = function (layer, sourceLayer, sourceRt) {
		if (this.width !== layer.renderTarget.width || this.height !== layer.renderTarget.height) {
			layer.onDisable();
			layer.onEnable();
		}
		layer.oldClear = layer.cameras[0].camera._clearOptions;
		layer.oldAspectMode = layer.cameras[0].aspectRatioMode;
		layer.oldAspect = layer.cameras[0].aspectRatio;
		layer.cameras[0].camera._clearOptions = this.clearOptions;
		layer.cameras[0].aspectRatioMode = ASPECT_MANUAL;
		var rt = sourceRt ? sourceRt : (sourceLayer ? sourceLayer.renderTarget : null);
		layer.cameras[0].aspectRatio = layer.cameras[0].calculateAspectRatio(rt);
		this.app.renderer.updateCameraFrustum(layer.cameras[0].camera);
	};
	Picker.prototype.onLayerPostRender = function (layer) {
		layer.cameras[0].camera._clearOptions = layer.oldClear;
		layer.cameras[0].aspectRatioMode = layer.oldAspectMode;
		layer.cameras[0].aspectRatio = layer.oldAspect;
	};
	Picker.prototype.resize = function (width, height) {
		this.width = width;
		this.height = height;
	};
	Object.defineProperty(Picker.prototype, 'renderTarget', {
		get: function () {
			return this.layer.renderTarget;
		}
	});

	var shadergraph = {};
	shadergraph.graphCounter = 0;
	shadergraph._getNode = function (name, funcString, declString) {
		if (!shadergraph_nodeRegistry.getNode(name)) {
			shadergraph_nodeRegistry.registerNode(name, new NodeMaterial(funcString, declString));
		}
		return shadergraph_nodeRegistry.getNode(name);
	};
	shadergraph._registerCoreFunction = function (coreName, coreNode) {
		this[coreName] = function (...args) {
			var sgIndex = this.graph.addSubGraph(this._getNode(coreName));
			var sgInputs = coreNode.graphData.graphVars.filter(function (graphVar) {
				return graphVar.name.startsWith('IN_');
			});
			if (sgInputs.length === args.length) {
				args.forEach((arg, argIndex) => {
					if (typeof(arg) === 'number') {
						var argNodeIndex = arg;
						this.graph.connect(argNodeIndex, 'OUT_ret', sgIndex, sgInputs[argIndex].name);
					} else if (arg.type) {
						this.graph.connect(-1, arg.name, sgIndex, sgInputs[argIndex].name);
					} else {
						this.graph.connect(arg.node, 'OUT_' + arg.port, sgIndex, sgInputs[argIndex].name);
					}
				});
			} else {
				console.log("arguments do not match core node function");
			}
			return sgIndex;
		};
	};
	shadergraph.start = function (coreNodesJSON) {
		const coreNodeList = JSON.parse(coreNodesJSON);
		Object.keys(coreNodeList).forEach((key) => {
			var coreNode = this._getNode(key, coreNodeList[key].code);
			this._registerCoreFunction(key, coreNode);
		});
		shadergraph.graph = this._getNode('graphRoot_' + shadergraph.graphCounter);
		shadergraph.graph.name = 'graphRoot_' + shadergraph.graphCounter;
	};
	shadergraph.end = function () {
		var ret = shadergraph.graph;
		shadergraph.graph = null;
		shadergraph.graphCounter++;
		return ret;
	};
	shadergraph.textureSample2D = function (name, texture, uv) {
		var texSampNode = this.graph.addSubGraph(this._getNode('texSample', 'vec4 texSample(in sampler2D tex, in vec2 uv, out vec3 color, out float alpha) {\n vec4 samp=texture2D(tex, uv);\n color=samp.rgb;\n alpha=samp.a;\n return samp;\n}'));
		var graphVar = this.graph.addInput('sampler2D', name, texture);
		this.graph.connect(-1, graphVar.name, texSampNode, 'IN_tex');
		this.graph.connect(uv, 'OUT_ret', texSampNode, 'IN_uv');
		return texSampNode;
	};
	shadergraph.customNode = function (name, f, d) {
		var nodeIndex = this.graph.addSubGraph(this._getNode(name, f, d));
		return nodeIndex;
	};
	Object.defineProperty(shadergraph, 'uv0', {
		get: function () {
			var nodeIndex = this.graph.addSubGraph(this._getNode('uv0', 'vec2 uv0() { return vUv0; }'));
			return nodeIndex;
		}
	});
	Object.defineProperty(shadergraph, 'worldPosPS', {
		get: function () {
			var nodeIndex = this.graph.addSubGraph(this._getNode('worldPosPS', 'vec3 wpPS() { return vPosition; }'));
			return nodeIndex;
		}
	});
	Object.defineProperty(shadergraph, 'worldNormPS', {
		get: function () {
			var nodeIndex = this.graph.addSubGraph(this._getNode('worldNormPS', 'vec3 wnPS() { return vNormal; }'));
			return nodeIndex;
		}
	});
	Object.defineProperty(shadergraph, 'worldPosVS', {
		get: function () {
			var nodeIndex = this.graph.addSubGraph(this._getNode('worldPosVS', 'vec3 wpVS() { return getWorldPosition(); }'));
			return nodeIndex;
		}
	});
	Object.defineProperty(shadergraph, 'worldNormVS', {
		get: function () {
			var nodeIndex = this.graph.addSubGraph(this._getNode('worldNormVS', 'vec3 wnVS() { return getNormal(); }'));
			return nodeIndex;
		}
	});
	shadergraph.param = function (type, name, value) {
		var graphVar = this.graph.addInput(type, name, value);
		return graphVar;
	};
	shadergraph.connectOutput = function (arg, type, name) {
		var graphVar = this.graph.addOutput(type, name);
		if (typeof(arg) === 'number') {
			var argNodeIndex = arg;
			this.graph.connect(argNodeIndex, 'OUT_ret', -1, graphVar.name);
		} else if (arg.type) {
			this.graph.connect(-1, arg.name, -1, graphVar.name);
		} else {
			this.graph.connect(arg.node, 'OUT_' + arg.port, -1, graphVar.name);
		}
	};
	shadergraph.connectVertexOffset = function (arg) {
		this.connectOutput(arg, 'vec3', 'vertOff');
	};
	shadergraph.connectAlphaOut = function (arg) {
		this.connectOutput(arg, 'float', 'dAlpha');
	};
	shadergraph.connectMetalnessOut = function (arg) {
	};
	shadergraph.connectGlossinessOut = function (arg) {
		this.connectOutput(arg, 'float', 'dGlossiness');
	};
	shadergraph.connectAlbedoOut = function (arg) {
		this.connectOutput(arg, 'vec3', 'dAlbedo');
	};
	shadergraph.connectEmissiveOut = function (arg) {
		this.connectOutput(arg, 'vec3', 'dEmission');
	};
	shadergraph.connectFragOut = function (arg) {
		this.connectOutput(arg, 'vec4', 'fragOut');
	};
	shadergraph.connectCustom = function (destNodeIndex, destName, nodeIndex_or_param, name) {
		if (typeof(nodeIndex_or_param) === 'number') {
			var nodeIndex = nodeIndex_or_param;
			this.graph.connect(nodeIndex, (name) ? 'OUT_' + name : 'OUT_ret', destNodeIndex, 'IN_' + destName);
		} else {
			var graphVar = nodeIndex_or_param;
			this.graph.connect(-1, graphVar.name, destNodeIndex, 'IN_' + destName);
		}
	};

	function StandardNodeMaterial(mat, chunk) {
		StandardMaterial.call(this);
		if (mat)
		{
			StandardMaterial.prototype._cloneInternal.call(mat, this);
		}
		if (chunk)
		{
			this._shaderGraphChunk = chunk.name;
		}
	}
	StandardNodeMaterial.prototype = Object.create(StandardMaterial.prototype);
	StandardNodeMaterial.prototype.constructor = StandardNodeMaterial;
	Object.assign(StandardNodeMaterial.prototype, {
		clone: function () {
			var clone = new StandardNodeMaterial();
			StandardMaterial.prototype._cloneInternal.call(this, clone);
			clone._shaderGraphChunk = this._shaderGraphChunk;
			return clone;
		},
		updateUniforms: function () {
			StandardMaterial.prototype.updateUniforms.call(this);
			if (this._shaderGraphChunk)
			{
				var rootShaderGraph = shadergraph_nodeRegistry.getNode(this._shaderGraphChunk);
				rootShaderGraph.updateShaderGraphUniforms(this);
			}
		},
		updateShader: function (device, scene, objDefs, staticLightList, pass, sortedLights) {
			var prefilteredCubeMap128 = StandardMaterial.prototype._updateShaderGlobals.call(this, device, scene);
			var minimalOptions = pass > SHADER_FORWARDHDR && pass <= SHADER_PICK;
			var options = minimalOptions ? standard.optionsContextMin : standard.optionsContext;
			if (minimalOptions)
				this.shaderOptBuilder.updateMinRef(options, device, scene, this, objDefs, staticLightList, pass, sortedLights, prefilteredCubeMap128);
			else
				this.shaderOptBuilder.updateRef(options, device, scene, this, objDefs, staticLightList, pass, sortedLights, prefilteredCubeMap128);
			if (this._shaderGraphChunk) {
				options._shaderGraphChunk = this._shaderGraphChunk;
			}
			if (this.onUpdateShader) {
				options = this.onUpdateShader(options);
			}
			var library = device.getProgramLibrary();
			this.shader = library.getProgram('standard', options);
			if (!objDefs) {
				this.clearVariants();
				this.variants[0] = this.shader;
			}
			this.dirtyShader = false;
		}
	});

	function ResourceHandler() {}
	Object.assign(ResourceHandler.prototype, {
		load: function (url, callback, asset) {
			throw new Error('not implemented');
		},
		open: function (url, data, asset) {
			throw new Error('not implemented');
		},
		patch: function (asset, assets) {
		}
	});

	var ACTION_MOUSE = 'mouse';
	var ACTION_KEYBOARD = 'keyboard';
	var ACTION_GAMEPAD = 'gamepad';
	var AXIS_MOUSE_X = 'mousex';
	var AXIS_MOUSE_Y = 'mousey';
	var AXIS_PAD_L_X = 'padlx';
	var AXIS_PAD_L_Y = 'padly';
	var AXIS_PAD_R_X = 'padrx';
	var AXIS_PAD_R_Y = 'padry';
	var AXIS_KEY = 'key';
	var EVENT_KEYDOWN = 'keydown';
	var EVENT_KEYUP = 'keyup';
	var EVENT_MOUSEDOWN = "mousedown";
	var EVENT_MOUSEMOVE = "mousemove";
	var EVENT_MOUSEUP = "mouseup";
	var EVENT_MOUSEWHEEL = "mousewheel";
	var EVENT_TOUCHSTART = 'touchstart';
	var EVENT_TOUCHEND = 'touchend';
	var EVENT_TOUCHMOVE = 'touchmove';
	var EVENT_TOUCHCANCEL = 'touchcancel';
	var EVENT_SELECT = 'select';
	var EVENT_SELECTSTART = 'selectstart';
	var EVENT_SELECTEND = 'selectend';
	var KEY_BACKSPACE = 8;
	var KEY_TAB = 9;
	var KEY_RETURN = 13;
	var KEY_ENTER = 13;
	var KEY_SHIFT = 16;
	var KEY_CONTROL = 17;
	var KEY_ALT = 18;
	var KEY_PAUSE = 19;
	var KEY_CAPS_LOCK = 20;
	var KEY_ESCAPE = 27;
	var KEY_SPACE = 32;
	var KEY_PAGE_UP = 33;
	var KEY_PAGE_DOWN = 34;
	var KEY_END = 35;
	var KEY_HOME = 36;
	var KEY_LEFT = 37;
	var KEY_UP = 38;
	var KEY_RIGHT = 39;
	var KEY_DOWN = 40;
	var KEY_PRINT_SCREEN = 44;
	var KEY_INSERT = 45;
	var KEY_DELETE = 46;
	var KEY_0 = 48;
	var KEY_1 = 49;
	var KEY_2 = 50;
	var KEY_3 = 51;
	var KEY_4 = 52;
	var KEY_5 = 53;
	var KEY_6 = 54;
	var KEY_7 = 55;
	var KEY_8 = 56;
	var KEY_9 = 57;
	var KEY_SEMICOLON = 59;
	var KEY_EQUAL = 61;
	var KEY_A = 65;
	var KEY_B = 66;
	var KEY_C = 67;
	var KEY_D = 68;
	var KEY_E = 69;
	var KEY_F = 70;
	var KEY_G = 71;
	var KEY_H = 72;
	var KEY_I = 73;
	var KEY_J = 74;
	var KEY_K = 75;
	var KEY_L = 76;
	var KEY_M = 77;
	var KEY_N = 78;
	var KEY_O = 79;
	var KEY_P = 80;
	var KEY_Q = 81;
	var KEY_R = 82;
	var KEY_S = 83;
	var KEY_T = 84;
	var KEY_U = 85;
	var KEY_V = 86;
	var KEY_W = 87;
	var KEY_X = 88;
	var KEY_Y = 89;
	var KEY_Z = 90;
	var KEY_WINDOWS = 91;
	var KEY_CONTEXT_MENU = 93;
	var KEY_NUMPAD_0 = 96;
	var KEY_NUMPAD_1 = 97;
	var KEY_NUMPAD_2 = 98;
	var KEY_NUMPAD_3 = 99;
	var KEY_NUMPAD_4 = 100;
	var KEY_NUMPAD_5 = 101;
	var KEY_NUMPAD_6 = 102;
	var KEY_NUMPAD_7 = 103;
	var KEY_NUMPAD_8 = 104;
	var KEY_NUMPAD_9 = 105;
	var KEY_MULTIPLY = 106;
	var KEY_ADD = 107;
	var KEY_SEPARATOR = 108;
	var KEY_SUBTRACT = 109;
	var KEY_DECIMAL = 110;
	var KEY_DIVIDE = 111;
	var KEY_F1 = 112;
	var KEY_F2 = 113;
	var KEY_F3 = 114;
	var KEY_F4 = 115;
	var KEY_F5 = 116;
	var KEY_F6 = 117;
	var KEY_F7 = 118;
	var KEY_F8 = 119;
	var KEY_F9 = 120;
	var KEY_F10 = 121;
	var KEY_F11 = 122;
	var KEY_F12 = 123;
	var KEY_COMMA = 188;
	var KEY_PERIOD = 190;
	var KEY_SLASH = 191;
	var KEY_OPEN_BRACKET = 219;
	var KEY_BACK_SLASH = 220;
	var KEY_CLOSE_BRACKET = 221;
	var KEY_META = 224;
	var MOUSEBUTTON_NONE = -1;
	var MOUSEBUTTON_LEFT = 0;
	var MOUSEBUTTON_MIDDLE = 1;
	var MOUSEBUTTON_RIGHT = 2;
	var PAD_1 = 0;
	var PAD_2 = 1;
	var PAD_3 = 2;
	var PAD_4 = 3;
	var PAD_FACE_1 = 0;
	var PAD_FACE_2 = 1;
	var PAD_FACE_3 = 2;
	var PAD_FACE_4 = 3;
	var PAD_L_SHOULDER_1 = 4;
	var PAD_R_SHOULDER_1 = 5;
	var PAD_L_SHOULDER_2 = 6;
	var PAD_R_SHOULDER_2 = 7;
	var PAD_SELECT = 8;
	var PAD_START = 9;
	var PAD_L_STICK_BUTTON = 10;
	var PAD_R_STICK_BUTTON = 11;
	var PAD_UP = 12;
	var PAD_DOWN = 13;
	var PAD_LEFT = 14;
	var PAD_RIGHT = 15;
	var PAD_VENDOR = 16;
	var PAD_L_STICK_X = 0;
	var PAD_L_STICK_Y = 1;
	var PAD_R_STICK_X = 2;
	var PAD_R_STICK_Y = 3;

	function KeyboardEvent(keyboard, event) {
		if (event) {
			this.key = event.keyCode;
			this.element = event.target;
			this.event = event;
		} else {
			this.key = null;
			this.element = null;
			this.event = null;
		}
	}
	var _keyboardEvent = new KeyboardEvent();
	function makeKeyboardEvent(event) {
		_keyboardEvent.key = event.keyCode;
		_keyboardEvent.element = event.target;
		_keyboardEvent.event = event;
		return _keyboardEvent;
	}
	function toKeyCode(s){
		if (typeof s === "string") {
			return s.toUpperCase().charCodeAt(0);
		}
		return s;
	}
	var _keyCodeToKeyIdentifier = {
		'9': 'Tab',
		'13': 'Enter',
		'16': 'Shift',
		'17': 'Control',
		'18': 'Alt',
		'27': 'Escape',
		'37': 'Left',
		'38': 'Up',
		'39': 'Right',
		'40': 'Down',
		'46': 'Delete',
		'91': 'Win'
	};
	function Keyboard(element, options) {
		EventHandler.call(this);
		options = options || {};
		this._element = null;
		this._keyDownHandler = this._handleKeyDown.bind(this);
		this._keyUpHandler = this._handleKeyUp.bind(this);
		this._keyPressHandler = this._handleKeyPress.bind(this);
		this._keymap = {};
		this._lastmap = {};
		if (element) {
			this.attach(element);
		}
		this.preventDefault = options.preventDefault || false;
		this.stopPropagation = options.stopPropagation || false;
	}
	Keyboard.prototype = Object.create(EventHandler.prototype);
	Keyboard.prototype.constructor = Keyboard;
	Keyboard.prototype.attach = function (element) {
		if (this._element) {
			this.detach();
		}
		this._element = element;
		this._element.addEventListener("keydown", this._keyDownHandler, false);
		this._element.addEventListener("keypress", this._keyPressHandler, false);
		this._element.addEventListener("keyup", this._keyUpHandler, false);
	};
	Keyboard.prototype.detach = function () {
		this._element.removeEventListener("keydown", this._keyDownHandler);
		this._element.removeEventListener("keypress", this._keyPressHandler);
		this._element.removeEventListener("keyup", this._keyUpHandler);
		this._element = null;
	};
	Keyboard.prototype.toKeyIdentifier = function (keyCode){
		keyCode = toKeyCode(keyCode);
		var count;
		var hex;
		var length;
		var id = _keyCodeToKeyIdentifier[keyCode.toString()];
		if (id) {
			return id;
		}
		hex = keyCode.toString(16).toUpperCase();
		length = hex.length;
		for (count = 0; count < (4 - length); count++) {
			hex = '0' + hex;
		}
		return 'U+' + hex;
	};
	Keyboard.prototype._handleKeyDown = function (event) {
		var code = event.keyCode || event.charCode;
		if (code === undefined) return;
		var id = this.toKeyIdentifier(code);
		this._keymap[id] = true;
		this.fire("keydown", makeKeyboardEvent(event));
		if (this.preventDefault) {
			event.preventDefault();
		}
		if (this.stopPropagation) {
			event.stopPropagation();
		}
	};
	Keyboard.prototype._handleKeyUp = function (event){
		var code = event.keyCode || event.charCode;
		if (code === undefined) return;
		var id = this.toKeyIdentifier(code);
		delete this._keymap[id];
		this.fire("keyup", makeKeyboardEvent(event));
		if (this.preventDefault) {
			event.preventDefault();
		}
		if (this.stopPropagation) {
			event.stopPropagation();
		}
	};
	Keyboard.prototype._handleKeyPress = function (event){
		this.fire("keypress", makeKeyboardEvent(event));
		if (this.preventDefault) {
			event.preventDefault();
		}
		if (this.stopPropagation) {
			event.stopPropagation();
		}
	};
	Keyboard.prototype.update = function () {
		var prop;
		for (prop in this._lastmap) {
			delete this._lastmap[prop];
		}
		for (prop in this._keymap) {
			if (this._keymap.hasOwnProperty(prop)) {
				this._lastmap[prop] = this._keymap[prop];
			}
		}
	};
	Keyboard.prototype.isPressed = function (key) {
		var keyCode = toKeyCode(key);
		var id = this.toKeyIdentifier(keyCode);
		return !!(this._keymap[id]);
	};
	Keyboard.prototype.wasPressed = function (key) {
		var keyCode = toKeyCode(key);
		var id = this.toKeyIdentifier(keyCode);
		return (!!(this._keymap[id]) && !!!(this._lastmap[id]));
	};
	Keyboard.prototype.wasReleased = function (key) {
		var keyCode = toKeyCode(key);
		var id = this.toKeyIdentifier(keyCode);
		return (!!!(this._keymap[id]) && !!(this._lastmap[id]));
	};

	function MouseEvent(mouse, event) {
		var coords = {
			x: 0,
			y: 0
		};
		if (event) {
			if (event instanceof MouseEvent) {
				throw Error("Expected MouseEvent");
			}
			coords = mouse._getTargetCoords(event);
		} else {
			event = { };
		}
		if (coords) {
			this.x = coords.x;
			this.y = coords.y;
		} else if (Mouse.isPointerLocked()) {
			this.x = 0;
			this.y = 0;
		} else {
			return;
		}
		this.wheelDelta = 0;
		if (event.type === 'wheel') {
			if (event.deltaY > 0) {
				this.wheelDelta = 1;
			} else if (event.deltaY < 0) {
				this.wheelDelta = -1;
			}
		}
		if (Mouse.isPointerLocked()) {
			this.dx = event.movementX || event.webkitMovementX || event.mozMovementX || 0;
			this.dy = event.movementY || event.webkitMovementY || event.mozMovementY || 0;
		} else {
			this.dx = this.x - mouse._lastX;
			this.dy = this.y - mouse._lastY;
		}
		if (event.type === 'mousedown' || event.type === 'mouseup') {
			this.button = event.button;
		} else {
			this.button = MOUSEBUTTON_NONE;
		}
		this.buttons = mouse._buttons.slice(0);
		this.element = event.target;
		this.ctrlKey = event.ctrlKey || false;
		this.altKey = event.altKey || false;
		this.shiftKey = event.shiftKey || false;
		this.metaKey = event.metaKey || false;
		this.event = event;
	}
	function Mouse(element) {
		EventHandler.call(this);
		this._lastX	  = 0;
		this._lastY	  = 0;
		this._buttons	  = [false, false, false];
		this._lastbuttons  = [false, false, false];
		this._upHandler = this._handleUp.bind(this);
		this._downHandler = this._handleDown.bind(this);
		this._moveHandler = this._handleMove.bind(this);
		this._wheelHandler = this._handleWheel.bind(this);
		this._contextMenuHandler = function (event) {
			event.preventDefault();
		};
		this._target = null;
		this._attached = false;
		this.attach(element);
	}
	Mouse.prototype = Object.create(EventHandler.prototype);
	Mouse.prototype.constructor = Mouse;
	Mouse.isPointerLocked = function () {
		return !!(document.pointerLockElement || document.mozPointerLockElement || document.webkitPointerLockElement);
	};
	Object.assign(Mouse.prototype, {
		attach: function (element) {
			this._target = element;
			if (this._attached) return;
			this._attached = true;
			var opts = platform.passiveEvents ? { passive: false } : false;
			window.addEventListener("mouseup", this._upHandler, opts);
			window.addEventListener("mousedown", this._downHandler, opts);
			window.addEventListener("mousemove", this._moveHandler, opts);
			window.addEventListener("wheel", this._wheelHandler, opts);
		},
		detach: function () {
			if (!this._attached) return;
			this._attached = false;
			this._target = null;
			var opts = platform.passiveEvents ? { passive: false } : false;
			window.removeEventListener("mouseup", this._upHandler, opts);
			window.removeEventListener("mousedown", this._downHandler, opts);
			window.removeEventListener("mousemove", this._moveHandler, opts);
			window.removeEventListener("wheel", this._wheelHandler, opts);
		},
		disableContextMenu: function () {
			if (!this._target) return;
			this._target.addEventListener("contextmenu", this._contextMenuHandler);
		},
		enableContextMenu: function () {
			if (!this._target) return;
			this._target.removeEventListener("contextmenu", this._contextMenuHandler);
		},
		enablePointerLock: function (success, error) {
			if (!document.body.requestPointerLock) {
				if (error)
					error();
				return;
			}
			var s = function () {
				success();
				document.removeEventListener('pointerlockchange', s);
			};
			var e = function () {
				error();
				document.removeEventListener('pointerlockerror', e);
			};
			if (success) {
				document.addEventListener('pointerlockchange', s, false);
			}
			if (error) {
				document.addEventListener('pointerlockerror', e, false);
			}
			document.body.requestPointerLock();
		},
		disablePointerLock: function (success) {
			if (!document.exitPointerLock) {
				return;
			}
			var s = function () {
				success();
				document.removeEventListener('pointerlockchange', s);
			};
			if (success) {
				document.addEventListener('pointerlockchange', s, false);
			}
			document.exitPointerLock();
		},
		update: function () {
			this._lastbuttons[0] = this._buttons[0];
			this._lastbuttons[1] = this._buttons[1];
			this._lastbuttons[2] = this._buttons[2];
		},
		isPressed: function (button) {
			return this._buttons[button];
		},
		wasPressed: function (button) {
			return (this._buttons[button] && !this._lastbuttons[button]);
		},
		wasReleased: function (button) {
			return (!this._buttons[button] && this._lastbuttons[button]);
		},
		_handleUp: function (event) {
			this._buttons[event.button] = false;
			var e = new MouseEvent(this, event);
			if (!e.event) return;
			this.fire(EVENT_MOUSEUP, e);
		},
		_handleDown: function (event) {
			this._buttons[event.button] = true;
			var e = new MouseEvent(this, event);
			if (!e.event) return;
			this.fire(EVENT_MOUSEDOWN, e);
		},
		_handleMove: function (event) {
			var e = new MouseEvent(this, event);
			if (!e.event) return;
			this.fire(EVENT_MOUSEMOVE, e);
			this._lastX = e.x;
			this._lastY = e.y;
		},
		_handleWheel: function (event) {
			var e = new MouseEvent(this, event);
			if (!e.event) return;
			this.fire(EVENT_MOUSEWHEEL, e);
		},
		_getTargetCoords: function (event) {
			var rect = this._target.getBoundingClientRect();
			var left = Math.floor(rect.left);
			var top = Math.floor(rect.top);
			if (event.clientX < left ||
				event.clientX >= left + this._target.clientWidth ||
				event.clientY < top ||
				event.clientY >= top + this._target.clientHeight) {
				return null;
			}
			return {
				x: event.clientX - left,
				y: event.clientY - top
			};
		}
	});

	function Controller(element, options) {
		options = options || {};
		this._keyboard = options.keyboard || null;
		this._mouse = options.mouse || null;
		this._gamepads = options.gamepads || null;
		this._element = null;
		this._actions = {};
		this._axes = {};
		this._axesValues = {};
		if (element) {
			this.attach(element);
		}
	}
	Controller.prototype.attach = function (element) {
		this._element = element;
		if (this._keyboard) {
			this._keyboard.attach(element);
		}
		if (this._mouse) {
			this._mouse.attach(element);
		}
	};
	Controller.prototype.detach = function () {
		if (this._keyboard) {
			this._keyboard.detach();
		}
		if (this._mouse) {
			this._mouse.detach();
		}
		this._element = null;
	};
	Controller.prototype.disableContextMenu = function () {
		if (!this._mouse) {
			this._enableMouse();
		}
		this._mouse.disableContextMenu();
	};
	Controller.prototype.enableContextMenu = function () {
		if (!this._mouse) {
			this._enableMouse();
		}
		this._mouse.enableContextMenu();
	};
	Controller.prototype.update = function (dt) {
		if (this._keyboard) {
			this._keyboard.update(dt);
		}
		if (this._mouse) {
			this._mouse.update(dt);
		}
		if (this._gamepads) {
			this._gamepads.update(dt);
		}
		this._axesValues = {};
		for (var key in this._axes) {
			this._axesValues[key] = [];
		}
	};
	Controller.prototype.registerKeys = function (action, keys) {
		if (!this._keyboard) {
			this._enableKeyboard();
		}
		if (this._actions[action]) {
			throw new Error("Action: " + action + " already registered");
		}
		if (keys === undefined) {
			throw new Error("Invalid button");
		}
		if (!keys.length) {
			keys = [keys];
		}
		if (this._actions[action]) {
			this._actions[action].push({
				type: ACTION_KEYBOARD,
				keys: keys
			});
		} else {
			this._actions[action] = [{
				type: ACTION_KEYBOARD,
				keys: keys
			}];
		}
	};
	Controller.prototype.registerMouse = function (action, button) {
		if (!this._mouse) {
			this._enableMouse();
		}
		if (button === undefined) {
			throw new Error('Invalid button');
		}
		if (this._actions[action]) {
			this._actions[action].push({
				type: ACTION_MOUSE,
				button: button
			});
		} else {
			this._actions[action] = [{
				type: ACTION_MOUSE,
				button: -button
			}];
		}
	};
	Controller.prototype.registerPadButton = function (action, pad, button) {
		if (button === undefined) {
			throw new Error('Invalid button');
		}
		if (this._actions[action]) {
			this._actions[action].push({
				type: ACTION_GAMEPAD,
				button: button,
				pad: pad
			});
		} else {
			this._actions[action] = [{
				type: ACTION_GAMEPAD,
				button: button,
				pad: pad
			}];
		}
	};
	Controller.prototype.registerAxis = function (options) {
		var name = options.name;
		if (!this._axes[name]) {
			this._axes[name] = [];
		}
		var i = this._axes[name].push(name);
		options = options || {};
		options.pad = options.pad || PAD_1;
		var bind = function (controller, source, value, key) {
			switch (source) {
				case 'mousex':
					controller._mouse.on(EVENT_MOUSEMOVE, function (e) {
						controller._axesValues[name][i] = e.dx / 10;
					});
					break;
				case 'mousey':
					controller._mouse.on(EVENT_MOUSEMOVE, function (e) {
						controller._axesValues[name][i] = e.dy / 10;
					});
					break;
				case 'key':
					controller._axes[name].push(function () {
						return controller._keyboard.isPressed(key) ? value : 0;
					});
					break;
				case 'padrx':
					controller._axes[name].push(function () {
						return controller._gamepads.getAxis(options.pad, PAD_R_STICK_X);
					});
					break;
				case 'padry':
					controller._axes[name].push(function () {
						return controller._gamepads.getAxis(options.pad, PAD_R_STICK_Y);
					});
					break;
				case 'padlx':
					controller._axes[name].push(function () {
						return controller._gamepads.getAxis(options.pad, PAD_L_STICK_X);
					});
					break;
				case 'padly':
					controller._axes[name].push(function () {
						return controller._gamepads.getAxis(options.pad, PAD_L_STICK_Y);
					});
					break;
				default:
					throw new Error('Unknown axis');
			}
		};
		bind(this, options.positive, 1, options.positiveKey);
		if (options.negativeKey || options.negative !== options.positive) {
			bind(this, options.negative, -1, options.negativeKey);
		}
	};
	Controller.prototype.isPressed = function (actionName) {
		if (!this._actions[actionName]) {
			return false;
		}
		var action;
		var index = 0;
		var length = this._actions[actionName].length;
		for (index = 0; index < length; ++index) {
			action = this._actions[actionName][index];
			switch (action.type) {
				case ACTION_KEYBOARD:
					if (this._keyboard) {
						var i, len = action.keys.length;
						for (i = 0; i < len; i++) {
							if (this._keyboard.isPressed(action.keys[i])) {
								return true;
							}
						}
					}
					break;
				case ACTION_MOUSE:
					if (this._mouse && this._mouse.isPressed(action.button)) {
						return true;
					}
					break;
				case ACTION_GAMEPAD:
					if (this._gamepads && this._gamepads.isPressed(action.pad, action.button)) {
						return true;
					}
					break;
			}
		}
		return false;
	};
	Controller.prototype.wasPressed = function (actionName) {
		if (!this._actions[actionName]) {
			return false;
		}
		var index = 0;
		var length = this._actions[actionName].length;
		for (index = 0; index < length; ++index) {
			var action = this._actions[actionName][index];
			switch (action.type) {
				case ACTION_KEYBOARD:
					if (this._keyboard) {
						var i, len = action.keys.length;
						for (i = 0; i < len; i++) {
							if (this._keyboard.wasPressed(action.keys[i])) {
								return true;
							}
						}
					}
					break;
				case ACTION_MOUSE:
					if (this._mouse && this._mouse.wasPressed(action.button)) {
						return true;
					}
					break;
				case ACTION_GAMEPAD:
					if (this._gamepads && this._gamepads.wasPressed(action.pad, action.button)) {
						return true;
					}
					break;
			}
		}
		return false;
	};
	Controller.prototype.getAxis = function (name) {
		var value = 0;
		if (this._axes[name]) {
			var i, len = this._axes[name].length;
			for (i = 0; i < len; i++) {
				if (type(this._axes[name][i]) === 'function') {
					var v = this._axes[name][i]();
					if (Math.abs(v) > Math.abs(value)) {
						value = v;
					}
				} else if (this._axesValues[name]) {
					if (Math.abs(this._axesValues[name][i]) > Math.abs(value)) {
						value = this._axesValues[name][i];
					}
				}
			}
		}
		return value;
	};
	Controller.prototype._enableMouse = function () {
		this._mouse = new Mouse();
		if (!this._element) {
			throw new Error("Controller must be attached to an Element");
		}
		this._mouse.attach(this._element);
	};
	Controller.prototype._enableKeyboard = function () {
		this._keyboard = new Keyboard();
		if (!this._element) {
			throw new Error("Controller must be attached to an Element");
		}
		this._keyboard.attach(this._element);
	};

	var targetX, targetY;
	var vecA$2 = new Vec3();
	var vecB$2 = new Vec3();
	var rayA = new Ray();
	var rayB = new Ray();
	var rayC = new Ray();
	rayA.end = new Vec3();
	rayB.end = new Vec3();
	rayC.end = new Vec3();
	var _pq = new Vec3();
	var _pa = new Vec3();
	var _pb = new Vec3();
	var _pc = new Vec3();
	var _pd = new Vec3();
	var _m = new Vec3();
	var _sct = new Vec3();
	var _accumulatedScale = new Vec2();
	var _paddingTop = new Vec3();
	var _paddingBottom = new Vec3();
	var _paddingLeft = new Vec3();
	var _paddingRight = new Vec3();
	var _cornerBottomLeft = new Vec3();
	var _cornerBottomRight = new Vec3();
	var _cornerTopRight = new Vec3();
	var _cornerTopLeft = new Vec3();
	var ZERO_VEC4 = new Vec4();
	function scalarTriple(p1, p2, p3) {
		return _sct.cross(p1, p2).dot(p3);
	}
	function intersectLineQuad(p, q, corners) {
		_pq.sub2(q, p);
		_pa.sub2(corners[0], p);
		_pb.sub2(corners[1], p);
		_pc.sub2(corners[2], p);
		_m.cross(_pc, _pq);
		var v = _pa.dot(_m);
		if (v >= 0) {
			if (-_pb.dot(_m) < 0)
				return false;
			if (scalarTriple(_pq, _pb, _pa) < 0)
				return false;
		} else {
			_pd.sub2(corners[3], p);
			if (_pd.dot(_m) < 0)
				return false;
			if (scalarTriple(_pq, _pa, _pd) < 0)
				return false;
		}
		if (_pq.sub2(corners[0], corners[2]).lengthSq() < 0.0001 * 0.0001) return false;
		if (_pq.sub2(corners[1], corners[3]).lengthSq() < 0.0001 * 0.0001) return false;
		return true;
	}
	function ElementInputEvent(event, element, camera) {
		this.event = event;
		this.element = element;
		this.camera = camera;
		this._stopPropagation = false;
	}
	Object.assign(ElementInputEvent.prototype, {
		stopPropagation: function () {
			this._stopPropagation = true;
			if (this.event) {
				this.event.stopImmediatePropagation();
				this.event.stopPropagation();
			}
		}
	});
	function ElementMouseEvent(event, element, camera, x, y, lastX, lastY) {
		ElementInputEvent.call(this, event, element, camera);
		this.x = x;
		this.y = y;
		this.ctrlKey = event.ctrlKey || false;
		this.altKey = event.altKey || false;
		this.shiftKey = event.shiftKey || false;
		this.metaKey = event.metaKey || false;
		this.button = event.button;
		if (Mouse.isPointerLocked()) {
			this.dx = event.movementX || event.webkitMovementX || event.mozMovementX || 0;
			this.dy = event.movementY || event.webkitMovementY || event.mozMovementY || 0;
		} else {
			this.dx = x - lastX;
			this.dy = y - lastY;
		}
		this.wheelDelta = 0;
		if (event.type === 'wheel') {
			if (event.deltaY > 0) {
				this.wheelDelta = 1;
			} else if (event.deltaY < 0) {
				this.wheelDelta = -1;
			}
		}
	}
	ElementMouseEvent.prototype = Object.create(ElementInputEvent.prototype);
	ElementMouseEvent.prototype.constructor = ElementMouseEvent;
	function ElementTouchEvent(event, element, camera, x, y, touch) {
		ElementInputEvent.call(this, event, element, camera);
		this.touches = event.touches;
		this.changedTouches = event.changedTouches;
		this.x = x;
		this.y = y;
		this.touch = touch;
	}
	ElementTouchEvent.prototype = Object.create(ElementInputEvent.prototype);
	ElementTouchEvent.prototype.constructor = ElementTouchEvent;
	function ElementSelectEvent(event, element, camera, inputSource) {
		ElementInputEvent.call(this, event, element, camera);
		this.inputSource = inputSource;
	}
	ElementSelectEvent.prototype = Object.create(ElementInputEvent.prototype);
	ElementSelectEvent.prototype.constructor = ElementSelectEvent;
	function ElementInput(domElement, options) {
		this._app = null;
		this._attached = false;
		this._target = null;
		this._enabled = true;
		this._lastX = 0;
		this._lastY = 0;
		this._upHandler = this._handleUp.bind(this);
		this._downHandler = this._handleDown.bind(this);
		this._moveHandler = this._handleMove.bind(this);
		this._wheelHandler = this._handleWheel.bind(this);
		this._touchstartHandler = this._handleTouchStart.bind(this);
		this._touchendHandler = this._handleTouchEnd.bind(this);
		this._touchcancelHandler = this._touchendHandler;
		this._touchmoveHandler = this._handleTouchMove.bind(this);
		this._sortHandler = this._sortElements.bind(this);
		this._elements = [];
		this._hoveredElement = null;
		this._pressedElement = null;
		this._touchedElements = {};
		this._touchesForWhichTouchLeaveHasFired = {};
		this._selectedElements = {};
		this._selectedPressedElements = {};
		this._useMouse = !options || options.useMouse !== false;
		this._useTouch = !options || options.useTouch !== false;
		this._useXr = !options || options.useXr !== false;
		this._selectEventsAttached = false;
		if (platform.touch)
			this._clickedEntities = {};
		this.attach(domElement);
	}
	Object.assign(ElementInput.prototype, {
		attach: function (domElement) {
			if (this._attached) {
				this._attached = false;
				this.detach();
			}
			this._target = domElement;
			this._attached = true;
			var opts = platform.passiveEvents ? { passive: true } : false;
			if (this._useMouse) {
				window.addEventListener('mouseup', this._upHandler, opts);
				window.addEventListener('mousedown', this._downHandler, opts);
				window.addEventListener('mousemove', this._moveHandler, opts);
				window.addEventListener('wheel', this._wheelHandler, opts);
			}
			if (this._useTouch && platform.touch) {
				this._target.addEventListener('touchstart', this._touchstartHandler, opts);
				this._target.addEventListener('touchend', this._touchendHandler, false);
				this._target.addEventListener('touchmove', this._touchmoveHandler, false);
				this._target.addEventListener('touchcancel', this._touchcancelHandler, false);
			}
			this.attachSelectEvents();
		},
		attachSelectEvents: function () {
			if (! this._selectEventsAttached && this._useXr && this.app && this.app.xr && this.app.xr.supported) {
				if (! this._clickedEntities)
					this._clickedEntities = {};
				this._selectEventsAttached = true;
				this.app.xr.on('start', this._onXrStart, this);
			}
		},
		detach: function () {
			if (!this._attached) return;
			this._attached = false;
			var opts = platform.passiveEvents ? { passive: true } : false;
			if (this._useMouse) {
				window.removeEventListener('mouseup', this._upHandler, opts);
				window.removeEventListener('mousedown', this._downHandler, opts);
				window.removeEventListener('mousemove', this._moveHandler, opts);
				window.removeEventListener('wheel', this._wheelHandler, opts);
			}
			if (this._useTouch) {
				this._target.removeEventListener('touchstart', this._touchstartHandler, opts);
				this._target.removeEventListener('touchend', this._touchendHandler, false);
				this._target.removeEventListener('touchmove', this._touchmoveHandler, false);
				this._target.removeEventListener('touchcancel', this._touchcancelHandler, false);
			}
			if (this._selectEventsAttached) {
				this._selectEventsAttached = false;
				this.app.xr.off('start', this._onXrStart, this);
				this.app.xr.off('end', this._onXrEnd, this);
				this.app.xr.off('update', this._onXrUpdate, this);
				this.app.xr.input.off('selectstart', this._onSelectStart, this);
				this.app.xr.input.off('selectend', this._onSelectEnd, this);
				this.app.xr.input.off('remove', this._onXrInputRemove, this);
			}
			this._target = null;
		},
		addElement: function (element) {
			if (this._elements.indexOf(element) === -1)
				this._elements.push(element);
		},
		removeElement: function (element) {
			var idx = this._elements.indexOf(element);
			if (idx !== -1)
				this._elements.splice(idx, 1);
		},
		_handleUp: function (event) {
			if (!this._enabled) return;
			if (Mouse.isPointerLocked())
				return;
			this._calcMouseCoords(event);
			if (targetX === null)
				return;
			this._onElementMouseEvent('mouseup', event);
		},
		_handleDown: function (event) {
			if (!this._enabled) return;
			if (Mouse.isPointerLocked())
				return;
			this._calcMouseCoords(event);
			if (targetX === null)
				return;
			this._onElementMouseEvent('mousedown', event);
		},
		_handleMove: function (event) {
			if (!this._enabled) return;
			this._calcMouseCoords(event);
			if (targetX === null)
				return;
			this._onElementMouseEvent('mousemove', event);
			this._lastX = targetX;
			this._lastY = targetY;
		},
		_handleWheel: function (event) {
			if (!this._enabled) return;
			this._calcMouseCoords(event);
			if (targetX === null)
				return;
			this._onElementMouseEvent('mousewheel', event);
		},
		_determineTouchedElements: function (event) {
			var touchedElements = {};
			var cameras = this.app.systems.camera.cameras;
			var i, j, len;
			for (i = cameras.length - 1; i >= 0; i--) {
				var camera = cameras[i];
				var done = 0;
				for (j = 0, len = event.changedTouches.length; j < len; j++) {
					if (touchedElements[event.changedTouches[j].identifier]) {
						done++;
						continue;
					}
					var coords = this._calcTouchCoords(event.changedTouches[j]);
					var element = this._getTargetElement(camera, coords.x, coords.y);
					if (element) {
						done++;
						touchedElements[event.changedTouches[j].identifier] = {
							element: element,
							camera: camera,
							x: coords.x,
							y: coords.y
						};
					}
				}
				if (done === len) {
					break;
				}
			}
			return touchedElements;
		},
		_handleTouchStart: function (event) {
			if (!this._enabled) return;
			var newTouchedElements = this._determineTouchedElements(event);
			for (var i = 0, len = event.changedTouches.length; i < len; i++) {
				var touch = event.changedTouches[i];
				var newTouchInfo = newTouchedElements[touch.identifier];
				var oldTouchInfo = this._touchedElements[touch.identifier];
				if (newTouchInfo && (!oldTouchInfo || newTouchInfo.element !== oldTouchInfo.element)) {
					this._fireEvent(event.type, new ElementTouchEvent(event, newTouchInfo.element, newTouchInfo.camera, newTouchInfo.x, newTouchInfo.y, touch));
					this._touchesForWhichTouchLeaveHasFired[touch.identifier] = false;
				}
			}
			for (var touchId in newTouchedElements) {
				this._touchedElements[touchId] = newTouchedElements[touchId];
			}
		},
		_handleTouchEnd: function (event) {
			if (!this._enabled) return;
			var cameras = this.app.systems.camera.cameras;
			for (var key in this._clickedEntities) {
				delete this._clickedEntities[key];
			}
			for (var i = 0, len = event.changedTouches.length; i < len; i++) {
				var touch = event.changedTouches[i];
				var touchInfo = this._touchedElements[touch.identifier];
				if (!touchInfo)
					continue;
				var element = touchInfo.element;
				var camera = touchInfo.camera;
				var x = touchInfo.x;
				var y = touchInfo.y;
				delete this._touchedElements[touch.identifier];
				delete this._touchesForWhichTouchLeaveHasFired[touch.identifier];
				this._fireEvent(event.type, new ElementTouchEvent(event, element, camera, x, y, touch));
				if (event.touches.length === 0) {
					var coords = this._calcTouchCoords(touch);
					for (var c = cameras.length - 1; c >= 0; c--) {
						var hovered = this._getTargetElement(cameras[c], coords.x, coords.y);
						if (hovered === element) {
							if (!this._clickedEntities[element.entity.getGuid()]) {
								this._fireEvent('click', new ElementTouchEvent(event, element, camera, x, y, touch));
								this._clickedEntities[element.entity.getGuid()] = true;
							}
						}
					}
				}
			}
		},
		_handleTouchMove: function (event) {
			event.preventDefault();
			if (!this._enabled) return;
			var newTouchedElements = this._determineTouchedElements(event);
			for (var i = 0, len = event.changedTouches.length; i < len; i++) {
				var touch = event.changedTouches[i];
				var newTouchInfo = newTouchedElements[touch.identifier];
				var oldTouchInfo = this._touchedElements[touch.identifier];
				if (oldTouchInfo) {
					var coords = this._calcTouchCoords(touch);
					if ((!newTouchInfo || newTouchInfo.element !== oldTouchInfo.element) && !this._touchesForWhichTouchLeaveHasFired[touch.identifier]) {
						this._fireEvent('touchleave', new ElementTouchEvent(event, oldTouchInfo.element, oldTouchInfo.camera, coords.x, coords.y, touch));
						this._touchesForWhichTouchLeaveHasFired[touch.identifier] = true;
					}
					this._fireEvent('touchmove', new ElementTouchEvent(event, oldTouchInfo.element, oldTouchInfo.camera, coords.x, coords.y, touch));
				}
			}
		},
		_onElementMouseEvent: function (eventType, event) {
			var element;
			var hovered = this._hoveredElement;
			this._hoveredElement = null;
			var cameras = this.app.systems.camera.cameras;
			var camera;
			for (var i = cameras.length - 1; i >= 0; i--) {
				camera = cameras[i];
				element = this._getTargetElement(camera, targetX, targetY);
				if (element)
					break;
			}
			if (element) {
				this._fireEvent(eventType, new ElementMouseEvent(event, element, camera, targetX, targetY, this._lastX, this._lastY));
				this._hoveredElement = element;
				if (eventType === 'mousedown') {
					this._pressedElement = element;
				}
			}
			if (hovered !== this._hoveredElement) {
				if (hovered) {
					this._fireEvent('mouseleave', new ElementMouseEvent(event, hovered, camera, targetX, targetY, this._lastX, this._lastY));
				}
				if (this._hoveredElement) {
					this._fireEvent('mouseenter', new ElementMouseEvent(event, this._hoveredElement, camera, targetX, targetY, this._lastX, this._lastY));
				}
			}
			if (eventType === 'mouseup' && this._pressedElement) {
				if (this._pressedElement === this._hoveredElement) {
					this._pressedElement = null;
					if (!this._clickedEntities || !this._clickedEntities[this._hoveredElement.entity.getGuid()]) {
						this._fireEvent('click', new ElementMouseEvent(event, this._hoveredElement, camera, targetX, targetY, this._lastX, this._lastY));
					}
				} else {
					this._pressedElement = null;
				}
			}
		},
		_onXrStart: function () {
			this.app.xr.on('end', this._onXrEnd, this);
			this.app.xr.on('update', this._onXrUpdate, this);
			this.app.xr.input.on('selectstart', this._onSelectStart, this);
			this.app.xr.input.on('selectend', this._onSelectEnd, this);
			this.app.xr.input.on('remove', this._onXrInputRemove, this);
		},
		_onXrEnd: function () {
			this.app.xr.off('update', this._onXrUpdate, this);
			this.app.xr.input.off('selectstart', this._onSelectStart, this);
			this.app.xr.input.off('selectend', this._onSelectEnd, this);
			this.app.xr.input.off('remove', this._onXrInputRemove, this);
		},
		_onXrUpdate: function () {
			if (!this._enabled) return;
			var inputSources = this.app.xr.input.inputSources;
			for (var i = 0; i < inputSources.length; i++) {
				this._onElementSelectEvent('selectmove', inputSources[i], null);
			}
		},
		_onXrInputRemove: function (inputSource) {
			var hovered = this._selectedElements[inputSource.id];
			if (hovered) {
				inputSource._elementEntity = null;
				this._fireEvent('selectleave', new ElementSelectEvent(null, hovered, null, inputSource));
			}
			delete this._selectedElements[inputSource.id];
			delete this._selectedPressedElements[inputSource.id];
		},
		_onSelectStart: function (inputSource, event) {
			if (! this._enabled) return;
			this._onElementSelectEvent('selectstart', inputSource, event);
		},
		_onSelectEnd: function (inputSource, event) {
			if (! this._enabled) return;
			this._onElementSelectEvent('selectend', inputSource, event);
		},
		_onElementSelectEvent: function (eventType, inputSource, event) {
			var element;
			var hoveredBefore = this._selectedElements[inputSource.id];
			var hoveredNow;
			var cameras = this.app.systems.camera.cameras;
			var camera;
			if (inputSource.elementInput) {
				rayC.set(inputSource.getOrigin(), inputSource.getDirection());
				for (var i = cameras.length - 1; i >= 0; i--) {
					camera = cameras[i];
					element = this._getTargetElementByRay(rayC, camera);
					if (element)
						break;
				}
			}
			inputSource._elementEntity = element || null;
			if (element) {
				this._selectedElements[inputSource.id] = element;
				hoveredNow = element;
			} else {
				delete this._selectedElements[inputSource.id];
			}
			if (hoveredBefore !== hoveredNow) {
				if (hoveredBefore) this._fireEvent('selectleave', new ElementSelectEvent(event, hoveredBefore, camera, inputSource));
				if (hoveredNow) this._fireEvent('selectenter', new ElementSelectEvent(event, hoveredNow, camera, inputSource));
			}
			if (eventType === 'selectstart') {
				this._selectedPressedElements[inputSource.id] = hoveredNow;
				if (hoveredNow) this._fireEvent('selectstart', new ElementSelectEvent(event, hoveredNow, camera, inputSource));
			}
			var pressed = this._selectedPressedElements[inputSource.id];
			if (! inputSource.elementInput && pressed) {
				delete this._selectedPressedElements[inputSource.id];
				if (hoveredBefore) this._fireEvent('selectend', new ElementSelectEvent(event, hoveredBefore, camera, inputSource));
			}
			if (eventType === 'selectend' && inputSource.elementInput) {
				delete this._selectedPressedElements[inputSource.id];
				if (hoveredBefore) this._fireEvent('selectend', new ElementSelectEvent(event, hoveredBefore, camera, inputSource));
				if (pressed && pressed === hoveredBefore) {
					this._fireEvent('click', new ElementSelectEvent(event, pressed, camera, inputSource));
				}
			}
		},
		_fireEvent: function (name, evt) {
			var element = evt.element;
			while (true) {
				element.fire(name, evt);
				if (evt._stopPropagation)
					break;
				if (!element.entity.parent)
					break;
				element = element.entity.parent.element;
				if (!element)
					break;
			}
		},
		_calcMouseCoords: function (event) {
			var rect = this._target.getBoundingClientRect();
			var left = Math.floor(rect.left);
			var top = Math.floor(rect.top);
			if (event.clientX < left ||
				event.clientX >= left + this._target.clientWidth ||
				event.clientY < top ||
				event.clientY >= top + this._target.clientHeight) {
				targetX = null;
				targetY = null;
			} else {
				targetX = (event.clientX - left);
				targetY = (event.clientY - top);
			}
		},
		_calcTouchCoords: function (touch) {
			var totalOffsetX = 0;
			var totalOffsetY = 0;
			var target = touch.target;
			while (!(target instanceof HTMLElement)) {
				target = target.parentNode;
			}
			var currentElement = target;
			do {
				totalOffsetX += currentElement.offsetLeft - currentElement.scrollLeft;
				totalOffsetY += currentElement.offsetTop - currentElement.scrollTop;
				currentElement = currentElement.offsetParent;
			} while (currentElement);
			return {
				x: (touch.pageX - totalOffsetX),
				y: (touch.pageY - totalOffsetY)
			};
		},
		_sortElements: function (a, b) {
			var layerOrder = this.app.scene.layers.sortTransparentLayers(a.layers, b.layers);
			if (layerOrder !== 0) return layerOrder;
			if (a.screen && !b.screen)
				return -1;
			if (!a.screen && b.screen)
				return 1;
			if (!a.screen && !b.screen)
				return 0;
			if (a.screen.screen.screenSpace && !b.screen.screen.screenSpace)
				return -1;
			if (b.screen.screen.screenSpace && !a.screen.screen.screenSpace)
				return 1;
			return b.drawOrder - a.drawOrder;
		},
		_getTargetElement: function (camera, x, y) {
			var result = null;
			this._elements.sort(this._sortHandler);
			var rayScreen, ray3d;
			for (var i = 0, len = this._elements.length; i < len; i++) {
				var element = this._elements[i];
				var screen = false;
				var ray;
				if (element.screen && element.screen.screen.screenSpace) {
					if (rayScreen === undefined) {
						rayScreen = rayA;
						if (this._calculateRayScreen(x, y, camera, rayScreen) === false) {
							rayScreen = null;
						}
					}
					ray = rayScreen;
					screen = true;
				} else {
					if (ray3d === undefined) {
						ray3d = rayB;
						if (this._calculateRay3d(x, y, camera, ray3d) === false) {
							ray3d = null;
						}
					}
					ray = ray3d;
				}
				if (ray && this._checkElement(ray, element, screen)) {
					result = element;
					break;
				}
			}
			return result;
		},
		_getTargetElementByRay: function (ray, camera) {
			var result = null;
			rayA.origin.copy(ray.origin);
			rayA.direction.copy(ray.direction);
			rayA.end.copy(rayA.direction).scale(camera.farClip * 2).add(rayA.origin);
			this._elements.sort(this._sortHandler);
			for (var i = 0, len = this._elements.length; i < len; i++) {
				var element = this._elements[i];
				if (! element.screen || ! element.screen.screen.screenSpace) {
					if (this._checkElement(rayA, element, false)) {
						result = element;
						break;
					}
				}
			}
			return result;
		},
		_buildHitCorners: function (element, screenOrWorldCorners, scaleX, scaleY) {
			var hitCorners = screenOrWorldCorners;
			var button = element.entity && element.entity.button;
			if (button) {
				var hitPadding = element.entity.button.hitPadding || ZERO_VEC4;
				_paddingTop.copy(element.entity.up);
				_paddingBottom.copy(_paddingTop).scale(-1);
				_paddingRight.copy(element.entity.right);
				_paddingLeft.copy(_paddingRight).scale(-1);
				_paddingTop.scale(hitPadding.w * scaleY);
				_paddingBottom.scale(hitPadding.y * scaleY);
				_paddingRight.scale(hitPadding.z * scaleX);
				_paddingLeft.scale(hitPadding.x * scaleX);
				_cornerBottomLeft.copy(hitCorners[0]).add(_paddingBottom).add(_paddingLeft);
				_cornerBottomRight.copy(hitCorners[1]).add(_paddingBottom).add(_paddingRight);
				_cornerTopRight.copy(hitCorners[2]).add(_paddingTop).add(_paddingRight);
				_cornerTopLeft.copy(hitCorners[3]).add(_paddingTop).add(_paddingLeft);
				hitCorners = [_cornerBottomLeft, _cornerBottomRight, _cornerTopRight, _cornerTopLeft];
			}
			return hitCorners;
		},
		_calculateScaleToScreen: function (element) {
			var current = element.entity;
			var screenScale = element.screen.screen.scale;
			_accumulatedScale.set(screenScale, screenScale);
			while (current && !current.screen) {
				_accumulatedScale.mul(current.getLocalScale());
				current = current.parent;
			}
			return _accumulatedScale;
		},
		_calculateRayScreen: function (x, y, camera, ray) {
			var sw = this.app.graphicsDevice.width;
			var sh = this.app.graphicsDevice.height;
			var cameraWidth = camera.rect.z * sw;
			var cameraHeight = camera.rect.w * sh;
			var cameraLeft = camera.rect.x * sw;
			var cameraRight = cameraLeft + cameraWidth;
			var cameraBottom = (1 - camera.rect.y) * sh;
			var cameraTop = cameraBottom - cameraHeight;
			var _x = x * sw / this._target.clientWidth;
			var _y = y * sh / this._target.clientHeight;
			if (_x >= cameraLeft && _x <= cameraRight &&
				_y <= cameraBottom && _y >= cameraTop) {
				_x = sw * (_x - cameraLeft) / cameraWidth;
				_y = sh * (_y - cameraTop) / cameraHeight;
				_y = sh - _y;
				ray.origin.set(_x, _y, 1);
				ray.direction.set(0, 0, -1);
				ray.end.copy(ray.direction).scale(2).add(ray.origin);
				return true;
			}
			return false;
		},
		_calculateRay3d: function (x, y, camera, ray) {
			var sw = this._target.clientWidth;
			var sh = this._target.clientHeight;
			var cameraWidth = camera.rect.z * sw;
			var cameraHeight = camera.rect.w * sh;
			var cameraLeft = camera.rect.x * sw;
			var cameraRight = cameraLeft + cameraWidth;
			var cameraBottom = (1 - camera.rect.y) * sh;
			var cameraTop = cameraBottom - cameraHeight;
			var _x = x;
			var _y = y;
			if (x >= cameraLeft && x <= cameraRight &&
				y <= cameraBottom && _y >= cameraTop) {
				_x = sw * (_x - cameraLeft) / cameraWidth;
				_y = sh * (_y - (cameraTop)) / cameraHeight;
				camera.screenToWorld(_x, _y, camera.nearClip, vecA$2);
				camera.screenToWorld(_x, _y, camera.farClip, vecB$2);
				ray.origin.copy(vecA$2);
				ray.direction.set(0, 0, -1);
				ray.end.copy(vecB$2);
				return true;
			}
			return false;
		},
		_checkElement: function (ray, element, screen) {
			if (element.maskedBy) {
				var result = this._checkElement(ray, element.maskedBy.element, screen);
				if (!result) return false;
			}
			var scale;
			if (screen) {
				scale = this._calculateScaleToScreen(element);
			} else {
				scale = element.entity.getWorldTransform().getScale();
			}
			var corners = this._buildHitCorners(element, screen ? element.screenCorners : element.worldCorners, scale.x, scale.y);
			if (intersectLineQuad(ray.origin, ray.end, corners))
				return true;
			return false;
		}
	});
	Object.defineProperty(ElementInput.prototype, 'enabled', {
		get: function () {
			return this._enabled;
		},
		set: function (value) {
			this._enabled = value;
		}
	});
	Object.defineProperty(ElementInput.prototype, 'app', {
		get: function () {
			return this._app || Application.getApplication();
		},
		set: function (value) {
			this._app = value;
		}
	});

	function GamePads() {
		this.gamepadsSupported = !!navigator.getGamepads || !!navigator.webkitGetGamepads;
		this.current = [];
		this.previous = [];
		this.deadZone = 0.25;
	}
	var MAPS = {
		DEFAULT: {
			buttons: [
				'PAD_FACE_1',
				'PAD_FACE_2',
				'PAD_FACE_3',
				'PAD_FACE_4',
				'PAD_L_SHOULDER_1',
				'PAD_R_SHOULDER_1',
				'PAD_L_SHOULDER_2',
				'PAD_R_SHOULDER_2',
				'PAD_SELECT',
				'PAD_START',
				'PAD_L_STICK_BUTTON',
				'PAD_R_STICK_BUTTON',
				'PAD_UP',
				'PAD_DOWN',
				'PAD_LEFT',
				'PAD_RIGHT',
				'PAD_VENDOR'
			],
			axes: [
				'PAD_L_STICK_X',
				'PAD_L_STICK_Y',
				'PAD_R_STICK_X',
				'PAD_R_STICK_Y'
			]
		},
		PS3: {
			buttons: [
				'PAD_FACE_1',
				'PAD_FACE_2',
				'PAD_FACE_4',
				'PAD_FACE_3',
				'PAD_L_SHOULDER_1',
				'PAD_R_SHOULDER_1',
				'PAD_L_SHOULDER_2',
				'PAD_R_SHOULDER_2',
				'PAD_SELECT',
				'PAD_START',
				'PAD_L_STICK_BUTTON',
				'PAD_R_STICK_BUTTON',
				'PAD_UP',
				'PAD_DOWN',
				'PAD_LEFT',
				'PAD_RIGHT',
				'PAD_VENDOR'
			],
			axes: [
				'PAD_L_STICK_X',
				'PAD_L_STICK_Y',
				'PAD_R_STICK_X',
				'PAD_R_STICK_Y'
			]
		}
	};
	var PRODUCT_CODES = {
		'Product: 0268': 'PS3'
	};
	Object.assign(GamePads.prototype, {
		update: function () {
			var i, j, l;
			var buttons, buttonsLen;
			for (i = 0, l = this.current.length; i < l; i++) {
				buttons = this.current[i].pad.buttons;
				buttonsLen = buttons.length;
				for (j = 0; j < buttonsLen; j++) {
					if (this.previous[i] === undefined) {
						this.previous[i] = [];
					}
					this.previous[i][j] = buttons[j].pressed;
				}
			}
			var pads = this.poll();
			for (i = 0, l = pads.length; i < l; i++) {
				this.current[i] = pads[i];
			}
		},
		poll: function () {
			var pads = [];
			if (this.gamepadsSupported) {
				var padDevices = navigator.getGamepads ? navigator.getGamepads() : navigator.webkitGetGamepads();
				var i, len = padDevices.length;
				for (i = 0; i < len; i++) {
					if (padDevices[i]) {
						pads.push({
							map: this.getMap(padDevices[i]),
							pad: padDevices[i]
						});
					}
				}
			}
			return pads;
		},
		getMap: function (pad) {
			for (var code in PRODUCT_CODES) {
				if (pad.id.indexOf(code) >= 0) {
					return MAPS[PRODUCT_CODES[code]];
				}
			}
			return MAPS.DEFAULT;
		},
		isPressed: function (index, button) {
			if (!this.current[index]) {
				return false;
			}
			var key = this.current[index].map.buttons[button];
			return this.current[index].pad.buttons[pc[key]].pressed;
		},
		wasPressed: function (index, button) {
			if (!this.current[index]) {
				return false;
			}
			var key = this.current[index].map.buttons[button];
			var i = pc[key];
			return this.current[index].pad.buttons[i].pressed && !this.previous[index][i];
		},
		getAxis: function (index, axes) {
			if (!this.current[index]) {
				return false;
			}
			var key = this.current[index].map.axes[axes];
			var value = this.current[index].pad.axes[pc[key]];
			if (Math.abs(value) < this.deadZone) {
				value = 0;
			}
			return value;
		}
	});

	function Touch(touch) {
		var coords = getTouchTargetCoords(touch);
		this.id = touch.identifier;
		this.x = coords.x;
		this.y = coords.y;
		this.target = touch.target;
		this.touch = touch;
	}
	function TouchEvent(device, event) {
		this.element = event.target;
		this.event = event;
		this.touches = [];
		this.changedTouches = [];
		if (event) {
			var i, l = event.touches.length;
			for (i = 0; i < l; i++) {
				this.touches.push(new Touch(event.touches[i]));
			}
			l = event.changedTouches.length;
			for (i = 0; i < l; i++) {
				this.changedTouches.push(new Touch(event.changedTouches[i]));
			}
		}
	}
	Object.assign(TouchEvent.prototype, {
		getTouchById: function (id, list) {
			var i, l = list.length;
			for (i = 0; i < l; i++) {
				if (list[i].id === id) {
					return list[i];
				}
			}
			return null;
		}
	});
	function TouchDevice(element) {
		EventHandler.call(this);
		this._element = null;
		this._startHandler = this._handleTouchStart.bind(this);
		this._endHandler = this._handleTouchEnd.bind(this);
		this._moveHandler = this._handleTouchMove.bind(this);
		this._cancelHandler = this._handleTouchCancel.bind(this);
		this.attach(element);
	}
	TouchDevice.prototype = Object.create(EventHandler.prototype);
	TouchDevice.prototype.constructor = TouchDevice;
	Object.assign(TouchDevice.prototype, {
		attach: function (element) {
			if (this._element) {
				this.detach();
			}
			this._element = element;
			this._element.addEventListener('touchstart', this._startHandler, false);
			this._element.addEventListener('touchend', this._endHandler, false);
			this._element.addEventListener('touchmove', this._moveHandler, false);
			this._element.addEventListener('touchcancel', this._cancelHandler, false);
		},
		detach: function () {
			if (this._element) {
				this._element.removeEventListener('touchstart', this._startHandler, false);
				this._element.removeEventListener('touchend', this._endHandler, false);
				this._element.removeEventListener('touchmove', this._moveHandler, false);
				this._element.removeEventListener('touchcancel', this._cancelHandler, false);
			}
			this._element = null;
		},
		_handleTouchStart: function (e) {
			this.fire('touchstart', new TouchEvent(this, e));
		},
		_handleTouchEnd: function (e) {
			this.fire('touchend', new TouchEvent(this, e));
		},
		_handleTouchMove: function (e) {
			e.preventDefault();
			this.fire('touchmove', new TouchEvent(this, e));
		},
		_handleTouchCancel: function (e) {
			this.fire('touchcancel', new TouchEvent(this, e));
		}
	});
	function getTouchTargetCoords(touch) {
		var totalOffsetX = 0;
		var totalOffsetY = 0;
		var target = touch.target;
		while (!(target instanceof HTMLElement)) {
			target = target.parentNode;
		}
		var currentElement = target;
		do {
			totalOffsetX += currentElement.offsetLeft - currentElement.scrollLeft;
			totalOffsetY += currentElement.offsetTop - currentElement.scrollTop;
			currentElement = currentElement.offsetParent;
		} while (currentElement);
		return {
			x: touch.pageX - totalOffsetX,
			y: touch.pageY - totalOffsetY
		};
	}

	var MAX_TEXTURE_SIZE = 4096;
	var DEFAULT_TEXTURE_SIZE = 512;
	function CanvasFont(app, options) {
		EventHandler.call(this);
		this.type = "bitmap";
		this.app = app;
		this.intensity = 0;
		options = options || {};
		this.fontWeight = options.fontWeight || 'normal';
		this.fontSize = parseInt(options.fontSize, 10);
		this.glyphSize = this.fontSize;
		this.fontName = options.fontName || 'Arial';
		this.color = options.color || new Color(1, 1, 1);
		this.padding = options.padding || 0;
		var w = options.width > MAX_TEXTURE_SIZE ? MAX_TEXTURE_SIZE : (options.width || DEFAULT_TEXTURE_SIZE);
		var h = options.height > MAX_TEXTURE_SIZE ? MAX_TEXTURE_SIZE : (options.height || DEFAULT_TEXTURE_SIZE);
		var canvas = document.createElement('canvas');
		canvas.height = h;
		canvas.width = w;
		var texture = new Texture(this.app.graphicsDevice, {
			format: PIXELFORMAT_R8_G8_B8_A8,
			autoMipmap: true
		});
		texture.name = 'font';
		texture.setSource(canvas);
		texture.minFilter = FILTER_LINEAR_MIPMAP_LINEAR;
		texture.magFilter = FILTER_LINEAR;
		texture.addressU = ADDRESS_CLAMP_TO_EDGE;
		texture.addressV = ADDRESS_CLAMP_TO_EDGE;
		this.textures = [texture];
		this.chars = "";
		this.data = {};
	}
	CanvasFont.prototype = Object.create(EventHandler.prototype);
	CanvasFont.prototype.constructor = CanvasFont;
	CanvasFont.prototype.createTextures = function (text) {
		var _chars = this._normalizeCharsSet(text);
		if (_chars.length !== this.chars.length) {
			this._renderAtlas(_chars);
			return;
		}
		for (var i = 0; i < _chars.length; i++) {
			if (_chars[i] !== this.chars[i]) {
				this._renderAtlas(_chars);
				return;
			}
		}
	};
	CanvasFont.prototype.updateTextures = function (text) {
		var _chars = this._normalizeCharsSet(text);
		var newCharsSet = [];
		for (var i = 0; i < _chars.length; i++) {
			var char = _chars[i];
			if (!this.data.chars[char]) {
				newCharsSet.push(char);
			}
		}
		if (newCharsSet.length > 0) {
			this._renderAtlas(this.chars.concat(newCharsSet));
		}
	};
	CanvasFont.prototype.destroy = function () {
		for (var i = 0; i < this.textures.length; i++) {
			this.textures[i].destroy();
		}
		this.chars = null;
		this.color = null;
		this.data = null;
		this.fontName = null;
		this.fontSize = null;
		this.glyphSize = null;
		this.intensity = null;
		this.textures = null;
		this.type = null;
		this.fontWeight = null;
	};
	CanvasFont.prototype._getAndClearContext = function (canvas, clearColor) {
		var w = canvas.width;
		var h = canvas.height;
		var ctx = canvas.getContext('2d', {
			alpha: true
		});
		ctx.clearRect(0, 0, w, h);
		ctx.fillStyle = clearColor;
		ctx.fillRect(0, 0, w, h);
		return ctx;
	};
	CanvasFont.prototype._colorToRgbString = function (color, alpha) {
		var str;
		var r = Math.round(255 * color.r);
		var g = Math.round(255 * color.g);
		var b = Math.round(255 * color.b);
		if (alpha) {
			str = "rgba(" + r + ", " + g + ", " + b + ", " + color.a + ")";
		} else {
			str = "rgb(" + r + ", " + g + ", " + b + ")";
		}
		return str;
	};
	CanvasFont.prototype.renderCharacter = function (context, char, x, y, color) {
		context.fillStyle = color;
		context.fillText(char, x, y);
	};
	CanvasFont.prototype._renderAtlas = function (charsArray) {
		this.chars = charsArray;
		var numTextures = 1;
		var canvas = this.textures[numTextures - 1].getSource();
		var w = canvas.width;
		var h = canvas.height;
		var color = this._colorToRgbString(this.color, false);
		var a = this.color.a;
		this.color.a = 1 / 255;
		var transparent = this._colorToRgbString(this.color, true);
		this.color.a = a;
		var TEXT_ALIGN = 'center';
		var TEXT_BASELINE = 'alphabetic';
		var ctx = this._getAndClearContext(canvas, transparent);
		ctx.font = this.fontWeight + ' ' + this.fontSize.toString() + 'px ' + this.fontName;
		ctx.textAlign = TEXT_ALIGN;
		ctx.textBaseline = TEXT_BASELINE;
		this.data = this._createJson(this.chars, this.fontName, w, h);
		var symbols = string.getSymbols(this.chars.join(''));
		var prevNumTextures = this.textures.length;
		var maxHeight = 0;
		var maxDescent = 0;
		var metrics = {};
		var i, ch;
		for (i = 0; i < symbols.length; i++) {
			ch = symbols[i];
			metrics[ch] = this._getTextMetrics(ch);
			maxHeight = Math.max(maxHeight, metrics[ch].height);
			maxDescent = Math.max(maxDescent, metrics[ch].descent);
		}
		this.glyphSize = Math.max(this.glyphSize, maxHeight);
		var sx = this.glyphSize + this.padding * 2;
		var sy = this.glyphSize + this.padding * 2;
		var _xOffset = this.glyphSize / 2 + this.padding;
		var _yOffset = sy - maxDescent - this.padding;
		var _x = 0;
		var _y = 0;
		for (i = 0; i < symbols.length; i++) {
			ch = symbols[i];
			var code = string.getCodePoint(symbols[i]);
			var fs = this.fontSize;
			ctx.font = this.fontWeight + ' ' + fs.toString() + 'px ' + this.fontName;
			ctx.textAlign = TEXT_ALIGN;
			ctx.textBaseline = TEXT_BASELINE;
			var width = ctx.measureText(ch).width;
			if (width > fs) {
				fs = this.fontSize * this.fontSize / width;
				ctx.font = this.fontWeight + ' ' + fs.toString() + 'px ' + this.fontName;
				width = this.fontSize;
			}
			this.renderCharacter(ctx, ch, _x + _xOffset, _y + _yOffset, color);
			var xoffset = this.padding + (this.glyphSize - width) / 2;
			var yoffset = -this.padding + metrics[ch].descent - maxDescent;
			var xadvance = width;
			this._addChar(this.data, ch, code, _x, _y, sx, sy, xoffset, yoffset, xadvance, numTextures - 1, w, h);
			_x += sx;
			if (_x + sx > w) {
				_x = 0;
				_y += sy;
				if (_y + sy > h) {
					this.textures[numTextures - 1].upload();
					numTextures++;
					_y = 0;
					if (numTextures > prevNumTextures) {
						canvas = document.createElement('canvas');
						canvas.height = h;
						canvas.width = w;
						ctx = this._getAndClearContext(canvas, transparent);
						var texture = new Texture(this.app.graphicsDevice, {
							format: PIXELFORMAT_R8_G8_B8_A8,
							autoMipmap: true
						});
						texture.name = 'font-atlas';
						texture.setSource(canvas);
						texture.minFilter = FILTER_LINEAR_MIPMAP_LINEAR;
						texture.magFilter = FILTER_LINEAR;
						texture.addressU = ADDRESS_CLAMP_TO_EDGE;
						texture.addressV = ADDRESS_CLAMP_TO_EDGE;
						this.textures.push(texture);
					} else {
						canvas = this.textures[numTextures - 1].getSource();
						ctx = this._getAndClearContext(canvas, transparent);
					}
				}
			}
		}
		this.textures[numTextures - 1].upload();
		if (numTextures < prevNumTextures) {
			for (i = numTextures; i < prevNumTextures; i++) {
				this.textures[i].destroy();
			}
			this.textures.splice(numTextures);
		}
		this.fire("render");
	};
	CanvasFont.prototype._createJson = function (chars, fontName, width, height) {
		var base = {
			"version": 3,
			"intensity": this.intensity,
			"info": {
				"face": fontName,
				"width": width,
				"height": height,
				"maps": [{
					"width": width,
					"height": height
				}]
			},
			"chars": {}
		};
		return base;
	};
	CanvasFont.prototype._addChar = function (json, char, charCode, x, y, w, h, xoffset, yoffset, xadvance, mapNum, mapW, mapH) {
		if (json.info.maps.length < mapNum + 1) {
			json.info.maps.push({ "width": mapW, "height": mapH });
		}
		var scale = this.fontSize / 32;
		json.chars[char] = {
			"id": charCode,
			"letter": char,
			"x": x,
			"y": y,
			"width": w,
			"height": h,
			"xadvance": xadvance / scale,
			"xoffset": xoffset / scale,
			"yoffset": (yoffset + this.padding) / scale,
			"scale": scale,
			"range": 1,
			"map": mapNum,
			"bounds": [0, 0, w / scale, h / scale]
		};
	};
	CanvasFont.prototype._normalizeCharsSet = function (text) {
		var unicodeConverterFunc = this.app.systems.element.getUnicodeConverter();
		if (unicodeConverterFunc) {
			text = unicodeConverterFunc(text);
		}
		var set = {};
		var symbols = string.getSymbols(text);
		var i;
		for (i = 0; i < symbols.length; i++) {
			var ch = symbols[i];
			if (set[ch]) continue;
			set[ch] = ch;
		}
		var chars = Object.keys(set);
		return chars.sort();
	};
	CanvasFont.prototype._getTextMetrics = function (text) {
		var textSpan = document.createElement('span');
		textSpan.id = 'content-span';
		textSpan.innerHTML = text;
		var block = document.createElement("div");
		block.id = 'content-block';
		block.style.display = 'inline-block';
		block.style.width = '1px';
		block.style.height = '0px';
		var div = document.createElement('div');
		div.appendChild(textSpan);
		div.appendChild(block);
		div.style.font = this.fontName;
		div.style.fontSize = this.fontSize + 'px';
		var body = document.body;
		body.appendChild(div);
		var ascent = -1;
		var descent = -1;
		var height = -1;
		try {
			block.style['vertical-align'] = 'baseline';
			ascent = block.offsetTop - textSpan.offsetTop;
			block.style['vertical-align'] = 'bottom';
			height = block.offsetTop - textSpan.offsetTop;
			descent = height - ascent;
		} finally {
			document.body.removeChild(div);
		}
		return {
			ascent: ascent,
			descent: descent,
			height: height
		};
	};

	function ComponentData() {}

	var _backbufferRt = [null, null];
	var _constInput = null;
	var _constScreenSize;
	var _constScreenSizeValue = new Vec4();
	var _constScreenSizeValueUniform = new Float32Array(4);
	var _postEffectChain = [];
	var _backbufferRtUsed = false;
	var _backbufferRt2Used = false;
	var _backbufferRtWrittenByPost = false;
	var _regexUniforms = /uniform[ \t\n\r]+\S+[ \t\n\r]+\S+[ \t\n\r]*\;/g;
	var _regexUniformStart = /\S+[ \t\n\r]*\;/;
	var _regexUniformEnd = /[ \t\n\r]*\;/;
	var _regexVariables = /(float|int|bool|vec2|vec3|vec4|struct)([ \t\n\r]+[^\;]+[ \t\n\r]*\,*)+\;/g;
	var _regexVariableSurroundings = /(float|int|bool|vec2|vec3|vec4|struct|\,|\;|\{|\})/g;
	var _regexIrrelevantVariables = /(uniform|varying|in|out)[ \t\n\r]+(float|int|bool|vec2|vec3|vec4|struct)([ \t\n\r]+[^\;]+[ \t\n\r]*\,*)+\;/g;
	var _regexIrrelevantVariableSurroundings = /(float|int|bool|vec2|vec3|vec4|struct|uniform|varying|in|out|\,|\;|\{|\})/g;
	var _regexVersion = /#version/g;
	var _regexFragColor = /out highp vec4 pc_fragColor;/g;
	var _regexFragColor2 = /#define gl_FragColor/g;
	var _regexFragColor3 = /gl_FragColor/g;
	var _regexColorBuffer = /uniform[ \t\n\r]+sampler2D[ \t\n\r]+uColorBuffer;/g;
	var _regexUv = /(varying|in)[ \t\n\r]+vec2[ \t\n\r]+vUv0;/g;
	var _regexColorBufferSample = /(texture2D|texture)[ \t\n\r]*\([ \t\n\r]*uColorBuffer/g;
	var _regexMain = /void[ \t\n\r]+main/g;
	function _createBackbufferRt(id, device, format) {
		var tex = new Texture(device, {
			format: format,
			width: device.width,
			height: device.height
		});
		tex.name = 'posteffect-pass';
		tex.minFilter = FILTER_NEAREST;
		tex.magFilter = FILTER_NEAREST;
		tex.addressU = ADDRESS_CLAMP_TO_EDGE;
		tex.addressV = ADDRESS_CLAMP_TO_EDGE;
		_backbufferRt[id]._colorBuffer = tex;
	}
	function _destroyBackbufferRt(id) {
		_backbufferRt[id].colorBuffer.destroy();
		_backbufferRt[id].destroy();
	}
	function _collectUniforms(code) {
		var strs = code.match(_regexUniforms) || [];
		var start, end, uname;
		var uniforms = [];
		for (var i = 0; i < strs.length; i++) {
			start = strs[i].search(_regexUniformStart);
			end = strs[i].search(_regexUniformEnd);
			uname = strs[i].substr(start, end - start);
			if (uname !== "uColorBuffer") {
				uniforms.push(uname);
			}
		}
		return uniforms;
	}
	function _uniformsCollide(layers, chain, count, shader) {
		var uniforms = _collectUniforms(shader.definition.fshader);
		if (uniforms.length === 0) return false;
		var i, j, k, uniforms2;
		var uname;
		for (i = 0; i < count; i++) {
			for (j = 0; j < uniforms.length; j++) {
				uname = uniforms[j];
				uniforms2 = _collectUniforms(layers[chain[i]].shader.definition.fshader);
				for (k = 0; k < uniforms2.length; k++) {
					if (uniforms2[k] === uname) {
						return true;
					}
				}
			}
		}
		return false;
	}
	function _collectGlobalTempVars(code, list) {
		var len = code.length;
		var chr;
		var scopeStart = 0;
		var scopeEnd = 0;
		var scopeDepth = 0;
		var codeStart = 0;
		var codeWithoutScopes = "";
		var i, j;
		for (i = 0; i < len; i++) {
			chr = code.charAt(i);
			if (chr === "{") {
				if (scopeDepth === 0) {
					scopeStart = i;
				}
				scopeDepth++;
			} else if (chr === "}") {
				if (scopeDepth === 1) {
					scopeEnd = i;
					codeWithoutScopes += code.substr(codeStart, (scopeStart - codeStart) + 1);
					codeStart = scopeEnd;
				}
				scopeDepth--;
			}
		}
		codeWithoutScopes += code.substr(codeStart, (code.length - codeStart) + 1);
		var collisions = null;
		var decls = codeWithoutScopes.match(_regexVariables) || [];
		var vars, varName;
		for (i = 0; i < decls.length; i++) {
			vars = decls[i].split(",");
			for (j = 0; j < vars.length; j++) {
				varName = vars[j].replace(_regexVariableSurroundings, "").trim();
				if (list.indexOf(varName) >= 0) {
					if (!collisions) collisions = [];
					collisions.push(varName);
				} else {
					list.push(varName);
				}
			}
		}
		var irrelevantDecls = codeWithoutScopes.match(_regexIrrelevantVariables) || [];
		var index;
		for (i = 0; i < irrelevantDecls.length; i++) {
			vars = irrelevantDecls[i].split(",");
			for (j = 0; j < vars.length; j++) {
				varName = vars[j].replace(_regexIrrelevantVariableSurroundings, "").trim();
				index = list.indexOf(varName);
				if (index >= 0) {
					list.splice(index, 1);
				}
			}
		}
		return collisions;
	}
	function PostEffectPass(app, options) {
		this.app = app;
		this.srcRenderTarget = options.srcRenderTarget;
		this.hdr = options.hdr;
		this.blending = options.blending;
		this.shader = options.shader;
		this.setup = options.setup;
		var self = this;
		var device = app.graphicsDevice;
		this.layer = new Layer({
			opaqueSortMode: SORTMODE_NONE,
			transparentSortMode: SORTMODE_NONE,
			passThrough: true,
			name: options.name,
			onPostRender: function () {
				if (self.srcRenderTarget) {
					_constScreenSizeValue.x = self.srcRenderTarget.width;
					_constScreenSizeValue.y = self.srcRenderTarget.height;
					_constScreenSizeValue.z = 1.0 / self.srcRenderTarget.width;
					_constScreenSizeValue.w = 1.0 / self.srcRenderTarget.height;
				} else {
					_constScreenSizeValue.x = device.width;
					_constScreenSizeValue.y = device.height;
					_constScreenSizeValue.z = 1.0 / device.width;
					_constScreenSizeValue.w = 1.0 / device.height;
				}
				_constScreenSizeValueUniform[0] = _constScreenSizeValue.x;
				_constScreenSizeValueUniform[1] = _constScreenSizeValue.y;
				_constScreenSizeValueUniform[2] = _constScreenSizeValue.z;
				_constScreenSizeValueUniform[3] = _constScreenSizeValue.w;
				_constScreenSize.setValue(_constScreenSizeValueUniform);
				if (this._postEffectCombined && this._postEffectCombined < 0) {
					if (self.setup) self.setup(device, self, _constScreenSizeValue, null, this.renderTarget);
					return;
				}
				var src;
				if (this._postEffectCombinedSrc) {
					src = this._postEffectCombinedSrc;
				} else {
					src = self.srcRenderTarget ? self.srcRenderTarget : _backbufferRt[this._backbufferRtId];
				}
				if (src._samples > 1) src.resolve(true, false);
				var tex = src._colorBuffer;
				tex.magFilter = (this._postEffectCombinedShader ? this._postEffectCombinedBilinear : this.postEffectBilinear) ? FILTER_LINEAR : FILTER_NEAREST;
				_constInput.setValue(tex);
				if (self.setup) self.setup(device, self, _constScreenSizeValue, src, this.renderTarget);
				var shader = this._postEffectCombinedShader ? this._postEffectCombinedShader : this.shader;
				if (shader) drawQuadWithShader(device, this.renderTarget, shader, null, null, self.blending);
				if (self.srcRenderTarget) return;
				var layers = app.scene.layers.layerList;
				for (var i = 0; i < layers.length; i++) {
					if (layers[i] === self.layer) break;
					if (layers[i].renderTarget === _backbufferRt[0] || layers[i].renderTarget === _backbufferRt[1]) {
						layers[i].renderTarget = null;
					}
				}
			}
		});
		this.layer._generateCameraHash();
		this.layer.isPostEffect = true;
		this.layer.unmodifiedUvs = options.unmodifiedUvs;
		this.layer.postEffectBilinear = options.bilinear;
		this.layer.postEffect = this;
		this.layer.shader = options.shader;
		this.layer.renderTarget = options.destRenderTarget;
		if (!_constInput) {
			_constInput = device.scope.resolve("uColorBuffer");
			_constScreenSize = device.scope.resolve("uScreenSize");
			var _backbufferMsaa = device.supportsMsaa ? 4 : 1;
			for (var i = 0; i < 2; i++) {
				_backbufferRt[i] = new RenderTarget({
					depth: true,
					stencil: device.supportsStencil,
					samples: _backbufferMsaa,
					autoResolve: false
				});
				_backbufferRt[i].name = "backbuffer" + i;
			}
			app.on("prerender", function () {
				var layers = app.scene.layers.layerList;
				var i, j;
				var offset = 0;
				var rtId = 0;
				_backbufferRtUsed = false;
				_backbufferRt2Used = false;
				_backbufferRtWrittenByPost = false;
				var backbufferRtFormat = PIXELFORMAT_R8_G8_B8_A8;
				if (app.scene.layers._dirty) {
					var iterator = 0;
					var breakChain = false;
					var collisions, k;
					for (i = 0; i < layers.length; i++) {
						breakChain = false;
						if (layers[i].isPostEffect && (iterator === 0 || (layers[i].unmodifiedUvs && layers[i].shader && !_uniformsCollide(layers, _postEffectChain, iterator, layers[i].shader)))) {
							_postEffectChain[iterator] = i;
							iterator++;
							if (i === layers.length - 1) breakChain = true;
						} else {
							if (iterator > 0) {
								breakChain = true;
							}
						}
						if (breakChain) {
							if (iterator > 1) {
								var cachedName = "post_";
								var layer;
								for (j = 0; j < iterator; j++) {
									layer = layers[_postEffectChain[j]];
									cachedName += layer.name ? layer.name : layer.id;
									if (j < iterator - 1) cachedName += "_";
								}
								var shader = device.programLib._cache[cachedName];
								if (!shader) {
									var subCode;
									var code = "vec4 shaderOutput;\n";
									var mainCode = "void main() {\n";
									var globalTempVars = [];
									for (j = 0; j < iterator; j++) {
										subCode = layers[_postEffectChain[j]].shader.definition.fshader + "\n";
										subCode = subCode.replace(_regexVersion, "//").replace(_regexFragColor, "//").replace(_regexFragColor2, "//").replace(_regexFragColor3, "shaderOutput");
										if (j > 0) {
											subCode = subCode.replace(_regexColorBuffer, "//").replace(_regexUv, "//").replace(_regexColorBufferSample, "shaderOutput;\/\/");
										}
										subCode = subCode.replace(_regexMain, "void main" + j);
										collisions = _collectGlobalTempVars(subCode, globalTempVars);
										if (collisions) {
											for (k = 0; k < collisions.length; k++) {
												subCode = subCode.replace(new RegExp("\\b" + collisions[k] + "\\b", 'g'), collisions[k] + "NNNN" + j);
											}
										}
										code += subCode;
										mainCode += "main" + j + "();\n";
									}
									mainCode += "gl_FragColor = shaderOutput;\n}\n";
									shader = createShaderFromCode(device,
																  shaderChunks.fullscreenQuadVS,
																  code + mainCode,
																  cachedName);
								}
								for (j = 0; j < iterator; j++) {
									layers[_postEffectChain[j]]._postEffectCombined = (j === iterator - 1) ? 1 : -1;
								}
								layers[_postEffectChain[iterator - 1]]._postEffectCombinedShader = shader;
								layers[_postEffectChain[iterator - 1]]._postEffectCombinedBilinear = layers[_postEffectChain[0]].postEffectBilinear;
								layers[_postEffectChain[iterator - 1]]._postEffectCombinedSrc = layers[_postEffectChain[0]].postEffect.srcRenderTarget;
							}
							_postEffectChain[0] = i;
							iterator = 1;
						}
					}
				}
				for (i = 0; i < layers.length; i++) {
					if (layers[i].isPostEffect && ((!layers[i].postEffect.srcRenderTarget && !layers[i]._postEffectCombined) ||
												   (!layers[i].postEffect._postEffectCombinedSrc && layers[i]._postEffectCombined >= 0))) {
						for (j = i - 1; j >= offset; j--) {
							if (!layers[j].renderTarget) {
								layers[j].renderTarget = _backbufferRt[rtId];
							}
						}
						layers[i]._backbufferRtId = rtId;
						offset = i;
						_backbufferRtUsed = true;
						if (rtId === 1) _backbufferRt2Used = true;
						if (layers[i].postEffect.hdr) {
							if (device.webgl2 && device.textureFloatRenderable) {
								backbufferRtFormat = PIXELFORMAT_111110F;
							} else if (device.extTextureHalfFloatLinear && device.textureHalfFloatRenderable) {
								backbufferRtFormat = PIXELFORMAT_RGBA16F;
							} else {
								backbufferRtFormat = PIXELFORMAT_R8_G8_B8_A8;
							}
						}
						if (layers[i].postEffect.shader && !layers[i].renderTarget) rtId = 1 - rtId;
					} else if (!layers[i].isPostEffect && !layers[i].renderTarget && _backbufferRtUsed) {
						layers[i].renderTarget = _backbufferRt[rtId];
					}
					if (layers[i].isPostEffect && !layers[i].renderTarget) {
						_backbufferRtWrittenByPost = true;
					}
				}
				if (_backbufferRtUsed) {
					if (!_backbufferRt[0].colorBuffer) {
						_createBackbufferRt(0, device, backbufferRtFormat);
					} else if (_backbufferRt[0].width !== device.width || _backbufferRt[0].height !== device.height || _backbufferRt[0]._colorBuffer._format !== backbufferRtFormat) {
						_destroyBackbufferRt(0);
						_createBackbufferRt(0, device, backbufferRtFormat);
					}
				}
				if (_backbufferRt2Used) {
					if (!_backbufferRt[1].colorBuffer) {
						_createBackbufferRt(1, device, backbufferRtFormat);
					} else if (_backbufferRt[1].width !== device.width || _backbufferRt[1].height !== device.height || _backbufferRt[1]._colorBuffer._format !== backbufferRtFormat) {
						_destroyBackbufferRt(1);
						_createBackbufferRt(1, device, backbufferRtFormat);
					}
				}
			}, this);
			app.on("postrender", function () {
				var device = app.graphicsDevice;
				if (_backbufferRtUsed && !_backbufferRtWrittenByPost) {
					var layers = app.scene.layers.layerList;
					var rt;
					for (var i = layers.length - 1; i >= 0; i--) {
						rt = layers[i].renderTarget;
						if (rt === _backbufferRt[0] || rt === _backbufferRt[1]) {
							break;
						}
					}
					if (rt) {
						if (rt._samples > 1) {
							rt.resolve(true, false);
						}
						device.copyRenderTarget(rt, null, true, false);
					}
				}
			}, this);
		}
	}
	PostEffectPass.prototype.addToComposition = function (order) {
		this.app.scene.layers.insertTransparent(this.layer, order);
	};

	var log = {
		write: function (text) {
			console.log(text);
		},
		open: function () {
			log.write("Powered by PlayCanvas " + version + " " + revision);
		},
		info: function (text) {
			console.info("INFO:	" + text);
		},
		debug: function (text) {
			console.debug("DEBUG:   " + text);
		},
		error: function (text) {
			console.error("ERROR:   " + text);
		},
		warning: function (text) {
			console.warn("WARNING: " + text);
		},
		alert: function (text) {
			log.write("ALERT:   " + text);
			alert(text);
		},
		assert: function (condition, text) {
			if (condition === false) {
				log.write("ASSERT:  " + text);
			}
		}
	};
	string.endsWith = function (s, subs) {
		return s.endsWith(subs);
	};
	string.startsWith = function (s, subs) {
		return s.startsWith(subs);
	};
	var time = {
		now: now,
		Timer: Timer
	};
	Object.defineProperty(Color.prototype, "data", {
		get: function () {
			if (!this._data) {
				this._data = new Float32Array(4);
			}
			this._data[0] = this.r;
			this._data[1] = this.g;
			this._data[2] = this.b;
			this._data[3] = this.a;
			return this._data;
		}
	});
	Object.defineProperty(Color.prototype, "data3", {
		get: function () {
			if (!this._data3) {
				this._data3 = new Float32Array(3);
			}
			this._data3[0] = this.r;
			this._data3[1] = this.g;
			this._data3[2] = this.b;
			return this._data3;
		}
	});
	function inherits(Self, Super) {
		var Temp = function () {};
		var Func = function (arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) {
			Super.call(this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
			Self.call(this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
		};
		Func._super = Super.prototype;
		Temp.prototype = Super.prototype;
		Func.prototype = new Temp();
		return Func;
	}
	function makeArray(arr) {
		return Array.prototype.slice.call(arr);
	}
	math.INV_LOG2 = Math.LOG2E;
	math.intToBytes = math.intToBytes32;
	math.bytesToInt = math.bytesToInt32;
	Object.defineProperty(Vec2.prototype, "data", {
		get: function () {
			if (!this._data) {
				this._data = new Float32Array(2);
			}
			this._data[0] = this.x;
			this._data[1] = this.y;
			return this._data;
		}
	});
	Object.defineProperty(Vec3.prototype, "data", {
		get: function () {
			if (!this._data) {
				this._data = new Float32Array(3);
			}
			this._data[0] = this.x;
			this._data[1] = this.y;
			this._data[2] = this.z;
			return this._data;
		}
	});
	Object.defineProperty(Vec4.prototype, "data", {
		get: function () {
			if (!this._data) {
				this._data = new Float32Array(4);
			}
			this._data[0] = this.x;
			this._data[1] = this.y;
			this._data[2] = this.z;
			this._data[3] = this.w;
			return this._data;
		}
	});
	var shape = {
		Aabb: BoundingBox,
		Sphere: BoundingSphere,
		Plane: Plane
	};
	BoundingSphere.prototype.intersectRay = BoundingSphere.prototype.intersectsRay;
	Frustum.prototype.update = function (projectionMatrix, viewMatrix) {
		var viewProj = new Mat4();
		viewProj.mul2(projectionMatrix, viewMatrix);
		this.setFromMat4(viewProj);
	};
	var ELEMENTTYPE_INT8 = TYPE_INT8;
	var ELEMENTTYPE_UINT8 = TYPE_UINT8;
	var ELEMENTTYPE_INT16 = TYPE_INT16;
	var ELEMENTTYPE_UINT16 = TYPE_UINT16;
	var ELEMENTTYPE_INT32 = TYPE_INT32;
	var ELEMENTTYPE_UINT32 = TYPE_UINT32;
	var ELEMENTTYPE_FLOAT32 = TYPE_FLOAT32;
	function UnsupportedBrowserError(message) {
		this.name = "UnsupportedBrowserError";
		this.message = (message || "");
	}
	UnsupportedBrowserError.prototype = Error.prototype;
	function ContextCreationError(message) {
		this.name = "ContextCreationError";
		this.message = (message || "");
	}
	ContextCreationError.prototype = Error.prototype;
	var gfx = {
		ADDRESS_CLAMP_TO_EDGE: ADDRESS_CLAMP_TO_EDGE,
		ADDRESS_MIRRORED_REPEAT: ADDRESS_MIRRORED_REPEAT,
		ADDRESS_REPEAT: ADDRESS_REPEAT,
		BLENDMODE_ZERO: BLENDMODE_ZERO,
		BLENDMODE_ONE: BLENDMODE_ONE,
		BLENDMODE_SRC_COLOR: BLENDMODE_SRC_COLOR,
		BLENDMODE_ONE_MINUS_SRC_COLOR: BLENDMODE_ONE_MINUS_SRC_COLOR,
		BLENDMODE_DST_COLOR: BLENDMODE_DST_COLOR,
		BLENDMODE_ONE_MINUS_DST_COLOR: BLENDMODE_ONE_MINUS_DST_COLOR,
		BLENDMODE_SRC_ALPHA: BLENDMODE_SRC_ALPHA,
		BLENDMODE_SRC_ALPHA_SATURATE: BLENDMODE_SRC_ALPHA_SATURATE,
		BLENDMODE_ONE_MINUS_SRC_ALPHA: BLENDMODE_ONE_MINUS_SRC_ALPHA,
		BLENDMODE_DST_ALPHA: BLENDMODE_DST_ALPHA,
		BLENDMODE_ONE_MINUS_DST_ALPHA: BLENDMODE_ONE_MINUS_DST_ALPHA,
		BUFFER_STATIC: BUFFER_STATIC,
		BUFFER_DYNAMIC: BUFFER_DYNAMIC,
		BUFFER_STREAM: BUFFER_STREAM,
		CULLFACE_NONE: CULLFACE_NONE,
		CULLFACE_BACK: CULLFACE_BACK,
		CULLFACE_FRONT: CULLFACE_FRONT,
		CULLFACE_FRONTANDBACK: CULLFACE_FRONTANDBACK,
		ELEMENTTYPE_INT8: TYPE_INT8,
		ELEMENTTYPE_UINT8: TYPE_UINT8,
		ELEMENTTYPE_INT16: TYPE_INT16,
		ELEMENTTYPE_UINT16: TYPE_UINT16,
		ELEMENTTYPE_INT32: TYPE_INT32,
		ELEMENTTYPE_UINT32: TYPE_UINT32,
		ELEMENTTYPE_FLOAT32: TYPE_FLOAT32,
		FILTER_NEAREST: FILTER_NEAREST,
		FILTER_LINEAR: FILTER_LINEAR,
		FILTER_NEAREST_MIPMAP_NEAREST: FILTER_NEAREST_MIPMAP_NEAREST,
		FILTER_NEAREST_MIPMAP_LINEAR: FILTER_NEAREST_MIPMAP_LINEAR,
		FILTER_LINEAR_MIPMAP_NEAREST: FILTER_LINEAR_MIPMAP_NEAREST,
		FILTER_LINEAR_MIPMAP_LINEAR: FILTER_LINEAR_MIPMAP_LINEAR,
		INDEXFORMAT_UINT8: INDEXFORMAT_UINT8,
		INDEXFORMAT_UINT16: INDEXFORMAT_UINT16,
		INDEXFORMAT_UINT32: INDEXFORMAT_UINT32,
		PIXELFORMAT_R5_G6_B5: PIXELFORMAT_R5_G6_B5,
		PIXELFORMAT_R8_G8_B8: PIXELFORMAT_R8_G8_B8,
		PIXELFORMAT_R8_G8_B8_A8: PIXELFORMAT_R8_G8_B8_A8,
		PRIMITIVE_POINTS: PRIMITIVE_POINTS,
		PRIMITIVE_LINES: PRIMITIVE_LINES,
		PRIMITIVE_LINELOOP: PRIMITIVE_LINELOOP,
		PRIMITIVE_LINESTRIP: PRIMITIVE_LINESTRIP,
		PRIMITIVE_TRIANGLES: PRIMITIVE_TRIANGLES,
		PRIMITIVE_TRISTRIP: PRIMITIVE_TRISTRIP,
		PRIMITIVE_TRIFAN: PRIMITIVE_TRIFAN,
		SEMANTIC_POSITION: SEMANTIC_POSITION,
		SEMANTIC_NORMAL: SEMANTIC_NORMAL,
		SEMANTIC_COLOR: SEMANTIC_COLOR,
		SEMANTIC_TEXCOORD: SEMANTIC_TEXCOORD,
		SEMANTIC_TEXCOORD0: SEMANTIC_TEXCOORD0,
		SEMANTIC_TEXCOORD1: SEMANTIC_TEXCOORD1,
		SEMANTIC_ATTR0: SEMANTIC_ATTR0,
		SEMANTIC_ATTR1: SEMANTIC_ATTR1,
		SEMANTIC_ATTR2: SEMANTIC_ATTR2,
		SEMANTIC_ATTR3: SEMANTIC_ATTR3,
		TEXTURELOCK_READ: TEXTURELOCK_READ,
		TEXTURELOCK_WRITE: TEXTURELOCK_WRITE,
		drawQuadWithShader: drawQuadWithShader,
		programlib: programlib,
		shaderChunks: shaderChunks,
		ContextCreationError: ContextCreationError,
		Device: GraphicsDevice,
		IndexBuffer: IndexBuffer,
		ProgramLibrary: ProgramLibrary,
		RenderTarget: RenderTarget,
		ScopeId: ScopeId,
		Shader: Shader,
		ShaderInput: ShaderInput,
		Texture: Texture,
		UnsupportedBrowserError: UnsupportedBrowserError,
		VertexBuffer: VertexBuffer,
		VertexFormat: VertexFormat,
		VertexIterator: VertexIterator
	};
	var posteffect = {
		createFullscreenQuad: createFullscreenQuad,
		drawFullscreenQuad: drawFullscreenQuad,
		PostEffect: PostEffect,
		PostEffectQueue: PostEffectQueue
	};
	Object.defineProperty(shaderChunks, "transformSkinnedVS", {
		get: function () {
			return "#define SKIN\n" + shaderChunks.transformVS;
		}
	});
	Object.defineProperties(Texture.prototype, {
		rgbm: {
			get: function () {
				return this.type === TEXTURETYPE_RGBM;
			},
			set: function (rgbm) {
				this.type = rgbm ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT;
			}
		},
		swizzleGGGR: {
			get: function () {
				return this.type === TEXTURETYPE_SWIZZLEGGGR;
			},
			set: function (swizzleGGGR) {
				this.type = swizzleGGGR ? TEXTURETYPE_SWIZZLEGGGR : TEXTURETYPE_DEFAULT;
			}
		}
	});
	var PhongMaterial = StandardMaterial;
	var scene = {
		partitionSkin: partitionSkin,
		procedural: {
			calculateTangents: calculateTangents,
			createMesh: createMesh,
			createTorus: createTorus,
			createCylinder: createCylinder,
			createCapsule: createCapsule,
			createCone: createCone,
			createSphere: createSphere,
			createPlane: createPlane,
			createBox: createBox
		},
		BasicMaterial: BasicMaterial,
		Command: Command,
		DepthMaterial: DepthMaterial,
		ForwardRenderer: ForwardRenderer,
		GraphNode: GraphNode,
		Material: Material,
		Mesh: Mesh,
		MeshInstance: MeshInstance,
		Model: Model,
		ParticleEmitter: ParticleEmitter,
		PhongMaterial: StandardMaterial,
		Picker: Picker,
		Projection: {
			ORTHOGRAPHIC: PROJECTION_ORTHOGRAPHIC,
			PERSPECTIVE: PROJECTION_PERSPECTIVE
		},
		Scene: Scene,
		Skin: Skin,
		SkinInstance: SkinInstance
	};
	GraphNode.prototype._dirtify = function (local) {
		if (local)
			this._dirtifyLocal();
		else
			this._dirtifyWorld();
	};
	GraphNode.prototype.addLabel = function (label) {
		this._labels[label] = true;
	};
	GraphNode.prototype.getLabels = function () {
		return Object.keys(this._labels);
	};
	GraphNode.prototype.hasLabel = function (label) {
		return !!this._labels[label];
	};
	GraphNode.prototype.removeLabel = function (label) {
		delete this._labels[label];
	};
	GraphNode.prototype.findByLabel = function (label, results) {
		var i, length = this._children.length;
		results = results || [];
		if (this.hasLabel(label)) {
			results.push(this);
		}
		for (i = 0; i < length; ++i) {
			results = this._children[i].findByLabel(label, results);
		}
		return results;
	};
	GraphNode.prototype.getChildren = function () {
		return this.children;
	};
	GraphNode.prototype.getName = function () {
		return this.name;
	};
	GraphNode.prototype.getPath = function () {
		return this.path;
	};
	GraphNode.prototype.getRoot = function () {
		return this.root;
	};
	GraphNode.prototype.getParent = function () {
		return this.parent;
	};
	GraphNode.prototype.setName = function (name) {
		this.name = name;
	};
	Material.prototype.getName = function () {
		return this.name;
	};
	Material.prototype.setName = function (name) {
		this.name = name;
	};
	Material.prototype.getShader = function () {
		return this.shader;
	};
	Material.prototype.setShader = function (shader) {
		this.shader = shader;
	};
	var anim = {
		Animation: Animation,
		Key: Key,
		Node: Node,
		Skeleton: Skeleton
	};
	var audio = {
		AudioManager: SoundManager,
		Channel: Channel,
		Channel3d: Channel3d,
		Listener: Listener,
		Sound: Sound
	};
	SoundManager.prototype.getListener = function () {
		return this.listener;
	};
	SoundManager.prototype.getVolume = function () {
		return this.volume;
	};
	SoundManager.prototype.setVolume = function (volume) {
		this.volume = volume;
	};
	var asset = {
		ASSET_ANIMATION: 'animation',
		ASSET_AUDIO: 'audio',
		ASSET_IMAGE: 'image',
		ASSET_JSON: 'json',
		ASSET_MODEL: 'model',
		ASSET_MATERIAL: 'material',
		ASSET_TEXT: 'text',
		ASSET_TEXTURE: 'texture',
		ASSET_CUBEMAP: 'cubemap',
		ASSET_SCRIPT: 'script'
	};
	AssetRegistry.prototype.getAssetById = function (id) {
		return this.get(id);
	};
	Object.defineProperty(XrInputSource.prototype, 'ray', {
		get: function () {
			return this._rayLocal;
		}
	});
	Object.defineProperty(XrInputSource.prototype, 'position', {
		get: function () {
			return this._localPosition;
		}
	});
	Object.defineProperty(XrInputSource.prototype, 'rotation', {
		get: function () {
			return this._localRotation;
		}
	});
	var input = {
		getTouchTargetCoords: getTouchTargetCoords,
		Controller: Controller,
		GamePads: GamePads,
		Keyboard: Keyboard,
		KeyboardEvent: KeyboardEvent,
		Mouse: Mouse,
		MouseEvent: MouseEvent,
		Touch: Touch,
		TouchDevice: TouchDevice,
		TouchEvent: TouchEvent
	};
	Object.defineProperty(ElementInput.prototype, 'wheel', {
		get: function () {
			return this.wheelDelta * -2;
		}
	});
	Object.defineProperty(MouseEvent.prototype, 'wheel', {
		get: function () {
			return this.wheelDelta * -2;
		}
	});
	var RIGIDBODY_TYPE_STATIC = BODYTYPE_STATIC;
	var RIGIDBODY_TYPE_DYNAMIC = BODYTYPE_DYNAMIC;
	var RIGIDBODY_TYPE_KINEMATIC = BODYTYPE_KINEMATIC;
	var RIGIDBODY_CF_STATIC_OBJECT = BODYFLAG_STATIC_OBJECT;
	var RIGIDBODY_CF_KINEMATIC_OBJECT = BODYFLAG_KINEMATIC_OBJECT;
	var RIGIDBODY_CF_NORESPONSE_OBJECT = BODYFLAG_NORESPONSE_OBJECT;
	var RIGIDBODY_ACTIVE_TAG = BODYSTATE_ACTIVE_TAG;
	var RIGIDBODY_ISLAND_SLEEPING = BODYSTATE_ISLAND_SLEEPING;
	var RIGIDBODY_WANTS_DEACTIVATION = BODYSTATE_WANTS_DEACTIVATION;
	var RIGIDBODY_DISABLE_DEACTIVATION = BODYSTATE_DISABLE_DEACTIVATION;
	var RIGIDBODY_DISABLE_SIMULATION = BODYSTATE_DISABLE_SIMULATION;
	var fw = {
		Application: Application,
		Component: Component,
		ComponentData: ComponentData,
		ComponentSystem: ComponentSystem,
		Entity: Entity,
		FillMode: {
			NONE: FILLMODE_NONE,
			FILL_WINDOW: FILLMODE_FILL_WINDOW,
			KEEP_ASPECT: FILLMODE_KEEP_ASPECT
		},
		ResolutionMode: {
			AUTO: RESOLUTION_AUTO,
			FIXED: RESOLUTION_FIXED
		}
	};
	Application.prototype.isFullscreen = function () {
		return !!document.fullscreenElement;
	};
	Application.prototype.enableFullscreen = function (element, success, error) {
		element = element || this.graphicsDevice.canvas;
		var s = function () {
			success();
			document.removeEventListener('fullscreenchange', s);
		};
		var e = function () {
			error();
			document.removeEventListener('fullscreenerror', e);
		};
		if (success) {
			document.addEventListener('fullscreenchange', s, false);
		}
		if (error) {
			document.addEventListener('fullscreenerror', e, false);
		}
		if (element.requestFullscreen) {
			element.requestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
		} else {
			error();
		}
	};
	Application.prototype.disableFullscreen = function (success) {
		var s = function () {
			success();
			document.removeEventListener('fullscreenchange', s);
		};
		if (success) {
			document.addEventListener('fullscreenchange', s, false);
		}
		document.exitFullscreen();
	};
	Object.defineProperty(CameraComponent.prototype, "node", {
		get: function () {
			return this.entity;
		}
	});
	Object.defineProperty(LightComponent.prototype, "enable", {
		get: function () {
			return this.enabled;
		},
		set: function (value) {
			this.enabled = value;
		}
	});
	ModelComponent.prototype.setVisible = function (visible) {
		this.enabled = visible;
	};
	Object.defineProperty(RigidBodyComponent.prototype, "bodyType", {
		get: function () {
			return this.type;
		},
		set: function (type) {
			this.type = type;
		}
	});
	RigidBodyComponent.prototype.syncBodyToEntity = function () {
		this._updateDynamic();
	};
	RigidBodyComponentSystem.prototype.setGravity = function () {
		if (arguments.length === 1) {
			this.gravity.copy(arguments[0]);
		} else {
			this.gravity.set(arguments[0], arguments[1], arguments[2]);
		}
	};

	exports.ABSOLUTE_URL = ABSOLUTE_URL;
	exports.ACTION_GAMEPAD = ACTION_GAMEPAD;
	exports.ACTION_KEYBOARD = ACTION_KEYBOARD;
	exports.ACTION_MOUSE = ACTION_MOUSE;
	exports.ADDRESS_CLAMP_TO_EDGE = ADDRESS_CLAMP_TO_EDGE;
	exports.ADDRESS_MIRRORED_REPEAT = ADDRESS_MIRRORED_REPEAT;
	exports.ADDRESS_REPEAT = ADDRESS_REPEAT;
	exports.ANIM_EQUAL_TO = ANIM_EQUAL_TO;
	exports.ANIM_GREATER_THAN = ANIM_GREATER_THAN;
	exports.ANIM_GREATER_THAN_EQUAL_TO = ANIM_GREATER_THAN_EQUAL_TO;
	exports.ANIM_INTERRUPTION_NEXT = ANIM_INTERRUPTION_NEXT;
	exports.ANIM_INTERRUPTION_NEXT_PREV = ANIM_INTERRUPTION_NEXT_PREV;
	exports.ANIM_INTERRUPTION_NONE = ANIM_INTERRUPTION_NONE;
	exports.ANIM_INTERRUPTION_PREV = ANIM_INTERRUPTION_PREV;
	exports.ANIM_INTERRUPTION_PREV_NEXT = ANIM_INTERRUPTION_PREV_NEXT;
	exports.ANIM_LESS_THAN = ANIM_LESS_THAN;
	exports.ANIM_LESS_THAN_EQUAL_TO = ANIM_LESS_THAN_EQUAL_TO;
	exports.ANIM_NOT_EQUAL_TO = ANIM_NOT_EQUAL_TO;
	exports.ANIM_PARAMETER_BOOLEAN = ANIM_PARAMETER_BOOLEAN;
	exports.ANIM_PARAMETER_FLOAT = ANIM_PARAMETER_FLOAT;
	exports.ANIM_PARAMETER_INTEGER = ANIM_PARAMETER_INTEGER;
	exports.ANIM_PARAMETER_TRIGGER = ANIM_PARAMETER_TRIGGER;
	exports.ANIM_STATE_END = ANIM_STATE_END;
	exports.ANIM_STATE_START = ANIM_STATE_START;
	exports.ASPECT_AUTO = ASPECT_AUTO;
	exports.ASPECT_MANUAL = ASPECT_MANUAL;
	exports.ASSET_ANIMATION = ASSET_ANIMATION;
	exports.ASSET_AUDIO = ASSET_AUDIO;
	exports.ASSET_CONTAINER = ASSET_CONTAINER;
	exports.ASSET_CSS = ASSET_CSS;
	exports.ASSET_CUBEMAP = ASSET_CUBEMAP;
	exports.ASSET_HTML = ASSET_HTML;
	exports.ASSET_IMAGE = ASSET_IMAGE;
	exports.ASSET_JSON = ASSET_JSON;
	exports.ASSET_MATERIAL = ASSET_MATERIAL;
	exports.ASSET_MODEL = ASSET_MODEL;
	exports.ASSET_SCRIPT = ASSET_SCRIPT;
	exports.ASSET_SHADER = ASSET_SHADER;
	exports.ASSET_TEXT = ASSET_TEXT;
	exports.ASSET_TEXTURE = ASSET_TEXTURE;
	exports.AXIS_KEY = AXIS_KEY;
	exports.AXIS_MOUSE_X = AXIS_MOUSE_X;
	exports.AXIS_MOUSE_Y = AXIS_MOUSE_Y;
	exports.AXIS_PAD_L_X = AXIS_PAD_L_X;
	exports.AXIS_PAD_L_Y = AXIS_PAD_L_Y;
	exports.AXIS_PAD_R_X = AXIS_PAD_R_X;
	exports.AXIS_PAD_R_Y = AXIS_PAD_R_Y;
	exports.AnimBinder = AnimBinder;
	exports.AnimClip = AnimClip;
	exports.AnimClipHandler = AnimClipHandler;
	exports.AnimComponent = AnimComponent;
	exports.AnimComponentLayer = AnimComponentLayer;
	exports.AnimComponentSystem = AnimComponentSystem;
	exports.AnimController = AnimController;
	exports.AnimCurve = AnimCurve;
	exports.AnimData = AnimData;
	exports.AnimEvaluator = AnimEvaluator;
	exports.AnimPropertyLocator = AnimPropertyLocator;
	exports.AnimSnapshot = AnimSnapshot;
	exports.AnimStateGraph = AnimStateGraph;
	exports.AnimStateGraphHandler = AnimStateGraphHandler;
	exports.AnimTarget = AnimTarget;
	exports.AnimTrack = AnimTrack;
	exports.Animation = Animation;
	exports.AnimationComponent = AnimationComponent;
	exports.AnimationComponentSystem = AnimationComponentSystem;
	exports.AnimationHandler = AnimationHandler;
	exports.Application = Application;
	exports.Asset = Asset;
	exports.AssetListLoader = AssetListLoader;
	exports.AssetReference = AssetReference;
	exports.AssetRegistry = AssetRegistry;
	exports.AudioHandler = AudioHandler;
	exports.AudioListenerComponent = AudioListenerComponent;
	exports.AudioListenerComponentSystem = AudioListenerComponentSystem;
	exports.AudioSourceComponent = AudioSourceComponent;
	exports.AudioSourceComponentSystem = AudioSourceComponentSystem;
	exports.BAKE_COLOR = BAKE_COLOR;
	exports.BAKE_COLORDIR = BAKE_COLORDIR;
	exports.BLENDEQUATION_ADD = BLENDEQUATION_ADD;
	exports.BLENDEQUATION_MAX = BLENDEQUATION_MAX;
	exports.BLENDEQUATION_MIN = BLENDEQUATION_MIN;
	exports.BLENDEQUATION_REVERSE_SUBTRACT = BLENDEQUATION_REVERSE_SUBTRACT;
	exports.BLENDEQUATION_SUBTRACT = BLENDEQUATION_SUBTRACT;
	exports.BLENDMODE_DST_ALPHA = BLENDMODE_DST_ALPHA;
	exports.BLENDMODE_DST_COLOR = BLENDMODE_DST_COLOR;
	exports.BLENDMODE_ONE = BLENDMODE_ONE;
	exports.BLENDMODE_ONE_MINUS_DST_ALPHA = BLENDMODE_ONE_MINUS_DST_ALPHA;
	exports.BLENDMODE_ONE_MINUS_DST_COLOR = BLENDMODE_ONE_MINUS_DST_COLOR;
	exports.BLENDMODE_ONE_MINUS_SRC_ALPHA = BLENDMODE_ONE_MINUS_SRC_ALPHA;
	exports.BLENDMODE_ONE_MINUS_SRC_COLOR = BLENDMODE_ONE_MINUS_SRC_COLOR;
	exports.BLENDMODE_SRC_ALPHA = BLENDMODE_SRC_ALPHA;
	exports.BLENDMODE_SRC_ALPHA_SATURATE = BLENDMODE_SRC_ALPHA_SATURATE;
	exports.BLENDMODE_SRC_COLOR = BLENDMODE_SRC_COLOR;
	exports.BLENDMODE_ZERO = BLENDMODE_ZERO;
	exports.BLEND_ADDITIVE = BLEND_ADDITIVE;
	exports.BLEND_ADDITIVEALPHA = BLEND_ADDITIVEALPHA;
	exports.BLEND_MAX = BLEND_MAX;
	exports.BLEND_MIN = BLEND_MIN;
	exports.BLEND_MULTIPLICATIVE = BLEND_MULTIPLICATIVE;
	exports.BLEND_MULTIPLICATIVE2X = BLEND_MULTIPLICATIVE2X;
	exports.BLEND_NONE = BLEND_NONE;
	exports.BLEND_NORMAL = BLEND_NORMAL;
	exports.BLEND_PREMULTIPLIED = BLEND_PREMULTIPLIED;
	exports.BLEND_SCREEN = BLEND_SCREEN;
	exports.BLEND_SUBTRACTIVE = BLEND_SUBTRACTIVE;
	exports.BLUR_BOX = BLUR_BOX;
	exports.BLUR_GAUSSIAN = BLUR_GAUSSIAN;
	exports.BODYFLAG_KINEMATIC_OBJECT = BODYFLAG_KINEMATIC_OBJECT;
	exports.BODYFLAG_NORESPONSE_OBJECT = BODYFLAG_NORESPONSE_OBJECT;
	exports.BODYFLAG_STATIC_OBJECT = BODYFLAG_STATIC_OBJECT;
	exports.BODYGROUP_DEFAULT = BODYGROUP_DEFAULT;
	exports.BODYGROUP_DYNAMIC = BODYGROUP_DYNAMIC;
	exports.BODYGROUP_ENGINE_1 = BODYGROUP_ENGINE_1;
	exports.BODYGROUP_ENGINE_2 = BODYGROUP_ENGINE_2;
	exports.BODYGROUP_ENGINE_3 = BODYGROUP_ENGINE_3;
	exports.BODYGROUP_KINEMATIC = BODYGROUP_KINEMATIC;
	exports.BODYGROUP_NONE = BODYGROUP_NONE;
	exports.BODYGROUP_STATIC = BODYGROUP_STATIC;
	exports.BODYGROUP_TRIGGER = BODYGROUP_TRIGGER;
	exports.BODYGROUP_USER_1 = BODYGROUP_USER_1;
	exports.BODYGROUP_USER_2 = BODYGROUP_USER_2;
	exports.BODYGROUP_USER_3 = BODYGROUP_USER_3;
	exports.BODYGROUP_USER_4 = BODYGROUP_USER_4;
	exports.BODYGROUP_USER_5 = BODYGROUP_USER_5;
	exports.BODYGROUP_USER_6 = BODYGROUP_USER_6;
	exports.BODYGROUP_USER_7 = BODYGROUP_USER_7;
	exports.BODYGROUP_USER_8 = BODYGROUP_USER_8;
	exports.BODYMASK_ALL = BODYMASK_ALL;
	exports.BODYMASK_NONE = BODYMASK_NONE;
	exports.BODYMASK_NOT_STATIC = BODYMASK_NOT_STATIC;
	exports.BODYMASK_NOT_STATIC_KINEMATIC = BODYMASK_NOT_STATIC_KINEMATIC;
	exports.BODYMASK_STATIC = BODYMASK_STATIC;
	exports.BODYSTATE_ACTIVE_TAG = BODYSTATE_ACTIVE_TAG;
	exports.BODYSTATE_DISABLE_DEACTIVATION = BODYSTATE_DISABLE_DEACTIVATION;
	exports.BODYSTATE_DISABLE_SIMULATION = BODYSTATE_DISABLE_SIMULATION;
	exports.BODYSTATE_ISLAND_SLEEPING = BODYSTATE_ISLAND_SLEEPING;
	exports.BODYSTATE_WANTS_DEACTIVATION = BODYSTATE_WANTS_DEACTIVATION;
	exports.BODYTYPE_DYNAMIC = BODYTYPE_DYNAMIC;
	exports.BODYTYPE_KINEMATIC = BODYTYPE_KINEMATIC;
	exports.BODYTYPE_STATIC = BODYTYPE_STATIC;
	exports.BUFFER_DYNAMIC = BUFFER_DYNAMIC;
	exports.BUFFER_GPUDYNAMIC = BUFFER_GPUDYNAMIC;
	exports.BUFFER_STATIC = BUFFER_STATIC;
	exports.BUFFER_STREAM = BUFFER_STREAM;
	exports.BUTTON_TRANSITION_MODE_SPRITE_CHANGE = BUTTON_TRANSITION_MODE_SPRITE_CHANGE;
	exports.BUTTON_TRANSITION_MODE_TINT = BUTTON_TRANSITION_MODE_TINT;
	exports.BasicMaterial = BasicMaterial;
	exports.BasisParser = BasisParser;
	exports.Batch = Batch;
	exports.BatchGroup = BatchGroup;
	exports.BatchManager = BatchManager;
	exports.BinaryHandler = BinaryHandler;
	exports.BoundingBox = BoundingBox;
	exports.BoundingSphere = BoundingSphere;
	exports.Bundle = Bundle;
	exports.BundleHandler = BundleHandler;
	exports.BundleRegistry = BundleRegistry;
	exports.ButtonComponent = ButtonComponent;
	exports.ButtonComponentSystem = ButtonComponentSystem;
	exports.CLEARFLAG_COLOR = CLEARFLAG_COLOR;
	exports.CLEARFLAG_DEPTH = CLEARFLAG_DEPTH;
	exports.CLEARFLAG_STENCIL = CLEARFLAG_STENCIL;
	exports.COMPUPDATED_BLEND = COMPUPDATED_BLEND;
	exports.COMPUPDATED_CAMERAS = COMPUPDATED_CAMERAS;
	exports.COMPUPDATED_INSTANCES = COMPUPDATED_INSTANCES;
	exports.COMPUPDATED_LIGHTS = COMPUPDATED_LIGHTS;
	exports.CUBEFACE_NEGX = CUBEFACE_NEGX;
	exports.CUBEFACE_NEGY = CUBEFACE_NEGY;
	exports.CUBEFACE_NEGZ = CUBEFACE_NEGZ;
	exports.CUBEFACE_POSX = CUBEFACE_POSX;
	exports.CUBEFACE_POSY = CUBEFACE_POSY;
	exports.CUBEFACE_POSZ = CUBEFACE_POSZ;
	exports.CUBEPROJ_BOX = CUBEPROJ_BOX;
	exports.CUBEPROJ_NONE = CUBEPROJ_NONE;
	exports.CULLFACE_BACK = CULLFACE_BACK;
	exports.CULLFACE_FRONT = CULLFACE_FRONT;
	exports.CULLFACE_FRONTANDBACK = CULLFACE_FRONTANDBACK;
	exports.CULLFACE_NONE = CULLFACE_NONE;
	exports.CURVE_CARDINAL = CURVE_CARDINAL;
	exports.CURVE_CATMULL = CURVE_CATMULL;
	exports.CURVE_LINEAR = CURVE_LINEAR;
	exports.CURVE_SMOOTHSTEP = CURVE_SMOOTHSTEP;
	exports.CURVE_SPLINE = CURVE_SPLINE;
	exports.CURVE_STEP = CURVE_STEP;
	exports.Camera = Camera;
	exports.CameraComponent = CameraComponent;
	exports.CameraComponentSystem = CameraComponentSystem;
	exports.CanvasFont = CanvasFont;
	exports.CollisionComponent = CollisionComponent;
	exports.CollisionComponentSystem = CollisionComponentSystem;
	exports.Color = Color;
	exports.Command = Command;
	exports.Component = Component;
	exports.ComponentData = ComponentData;
	exports.ComponentSystem = ComponentSystem;
	exports.ComponentSystemRegistry = ComponentSystemRegistry;
	exports.ContactPoint = ContactPoint;
	exports.ContactResult = ContactResult;
	exports.ContainerHandler = ContainerHandler;
	exports.ContainerResource = ContainerResource;
	exports.ContextCreationError = ContextCreationError;
	exports.Controller = Controller;
	exports.CssHandler = CssHandler;
	exports.CubemapHandler = CubemapHandler;
	exports.Curve = Curve;
	exports.CurveSet = CurveSet;
	exports.DETAILMODE_ADD = DETAILMODE_ADD;
	exports.DETAILMODE_MAX = DETAILMODE_MAX;
	exports.DETAILMODE_MIN = DETAILMODE_MIN;
	exports.DETAILMODE_MUL = DETAILMODE_MUL;
	exports.DETAILMODE_OVERLAY = DETAILMODE_OVERLAY;
	exports.DETAILMODE_SCREEN = DETAILMODE_SCREEN;
	exports.DISTANCE_EXPONENTIAL = DISTANCE_EXPONENTIAL;
	exports.DISTANCE_INVERSE = DISTANCE_INVERSE;
	exports.DISTANCE_LINEAR = DISTANCE_LINEAR;
	exports.DefaultAnimBinder = DefaultAnimBinder;
	exports.DepthMaterial = DepthMaterial;
	exports.ELEMENTTYPE_FLOAT32 = ELEMENTTYPE_FLOAT32;
	exports.ELEMENTTYPE_GROUP = ELEMENTTYPE_GROUP;
	exports.ELEMENTTYPE_IMAGE = ELEMENTTYPE_IMAGE;
	exports.ELEMENTTYPE_INT16 = ELEMENTTYPE_INT16;
	exports.ELEMENTTYPE_INT32 = ELEMENTTYPE_INT32;
	exports.ELEMENTTYPE_INT8 = ELEMENTTYPE_INT8;
	exports.ELEMENTTYPE_TEXT = ELEMENTTYPE_TEXT;
	exports.ELEMENTTYPE_UINT16 = ELEMENTTYPE_UINT16;
	exports.ELEMENTTYPE_UINT32 = ELEMENTTYPE_UINT32;
	exports.ELEMENTTYPE_UINT8 = ELEMENTTYPE_UINT8;
	exports.EMITTERSHAPE_BOX = EMITTERSHAPE_BOX;
	exports.EMITTERSHAPE_SPHERE = EMITTERSHAPE_SPHERE;
	exports.EVENT_KEYDOWN = EVENT_KEYDOWN;
	exports.EVENT_KEYUP = EVENT_KEYUP;
	exports.EVENT_MOUSEDOWN = EVENT_MOUSEDOWN;
	exports.EVENT_MOUSEMOVE = EVENT_MOUSEMOVE;
	exports.EVENT_MOUSEUP = EVENT_MOUSEUP;
	exports.EVENT_MOUSEWHEEL = EVENT_MOUSEWHEEL;
	exports.EVENT_SELECT = EVENT_SELECT;
	exports.EVENT_SELECTEND = EVENT_SELECTEND;
	exports.EVENT_SELECTSTART = EVENT_SELECTSTART;
	exports.EVENT_TOUCHCANCEL = EVENT_TOUCHCANCEL;
	exports.EVENT_TOUCHEND = EVENT_TOUCHEND;
	exports.EVENT_TOUCHMOVE = EVENT_TOUCHMOVE;
	exports.EVENT_TOUCHSTART = EVENT_TOUCHSTART;
	exports.ElementComponent = ElementComponent;
	exports.ElementComponentSystem = ElementComponentSystem;
	exports.ElementDragHelper = ElementDragHelper;
	exports.ElementInput = ElementInput;
	exports.ElementInputEvent = ElementInputEvent;
	exports.ElementMouseEvent = ElementMouseEvent;
	exports.ElementSelectEvent = ElementSelectEvent;
	exports.ElementTouchEvent = ElementTouchEvent;
	exports.Entity = Entity;
	exports.EntityReference = EntityReference;
	exports.EventHandler = EventHandler;
	exports.FILLMODE_FILL_WINDOW = FILLMODE_FILL_WINDOW;
	exports.FILLMODE_KEEP_ASPECT = FILLMODE_KEEP_ASPECT;
	exports.FILLMODE_NONE = FILLMODE_NONE;
	exports.FILTER_LINEAR = FILTER_LINEAR;
	exports.FILTER_LINEAR_MIPMAP_LINEAR = FILTER_LINEAR_MIPMAP_LINEAR;
	exports.FILTER_LINEAR_MIPMAP_NEAREST = FILTER_LINEAR_MIPMAP_NEAREST;
	exports.FILTER_NEAREST = FILTER_NEAREST;
	exports.FILTER_NEAREST_MIPMAP_LINEAR = FILTER_NEAREST_MIPMAP_LINEAR;
	exports.FILTER_NEAREST_MIPMAP_NEAREST = FILTER_NEAREST_MIPMAP_NEAREST;
	exports.FITTING_BOTH = FITTING_BOTH;
	exports.FITTING_NONE = FITTING_NONE;
	exports.FITTING_SHRINK = FITTING_SHRINK;
	exports.FITTING_STRETCH = FITTING_STRETCH;
	exports.FOG_EXP = FOG_EXP;
	exports.FOG_EXP2 = FOG_EXP2;
	exports.FOG_LINEAR = FOG_LINEAR;
	exports.FOG_NONE = FOG_NONE;
	exports.FONT_BITMAP = FONT_BITMAP;
	exports.FONT_MSDF = FONT_MSDF;
	exports.FRESNEL_NONE = FRESNEL_NONE;
	exports.FRESNEL_SCHLICK = FRESNEL_SCHLICK;
	exports.FUNC_ALWAYS = FUNC_ALWAYS;
	exports.FUNC_EQUAL = FUNC_EQUAL;
	exports.FUNC_GREATER = FUNC_GREATER;
	exports.FUNC_GREATEREQUAL = FUNC_GREATEREQUAL;
	exports.FUNC_LESS = FUNC_LESS;
	exports.FUNC_LESSEQUAL = FUNC_LESSEQUAL;
	exports.FUNC_NEVER = FUNC_NEVER;
	exports.FUNC_NOTEQUAL = FUNC_NOTEQUAL;
	exports.FolderHandler = FolderHandler;
	exports.Font = Font;
	exports.FontHandler = FontHandler;
	exports.ForwardRenderer = ForwardRenderer;
	exports.Frustum = Frustum;
	exports.GAMMA_NONE = GAMMA_NONE;
	exports.GAMMA_SRGB = GAMMA_SRGB;
	exports.GAMMA_SRGBFAST = GAMMA_SRGBFAST;
	exports.GAMMA_SRGBHDR = GAMMA_SRGBHDR;
	exports.GamePads = GamePads;
	exports.GraphNode = GraphNode;
	exports.GraphicsDevice = GraphicsDevice;
	exports.HierarchyHandler = HierarchyHandler;
	exports.HtmlHandler = HtmlHandler;
	exports.Http = Http;
	exports.I18n = I18n;
	exports.INDEXFORMAT_UINT16 = INDEXFORMAT_UINT16;
	exports.INDEXFORMAT_UINT32 = INDEXFORMAT_UINT32;
	exports.INDEXFORMAT_UINT8 = INDEXFORMAT_UINT8;
	exports.INTERPOLATION_CUBIC = INTERPOLATION_CUBIC;
	exports.INTERPOLATION_LINEAR = INTERPOLATION_LINEAR;
	exports.INTERPOLATION_STEP = INTERPOLATION_STEP;
	exports.ImageElement = ImageElement;
	exports.ImgParser = ImgParser;
	exports.IndexBuffer = IndexBuffer;
	exports.IndexedList = IndexedList;
	exports.JsonHandler = JsonHandler;
	exports.JsonNodeMaterialParser = JsonNodeMaterialParser;
	exports.JsonStandardMaterialParser = JsonStandardMaterialParser;
	exports.KEY_0 = KEY_0;
	exports.KEY_1 = KEY_1;
	exports.KEY_2 = KEY_2;
	exports.KEY_3 = KEY_3;
	exports.KEY_4 = KEY_4;
	exports.KEY_5 = KEY_5;
	exports.KEY_6 = KEY_6;
	exports.KEY_7 = KEY_7;
	exports.KEY_8 = KEY_8;
	exports.KEY_9 = KEY_9;
	exports.KEY_A = KEY_A;
	exports.KEY_ADD = KEY_ADD;
	exports.KEY_ALT = KEY_ALT;
	exports.KEY_B = KEY_B;
	exports.KEY_BACKSPACE = KEY_BACKSPACE;
	exports.KEY_BACK_SLASH = KEY_BACK_SLASH;
	exports.KEY_C = KEY_C;
	exports.KEY_CAPS_LOCK = KEY_CAPS_LOCK;
	exports.KEY_CLOSE_BRACKET = KEY_CLOSE_BRACKET;
	exports.KEY_COMMA = KEY_COMMA;
	exports.KEY_CONTEXT_MENU = KEY_CONTEXT_MENU;
	exports.KEY_CONTROL = KEY_CONTROL;
	exports.KEY_D = KEY_D;
	exports.KEY_DECIMAL = KEY_DECIMAL;
	exports.KEY_DELETE = KEY_DELETE;
	exports.KEY_DIVIDE = KEY_DIVIDE;
	exports.KEY_DOWN = KEY_DOWN;
	exports.KEY_E = KEY_E;
	exports.KEY_END = KEY_END;
	exports.KEY_ENTER = KEY_ENTER;
	exports.KEY_EQUAL = KEY_EQUAL;
	exports.KEY_ESCAPE = KEY_ESCAPE;
	exports.KEY_F = KEY_F;
	exports.KEY_F1 = KEY_F1;
	exports.KEY_F10 = KEY_F10;
	exports.KEY_F11 = KEY_F11;
	exports.KEY_F12 = KEY_F12;
	exports.KEY_F2 = KEY_F2;
	exports.KEY_F3 = KEY_F3;
	exports.KEY_F4 = KEY_F4;
	exports.KEY_F5 = KEY_F5;
	exports.KEY_F6 = KEY_F6;
	exports.KEY_F7 = KEY_F7;
	exports.KEY_F8 = KEY_F8;
	exports.KEY_F9 = KEY_F9;
	exports.KEY_G = KEY_G;
	exports.KEY_H = KEY_H;
	exports.KEY_HOME = KEY_HOME;
	exports.KEY_I = KEY_I;
	exports.KEY_INSERT = KEY_INSERT;
	exports.KEY_J = KEY_J;
	exports.KEY_K = KEY_K;
	exports.KEY_L = KEY_L;
	exports.KEY_LEFT = KEY_LEFT;
	exports.KEY_M = KEY_M;
	exports.KEY_META = KEY_META;
	exports.KEY_MULTIPLY = KEY_MULTIPLY;
	exports.KEY_N = KEY_N;
	exports.KEY_NUMPAD_0 = KEY_NUMPAD_0;
	exports.KEY_NUMPAD_1 = KEY_NUMPAD_1;
	exports.KEY_NUMPAD_2 = KEY_NUMPAD_2;
	exports.KEY_NUMPAD_3 = KEY_NUMPAD_3;
	exports.KEY_NUMPAD_4 = KEY_NUMPAD_4;
	exports.KEY_NUMPAD_5 = KEY_NUMPAD_5;
	exports.KEY_NUMPAD_6 = KEY_NUMPAD_6;
	exports.KEY_NUMPAD_7 = KEY_NUMPAD_7;
	exports.KEY_NUMPAD_8 = KEY_NUMPAD_8;
	exports.KEY_NUMPAD_9 = KEY_NUMPAD_9;
	exports.KEY_O = KEY_O;
	exports.KEY_OPEN_BRACKET = KEY_OPEN_BRACKET;
	exports.KEY_P = KEY_P;
	exports.KEY_PAGE_DOWN = KEY_PAGE_DOWN;
	exports.KEY_PAGE_UP = KEY_PAGE_UP;
	exports.KEY_PAUSE = KEY_PAUSE;
	exports.KEY_PERIOD = KEY_PERIOD;
	exports.KEY_PRINT_SCREEN = KEY_PRINT_SCREEN;
	exports.KEY_Q = KEY_Q;
	exports.KEY_R = KEY_R;
	exports.KEY_RETURN = KEY_RETURN;
	exports.KEY_RIGHT = KEY_RIGHT;
	exports.KEY_S = KEY_S;
	exports.KEY_SEMICOLON = KEY_SEMICOLON;
	exports.KEY_SEPARATOR = KEY_SEPARATOR;
	exports.KEY_SHIFT = KEY_SHIFT;
	exports.KEY_SLASH = KEY_SLASH;
	exports.KEY_SPACE = KEY_SPACE;
	exports.KEY_SUBTRACT = KEY_SUBTRACT;
	exports.KEY_T = KEY_T;
	exports.KEY_TAB = KEY_TAB;
	exports.KEY_U = KEY_U;
	exports.KEY_UP = KEY_UP;
	exports.KEY_V = KEY_V;
	exports.KEY_W = KEY_W;
	exports.KEY_WINDOWS = KEY_WINDOWS;
	exports.KEY_X = KEY_X;
	exports.KEY_Y = KEY_Y;
	exports.KEY_Z = KEY_Z;
	exports.Key = Key;
	exports.Keyboard = Keyboard;
	exports.KeyboardEvent = KeyboardEvent;
	exports.KtxParser = KtxParser;
	exports.LAYERID_DEPTH = LAYERID_DEPTH;
	exports.LAYERID_IMMEDIATE = LAYERID_IMMEDIATE;
	exports.LAYERID_SKYBOX = LAYERID_SKYBOX;
	exports.LAYERID_UI = LAYERID_UI;
	exports.LAYERID_WORLD = LAYERID_WORLD;
	exports.LAYER_FX = LAYER_FX;
	exports.LAYER_GIZMO = LAYER_GIZMO;
	exports.LAYER_HUD = LAYER_HUD;
	exports.LAYER_WORLD = LAYER_WORLD;
	exports.LIGHTFALLOFF_INVERSESQUARED = LIGHTFALLOFF_INVERSESQUARED;
	exports.LIGHTFALLOFF_LINEAR = LIGHTFALLOFF_LINEAR;
	exports.LIGHTTYPE_DIRECTIONAL = LIGHTTYPE_DIRECTIONAL;
	exports.LIGHTTYPE_POINT = LIGHTTYPE_POINT;
	exports.LIGHTTYPE_SPOT = LIGHTTYPE_SPOT;
	exports.LINEBATCH_GIZMO = LINEBATCH_GIZMO;
	exports.LINEBATCH_OVERLAY = LINEBATCH_OVERLAY;
	exports.LINEBATCH_WORLD = LINEBATCH_WORLD;
	exports.Layer = Layer;
	exports.LayerComposition = LayerComposition;
	exports.LayoutCalculator = LayoutCalculator;
	exports.LayoutChildComponent = LayoutChildComponent;
	exports.LayoutChildComponentSystem = LayoutChildComponentSystem;
	exports.LayoutGroupComponent = LayoutGroupComponent;
	exports.LayoutGroupComponentSystem = LayoutGroupComponentSystem;
	exports.LegacyDdsParser = LegacyDdsParser;
	exports.Light = Light;
	exports.LightComponent = LightComponent;
	exports.LightComponentSystem = LightComponentSystem;
	exports.Lightmapper = Lightmapper;
	exports.LocalizedAsset = LocalizedAsset;
	exports.MASK_BAKED = MASK_BAKED;
	exports.MASK_DYNAMIC = MASK_DYNAMIC;
	exports.MASK_LIGHTMAP = MASK_LIGHTMAP;
	exports.MOUSEBUTTON_LEFT = MOUSEBUTTON_LEFT;
	exports.MOUSEBUTTON_MIDDLE = MOUSEBUTTON_MIDDLE;
	exports.MOUSEBUTTON_NONE = MOUSEBUTTON_NONE;
	exports.MOUSEBUTTON_RIGHT = MOUSEBUTTON_RIGHT;
	exports.Mat3 = Mat3;
	exports.Mat4 = Mat4;
	exports.Material = Material;
	exports.MaterialHandler = MaterialHandler;
	exports.Mesh = Mesh;
	exports.MeshInstance = MeshInstance;
	exports.Model = Model;
	exports.ModelComponent = ModelComponent;
	exports.ModelComponentSystem = ModelComponentSystem;
	exports.ModelHandler = ModelHandler;
	exports.Morph = Morph;
	exports.MorphInstance = MorphInstance;
	exports.MorphTarget = MorphTarget;
	exports.Mouse = Mouse;
	exports.MouseEvent = MouseEvent;
	exports.Node = Node;
	exports.NodeMaterial = NodeMaterial;
	exports.ORIENTATION_HORIZONTAL = ORIENTATION_HORIZONTAL;
	exports.ORIENTATION_VERTICAL = ORIENTATION_VERTICAL;
	exports.OrientedBox = OrientedBox;
	exports.PAD_1 = PAD_1;
	exports.PAD_2 = PAD_2;
	exports.PAD_3 = PAD_3;
	exports.PAD_4 = PAD_4;
	exports.PAD_DOWN = PAD_DOWN;
	exports.PAD_FACE_1 = PAD_FACE_1;
	exports.PAD_FACE_2 = PAD_FACE_2;
	exports.PAD_FACE_3 = PAD_FACE_3;
	exports.PAD_FACE_4 = PAD_FACE_4;
	exports.PAD_LEFT = PAD_LEFT;
	exports.PAD_L_SHOULDER_1 = PAD_L_SHOULDER_1;
	exports.PAD_L_SHOULDER_2 = PAD_L_SHOULDER_2;
	exports.PAD_L_STICK_BUTTON = PAD_L_STICK_BUTTON;
	exports.PAD_L_STICK_X = PAD_L_STICK_X;
	exports.PAD_L_STICK_Y = PAD_L_STICK_Y;
	exports.PAD_RIGHT = PAD_RIGHT;
	exports.PAD_R_SHOULDER_1 = PAD_R_SHOULDER_1;
	exports.PAD_R_SHOULDER_2 = PAD_R_SHOULDER_2;
	exports.PAD_R_STICK_BUTTON = PAD_R_STICK_BUTTON;
	exports.PAD_R_STICK_X = PAD_R_STICK_X;
	exports.PAD_R_STICK_Y = PAD_R_STICK_Y;
	exports.PAD_SELECT = PAD_SELECT;
	exports.PAD_START = PAD_START;
	exports.PAD_UP = PAD_UP;
	exports.PAD_VENDOR = PAD_VENDOR;
	exports.PARTICLEMODE_CPU = PARTICLEMODE_CPU;
	exports.PARTICLEMODE_GPU = PARTICLEMODE_GPU;
	exports.PARTICLEORIENTATION_EMITTER = PARTICLEORIENTATION_EMITTER;
	exports.PARTICLEORIENTATION_SCREEN = PARTICLEORIENTATION_SCREEN;
	exports.PARTICLEORIENTATION_WORLD = PARTICLEORIENTATION_WORLD;
	exports.PARTICLESORT_DISTANCE = PARTICLESORT_DISTANCE;
	exports.PARTICLESORT_NEWER_FIRST = PARTICLESORT_NEWER_FIRST;
	exports.PARTICLESORT_NONE = PARTICLESORT_NONE;
	exports.PARTICLESORT_OLDER_FIRST = PARTICLESORT_OLDER_FIRST;
	exports.PIXELFORMAT_111110F = PIXELFORMAT_111110F;
	exports.PIXELFORMAT_A8 = PIXELFORMAT_A8;
	exports.PIXELFORMAT_ASTC_4x4 = PIXELFORMAT_ASTC_4x4;
	exports.PIXELFORMAT_ATC_RGB = PIXELFORMAT_ATC_RGB;
	exports.PIXELFORMAT_ATC_RGBA = PIXELFORMAT_ATC_RGBA;
	exports.PIXELFORMAT_DEPTH = PIXELFORMAT_DEPTH;
	exports.PIXELFORMAT_DEPTHSTENCIL = PIXELFORMAT_DEPTHSTENCIL;
	exports.PIXELFORMAT_DXT1 = PIXELFORMAT_DXT1;
	exports.PIXELFORMAT_DXT3 = PIXELFORMAT_DXT3;
	exports.PIXELFORMAT_DXT5 = PIXELFORMAT_DXT5;
	exports.PIXELFORMAT_ETC1 = PIXELFORMAT_ETC1;
	exports.PIXELFORMAT_ETC2_RGB = PIXELFORMAT_ETC2_RGB;
	exports.PIXELFORMAT_ETC2_RGBA = PIXELFORMAT_ETC2_RGBA;
	exports.PIXELFORMAT_L8 = PIXELFORMAT_L8;
	exports.PIXELFORMAT_L8_A8 = PIXELFORMAT_L8_A8;
	exports.PIXELFORMAT_PVRTC_2BPP_RGBA_1 = PIXELFORMAT_PVRTC_2BPP_RGBA_1;
	exports.PIXELFORMAT_PVRTC_2BPP_RGB_1 = PIXELFORMAT_PVRTC_2BPP_RGB_1;
	exports.PIXELFORMAT_PVRTC_4BPP_RGBA_1 = PIXELFORMAT_PVRTC_4BPP_RGBA_1;
	exports.PIXELFORMAT_PVRTC_4BPP_RGB_1 = PIXELFORMAT_PVRTC_4BPP_RGB_1;
	exports.PIXELFORMAT_R32F = PIXELFORMAT_R32F;
	exports.PIXELFORMAT_R4_G4_B4_A4 = PIXELFORMAT_R4_G4_B4_A4;
	exports.PIXELFORMAT_R5_G5_B5_A1 = PIXELFORMAT_R5_G5_B5_A1;
	exports.PIXELFORMAT_R5_G6_B5 = PIXELFORMAT_R5_G6_B5;
	exports.PIXELFORMAT_R8_G8_B8 = PIXELFORMAT_R8_G8_B8;
	exports.PIXELFORMAT_R8_G8_B8_A8 = PIXELFORMAT_R8_G8_B8_A8;
	exports.PIXELFORMAT_RGB16F = PIXELFORMAT_RGB16F;
	exports.PIXELFORMAT_RGB32F = PIXELFORMAT_RGB32F;
	exports.PIXELFORMAT_RGBA16F = PIXELFORMAT_RGBA16F;
	exports.PIXELFORMAT_RGBA32F = PIXELFORMAT_RGBA32F;
	exports.PIXELFORMAT_SRGB = PIXELFORMAT_SRGB;
	exports.PIXELFORMAT_SRGBA = PIXELFORMAT_SRGBA;
	exports.PRIMITIVE_LINELOOP = PRIMITIVE_LINELOOP;
	exports.PRIMITIVE_LINES = PRIMITIVE_LINES;
	exports.PRIMITIVE_LINESTRIP = PRIMITIVE_LINESTRIP;
	exports.PRIMITIVE_POINTS = PRIMITIVE_POINTS;
	exports.PRIMITIVE_TRIANGLES = PRIMITIVE_TRIANGLES;
	exports.PRIMITIVE_TRIFAN = PRIMITIVE_TRIFAN;
	exports.PRIMITIVE_TRISTRIP = PRIMITIVE_TRISTRIP;
	exports.PROJECTION_ORTHOGRAPHIC = PROJECTION_ORTHOGRAPHIC;
	exports.PROJECTION_PERSPECTIVE = PROJECTION_PERSPECTIVE;
	exports.ParticleEmitter = ParticleEmitter;
	exports.ParticleSystemComponent = ParticleSystemComponent;
	exports.ParticleSystemComponentSystem = ParticleSystemComponentSystem;
	exports.PhongMaterial = PhongMaterial;
	exports.Picker = Picker;
	exports.Plane = Plane;
	exports.PostEffect = PostEffect;
	exports.PostEffectPass = PostEffectPass;
	exports.PostEffectQueue = PostEffectQueue;
	exports.ProgramLibrary = ProgramLibrary;
	exports.Quat = Quat;
	exports.RENDERSTYLE_POINTS = RENDERSTYLE_POINTS;
	exports.RENDERSTYLE_SOLID = RENDERSTYLE_SOLID;
	exports.RENDERSTYLE_WIREFRAME = RENDERSTYLE_WIREFRAME;
	exports.RESOLUTION_AUTO = RESOLUTION_AUTO;
	exports.RESOLUTION_FIXED = RESOLUTION_FIXED;
	exports.RIGIDBODY_ACTIVE_TAG = RIGIDBODY_ACTIVE_TAG;
	exports.RIGIDBODY_CF_KINEMATIC_OBJECT = RIGIDBODY_CF_KINEMATIC_OBJECT;
	exports.RIGIDBODY_CF_NORESPONSE_OBJECT = RIGIDBODY_CF_NORESPONSE_OBJECT;
	exports.RIGIDBODY_CF_STATIC_OBJECT = RIGIDBODY_CF_STATIC_OBJECT;
	exports.RIGIDBODY_DISABLE_DEACTIVATION = RIGIDBODY_DISABLE_DEACTIVATION;
	exports.RIGIDBODY_DISABLE_SIMULATION = RIGIDBODY_DISABLE_SIMULATION;
	exports.RIGIDBODY_ISLAND_SLEEPING = RIGIDBODY_ISLAND_SLEEPING;
	exports.RIGIDBODY_TYPE_DYNAMIC = RIGIDBODY_TYPE_DYNAMIC;
	exports.RIGIDBODY_TYPE_KINEMATIC = RIGIDBODY_TYPE_KINEMATIC;
	exports.RIGIDBODY_TYPE_STATIC = RIGIDBODY_TYPE_STATIC;
	exports.RIGIDBODY_WANTS_DEACTIVATION = RIGIDBODY_WANTS_DEACTIVATION;
	exports.Ray = Ray;
	exports.RaycastResult = RaycastResult;
	exports.RenderTarget = RenderTarget;
	exports.ResourceHandler = ResourceHandler;
	exports.ResourceLoader = ResourceLoader;
	exports.RigidBodyComponent = RigidBodyComponent;
	exports.RigidBodyComponentSystem = RigidBodyComponentSystem;
	exports.SCALEMODE_BLEND = SCALEMODE_BLEND;
	exports.SCALEMODE_NONE = SCALEMODE_NONE;
	exports.SCROLLBAR_VISIBILITY_SHOW_ALWAYS = SCROLLBAR_VISIBILITY_SHOW_ALWAYS;
	exports.SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED = SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED;
	exports.SCROLL_MODE_BOUNCE = SCROLL_MODE_BOUNCE;
	exports.SCROLL_MODE_CLAMP = SCROLL_MODE_CLAMP;
	exports.SCROLL_MODE_INFINITE = SCROLL_MODE_INFINITE;
	exports.SEMANTIC_ATTR = SEMANTIC_ATTR;
	exports.SEMANTIC_ATTR0 = SEMANTIC_ATTR0;
	exports.SEMANTIC_ATTR1 = SEMANTIC_ATTR1;
	exports.SEMANTIC_ATTR10 = SEMANTIC_ATTR10;
	exports.SEMANTIC_ATTR11 = SEMANTIC_ATTR11;
	exports.SEMANTIC_ATTR12 = SEMANTIC_ATTR12;
	exports.SEMANTIC_ATTR13 = SEMANTIC_ATTR13;
	exports.SEMANTIC_ATTR14 = SEMANTIC_ATTR14;
	exports.SEMANTIC_ATTR15 = SEMANTIC_ATTR15;
	exports.SEMANTIC_ATTR2 = SEMANTIC_ATTR2;
	exports.SEMANTIC_ATTR3 = SEMANTIC_ATTR3;
	exports.SEMANTIC_ATTR4 = SEMANTIC_ATTR4;
	exports.SEMANTIC_ATTR5 = SEMANTIC_ATTR5;
	exports.SEMANTIC_ATTR6 = SEMANTIC_ATTR6;
	exports.SEMANTIC_ATTR7 = SEMANTIC_ATTR7;
	exports.SEMANTIC_ATTR8 = SEMANTIC_ATTR8;
	exports.SEMANTIC_ATTR9 = SEMANTIC_ATTR9;
	exports.SEMANTIC_BLENDINDICES = SEMANTIC_BLENDINDICES;
	exports.SEMANTIC_BLENDWEIGHT = SEMANTIC_BLENDWEIGHT;
	exports.SEMANTIC_COLOR = SEMANTIC_COLOR;
	exports.SEMANTIC_NORMAL = SEMANTIC_NORMAL;
	exports.SEMANTIC_POSITION = SEMANTIC_POSITION;
	exports.SEMANTIC_TANGENT = SEMANTIC_TANGENT;
	exports.SEMANTIC_TEXCOORD = SEMANTIC_TEXCOORD;
	exports.SEMANTIC_TEXCOORD0 = SEMANTIC_TEXCOORD0;
	exports.SEMANTIC_TEXCOORD1 = SEMANTIC_TEXCOORD1;
	exports.SEMANTIC_TEXCOORD2 = SEMANTIC_TEXCOORD2;
	exports.SEMANTIC_TEXCOORD3 = SEMANTIC_TEXCOORD3;
	exports.SEMANTIC_TEXCOORD4 = SEMANTIC_TEXCOORD4;
	exports.SEMANTIC_TEXCOORD5 = SEMANTIC_TEXCOORD5;
	exports.SEMANTIC_TEXCOORD6 = SEMANTIC_TEXCOORD6;
	exports.SEMANTIC_TEXCOORD7 = SEMANTIC_TEXCOORD7;
	exports.SHADERDEF_DIRLM = SHADERDEF_DIRLM;
	exports.SHADERDEF_INSTANCING = SHADERDEF_INSTANCING;
	exports.SHADERDEF_LM = SHADERDEF_LM;
	exports.SHADERDEF_MORPH_NORMAL = SHADERDEF_MORPH_NORMAL;
	exports.SHADERDEF_MORPH_POSITION = SHADERDEF_MORPH_POSITION;
	exports.SHADERDEF_MORPH_TEXTURE_BASED = SHADERDEF_MORPH_TEXTURE_BASED;
	exports.SHADERDEF_NOSHADOW = SHADERDEF_NOSHADOW;
	exports.SHADERDEF_SCREENSPACE = SHADERDEF_SCREENSPACE;
	exports.SHADERDEF_SKIN = SHADERDEF_SKIN;
	exports.SHADERDEF_TANGENTS = SHADERDEF_TANGENTS;
	exports.SHADERDEF_UV0 = SHADERDEF_UV0;
	exports.SHADERDEF_UV1 = SHADERDEF_UV1;
	exports.SHADERDEF_VCOLOR = SHADERDEF_VCOLOR;
	exports.SHADERTAG_MATERIAL = SHADERTAG_MATERIAL;
	exports.SHADER_DEPTH = SHADER_DEPTH;
	exports.SHADER_FORWARD = SHADER_FORWARD;
	exports.SHADER_FORWARDHDR = SHADER_FORWARDHDR;
	exports.SHADER_PICK = SHADER_PICK;
	exports.SHADER_SHADOW = SHADER_SHADOW;
	exports.SHADOWUPDATE_NONE = SHADOWUPDATE_NONE;
	exports.SHADOWUPDATE_REALTIME = SHADOWUPDATE_REALTIME;
	exports.SHADOWUPDATE_THISFRAME = SHADOWUPDATE_THISFRAME;
	exports.SHADOW_DEPTH = SHADOW_DEPTH;
	exports.SHADOW_PCF3 = SHADOW_PCF3;
	exports.SHADOW_PCF5 = SHADOW_PCF5;
	exports.SHADOW_VSM16 = SHADOW_VSM16;
	exports.SHADOW_VSM32 = SHADOW_VSM32;
	exports.SHADOW_VSM8 = SHADOW_VSM8;
	exports.SORTKEY_DEPTH = SORTKEY_DEPTH;
	exports.SORTKEY_FORWARD = SORTKEY_FORWARD;
	exports.SORTMODE_BACK2FRONT = SORTMODE_BACK2FRONT;
	exports.SORTMODE_CUSTOM = SORTMODE_CUSTOM;
	exports.SORTMODE_FRONT2BACK = SORTMODE_FRONT2BACK;
	exports.SORTMODE_MANUAL = SORTMODE_MANUAL;
	exports.SORTMODE_MATERIALMESH = SORTMODE_MATERIALMESH;
	exports.SORTMODE_NONE = SORTMODE_NONE;
	exports.SPECOCC_AO = SPECOCC_AO;
	exports.SPECOCC_GLOSSDEPENDENT = SPECOCC_GLOSSDEPENDENT;
	exports.SPECOCC_NONE = SPECOCC_NONE;
	exports.SPECULAR_BLINN = SPECULAR_BLINN;
	exports.SPECULAR_PHONG = SPECULAR_PHONG;
	exports.SPRITETYPE_ANIMATED = SPRITETYPE_ANIMATED;
	exports.SPRITETYPE_SIMPLE = SPRITETYPE_SIMPLE;
	exports.SPRITE_RENDERMODE_SIMPLE = SPRITE_RENDERMODE_SIMPLE;
	exports.SPRITE_RENDERMODE_SLICED = SPRITE_RENDERMODE_SLICED;
	exports.SPRITE_RENDERMODE_TILED = SPRITE_RENDERMODE_TILED;
	exports.STENCILOP_DECREMENT = STENCILOP_DECREMENT;
	exports.STENCILOP_DECREMENTWRAP = STENCILOP_DECREMENTWRAP;
	exports.STENCILOP_INCREMENT = STENCILOP_INCREMENT;
	exports.STENCILOP_INCREMENTWRAP = STENCILOP_INCREMENTWRAP;
	exports.STENCILOP_INVERT = STENCILOP_INVERT;
	exports.STENCILOP_KEEP = STENCILOP_KEEP;
	exports.STENCILOP_REPLACE = STENCILOP_REPLACE;
	exports.STENCILOP_ZERO = STENCILOP_ZERO;
	exports.Scene = Scene;
	exports.SceneHandler = SceneHandler;
	exports.SceneRegistry = SceneRegistry;
	exports.SceneRegistryItem = SceneRegistryItem;
	exports.SceneSettingsHandler = SceneSettingsHandler;
	exports.ScopeId = ScopeId;
	exports.ScopeSpace = ScopeSpace;
	exports.ScreenComponent = ScreenComponent;
	exports.ScreenComponentSystem = ScreenComponentSystem;
	exports.ScriptAttributes = ScriptAttributes;
	exports.ScriptComponent = ScriptComponent;
	exports.ScriptComponentSystem = ScriptComponentSystem;
	exports.ScriptHandler = ScriptHandler;
	exports.ScriptLegacyComponent = ScriptLegacyComponent;
	exports.ScriptLegacyComponentSystem = ScriptLegacyComponentSystem;
	exports.ScriptRegistry = ScriptRegistry;
	exports.ScriptType = ScriptType;
	exports.ScrollViewComponent = ScrollViewComponent;
	exports.ScrollViewComponentSystem = ScrollViewComponentSystem;
	exports.ScrollbarComponent = ScrollbarComponent;
	exports.ScrollbarComponentSystem = ScrollbarComponentSystem;
	exports.Shader = Shader;
	exports.ShaderHandler = ShaderHandler;
	exports.SingleContactResult = SingleContactResult;
	exports.Skeleton = Skeleton;
	exports.Skin = Skin;
	exports.SkinInstance = SkinInstance;
	exports.SortedLoopArray = SortedLoopArray;
	exports.Sound = Sound;
	exports.SoundComponent = SoundComponent;
	exports.SoundComponentSystem = SoundComponentSystem;
	exports.SoundManager = SoundManager;
	exports.SoundSlot = SoundSlot;
	exports.Sprite = Sprite;
	exports.SpriteAnimationClip = SpriteAnimationClip;
	exports.SpriteComponent = SpriteComponent;
	exports.SpriteComponentSystem = SpriteComponentSystem;
	exports.SpriteHandler = SpriteHandler;
	exports.StandardMaterial = StandardMaterial;
	exports.StandardNodeMaterial = StandardNodeMaterial;
	exports.StencilParameters = StencilParameters;
	exports.TEXHINT_ASSET = TEXHINT_ASSET;
	exports.TEXHINT_LIGHTMAP = TEXHINT_LIGHTMAP;
	exports.TEXHINT_NONE = TEXHINT_NONE;
	exports.TEXHINT_SHADOWMAP = TEXHINT_SHADOWMAP;
	exports.TEXTURELOCK_READ = TEXTURELOCK_READ;
	exports.TEXTURELOCK_WRITE = TEXTURELOCK_WRITE;
	exports.TEXTURETYPE_DEFAULT = TEXTURETYPE_DEFAULT;
	exports.TEXTURETYPE_RGBE = TEXTURETYPE_RGBE;
	exports.TEXTURETYPE_RGBM = TEXTURETYPE_RGBM;
	exports.TEXTURETYPE_SWIZZLEGGGR = TEXTURETYPE_SWIZZLEGGGR;
	exports.TONEMAP_ACES = TONEMAP_ACES;
	exports.TONEMAP_ACES2 = TONEMAP_ACES2;
	exports.TONEMAP_FILMIC = TONEMAP_FILMIC;
	exports.TONEMAP_HEJL = TONEMAP_HEJL;
	exports.TONEMAP_LINEAR = TONEMAP_LINEAR;
	exports.TYPE_FLOAT32 = TYPE_FLOAT32;
	exports.TYPE_INT16 = TYPE_INT16;
	exports.TYPE_INT32 = TYPE_INT32;
	exports.TYPE_INT8 = TYPE_INT8;
	exports.TYPE_UINT16 = TYPE_UINT16;
	exports.TYPE_UINT32 = TYPE_UINT32;
	exports.TYPE_UINT8 = TYPE_UINT8;
	exports.Tags = Tags;
	exports.Template = Template;
	exports.TemplateHandler = TemplateHandler;
	exports.TemplateUtils = TemplateUtils;
	exports.TextElement = TextElement;
	exports.TextHandler = TextHandler;
	exports.Texture = Texture;
	exports.TextureAtlas = TextureAtlas;
	exports.TextureAtlasHandler = TextureAtlasHandler;
	exports.TextureHandler = TextureHandler;
	exports.TextureParser = TextureParser;
	exports.Timer = Timer;
	exports.Touch = Touch;
	exports.TouchDevice = TouchDevice;
	exports.TouchEvent = TouchEvent;
	exports.TransformFeedback = TransformFeedback;
	exports.UNIFORMTYPE_BOOL = UNIFORMTYPE_BOOL;
	exports.UNIFORMTYPE_BVEC2 = UNIFORMTYPE_BVEC2;
	exports.UNIFORMTYPE_BVEC3 = UNIFORMTYPE_BVEC3;
	exports.UNIFORMTYPE_BVEC4 = UNIFORMTYPE_BVEC4;
	exports.UNIFORMTYPE_FLOAT = UNIFORMTYPE_FLOAT;
	exports.UNIFORMTYPE_FLOATARRAY = UNIFORMTYPE_FLOATARRAY;
	exports.UNIFORMTYPE_INT = UNIFORMTYPE_INT;
	exports.UNIFORMTYPE_IVEC2 = UNIFORMTYPE_IVEC2;
	exports.UNIFORMTYPE_IVEC3 = UNIFORMTYPE_IVEC3;
	exports.UNIFORMTYPE_IVEC4 = UNIFORMTYPE_IVEC4;
	exports.UNIFORMTYPE_MAT2 = UNIFORMTYPE_MAT2;
	exports.UNIFORMTYPE_MAT3 = UNIFORMTYPE_MAT3;
	exports.UNIFORMTYPE_MAT4 = UNIFORMTYPE_MAT4;
	exports.UNIFORMTYPE_TEXTURE2D = UNIFORMTYPE_TEXTURE2D;
	exports.UNIFORMTYPE_TEXTURE2D_SHADOW = UNIFORMTYPE_TEXTURE2D_SHADOW;
	exports.UNIFORMTYPE_TEXTURE3D = UNIFORMTYPE_TEXTURE3D;
	exports.UNIFORMTYPE_TEXTURECUBE = UNIFORMTYPE_TEXTURECUBE;
	exports.UNIFORMTYPE_TEXTURECUBE_SHADOW = UNIFORMTYPE_TEXTURECUBE_SHADOW;
	exports.UNIFORMTYPE_VEC2 = UNIFORMTYPE_VEC2;
	exports.UNIFORMTYPE_VEC2ARRAY = UNIFORMTYPE_VEC2ARRAY;
	exports.UNIFORMTYPE_VEC3 = UNIFORMTYPE_VEC3;
	exports.UNIFORMTYPE_VEC3ARRAY = UNIFORMTYPE_VEC3ARRAY;
	exports.UNIFORMTYPE_VEC4 = UNIFORMTYPE_VEC4;
	exports.UNIFORMTYPE_VEC4ARRAY = UNIFORMTYPE_VEC4ARRAY;
	exports.URI = URI;
	exports.UnsupportedBrowserError = UnsupportedBrowserError;
	exports.VIEW_CENTER = VIEW_CENTER;
	exports.VIEW_LEFT = VIEW_LEFT;
	exports.VIEW_RIGHT = VIEW_RIGHT;
	exports.Vec2 = Vec2;
	exports.Vec3 = Vec3;
	exports.Vec4 = Vec4;
	exports.VertexBuffer = VertexBuffer;
	exports.VertexFormat = VertexFormat;
	exports.VertexIterator = VertexIterator;
	exports.VrDisplay = VrDisplay;
	exports.VrManager = VrManager;
	exports.XRHAND_LEFT = XRHAND_LEFT;
	exports.XRHAND_NONE = XRHAND_NONE;
	exports.XRHAND_RIGHT = XRHAND_RIGHT;
	exports.XRSPACE_BOUNDEDFLOOR = XRSPACE_BOUNDEDFLOOR;
	exports.XRSPACE_LOCAL = XRSPACE_LOCAL;
	exports.XRSPACE_LOCALFLOOR = XRSPACE_LOCALFLOOR;
	exports.XRSPACE_UNBOUNDED = XRSPACE_UNBOUNDED;
	exports.XRSPACE_VIEWER = XRSPACE_VIEWER;
	exports.XRTARGETRAY_GAZE = XRTARGETRAY_GAZE;
	exports.XRTARGETRAY_POINTER = XRTARGETRAY_POINTER;
	exports.XRTARGETRAY_SCREEN = XRTARGETRAY_SCREEN;
	exports.XRTRACKABLE_MESH = XRTRACKABLE_MESH;
	exports.XRTRACKABLE_PLANE = XRTRACKABLE_PLANE;
	exports.XRTRACKABLE_POINT = XRTRACKABLE_POINT;
	exports.XRTYPE_AR = XRTYPE_AR;
	exports.XRTYPE_INLINE = XRTYPE_INLINE;
	exports.XRTYPE_VR = XRTYPE_VR;
	exports.XrHitTest = XrHitTest;
	exports.XrHitTestSource = XrHitTestSource;
	exports.XrInput = XrInput;
	exports.XrInputSource = XrInputSource;
	exports.XrLightEstimation = XrLightEstimation;
	exports.XrManager = XrManager;
	exports.ZoneComponent = ZoneComponent;
	exports.ZoneComponentSystem = ZoneComponentSystem;
	exports.anim = anim;
	exports.apps = apps;
	exports.asset = asset;
	exports.audio = audio;
	exports.basisDownload = basisDownload;
	exports.basisDownloadFromConfig = basisDownloadFromConfig;
	exports.basisInitialize = basisInitialize;
	exports.basisTargetFormat = basisTargetFormat;
	exports.basisTranscode = basisTranscode;
	exports.calculateNormals = calculateNormals;
	exports.calculateTangents = calculateTangents;
	exports.common = common;
	exports.config = config;
	exports.createBox = createBox;
	exports.createCapsule = createCapsule;
	exports.createCone = createCone;
	exports.createCylinder = createCylinder;
	exports.createMesh = createMesh;
	exports.createPlane = createPlane;
	exports.createScript = createScript;
	exports.createSphere = createSphere;
	exports.createStyle = createStyle;
	exports.createTorus = createTorus;
	exports.createURI = createURI;
	exports.data = data;
	exports.debug = debug;
	exports.drawFullscreenQuad = drawFullscreenQuad;
	exports.drawQuadWithShader = drawQuadWithShader;
	exports.drawTexture = drawTexture;
	exports.events = events;
	exports.extend = extend;
	exports.fw = fw;
	exports.getTouchTargetCoords = getTouchTargetCoords;
	exports.gfx = gfx;
	exports.guid = guid;
	exports.http = http;
	exports.inherits = inherits;
	exports.input = input;
	exports.isDefined = isDefined;
	exports.log = log;
	exports.makeArray = makeArray;
	exports.math = math;
	exports.now = now;
	exports.path = path;
	exports.platform = platform;
	exports.posteffect = posteffect;
	exports.prefilterCubemap = prefilterCubemap;
	exports.programlib = programlib;
	exports.registerScript = registerScript;
	exports.reprojectTexture = reprojectTexture;
	exports.revision = revision;
	exports.scene = scene;
	exports.script = script;
	exports.semanticToLocation = semanticToLocation;
	exports.shFromCubemap = shFromCubemap;
	exports.shaderChunks = shaderChunks;
	exports.shadergraph = shadergraph;
	exports.shape = shape;
	exports.string = string;
	exports.time = time;
	exports.type = type;
	exports.typedArrayIndexFormats = typedArrayIndexFormats;
	exports.typedArrayIndexFormatsByteSize = typedArrayIndexFormatsByteSize;
	exports.typedArrayToType = typedArrayToType;
	exports.typedArrayTypes = typedArrayTypes;
	exports.typedArrayTypesByteSize = typedArrayTypesByteSize;
	exports.version = version;

	Object.defineProperty(exports, '__esModule', { value: true });

})));
