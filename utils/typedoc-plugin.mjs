import { Converter, ReflectionKind, DeclarationReflection, ReflectionFlag, IntrinsicType, ReferenceType } from 'typedoc'; // eslint-disable-line import/no-unresolved

/**
 * This Typedoc plugin adds missing PlayCanvas API symbols to the Typedoc reflection graph. The
 * symbols are missing because they are generated by `Object.defineProperty` in the PlayCanvas
 * sourcebase. The TypeScript compiler is unable to detect them, either in the code or in the
 * JSDoc comments (specified via \@property tags).
 *
 * @param {import('typedoc').Application} app - The Typedoc application.
 */
function load(app) {
    app.converter.on(Converter.EVENT_CREATE_DECLARATION, (/** @type {import('typedoc').Context} */ context, /** @type {DeclarationReflection} */ reflection) => {
        // Select the StandardMaterial class
        if (reflection.kind === ReflectionKind.Class && reflection.name === 'StandardMaterial') {
            /**
             * Returns the reference type matching the specified class name.
             *
             * @param {string} type - The class name.
             * @returns {ReferenceType} The reference type.
             */ 
            const getType = (type) => {
                const reflection = context.project.children.find(child => child.name === type && child.kind === ReflectionKind.Class);
                return new ReferenceType(type, reflection, context.project);
            };

            /** @type {Map<string, ReferenceType>} */
            const types = new Map();
            ['Color', 'Texture', 'Vec2', 'Vec3', 'Vec4'].forEach(type => types.set(type, getType(type)));

            // Get just the @property definitions from the class' JSDoc block
            const blockTags = reflection.comment.blockTags.filter(blockTag => blockTag.tag === '@property');

            // Convert all @property tags on StandardMaterial to actual child properties of StandardMaterial
            for (const blockTag of blockTags) {
                const newProperty = new DeclarationReflection(blockTag.name, ReflectionKind.Property, reflection);

                if (blockTag.name.endsWith('Channel')) {
                    newProperty.type = new IntrinsicType('string');
                } else if (blockTag.name.endsWith('Rotation') || blockTag.name.endsWith('Uv')) {
                    newProperty.type = new IntrinsicType('number');
                } else if (blockTag.name.startsWith('use') || blockTag.name.endsWith('Invert') || blockTag.name.endsWith('Tint') || blockTag.name.endsWith('VertexColor')) {
                    newProperty.type = new IntrinsicType('boolean');
                } else if (blockTag.name.endsWith('Map')) {
                    newProperty.type = types.get('Texture');
                } else if (blockTag.name.endsWith('Offset')) {
                    newProperty.type = types.get('Vec2');
                } else if (blockTag.name.endsWith('Tiling')) {
                    newProperty.type = types.get('Vec2');
                }

                // Mark the new property as public
                newProperty.setFlag(ReflectionFlag.Public, true);

                // Add the new property to the class
                if (!reflection.children) {
                    reflection.children = [];
                }
                reflection.children.push(newProperty);
            }
        }
    });
}

export { load };
