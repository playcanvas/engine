import { readFileSync } from 'fs';
import { resolve } from 'path';

import { Converter, ReflectionKind, DeclarationReflection, ReflectionFlag, IntrinsicType, ReferenceType, UnionType } from 'typedoc'; // eslint-disable-line import/no-unresolved

/**
 * Extract property types from JSDoc in a .js file.
 * @param {string} filePath - The path to the .js file.
 * @returns {Map<string, string>} A map of property names to types.
 */
function getProperties(filePath) {
    const data = readFileSync(resolve(process.cwd(), filePath), 'utf-8');
    const docBlocks = data.match(/\/\*\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*+\//g);
    const properties = new Map();

    if (docBlocks) {
        docBlocks.forEach(block => {
            const propertyLines = block.match(/@property\s*\{[^}]+\}\s*[^*]*/g);

            if (propertyLines) {
                propertyLines.forEach(line => {
                    const match = line.match(/@property\s*\{([^}]+)\}\s*(\w+)/);

                    if (match) {
                        let type = match[1].trim();
                        const name = match[2].trim();

                        // Simplify complex import types.
                        type = type.replace(/import\(['"]([^'"]+)['"]\)\.(\w+)/g, (_, p1, p2) => p2);

                        properties.set(name, type);
                    }
                });
            }
        });
    }

    return properties;
}

/**
 * This Typedoc plugin adds missing PlayCanvas API symbols to the Typedoc reflection graph. The
 * symbols are missing because they are generated by `Object.defineProperty` in the PlayCanvas
 * sourcebase. The TypeScript compiler is unable to detect them, either in the code or in the
 * JSDoc comments (specified via \@property tags).
 *
 * @param {import('typedoc').Application} app - The Typedoc application.
 */
function load(app) {
    app.converter.on(Converter.EVENT_CREATE_DECLARATION, (/** @type {import('typedoc').Context} */ context, /** @type {DeclarationReflection} */ reflection) => {
        // Select the StandardMaterial class
        if (reflection.kind === ReflectionKind.Class && reflection.name === 'StandardMaterial') {
            /**
             * Returns the reference type matching the specified class name.
             *
             * @param {string} type - The class name.
             * @returns {ReferenceType} The reference type.
             */
            const getReferenceType = (type) => {
                const reflection = context.project.children.find(child => child.name === type && child.kind === ReflectionKind.Class);
                return new ReferenceType(type, reflection, context.project);
            };

            /** @type {Map<string, ReferenceType>} */
            const types = new Map();
            ['Color', 'Texture', 'Vec2', 'Vec3', 'Vec4'].forEach(type => types.set(type, getReferenceType(type)));

            const properties = getProperties('./src/scene/materials/standard-material.js');

            // Get just the @property definitions from the class' JSDoc block
            const blockTags = reflection.comment.blockTags.filter(blockTag => blockTag.tag === '@property');

            // Convert all @property tags on StandardMaterial to actual child properties of StandardMaterial
            for (const blockTag of blockTags) {
                const newProperty = new DeclarationReflection(blockTag.name, ReflectionKind.Property, reflection);

                const type = properties.get(blockTag.name);

                const getType = (type) => {
                    if (type.includes('|')) {
                        const types = type.split('|');
                        return new UnionType(types.map(type => getType(type)));
                    }

                    switch (type) {
                        case 'null':
                            return new IntrinsicType('null');
                        case 'boolean':
                            return new IntrinsicType('boolean');
                        case 'number':
                            return new IntrinsicType('number');
                        case 'string':
                            return new IntrinsicType('string');
                        default:
                            return types.get(type);
                    }
                };

                newProperty.type = getType(type);

                // Mark the new property as public
                newProperty.setFlag(ReflectionFlag.Public, true);

                // Add the new property to the class
                if (!reflection.children) {
                    reflection.children = [];
                }
                reflection.children.push(newProperty);
            }
        }
    });
}

export { load };
